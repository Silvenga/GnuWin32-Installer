*************
* intro
*************

What is calc?

    Calc is an interactive calculator which provides for easy large
    numeric calculations, but which also can be easily programmed
    for difficult or long calculations.	 It can accept a command line
    argument, in which case it executes that single command and exits.
    Otherwise, it enters interactive mode.  In this mode, it accepts
    commands one at a time, processes them, and displays the answers.
    In the simplest case, commands are simply expressions which are
    evaluated.	For example, the following line can be input:

	    3 * (4 + 1)

    and the calculator will print:

    	    15

    Calc as the usual collection of arithmetic operators +, -, /, *
    as well as ^ (exponentiation), % (modulus) and // (integer divide).
    For example:

	    3 * 19^43 - 1

     will produce:

	    29075426613099201338473141505176993450849249622191102976

    Notice that calc values can be very large.  For example:

    	    2^23209-1

    will print:

	   402874115778988778181873329071 ... many digits ... 3779264511

    The special '.' symbol (called dot), represents the result of the
    last command expression, if any.  This is of great use when a series
    of partial results are calculated, or when the output mode is changed
    and the last result needs to be redisplayed.  For example, the above
    result can be modified by typing:

	    . % (2^127-1)

    and the calculator will print:

	    47385033654019111249345128555354223304

    For more complex calculations, variables can be used to save the
    intermediate results.  For example, the result of adding 7 to the
    previous result can be saved by typing:

	    curds = 15
	    whey = 7 + 2*curds

    Functions can be used in expressions.  There are a great number of
    pre-defined functions.  For example, the following will calculate
    the factorial of the value of 'old':

	    fact(whey)

    and the calculator prints:

    	    13763753091226345046315979581580902400000000

    The calculator also knows about complex numbers, so that typing:

	    (2+3i) * (4-3i)
	    cos(.)

    will print:

    	    17+6i
	    -55.50474777265624667147+193.9265235748927986537i

    The calculator can calculate transcendental functions, and accept and
    display numbers in real or exponential format. For example, typing:

	    config("display", 70)
	    epsilon(1e-70)
	    sin(1)

    prints:

    	0.8414709848078965066525023216302989996225630607983710656727517099919104

    Calc can output values in terms of fractions, octal or hexadecimal.
    For example:

    	    config("mode", "fraction"),
	    (17/19)^23
	    base(16),
	    (19/17)^29

     will print:

     	    19967568900859523802559065713/257829627945307727248226067259
	    0x9201e65bdbb801eaf403f657efcf863/0x5cd2e2a01291ffd73bee6aa7dcf7d1

    All numbers are represented as fractions with arbitrarily large
    numerators and denominators which are always reduced to lowest terms.
    Real or exponential format numbers can be input and are converted
    to the equivalent fraction.  Hex, binary, or octal numbers can be
    input by using numbers with leading '0x', '0b' or '0' characters.
    Complex numbers can be input using a trailing 'i', as in '2+3i'.
    Strings and characters are input by using single or double quotes.

    Commands are statements in a C-like language, where each input
    line is treated as the body of a procedure.  Thus the command
    line can contain variable declarations, expressions, labels,
    conditional tests, and loops.  Assignments to any variable name
    will automatically define that name as a global variable.  The
    other important thing to know is that all non-assignment expressions
    which are evaluated are automatically printed.  Thus, you can evaluate
    an expression's value by simply typing it in.

    Many useful built-in mathematical functions are available.  Use
    the:

	    help builtin

    command to list them.

    You can also define your own functions by using the 'define' keyword,
    followed by a function declaration very similar to C.

	    define f2(n)
	    {
		    local       ans;

		    ans = 1;
		    while (n > 1)
			    ans *= (n -= 2);
		    return ans;
	    }

    Thus the input:

	    f2(79)

    will produce;

	    1009847364737869270905302433221592504062302663202724609375

    Functions which only need to return a simple expression can be defined
    using an equals sign, as in the example:

	    define sc(a,b) = a^3 + b^3

    Thus the input:

	    sc(31, 61)

    will produce;

	    256772

    Variables in functions can be defined as either 'global', 'local',
    or 'static'.  Global variables are common to all functions and the
    command line, whereas local variables are unique to each function
    level, and are destroyed when the function returns.  Static variables
    are scoped within single input files, or within functions, and are
    never destroyed.  Variables are not typed at definition time, but
    dynamically change as they are used.

    For more information about the calc language and features, try:

	    help overview

    In particular, check out the other help functions listed in the
    overview help file.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.3 $
## @(#) $Id: intro,v 29.3 2000/06/07 15:26:20 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/intro,v $
##
## Under source code control:	1991/07/21 04:37:21
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* overview
*************

		    CALC - An arbitrary precision calculator.
			    by David I. Bell


    This is a calculator program with arbitrary precision arithmetic.
    All numbers are represented as fractions with arbitrarily large
    numerators and denominators which are always reduced to lowest terms.
    Real or exponential format numbers can be input and are converted
    to the equivalent fraction.	 Hex, binary, or octal numbers can be
    input by using numbers with leading '0x', '0b' or '0' characters.
    Complex numbers can be input using a trailing 'i', as in '2+3i'.
    Strings and characters are input by using single or double quotes.

    Commands are statements in a C-like language, where each input
    line is treated as the body of a procedure.	 Thus the command
    line can contain variable declarations, expressions, labels,
    conditional tests, and loops.  Assignments to any variable name
    will automatically define that name as a global variable.  The
    other important thing to know is that all non-assignment expressions
    which are evaluated are automatically printed.  Thus, you can evaluate
    an expression's value by simply typing it in.

    Many useful built-in mathematical functions are available.	Use
    the 'show builtins' command to list them.  You can also define
    your own functions by using the 'define' keyword, followed by a
    function declaration very similar to C.  Functions which only
    need to return a simple expression can be defined using an
    equals sign, as in the example 'define sc(a,b) = a^3 + b^3'.
    Variables in functions can be defined as either 'global', 'local',
    or 'static'.  Global variables are common to all functions and the
    command line, whereas local variables are unique to each function
    level, and are destroyed when the function returns.	 Static variables
    are scoped within single input files, or within functions, and are
    never destroyed.  Variables are not typed at definition time, but
    dynamically change as they are used.  So you must supply the correct
    type of variable to those functions and operators which only work
    for a subset of types.

    Calc has a help command that will produce information about
    every builtin function, command as well as a number of other
    aspects of calc usage.  Try the command:

	    help help

    for and overview of the help system.  The command:

	    help builtin

    provides information on built-in mathematical functions, whereas:

	    help asinh

    will provides information a specific function.  The following
    help files:

	    help command
	    help define
	    help operator
	    help statement
	    help variable

    provide a good overview of the calc language.  If you are familiar
    with C, you should also try:

	    help unexpected

    It contains information about differences between C and calc
    that may surprize you.

    To learn about calc standard resource files, try:

	    help resource

    To learn how to invoke the calc command and about calc -flags, try:

	    help usage

    To learn about calc shell scripts, try:

	    help script

    A full and extensive overview of calc may be obtained by:

	    help full

    By default, arguments to functions are passed by value (even
    matrices).	For speed, you can put an ampersand before any
    variable argument in a function call, and that variable will be
    passed by reference instead.  However, if the function changes
    its argument, the variable will change.  Arguments to built-in
    functions and object manipulation functions are always called
    by reference.  If a user-defined function takes more arguments
    than are passed, the undefined arguments have the null value.
    The 'param' function returns function arguments by argument
    number, and also returns the number of arguments passed.  Thus
    functions can be written to handle an arbitrary number of
    arguments.

    The mat statement is used to create a matrix.  It takes a
    variable name, followed by the bounds of the matrix in square
    brackets.  The lower bounds are zero by default, but colons can
    be used to change them.  For example 'mat foo[3, 1:10]' defines
    a two dimensional matrix, with the first index ranging from 0
    to 3, and the second index ranging from 1 to 10.  The bounds of
    a matrix can be an expression calculated at runtime.

    Lists of values are created using the 'list' function, and values can
    be inserted or removed from either the front or the end of the list.
    List elements can be indexed directly using double square brackets.

    The obj statement is used to create an object.  Objects are
    user-defined values for which user-defined routines are
    implicitly called to perform simple actions such as add,
    multiply, compare, and print. Objects types are defined as in
    the example 'obj complex {real, imag}', where 'complex' is the
    name of the object type, and 'real' and 'imag' are element
    names used to define the value of the object (very much like
    structures).  Variables of an object type are created as in the
    example 'obj complex x,y', where 'x' and 'y' are variables.
    The elements of an object are referenced using a dot, as in the
    example 'x.real'. All user-defined routines have names composed
    of the object type and the action to perform separated by an
    underscore, as in the example 'complex_add'.  The command 'show
    objfuncs' lists all the definable routines.	 Object routines
    which accept two arguments should be prepared to handle cases
    in which either one of the arguments is not of the expected
    object type.

    These are the differences between the normal C operators and
    the ones defined by the calculator.	 The '/' operator divides
    fractions, so that '7 / 2' evaluates to 7/2. The '//' operator
    is an integer divide, so that '7 // 2' evaluates to 3.  The '^'
    operator is a integral power function, so that 3^4 evaluates to
    81.	 Matrices of any dimension can be treated as a zero based
    linear array using double square brackets, as in 'foo[[3]]'.
    Matrices can be indexed by using commas between the indices, as
    in foo[3,4].  Object and list elements can be referenced by
    using double square brackets.

    The print statement is used to print values of expressions.
    Separating values by a comma puts one space between the output
    values, whereas separating values by a colon concatenates the
    output values.  A trailing colon suppresses printing of the end
    of line.  An example of printing is 'print \"The square of\",
    x, \"is\", x^2\'.

    The 'config' function is used to modify certain parameters that
    affect calculations or the display of values.  For example, the
    output display mode can be set using 'config(\"mode\", type)',
    where 'type' is one of 'frac', 'int', 'real', 'exp', 'hex',
    'oct', or 'bin'.  The default output mode is real.	For the
    integer, real, or exponential formats, a leading '~' indicates
    that the number was truncated to the number of decimal places
    specified by the default precision.	 If the '~' does not
    appear, then the displayed number is the exact value.

    The number of decimal places printed is set by using
    'config(\"display\", n)'.  The default precision for
    real-valued functions can be set by using 'epsilon(x)', where x
    is the required precision (such as 1e-50).

    There is a command stack feature so that you can easily
    re-execute previous commands and expressions from the terminal.
    You can also edit the current command before it is completed.
    Both of these features use emacs-like commands.

    Files can be read in by using the 'read filename' command.
    These can contain both functions to be defined, and expressions
    to be calculated.  Global variables which are numbers can be
    saved to a file by using the 'write filename' command.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: overview,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/overview,v $
##
## Under source code control:	1991/07/21 04:37:23
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* help
*************

For more information while running calc, type  help  followed by one of the
following topics:

    topic		description
    -----		-----------
    intro		introduction to calc
    overview		overview of calc
    help		this file

    assoc		using associations
    builtin		builtin functions
    command		top level commands
    config		configuration parameters
    custom		information about the custom builtin interface
    define		how to define functions
    environment		how environment variables effect calc
    errorcodes		calc generated error codes
    expression		expression sequences
    file		using files
    history		command history
    interrupt		how interrupts are handled
    list		using lists
    mat			using matrices
    obj			user defined data types
    operator		math, relational, logic and variable access operators
    statement		flow control and declaration statements
    types		builtin data types
    unexpected		unexpected syntax/usage surprises for C programmers
    usage		how to invoke the calc command
    variable		variables and variable declarations

    bindings		input & history character bindings
    custom_cal		information about custom calc resource files
    libcalc		using the arbitrary precision routines in a C program
    new_custom		information about how to add new custom functions
    resource		standard calc resource files
    script		using calc shell scripts
    cscript		info on the calc shell scripts supplied with calc

    archive		where to get the latest versions of calc
    bugs		known bugs and mis-features
    changes		recent changes to calc
    contrib		how to contribute scripts, code or custom functions
    todo		list of priority action items for calc
    wishlist		wish list of future enhancements of calc

    credit		who wrote calc and who helped
    copyright		calc copyright and the GNU LGPL
    copying		details on the Calc GNU Lesser General Public License
    copying-lgpl	calc GNU Lesser General Public License text

    full		all of the above (in the above order)

You can also ask for help on a particular function name.  For example,

    help asinh
    help round

or on a particular symbol such as:

    help =

For example:

    help usage

will print the calc command usage information.	One can obtain calc help
without invoking any startup code by running calc as follows:

    calc -q help topic

where 'topic' is one of the topics listed above.

If the -m mode disallows opening files for reading or execution of programs,
then the help facility will be disabled.  See:

    help usage

for details of the -m mode.

The help command is able to display installed help files for custom builtin
functions.  However, if the custom name is the same as a standard help
file, the standard help file will be displayed instead.	 The custom help
builtin should be used to directly access the custom help file.

For example, the custom help builtin has the same name as the standard
help file.  That is:

    help help

will print this file only.  However the custom help builtin will print
only the custom builtin help file:

    custom("help", "help");

will by-pass a standard help file and look for the custom version directly.

As a hack, the following:

     help custhelp/anything

as the same effect as:

    custom("help", "anything");

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.3 $
## @(#) $Id: help,v 29.3 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/help,v $
##
## Under source code control:	1991/07/21 04:37:20
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* assoc
*************

NAME
    assoc - create a new association array

SYNOPSIS
    assoc()

TYPES
    return	association

DESCRIPTION
    This function returns an empty association array.

    After A = assoc(), elements can be added to the association by
    assignments of the forms

	A[a_1] = v_1
	A[a_1, a_2] = v_2
	A[a_1, a_2, a_3] = v_3
	A[a_1, a_2, a_3, a_4] = v_4

    There are no restrictions on the values of the "indices" a_i or
    the "values" v_i.

    After the above assignments, so long as no new values have been
    assigned to A[a_i], etc., the expressions A[a_1], A[a_1, a_2], etc.
    will return the values v_1, v_2, ...

    Until A[a_1], A[a_1, a_2], ... are defined as described above, these
    expressions return the null value.

    Thus associations act like matrices except that different elements
    may have different numbers (between 1 and 4 inclusive) of indices,
    and these indices need not be integers in specified ranges.

    Assignment of a null value to an element of an association does not
    delete the element, but a later reference to that element will return
    the null value as if the element is undefined.

    The elements of an association are stored in a hash table for
    quick access.  The index values are hashed to select the correct
    hash chain for a small sequential search for the element.  The hash
    table will be resized as necessary as the number of entries in
    the association becomes larger.

    The size function returns the number of elements in an association.
    This size will include elements with null values.

    Double bracket indexing can be used for associations to walk through
    the elements of the association.  The order that the elements are
    returned in as the index increases is essentially random.  Any
    change made to the association can reorder the elements, this making
    a sequential scan through the elements difficult.

    The search and rsearch functions can search for an element in an
    association which has the specified value.	They return the index
    of the found element, or a NULL value if the value was not found.

    Associations can be copied by an assignment, and can be compared
    for equality.  But no other operations on associations have meaning,
    and are illegal.

EXAMPLE
    > A = assoc(); print A
     assoc (0 elements):

    > A["zero"] = 0; A["one"] = 1; A["two"] = 2; A["three"] = 3;
    > A["smallest", "prime"] = 2;
    > print A
    assoc (5 elements);
    ["two"] = 2
    ["three"] = 3
    ["one"] = 1
    ["zero"] = 0
    ["smallest","prime"] = 2

LIMITS
    none

LINK LIBRARY
    none

SEE ALSO
    isassoc, rsearch, search, size

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.3 $
## @(#) $Id: assoc,v 29.3 2002/07/10 11:47:04 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/assoc,v $
##
## Under source code control:	1994/09/25 20:22:31
## File existed as early as:	1994
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* builtin
*************

Builtin functions

	There is a large number of built-in functions.	Many of the
	functions work on several types of arguments, whereas some only
	work for the correct types (e.g., numbers or strings).	In the
	following description, this is indicated by whether or not the
	description refers to values or numbers.  This display is generated
	by the 'show builtin' command.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: builtin.top,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/builtin.top,v $
##
## Under source code control:	1995/07/10 01:17:53
## File existed as early as:	1995
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

	Name	Args	Description

	abs       1-2   absolute value within accuracy b
	access    1-2   determine accessibility of file a for mode b
	acos      1-2   arccosine of a within accuracy b
	acosh     1-2   inverse hyperbolic cosine of a within accuracy b
	acot      1-2   arccotangent of a within accuracy b
	acoth     1-2   inverse hyperbolic cotangent of a within accuracy b
	acsc      1-2   arccosecant of a within accuracy b
	acsch     1-2   inverse csch of a within accuracy b
	agd       1-2   inverse gudermannian function
	append    1+    append values to end of list
	appr      1-3   approximate a by multiple of b using rounding c
	arg       1-2   argument (the angle) of complex number
	argv      0-1   calc argc or argv string
	asec      1-2   arcsecant of a within accuracy b
	asech     1-2   inverse hyperbolic secant of a within accuracy b
	asin      1-2   arcsine of a within accuracy b
	asinh     1-2   inverse hyperbolic sine of a within accuracy b
	assoc     0     create new association array
	atan      1-2   arctangent of a within accuracy b
	atan2     2-3   angle to point (b,a) within accuracy c
	atanh     1-2   inverse hyperbolic tangent of a within accuracy b
	avg       0+    arithmetic mean of values
	base      0-1   set default output base
	base2     0-1   set default secondary output base
	bernoulli 1     Bernoulli number for index a
	bit       2     whether bit b in value a is set
	blk       0-3   block with or without name, octet number, chunksize
	blkcpy    2-5   copy value to/from a block: blkcpy(d,s,len,di,si)
	blkfree   1     free all storage from a named block
	blocks    0-1   named block with specified index, or null value
	bround    1-3   round value a to b number of binary places
	btrunc    1-2   truncate a to b number of binary places
	calclevel 0     current calculation level
	calc_tty  0     set tty for interactivity
	catalan   1     catalan number for index a
	ceil      1     smallest integer greater than or equal to number
	cfappr    1-3   approximate a within accuracy b using
				 continued fractions
	cfsim     1-2   simplify number using continued fractions
	char      1     character corresponding to integer value
	cmdbuf    0     command buffer
	cmp       2     compare values returning -1, 0, or 1
	comb      2     combinatorial number a!/b!(a-b)!
	config    1-2   set or read configuration value
	conj      1     complex conjugate of value
	copy      2-5   copy value to/from a block: copy(s,d,len,si,di)
	cos       1-2   cosine of value a within accuracy b
	cosh      1-2   hyperbolic cosine of a within accuracy b
	cot       1-2   cotangent of a within accuracy b
	coth      1-2   hyperbolic cotangent of a within accuracy b
	count     2     count listr/matrix elements satisfying some condition
	cp        2     cross product of two vectors
	csc       1-2   cosecant of a within accuracy b
	csch      1-2   hyperbolic cosecant of a within accuracy b
	ctime     0     date and time as string
	custom    0+    custom builtin function interface
	delete    2     delete element from list a at position b
	den       1     denominator of fraction
	det       1     determinant of matrix
	digit     2-3   digit at specified decimal place of number
	digits    1-2   number of digits in base b representation of a
	display   0-1   number of decimal digits for displaying numbers
	dp        2     dot product of two vectors
	epsilon   0-1   set or read allowed error for real calculations
	errcount  0-1   set or read error count
	errmax    0-1   set or read maximum for error count
	errno     0-1   set or read calc_errno
	error     0-1   generate error value
	euler     1     Euler number
	eval      1     evaluate expression from string to value
	exp       1-2   exponential of value a within accuracy b
	factor    1-3   lowest prime factor < b of a, return c if error
	fcnt      2     count of times one number divides another
	fib       1     Fibonacci number F(n)
	forall    2     do function for all elements of list or matrix
	frem      2     number with all occurrences of factor removed
	fact      1     factorial
	fclose    0+    close file
	feof      1     whether EOF reached for file
	ferror    1     whether error occurred for file
	fflush    0+    flush output to file(s)
	fgetc     1     read next char from file
	fgetfield 1     read next white-space delimited field from file
	fgetline  1     read next line from file, newline removed
	fgets     1     read next line from file, newline is kept
	fgetstr   1     read next null-terminated string from file, null character is kept
	files     0-1   return opened file or max number of opened files
	floor     1     greatest integer less than or equal to number
	fopen     2     open file name a in mode b
	fprintf   2+    print formatted output to opened file
	fputc     2     write a character to a file
	fputs     2+    write one or more strings to a file
	fputstr   2+    write one or more null-terminated strings to a file
	free      0+    free listed or all global variables
	freebernoulli 0     free stored Bernoulli numbers
	freeeuler 0     free stored Euler numbers
	freeglobals 0     free all global and visible static variables
	freeredc  0     free redc data cache
	freestatics 0     free all unscoped static variables
	freopen   2-3   reopen a file stream to a named file
	fscan     2+    scan a file for assignments to one or more variables
	fscanf    2+    formatted scan of a file for assignment to one or more variables
	fseek     2-3   seek to position b (offset from c) in file a
	fsize     1     return the size of the file
	ftell     1     return the file position
	frac      1     fractional part of value
	gcd       1+    greatest common divisor
	gcdrem    2     a divided repeatedly by gcd with b
	gd        1-2   gudermannian function
	getenv    1     value of environment variable (or NULL)
	hash      1+    return non-negative hash value for one or
			    more values
	head      2     return list of specified number at head of a list
	highbit   1     high bit number in base 2 representation
	hmean     0+    harmonic mean of values
	hnrmod    4     v mod h*2^n+r, h>0, n>0, r = -1, 0 or 1
	hypot     2-3   hypotenuse of right triangle within accuracy c
	ilog      2     integral log of a to integral base b
	ilog10    1     integral log of a number base 10
	ilog2     1     integral log of a number base 2
	im        1     imaginary part of complex number
	indices   2     indices of a specified assoc or mat value
	inputlevel 0     current input depth
	insert    2+    insert values c ... into list a at position b
	int       1     integer part of value
	inverse   1     multiplicative inverse of value
	iroot     2     integer b'th root of a
	isassoc   1     whether a value is an association
	isatty    1     whether a file is a tty
	isblk     1     whether a value is a block
	isconfig  1     whether a value is a config state
	isdefined 1     whether a string names a function
	iserror   1     where a value is an error
	iseven    1     whether a value is an even integer
	isfile    1     whether a value is a file
	ishash    1     whether a value is a hash state
	isident   1     returns 1 if identity matrix
	isint     1     whether a value is an integer
	islist    1     whether a value is a list
	ismat     1     whether a value is a matrix
	ismult    2     whether a is a multiple of b
	isnull    1     whether a value is the null value
	isnum     1     whether a value is a number
	isobj     1     whether a value is an object
	isobjtype 1     whether a string names an object type
	isodd     1     whether a value is an odd integer
	isoctet   1     whether a value is an octet
	isprime   1-2   whether a is a small prime, return b if error
	isptr     1     whether a value is a pointer
	isqrt     1     integer part of square root
	isrand    1     whether a value is a additive 55 state
	israndom  1     whether a value is a Blum state
	isreal    1     whether a value is a real number
	isrel     2     whether two numbers are relatively prime
	isstr     1     whether a value is a string
	issimple  1     whether value is a simple type
	issq      1     whether or not number is a square
	istype    2     whether the type of a is same as the type of b
	jacobi    2     -1 => a is not quadratic residue mod b
				  1 => b is composite, or a is quad residue of b
	join      1+    join one or more lists into one list
	lcm       1+    least common multiple
	lcmfact   1     lcm of all integers up till number
	lfactor   2     lowest prime factor of a in first b primes
	links     1     links to number or string value
	list      0+    create list of specified values
	ln        1-2   natural logarithm of value a within accuracy b
	lowbit    1     low bit number in base 2 representation
	ltol      1-2   leg-to-leg of unit right triangle (sqrt(1 - a^2))
	makelist  1     create a list with a null elements
	matdim    1     number of dimensions of matrix
	matfill   2-3   fill matrix with value b (value c on diagonal)
	matmax    2     maximum index of matrix a dim b
	matmin    2     minimum index of matrix a dim b
	matsum    1     sum the numeric values in a matrix
	mattrace  1     return the trace of a square matrix
	mattrans  1     transpose of matrix
	max       0+    maximum value
	md5       0+    MD5 Hash Algorithm
	memsize   1     number of octets used by the value, including overhead
	meq       3     whether a and b are equal modulo c
	min       0+    minimum value
	minv      2     inverse of a modulo b
	mmin      2     a mod b value with smallest abs value
	mne       3     whether a and b are not equal modulo c
	mod       2-3   residue of a modulo b, rounding type c
	modify    2     modify elements of a list or matrix
	name      1     name assigned to block or file
	near      2-3   sign of (abs(a-b) - c)
	newerror  0-1   create new error type with message a
	nextcand  1-5   smallest value == d mod e > a, ptest(a,b,c) true
	nextprime 1-2   return next small prime, return b if err
	norm      1     norm of a value (square of absolute value)
	null      0+    null value
	num       1     numerator of fraction
	ord       1     integer corresponding to character value
	param     1     value of parameter n (or parameter count if n
				 is zero)
	perm      2     permutation number a!/(a-b)!
	prevcand  1-5   largest value == d mod e < a, ptest(a,b,c) true
	prevprime 1-2   return previous small prime, return b if err
	pfact     1     product of primes up till number
	pi        0-1   value of pi accurate to within epsilon
	pix       1-2   number of primes <= a < 2^32, return b if error
	places    1-2   places after "decimal" point (-1 if infinite)
	pmod      3     mod of a power (a ^ b (mod c))
	polar     2-3   complex value of polar coordinate (a * exp(b*1i))
	poly      1+    evaluates a polynomial given its coefficients or coefficient-list
	pop       1     pop value from front of list
	popcnt    1-2   number of bits in a that match b (or 1)
	power     2-3   value a raised to the power b within accuracy c
	protect   1-2   read or set protection level for variable
	ptest     1-3   probabilistic primality test
	printf    1+    print formatted output to stdout
	prompt    1     prompt for input line using value a
	push      1+    push values onto front of list
	putenv    1-2   define an environment variable
	quo       2-3   integer quotient of a by b, rounding type c
	quomod    4     set c and d to quotient and remainder of a
			    divided by b
	rand      0-2   additive 55 random number [0,2^64), [0,a), or [a,b)
	randbit   0-1   additive 55 random number [0,2^a)
	random    0-2   Blum-Blum-Shub random number [0,2^64), [0,a), or [a,b)
	randombit 0-1   Blum-Blum-Sub random number [0,2^a)
	randperm  1     random permutation of a list or matrix
	rcin      2     convert normal number a to REDC number mod b
	rcmul     3     multiply REDC numbers a and b mod c
	rcout     2     convert REDC number a mod b to normal number
	rcpow     3     raise REDC number a to power b mod c
	rcsq      2     square REDC number a mod b
	re        1     real part of complex number
	remove    1     remove value from end of list
	reverse   1     reverse a copy of a matrix or list
	rewind    0+    rewind file(s)
	rm        1+    remove file(s), -f turns off no-such-file errors
	root      2-3   value a taken to the b'th root within accuracy c
	round     1-3   round value a to b number of decimal places
	rsearch   2-4   reverse search matrix or list for value b
			    starting at index c
	runtime   0     user mode cpu time in seconds
	saveval   1     set flag for saving values
	scale     2     scale value up or down by a power of two
	scan      1+    scan standard input for assignment to one or more variables
	scanf     2+    formatted scan of standard input for assignment to variables
	search    2-4   search matrix or list for value b starting
			    at index c
	sec       1-2   sec of a within accuracy b
	sech      1-2   hyperbolic secant of a within accuracy b
	seed      0     return a 64 bit seed for a psuedo-random generator
	segment   2-3   specified segment of specified list
	select    2     form sublist of selected elements from list
	setbit    2-3   set specified bit in string
	sgn       1     sign of value (-1, 0, 1)
	sha       0+    old Secure Hash Algorithm (SHS FIPS Pub 180)
	sha1      0+    Secure Hash Algorithm (SHS-1 FIPS Pub 180-1)
	sin       1-2   sine of value a within accuracy b
	sinh      1-2   hyperbolic sine of a within accuracy b
	size      1     total number of elements in value
	sizeof    1     number of octets used to hold the value
	sleep     0-1   suspend operation for a seconds
	sort      1     sort a copy of a matrix or list
	sqrt      1-3   square root of value a within accuracy b
	srand     0-1   seed the rand() function
	srandom   0-4   seed the random() function
	ssq       1+    sum of squares of values
	stoponerror 0-1   assign value to stoponerror flag
	str       1     simple value converted to string
	strcat    1+    concatenate strings together
	strcmp    2     compare two null-terminated strings
	strcpy    2     copy null-terminated string to string
	strerror  0-1   string describing error type
	strlen    1     length of string
	strncmp   3     compare strings a, b to c characters
	strncpy   3     copy up to c characters from string to string
	strpos    2     index of first occurrence of b in a
	strprintf 1+    return formatted output as a string
	strscan   2+    scan a string for assignments to one or more variables
	strscanf  2+    formatted scan of string for assignments to variables
	substr    3     substring of a from position b for c chars
	sum       0+    sum of list or object sums and/or other terms
	swap      2     swap values of variables a and b (can be dangerous)
	system    1     call Unix command
	tail      2     retain list of specified number at tail of list
	tan       1-2   tangent of a within accuracy b
	tanh      1-2   hyperbolic tangent of a within accuracy b
	test      1     test that value is nonzero
	time      0     number of seconds since 00:00:00 1 Jan 1970 UTC
	trunc     1-2   truncate a to b number of decimal places
	ungetc    2     unget char read from file
	version   0     calc version string
	xor       1+    logical xor


	The config function sets or reads the value of a configuration
	parameter.  The first argument is a string which names the parameter
	to be set or read.  If only one argument is given, then the current
	value of the named parameter is returned.  If two arguments are given,
	then the named parameter is set to the value of the second argument,
	and the old value of the parameter is returned.	 Therefore you can
	change a parameter and restore its old value later.  The possible
	parameters are explained in the next section.

	The scale function multiplies or divides a number by a power of 2.
	This is used for fractional calculations, unlike the << and >>
	operators, which are only defined for integers.	 For example,
	scale(6, -3) is 3/4.

	The quomod function is used to obtain both the quotient and remainder
	of a division in one operation.	 The first two arguments a and b are
	the numbers to be divided.  The last two arguments c and d are two
	variables which will be assigned the quotient and remainder.  For
	nonnegative arguments, the results are equivalent to computing a//b
	and a%b.  If a is negative and the remainder is nonzero, then the
	quotient will be one less than a//b.  This makes the following three
	properties always hold:	 The quotient c is always an integer.  The
	remainder d is always 0 <= d < b.  The equation a = b * c + d always
	holds.	This function returns 0 if there is no remainder, and 1 if
	there is a remainder.  For examples, quomod(10, 3, x, y) sets x to 3,
	y to 1, and returns the value 1, and quomod(-4, 3.14159, x, y) sets x
	to -2, y to 2.28318, and returns the value 1.

	The eval function accepts a string argument and evaluates the
	expression represented by the string and returns its value.
	The expression can include function calls and variable references.
	For example, eval("fact(3) + 7") returns 13.  When combined with
	the prompt function, this allows the calculator to read values from
	the user.  For example, x=eval(prompt("Number: ")) sets x to the
	value input by the user.

	The digit and bit functions return individual digits of a number,
	either in base 10 or in base 2, where the lowest digit of a number
	is at digit position 0.	 For example, digit(5678, 3) is 5, and
	bit(0b1000100, 2) is 1.	 Negative digit positions indicate places
	to the right of the decimal or binary point, so that for example,
	digit(3.456, -1) is 4.

	The ptest builtin is a primality testing function.  The
	1st argument is the suspected prime to be tested.  The
	absolute value of the 2nd argument is an iteration count.

	If ptest is called with only 2 args, the 3rd argument is
	assumed to be 0.  If ptest is called with only 1 arg, the
	2nd argument is assumed to be 1.  Thus, the following
	calls are equivalent:

		ptest(a)
		ptest(a,1)
		ptest(a,1,0)

	Normally ptest performs a some checks to determine if the
	value is divisable by some trivial prime.  If the 2nd
	argument is < 0, then the trivial check is omitted.

	For example, ptest(a,10) performs the same work as:

		ptest(a,-3)	(7 tests without trivial check)
		ptest(a,-7,3)	(3 more tests without the trivial check)

	The ptest function returns 0 if the number is definitely not
	prime, and 1 is the number is probably prime.  The chance
	of a number which is probably prime being actually composite
	is less than 1/4 raised to the power of the iteration count.
	For example, for a random number p, ptest(p, 10) incorrectly
	returns 1 less than once in every million numbers, and you
	will probably never find a number where ptest(p, 20) gives
	the wrong answer.

	The first 3 args of nextcand and prevcand functions are the same
	arguments as ptest.  But unlike ptest, nextcand and prevcand return
	the next and previous values for which ptest is true.

	For example, nextcand(2^1000) returns 2^1000+297 because
	2^1000+297 is the smallest value x > 2^1000 for which
	ptest(x,1) is true.  And for example, prevcand(2^31-1,10,5)
	returns 2147483629 (2^31-19) because 2^31-19 is the largest
	value y < 2^31-1 for which ptest(y,10,5) is true.

	The nextcand and prevcand functions also have a 5 argument form:

		nextcand(num, count, skip, modval, modulus)
		prevcand(num, count, skip, modval, modulus)

	return the smallest (or largest) value ans > num (or < num) that
	is also == modval % modulus for which ptest(ans,count,skip) is true.

	The builtins nextprime(x) and prevprime(x) return the
	next and previous primes with respect to x respectively.
	As of this release, x must be < 2^32.  With one argument, they
	will return an error if x is out of range.  With two arguments,
	they will not generate an error but instead will return y.

	The builtin function pix(x) returns the number of primes <= x.
	As of this release, x must be < 2^32.  With one argument, pix(x)
	will return an error if x is out of range.  With two arguments,
	pix(x,y) will not generate an error but instead will return y.

	The builtin function factor may be used to search for the
	smallest factor of a given number.  The call factor(x,y)
	will attempt to find the smallest factor of x < min(x,y).
	As of this release, y must be < 2^32.  If y is omitted, y
	is assumed to be 2^32-1.

	If x < 0, factor(x,y) will return -1.  If no factor <
	min(x,y) is found, factor(x,y) will return 1.  In all other
	cases, factor(x,y) will return the smallest prime factor
	of x.  Note except for the case when abs(x) == 1, factor(x,y)
	will not return x.

	If factor is called with y that is too large, or if x or y
	is not an integer, calc will report an error.  If a 3rd argument
	is given, factor will return that value instead.  For example,
	factor(1/2,b,c) will return c instead of issuing an error.

	The builtin lfactor(x,y) searches a number of primes instead
	of below a limit.  As of this release, y must be <= 203280221
	(y <= pix(2^32-1)).  In all other cases, lfactor is operates
	in the same way as factor.

	If lfactor is called with y that is too large, or if x or y
	is not an integer, calc will report an error.  If a 3rd argument
	is given, lfactor will return that value instead.  For example,
	lfactor(1/2,b,c) will return c instead of issuing an error.

	The lfactor function is slower than factor.  If possible factor
	should be used instead of lfactor.

	The builtin isprime(x) will attempt to determine if x is prime.
	As of this release, x must be < 2^32.  With one argument, isprime(x)
	will return an error if x is out of range.  With two arguments,
	isprime(x,y) will not generate an error but instead will return y.

	The functions rcin, rcmul, rcout, rcpow, and rcsq are used to
	perform modular arithmetic calculations for large odd numbers
	faster than the usual methods.	To do this, you first use the
	rcin function to convert all input values into numbers which are
	in a format called REDC format.	 Then you use rcmul, rcsq, and
	rcpow to multiply such numbers together to produce results also
	in REDC format.	 Finally, you use rcout to convert a number in
	REDC format back to a normal number.  The addition, subtraction,
	negation, and equality comparison between REDC numbers are done
	using the normal modular methods.  For example, to calculate the
	value 13 * 17 + 1 (mod 11), you could use:

		p = 11;
		t1 = rcin(13, p);
		t2 = rcin(17, p);
		t3 = rcin(1, p);
		t4 = rcmul(t1, t2, p);
		t5 = (t4 + t3) % p;
		answer = rcout(t5, p);

	The swap function exchanges the values of two variables without
	performing copies.  For example, after:

		x = 17;
		y = 19;
		swap(x, y);

	then x is 19 and y is 17.  This function should not be used to
	swap a value which is contained within another one.  If this is
	done, then some memory will be lost.  For example, the following
	should not be done:

		mat x[5];
		swap(x, x[0]);

	The hash function returns a relatively small non-negative integer
	for one or more input values.  The hash values should not be used
	across runs of the calculator, since the algorithms used to generate
	the hash value may change with different versions of the calculator.

	The base function allows one to specify how numbers should be
	printer.  The base function provides a numeric shorthand to the
	config("mode") interface.  With no args, base() will return the
	current mode.  With 1 arg, base(val) will set the mode according to
	the arg and return the previous mode.

	The following convention is used to declare modes:

		 base	 config
		value	 string

		   2	"binary"	binary fractions
		   8	"octal"		octal fractions
		  10	"real"		decimal floating point
		  16	"hex"		hexadecimal fractions
		 -10	"int"		decimal integer
		 1/3	"frac"		decimal fractions
		1e20	"exp"		decimal exponential

	For convenience, any non-integer value is assumed to mean "frac",
	and any integer >= 2^64 is assumed to mean "exp".

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: builtin.end,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/builtin.end,v $
##
## Under source code control:	1995/07/10 01:17:53
## File existed as early as:	1995
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* command
*************

Command sequence

    This is a sequence of any the following command formats, where
    each command is terminated by a semicolon or newline.  Long command
    lines can be extended by using a back-slash followed by a newline
    character.	When this is done, the prompt shows a double angle
    bracket to indicate that the line is still in progress.  Certain
    cases will automatically prompt for more input in a similar manner,
    even without the back-slash.  The most common case for this is when
    a function is being defined, but is not yet completed.

    Each command sequence terminates only on an end of file.  In
    addition, commands can consist of expression sequences, which are
    described in the next section.


    define a function
    -----------------
    define function(params) { body }
    define function(params) = expression
	    This first form defines a full function which can consist
	    of declarations followed by many statements which implement
	    the function.

	    The second form defines a simple function which calculates
	    the specified expression value from the specified parameters.
	    The expression cannot be a statement.  However, the comma
	    and question mark operators can be useful.	Examples of
	    simple functions are:

		    define sumcubes(a, b) = a^3 + b^3
		    define pimod(a) = a % pi()
		    define printnum(a, n, p)
		    {
			if (p == 0) {
			    print a: "^": n, "=", a^n;
			} else {
			    print a: "^": n, "mod", p, "=", pmod(a,n,p);
			}
		    }


    read calc commands
    ------------------
    read filename
    read -once filename
	    This reads definitions from the specified calc resource filename.

	    The name can be quoted if desired.	The calculator uses the
	    CALCPATH environment variable to search through the specified
	    directories for the filename, similarly to the use of the
	    PATH environment variable.	If CALCPATH is not defined,
	    then a default path which is usually ":/usr/local/lib/calc"
	    is used.

	    The ".cal" extension is defaulted for input files, so that
	    if "filename" is not found, then "filename.cal" is then
	    searched for.  The contents of the filename are command
	    sequences which can consist of expressions to evaluate or
	    functions to define, just like at the top level command level.

	    When -once is given, the read command acts like the regular
	    read expect that it will ignore filename if is has been
	    previously read.

	    The read -once form is particularly useful in a resource
	    file that needs to read a 2nd resource file.  By using the
	    READ -once command, one will not reread that 2nd resource
	    file, nor will once risk entering into a infinite READ loop
	    (where that 2nd resource file directly or indirectly does
	    a READ of the first resource file).

	    If the -m mode disallows opening of files for reading,
	    this command will be disabled.


    write calc commands
    -------------------
    write filename
	    This writes the values of all global variables to the
	    specified filename, in such a way that the file can be
	    later read in order to recreate the variable values.
	    For speed reasons, values are written as hex fractions.
	    This command currently only saves simple types, so that
	    matrices, lists, and objects are not saved.	 Function
	    definitions are also not saved.

	    If the -m mode disallows opening of files for writing,
	    this command will be disabled.


    quit or exit
    ------------
    quit
    quit string
    exit
    exit string
	    The action of these commands depends on where they are used.
	    At the interactive level, they will cause calc it edit.
	    This is the normal way to leave the calculator.  In any
	    other use, they will stop the current calculation as if
	    an error had occurred.

	    If a string is given, then the string is printed as the reason
	    for quitting, otherwise a general quit message is printed.
	    The routine name and line number which executed the quit is
	    also printed in either case.

	    Exit is an alias for quit.

	    Quit is useful when a routine detects invalid arguments,
	    in order to stop a calculation cleanly.  For example,
	    for a square root routine, an error can be given if the
	    supplied parameter was a negative number, as in:

		    define mysqrt(n)
		    {
			if (! isnum(n))
			    quit "non-numeric argument";
			if (n < 0)
			    quit "Negative argument";
			return sqrt(n);
		    }

	    See 'more information about abort and quit' below for
	    more information.



    abort
    -----
    abort
    abort string
	    This command behaves like QUIT except that it will attempt
	    to return to the interactive level if permitted, otherwise
	    calc exit.

	    See 'more information about abort and quit' below for
	    more information.


    change current directory
    ------------------------
    cd
    cd dir
	    Change the current directory to 'dir'.  If 'dir' is ommitted,
	    change the current directory to the home directory, if $HOME
	    is set in the environment.


    show information
    ----------------
    show item
	    This command displays some information where 'item' is
	    one of the following:

		    blocks		unfreed named blocks
		    builtin		built in functions
		    config		config parameters and values
		    constants		cache of numeric constants
		    custom		custom functions if calc -C was used
		    errors		new error-values created
		    files		open files, file position and sizes
		    function		user-defined functions
		    globaltypes		global variables
		    objfunctions	possible object functions
		    objtypes		defined objects
		    opcodes func	internal opcodes for function `func'
		    sizes		size in octets of calc value types
		    realglobals		numeric global variables
		    statics		unscoped static variables
		    numbers		calc number cache
		    redcdata		REDC data defined
		    strings		calc string cache
		    literals		calc literal cache

	    Only the first 4 characters of item are examined, so:

		    show globals
		    show global
		    show glob

	    do the same thing.


    calc help
    ---------
    help
    help name
	    This displays a help related to 'name' or general
	    help of none is given.


    =-=


    more information about abort and quit
    =====================================

    Consider the following calc file called myfile.cal:

	print "start of myfile.cal";
	define q() {quit "quit from q()"; print "end of q()"}
	define a() {abort "abort from a()"}
	x = 3;
	{print "start #1"; if (x > 1) q()} print "after #1";
	{print "start #2"; if (x > 1) a()} print "after #2";
	{print "start #3"; if (x > 1) quit "quit from 3rd statement"}
	print "end of myfile.cal";

    The command:

	calc read myfile

    will produce:

	q() defined
	a() defined
	start statment #1
	quit from q()
	after statment #1
	start statment #2
	abort from a()

    The QUIT within the q() function prevented the ``end of q()''
    statement from being evaluated.  This QUIT command caused
    control to be returned to just after the place where q()
    was called.

    Notice that unlike QUIT, the ABORT inside function a() halts
    the processing of statements from the input source (myfile.cal).
    Because calc was not interactive, ABORT causes calc to exit.

    The command:

	calc -i read myfile

    will produce:

	q() defined
	a() defined
	start statment #1
	quit from q()
	after statment #1
	start statment #2
	abort from a()
	>		<==== calc interactive prompt

    because the '-i' calc causes ABORT to drop into an
    interactive prompt.	 However typing a QUIT or ABORT
    at the interactive prompt level will always calc to exit,
    even when calc is invoked with '-i'.

    Also observe that both of these commands:

	cat myfile.cal | calc
	cat myfile.cal | calc -i

    will produce:

	q() defined
	a() defined
	start statment #1
	quit from q()
	after statment #1
	start statment #2
	abort from a()

    The ABORT inside function a() halts the processing of statements
    from the input source (standard input).  Because standard input
    is not a terminal, using '-i' does not force it to drop into
    an interactive prompt.

    If one were to type in the contents of myfile.cal interactively,
    calc will produce:

	> print "start of myfile.cal";
	start of myfile.cal
	> define q() {quit "quit from q()"; print "end of q()"}
	q() defined
	> define a() {abort "abort from a()"}
	a() defined
	> x = 3;
	> {print "start #1"; if (x > 1) q()} print "after #1";
	start statment #1
	quit from q()
	after statment #1
	> {print "start #2"; if (x > 1) a()} print "after #2";
	start statment #2
	abort from a()
	> {print "start #3"; if (x > 1) quit "quit from 3rd statement"}
	start #3
	quit from 3rd statement

    The ABORT from within the a() function returned control to
    the interactive level.

    The QUIT (after the if (x > 1) ...) will cause calc to exit
    because it was given at the interactive prompt level.


    =-=


    Also see the help topic:

	    statement	    flow control and declaration statements
	    usage	    how to invoke the calc command and calc -options

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: command,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/command,v $
##
## Under source code control:	1991/07/21 04:37:17
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* config
*************

Configuration parameters

    Configuration parameters affect how the calculator performs certain
    operations.	 Among features that are controlled by these parameters
    are the accuracy of some calculations, the displayed format of results,
    the choice from possible alternative algorithms, and whether or not
    debugging information is displayed.	 The parameters are
    read or set using the "config" built-in function; they remain in effect
    until their values are changed by a config or equivalent instruction.
    The following parameters can be specified:

	    "all"		all configuration values listed below

	    "trace"		turns tracing features on or off
	    "display"		sets number of digits in prints.
	    "epsilon"		sets error value for transcendentals.
	    "maxprint"		sets maximum number of elements printed.
	    "mode"		sets printout mode.
	    "mode2"		sets 2nd base printout mode.
	    "mul2"		sets size for alternative multiply.
	    "sq2"		sets size for alternative squaring.
	    "pow2"		sets size for alternate powering.
	    "redc2"		sets size for alternate REDC.
	    "tilde"		enable/disable printing of the roundoff '~'
	    "tab"		enable/disable printing of leading tabs
	    "quomod"		sets rounding mode for quomod
	    "quo"		sets rounding mode for //, default for quo
	    "mod"		sets "rounding" mode for %, default for mod
	    "sqrt"		sets rounding mode for sqrt
	    "appr"		sets rounding mode for appr
	    "cfappr"		sets rounding mode for cfappr
	    "cfsim"		sets rounding mode for cfsim
	    "round"		sets rounding mode for round and bround
	    "outround"		sets rounding mode for printing of numbers
	    "leadzero"		enables/disables printing of 0 as in 0.5
	    "fullzero"		enables/disables padding zeros as in .5000
	    "maxscan"		maximum number of scan errors before abort
	    "prompt"		default interactive prompt
	    "more"		default interactive multi-line input prompt
	    "blkmaxprint"	number of block octets to print, 0 means all
	    "blkverbose"	TRUE=>print all lines, FALSE=>skip duplicates
	    "blkbase"		block output base
	    "blkfmt"		block output format
	    "calc_debug"	controls internal calc debug information
	    "resource_debug"	controls resource file debug information
	    "user_debug"	for user defined debug information
	    "verbose_quit"	TRUE=>print message on empty quit or abort
	    "ctrl_d"		The interactive meaning of ^D (Control D)
	    "program"		Read-only calc program or shell script path
	    "basename"		Read-only basename of the program value
	    "windows"		Read-only indicator of MS windows
	    "cygwin"		TRUE=>calc compiled with cygwin, Read-only
	    "compile_custom"	TRUE=>calc was compiled with custom functions
	    "allow_custom"	TRUE=>custom functions are enabled
	    "version"		Read-only calc version

    The "all" config value allows one to save/restore the configuration
    set of values.  The return of:

	    config("all")

    is a CONFIG type which may be used as the 2rd arg in a later call.
    One may save, modify and restore the configuration state as follows:

	    oldstate = config("all")
	    ...
	    config("tab", 0)
	    config("mod", 10)
	    ...
	    config("all", oldstate)

    This save/restore method is useful within functions.
    It allows functions to control their configuration without impacting
    the calling function.

    There are two configuration state aliases that may be set.	To
    set the backward compatible standard configuration:

	    config("all", "oldstd")

    The "oldstd" will restore the configuration to the default at startup.

    A new configuration that some people prefer may be set by:

	    config("all", "newstd")

    The "newstd" is not backward compatible with the historic
    configuration.  Even so, some people prefer this configuration
    and place the config("all", "newstd") command in their CALCRC
    startup files; newstd may also be established by invoking calc
    with the flag -n.

    The following are synonyms for true:

	    "on"
	    "true"
	    "t"
	    "yes"
	    "y"
	    "set"
	    "1"
	    any non-zero number

    The following are synonyms for false:

	    "off"
	    "false"
	    "f"
	    "no"
	    "n"
	    "unset"
	    "0"
	    the number zero (0)

    Examples of setting some parameters are:

	    config("mode", "exp");	    exponential output
	    config("display", 50);	    50 digits of output
	    epsilon(epsilon() / 8);	    3 bits more accuracy
	    config("tilde", 0)		    disable roundoff tilde printing
	    config("tab", "off")	    disable leading tab printing


Detailed config descriptions

    =-=

    config("trace", bitflag)

    When nonzero, the "trace" parameter activates one or more features
    that may be useful for debugging.  These features correspond to
    powers of 2 which contribute additively to config("trace"):

	1: opcodes are displayed as functions are evaluated

	2: disables the inclusion of debug lines in opcodes for functions
	   whose definitions are introduced with a left-brace.

	4: the number of links for real and complex numbers are displayed
	   when the numbers are printed; for real numbers "#" or for
	   complex numbers "##", followed by the number of links, are
	   printed immediately after the number.

	8: the opcodes for a new functions are displayed when the function
	   is successfully defined.

    See also resource_debug, calc_debug and user_debug below for more
    debug levels.

    =-=

    config("display", int)

    The "display" parameter specifies the maximum number of digits after
    the decimal point to be printed in real or exponential mode in
    normal unformatted printing (print, strprint, fprint) or in
    formatted printing (printf, strprintf, fprintf) when precision is not
    specified.	The initial value for oldstd is 20, for newstd 10.
    The parameter may be changed to the value d by either
    config("display", d) or by display (d).  This parameter does not change
    the stored value of a number.  Where rounding is necessary to
    display up to d decimal places, the type of rounding to be used is
    controlled by config("outround").

    =-=

    config("epsilon", real)
    epsilon(real)

    The "epsilon" parameter specifies the default accuracy for the
    calculation of functions for which exact values are not possible or
    not desired.  For most functions, the

		remainder = exact value - calculated value

    has absolute value less than epsilon, but, except when the sign of
    the remainder is controlled by an appropriate parameter, the
    absolute value of the remainder usually does not exceed epsilon/2.
    Functions which require an epsilon value accept an
    optional argument which overrides this default epsilon value for
    that single call.  The value v can be assigned to the "epsilon"
    parameter by either config("epsilon", v) or epsilon(v); each of
    these functions return the current epsilon value; config("epsilon")
    or epsilon() returns but does not change the epsilon value.
    For the transcendental functions and the functions sqrt() and
    appr(), the calculated value is always a multiple of epsilon.

    =-=

    config("mode", "mode_string")
    config("mode2", "mode_string")

    The "mode" parameter is a string specifying the mode for printing of
    numbers by the unformatted print functions, and the default
    ("%d" specifier) for formatted print functions.  The initial mode
    is "real".	The available modes are:

	  config("mode")	meaning				equivalent
	      string						base() call

	    "binary"		base 2 fractions		base(2)
	    "bin"

	    "octal"		base 8 fractions		base(8)
	    "oct"

	    "real"		base 10 floating point		base(10)
	    "float"
	    "default"

	    "integer"		base 10 integer			base(-10)
	    "int"

	    "hexadecimal"	base 16 fractions		base(16)
	    "hex"

	    "fraction"		base 10 fractions		base(1/3)
	    "frac"

	    "scientific"	base 10 scientific notation	base(1e20)
	    "sci"
	    "exp"

    Where multiple strings are given, the first string listed is what
    config("mode") will return.

    The "mode2" controls the double base output.  When set to a value
    other than "off", calc outputs files in both the "base" mode as
    well as the "base2" mode.  The "mode2" value may be any of the
    "mode" values with the addition of:

	    "off"		disable 2nd base output mode	base2(0)

    The base() builtin function sets and returns the "mode" value.
    The base2() builtin function sets and returns the "mode2" value.

    The default "mode" is "real".  The default "mode2" is "off".

    =-=

    config("maxprint", int)

    The "maxprint" parameter specifies the maximum number of elements to
    be displayed when a matrix or list is printed.  The initial value is 16.

    =-=

    config("mul2", int)
    config("sq2", int)

    Mul2 and sq2 specify the sizes of numbers at which calc switches
    from its first to its second algorithm for multiplying and squaring.
    The first algorithm is the usual method of cross multiplying, which
    runs in a time of O(N^2).  The second method is a recursive and
    complicated method which runs in a time of O(N^1.585).  The argument
    for these parameters is the number of binary words at which the
    second algorithm begins to be used.	 The minimum value is 2, and
    the maximum value is very large.  If 2 is used, then the recursive
    algorithm is used all the way down to single digits, which becomes
    slow since the recursion overhead is high.	If a number such as
    1000000 is used, then the recursive algorithm is never used, causing
    calculations for large numbers to slow down.  For a typical example
    on a 386, the two algorithms are about equal in speed for a value
    of 20, which is about 100 decimal digits.  A value of zero resets
    the parameter back to its default value.  Usually there is no need
    to change these parameters.

    =-=

    config("pow2", int)

    Pow2 specifies the sizes of numbers at which calc switches from
    its first to its second algorithm for calculating powers modulo
    another number.  The first algorithm for calculating modular powers
    is by repeated squaring and multiplying and dividing by the modulus.
    The second method uses the REDC algorithm given by Peter Montgomery
    which avoids divisions.  The argument for pow2 is the size of the
    modulus at which the second algorithm begins to be used.

    =-=

    config("redc2", int)

    Redc2 specifies the sizes of numbers at which calc switches from
    its first to its second algorithm when using the REDC algorithm.
    The first algorithm performs a multiply and a modular reduction
    together in one loop which runs in O(N^2).	The second algorithm
    does the REDC calculation using three multiplies, and runs in
    O(N^1.585).	 The argument for redc2 is the size of the modulus at
    which the second algorithm begins to be used.

    =-=

    config("tilde", boolean)

    Config("tilde") controls whether or not a leading tilde ('~') is
    printed to indicate that a number has not been printed exactly
    because the number of decimal digits required would exceed the
    specified maximum number.  The initial "tilde" value is 1.

    =-=

    config("tab", boolean)

    Config ("tab") controls the printing of a tab before results
    automatically displayed when working interactively.	 It does not
    affect the printing by the functions print, printf, etc.  The initial
    "tab" value is 1.

    =-=

    config("quomod", bitflag)
    config("quo", bitflag)
    config("mod", bitflag)
    config("sqrt", bitflag)
    config("appr", bitflag)
    config("cfappr", bitflag)
    config("cfsim", bitflag)
    config("outround", bitflag)
    config("round", bitflag)

    The "quomod", "quo", "mod", "sqrt", "appr", "cfappr", "cfsim", and
    "round" control the way in which any necessary rounding occurs.
    Rounding occurs when for some reason, a calculated or displayed
    value (the "approximation") has to differ from the "true value",
    e.g. for quomod and quo, the quotient is to be an integer, for sqrt
    and appr, the approximation is to be a multiple of an explicit or
    implicit "epsilon", for round and bround (both controlled by
    config("round")) the number of decimal places or fractional bits
    in the approximation is limited.  Zero value for any of these
    parameters indicates that the true value is greater than the approximation,
    i.e. the rounding is "down", or in the case of mod, that the
    residue has the same sign as the divisor.  If bit 4 of the
    parameter is set, the rounding of to the nearest acceptable candidate
    when this is uniquely determined; in the remaining ambiguous cases,
    the type of rounding is determined by the lower bits of the parameter
    value.  If bit 3 is set, the rounding for quo, appr and sqrt,
    is to the nearest even integer or the nearest even multiple of epsilon,
    and for round to the nearest even "last decimal place".  The effects
    of the 3 lowest bits of the parameter value are as follows:

	Bit 0: Unconditional reversal (down to up, even to odd, etc.)
	Bit 1: Reversal if the exact value is negative
	Bit 2: Reversal if the divisor or epsilon is negative

    (Bit 2 is irrelevant for the functions round and bround since the
    equivalent epsilon (a power of 1/10 or 1/2) is always positive.)

    For quomod, the quotient is rounded to an integer value as if
    evaluating quo with config("quo") == config("quomod").  Similarly,
    quomod and mod give the same residues if config("mod") == config("quomod").

    For the sqrt function, if bit 5 of config("sqrt") is set, the exact
    square-root is returned when this is possible; otherwise the
    result is rounded to a multiple of epsilon as determined by the
    five lower order bits.  Bit 6 of config("sqrt") controls whether the
    principal or non-principal square-root is returned.

    For the functions cfappr and cfsim, whether the "rounding" is down
    or up, etc. is controlled by the appropriate bits of config("cfappr")
    and config("cfsim") as for quomod, quo, etc.

    The "outround" parameter determines the type of rounding to be used
    by the various kinds of printing to the output: bits 0, 1, 3 and 4
    are used in the same way as for the functions round and bround.

    =-=

    config("leadzero", bool)

    The "leadzero" parameter controls whether or not a 0 is printed
    before the decimal point in non-zero fractions with absolute value
    less than 1, e.g. whether 1/2 is printed as 0.5 or .5.   The
    initial value is 0, corresponding to the printing .5.

    =-=

    config("fullzero", bool)

    The "fullzero" parameter controls whether or not in decimal floating-
    point printing, the digits are padded with zeros to reach the
    number of digits specified by config("display") or by a precision
    specification in formatted printing.  The initial value for this
    parameter is 0, so that, for example, if config("display") >= 2,
    5/4 will print in "real" mode as 1.25.

    =-=

    config("maxscan", int)

    The maxscan value controls how many scan errors are allowed
    before the compiling phase of a computation is aborted.  The initial
    value of "maxscan" is 20.  Setting maxscan to 0 disables this feature.

    =-=

    config("prompt", str)

    The default prompt when in interactive mode is "> ".  One may change
    this prompt to a more cut-and-paste friendly prompt by:

	    config("prompt", "; ")

    On windowing systems that support cut/paste of a line, one may
    cut/copy an input line and paste it directly into input.  The
    leading ';' will be ignored.

    =-=

    config("more", str)

    When inside multi-line input, the more prompt is used.  One may
    change it by:

	    config("more", ";; ")

    =-=

    config("blkmaxprint", int)

    The "blkmaxprint" config value limits the number of octets to print
    for a block.  A "blkmaxprint" of 0 means to print all octets of a
    block, regardless of size.

    The default is to print only the first 256 octets.

    =-=

    config("blkverbose", bool)

    The "blkverbose" determines if all lines, including duplicates
    should be printed.	If TRUE, then all lines are printed.  If false,
    duplicate lines are skipped and only a "*" is printed in a style
    similar to od.  This config value has not meaning if "blkfmt" is "str".

    The default value for "blkverbose" is FALSE: duplicate lines are
    not printed.

    =-=

    config("blkbase", "blkbase_string")

    The "blkbase" determines the base in which octets of a block
    are printed.  Possible values are:

	"hexadecimal"		Octets printed in 2 digit hex
	"hex"
	"default"

	"octal"			Octets printed in 3 digit octal
	"oct"

	"character"		Octets printed as chars with non-printing
	"char"			    chars as \123 or \n, \t, \r

	"binary"		Octets printed as 0 or 1 chars
	"bin"

	"raw"			Octets printed as is, i.e. raw binary
	"none"

    Where multiple strings are given, the first string listed is what
    config("blkbase") will return.

    The default "blkbase" is "hexadecimal".

    =-=

    config("blkfmt", "blkfmt_string")

    The "blkfmt" determines for format of how block are printed:

	"lines"		print in lines of up to 79 chars + newline
	"line"

	"strings"	print as one long string
	"string"
	"str"

	"od_style"	print in od-like format, with leading offset,
	"odstyle"	   followed by octets in the given base
	"od"

	"hd_style"	print in hex dump format, with leading offset,
	"hdstyle"	   followed by octets in the given base, followed
	"hd"		   by chars or '.' if no-printable or blank
	"default"

    Where multiple strings are given, the first string listed is what
    config("blkfmt") will return.

    The default "blkfmt" is "hd_style".

    =-=

    config("calc_debug", bitflag)

    The "calc_debug" is intended for controlling internal calc routines
    that test its operation, or collect or display information that
    might be useful for debug purposes.	 Much of the output from these
    will make sense only to calc wizards.   Zero value (the default for
    both oldstd and newstd) of config("resource_debug") corresponds to
    switching off all these routines.  For nonzero value, particular
    bits currently have the following meanings:

	n		Meaning of bit n of config("calc_debug")

	0	outputs shell commands prior to execution

	1	outputs currently active functions when a quit instruction
		is executed

	2	some details of shs, shs1 and md5 hash states are included
		in the output when these are printed

	3	when a function constructs a block value, tests are
		made that the result has the properties required for use of
		that block, e.g. that the pointer to the start of the
		block is not NULL, and that its "length" is not negative.
		A failure will result in a runtime error.

	4	Report on changes to the state of stdin as well as changes
		to internal variables that control the setting and restoring
		of stdin.

	5	Report on changes to the run state of calc.

	6	Report on rand() subtractive 100 shuffle generator issues.

    Bits >= 7 are reserved for future use and should not be used at this time.

    By default, "calc_debug" is 0.  The initial value may be overridden
    by the -D command line option.

    =-=

    config("resource_debug", bitflag)
    config("lib_debug", bitflag)

    The "resource_debug" parameter is intended for controlling the possible
    display of special information relating to functions, objects, and
    other structures created by instructions in calc scripts.
    Zero value of config("resource_debug") means that no such information
    is displayed.  For other values, the non-zero bits which currently
    have meanings are as follows:

	n		Meaning of bit n of config("resource_debug")

	0	When a function is defined, redefined or undefined at
		interactive level, a message saying what has been done
		is displayed.

	1	When a function is defined, redefined or undefined during
		the reading of a file, a message saying what has been done
		is displayed.

	2	Show func will display more information about a functions
		arguments and argument summary information.

	3	During execution, allow calc standard resource files
		to output additional debugging information.

    The value for config("resource_debug") in both oldstd and newstd is 3,
    but if calc is invoked with the -d flag, its initial value is zero.
    Thus, if calc is started without the -d flag, until config("resource_debug")
    is changed, a message will be output when a function is defined
    either interactively or during the reading of a file.

    The name config("lib_debug") is equivalent to config("resource_debug")
    and is included for backward compatibility.

    By default, "resource_debug" is 3.	The -d flag changes this default to 0.
    The initial value may be overridden by the -D command line option.

    =-=

    config("user_debug", int)

    The "user_debug" is provided for use by users.  Calc ignores this value
    other than to set it to 0 by default (for both "oldstd" and "newstd").
    No calc code or standard resource should change this value.	 Users
    should feel free to use it in any way.   In particular they may
    use particular bits for special purposes as with "calc_debug", or
    they may use it to indicate a debug level with larger values
    indicating more stringent and more informative tests with presumably
    slower operation or more memory usage, and a particular value (like
    -1 or 0) corresponding to "no tests".

    By default, "user_debug" is 0.  The initial value may be overridden
    by the -D command line option.

    =-=

    config("verbose_quit", bool)

    The "verbose_quit" controls the print of the message:

	quit or abort executed

    when a non-interactive quit or abort without an argument is encountered.
    A quit of abort without an argument does not display a message when
    invoked at the interactive level.

    By deafult, "verbose_quit" is false.

    =-=

    config("ctrl_d", "ctrl_d_string")

    For calc that is using the calc binding (not GNU-readline) facility:

	The "ctrl_d" controls the interactive meaning of ^D (Control D):

	    "virgin_eof"  If ^D is the only character that has been typed
	    "virgineof"	  on a line, then calc will exit.  Otherwise ^D
	    "virgin"	  will act according to the calc binding, which
	    "default"	  by default is a Emacs-style delete-char.

	    "never_eof"	  The ^D never exits calc and only acts according
	    "nevereof"	  calc binding, which by default is a Emacs-style
	    "never"	  delete-char.

	    "empty_eof"	  The ^D always exits calc if typed on an empty line.
	    "emptyeof"	  This condition occurs when ^D either the first
	    "empty"	  character typed, or when all other characters on
			  the line have been removed (say by deleting them).

	Where multiple strings are given, the first string listed is what
	config("ctrl_d") will return.

	Note that config("ctrl_d") actually controls each and every character
	that is bound to ``delete_char''.  By default, ``delete_char'' is
	Control D.  Any character(s) bound to ``delete_char'' will cause calc
	to exit (or not exit) as directed by config("ctrl_d").

	See the ``binding'' help for information on the default calc bindings.

	The default "ctrl_d", without GNU-readline is "virgin_eof".

    For calc that was compiled with the GNU-readline facility:

	The "ctrl_d" controls the interactive meaning of ^D (Control D):

	    "virgin_eof"  Same as "empty_eof"
	    "virgineof"
	    "virgin"
	    "default"

	    "never_eof"	  The ^D never exits calc and only acts according
	    "nevereof"	  calc binding, which by default is a Emacs-style
	    "never"	  delete-char.

	    "empty_eof"	  The ^D always exits calc if typed on an empty line.
	    "emptyeof"	  This condition occurs when ^D either the first
	    "empty"	  character typed, or when all other characters on

	Where multiple strings are given, the first string listed is what
	config("ctrl_d") will return.

	The default "ctrl_d", with GNU-readline is effectively "empty_eof".

	Literally it is "virgin_eof", but since "virgin_eof" is the
	same as "empty_eof", the default is effectively "empty_eof".

    Emacs users may find the default behavior objectionable, particularly
    when using the GNU-readline facility.  Such users may want to add the line:

	config("ctrl_d", "never_eof"),;

    to their ~/.calcrc startup file to prevent ^D from causing calc to exit.

    =-=

    config("program")		<== NOTE: This is a read-only config value

    The full path to the calc program, or the calc shell script can be
    obtained by:

	config("program")

    This config parameter is read-only and cannot be set.

    =-=

    config("basename")		<== NOTE: This is a read-only config value

    The calc program, or the calc shell script basename can be obtained by:

	config("basename")

    The config("basename") is the config("program") without any leading
    path.  If config("program") has a / in it, config("basename") is
    everything after the last /, otherwise config("basename") is the
    same as config("program").

    This config parameter is read-only and cannot be set.

    =-=

    config("windows")		<== NOTE: This is a read-only config value

    Returns TRUE if you are running on a MS windows system, false if you
    are running on an operating system that does not hate you.

    This config parameter is read-only and cannot be set.

    =-=

    config("cygwin")		<== NOTE: This is a read-only config value

    Returns TRUE if you calc was compiled with cygwin, false otherwise.

    This config parameter is read-only and cannot be set.

    =-=

    config("compile_custom")	<== NOTE: This is a read-only config value

    Returns TRUE if you calc was compiled with -DCUSTOM.  By default,
    the calc Makefile uses ALLOW_CUSTOM= -DCUSTOM so by default
    config("compile_custom") is TRUE.  If, however, calc is compiled
    without -DCUSTOM, then config("compile_custom") will be FALSE.

    The config("compile_custom") value is only affected by compile
    flags.   The calc -D runtime command line option does not change
    the config("compile_custom") value.

    See also config("allow_custom").

    This config parameter is read-only and cannot be set.

    =-=

    config("allow_custom")	<== NOTE: This is a read-only config value

    Returns TRUE if you custom functions are enabled.  To allow the use
    of custom functions, calc must be compiled with -DCUSTOM (which it
    is by default) AND calc run be run with the -D runtime command line
    option (which it is not by default).

    If config("allow_custom") is TRUE, then custom functions are allowed.
    If config("allow_custom") is FALSE, then custom functions are not
    allowed.

    See also config("compile_custom").

    This config parameter is read-only and cannot be set.

    =-=

    config("version")		<== NOTE: This is a read-only config value

    The version string of the calc program can be obtained by:

	config("version")

    This config parameter is read-only and cannot be set.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.10 $
## @(#) $Id: config,v 29.10 2004/07/27 23:45:52 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/config,v $
##
## Under source code control:	1991/07/21 04:37:17
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* custom
*************

NAME
    custom - custom builtin interface

SYNOPSIS
    custom([custname [, arg ...]])

TYPES
    custname	string
    arg		any

    return	any

DESCRIPTION
    This function will invoke the custom function interface.  Custom
    functions are accessed by the custname argument.  The remainder
    of the args, if any, are passed to the custom function.  The
    custom function may return any value, including null.  Calling
    custom with no args is equivalent to the command 'show custom'.

    In order to use the custom interface, two things must happen:

	1) Calc must be built to allow custom functions.  By default,
	   the master Makefile is shipped with ALLOW_CUSTOM= -DCUSTOM
	   which causes custom functions to be compiled in.

	2) Calc must be invoked with an argument of -C as in:

		calc -C

    In other words, explicit action must be taken in order to
    enable the use of custom functions.	 By default (no -C arg)
    custom functions are compiled in but disabled so that only
    portable calc scripts may be used.

    The main focus for calc is to provide a portable platform for
    multi-precision calculations in a C-like environment.  You should
    consider implementing algorithms in the calc language as a first
    choice.  Sometimes an algorithm requires use of special hardware, a
    non-portable OS or pre-compiled C library.	In these cases a custom
    interface may be needed.

    The custom function interface is intended to make is easy for
    programmers to add functionality that would be otherwise
    un-suitable for general distribution.  Functions that are
    non-portable (machine, hardware or OS dependent) or highly
    specialized are possible candidates for custom functions.

    To add a new custom function requires access to calc source.
    For information on how to add a new custom function, try:

	    help new_custom

    To serve as examples, calc is shipped with a few custom functions.
    If calc if invoked with -C, then either of the following will
    display information about the custom functions that are available:

	    show custom
    or:

	    custom()

    A few resource files that uses these function are also provided
    to serve as usage examples.

    We welcome submissions for new custom functions.  For information
    on how to submit new custom functions for general distribution, see:

	    help contrib

EXAMPLE
    If calc compiled with ALLOW_CUSTOM= (custom disabled):

    > print custom("sysinfo", "baseb")
	    Calc was built with custom functions disabled
    Error 10195

    If calc compiled with ALLOW_CUSTOM= -DCUSTOM and is invoked without -C:

    > print custom("sysinfo", "baseb")
	    Calc must be run with a -C argument to use custom function
    Error 10194

    If calc compiled with ALLOW_CUSTOM= -DCUSTOM and is invoked with -C:

    > print custom("sysinfo", "baseb")
    32

LIMITS
    By default, custom is limited to 100 args.

LINK LIBRARY
    none

SEE ALSO
    custom_cal, new_custom, contrib

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: custom,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/custom,v $
##
## Under source code control:	1997/03/09 16:33:22
## File existed as early as:	1997
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* define
*************

NAME
    define - command keyword to start a function definition

SYNTAX
    define fname([param_1 [= default_1], ...]) = [expr]
    define fname([param_1 [= default_1], ...]) { [statement_1 ... ] }

TYPES
    fname		identifier, not a builtin function name
    param_1, ...	identifiers, no two the same
    default_1, ...	expressions
    expr		expression
    statement_1, ...	statements

DESCRIPTION
    The intention of a function definition is that the identifier fname
    becomes the name of a function which may be called by an expression
    of the form  fname(arg_1, arg_2, ...), where arg_1, arg_2, ... are
    expressions (including possibly blanks, which are treated as
    null values).  Evaluation of the function begins with evaluation
    of arg_1, arg_2, ...; then, in increasing order of i, if arg_i is
    null-valued and  "= default_i" has been included in the definition,
    default_i is evaluated and its value becomes the value of arg_i.
    The instructions in expr or the listed statements are then executed
    with each occurrence of param_i replaced by the value obtained
    for arg_i.

    In a call, arg_i may be preceded by a backquote (`)  to indicate that
    evaluation of arg_i is not to include a final evaluation of an lvalue.
    For example, suppose a function f and a global variable A have been
    defined by:

		define f(x) = (x = 3);
		global mat A[3];

    If g() is  a function that evaluates to 2:

		f(A[g()]);

    assigns the value of A[2] to the parameter x and then assigns the
    value 3 to x:

		f(`A[g()]);

    has essentially the effect of assigning A[2] as an lvalue to x and
    then assigning the value 3 to A[2].  (Very old versions of calc
    achieved the same result by using '&' as in  f(&A[g()]).)

    The number of arguments arg_1, arg_2, ... in a call need not equal the
    number of parameters.  If there are fewer arguments than parameters,
    the "missing" values are assigned the null value.

    In the definition of a function, the builtin function param(n)
    provides a way of referring to the parameters.  If n (which may
    result from evaluating an expreession) is zero, it returns the number
    of arguments in a call to the function, and if 1 <= n <= param(0),
    param(n) refers to the parameter with index n.

    If no error occurs and no quit statement or abort statement is
    encountered during evaluation of the expression or the statements,
    the function call returns a value.  In the expression form, this is
    simply the value of the expression.

    In the statement form, if a return statement is encountered,
    the "return" keyword is to be either immediately followed by an
    expression or by a statement terminator (semicolon or rightbrace);
    in the former case, the expression is evaluated, evaluation of
    the function ceases, and the value obtained for the expression is
    returned as the "value of the function";  in the no-expression case,
    evaluation ceases immediately and the null-value is returned.

    In the expression form of definition, the end of the expression expr
    is to be indicated by either a semicolon or a newline not within
    a part enclosed by parentheses; the definition may extend over
    several physical lines by ending each line with a '\' character or by
    enclosing the expression in parentheses.  In interactive mode, that
    a definition has not been completed is indicated by the continuation
    prompt.   A ctrl-C interrupt at this stage will abort the definition.

    If the expr is omitted from an expression definition, as in:

		define h() = ;

    any call to the function will evaluate the arguments and return the
    null value.

    In the statement form, the definition ends when a matching right
    brace completes the "block" started by the initial left brace.
    Newlines within the block are treated as white space; statements
    within the block end with a ';' or a '}' matching an earlier '{'.

    If a function with name fname had been defined earlier, the old
    definition has no effect on the new definition, but if the definition
    is completed successfully, the new definition replaces the old one;
    otherwise the old definition is retained.  The number of parameters
    and their names in the new definiton may be quite different from
    those in the old definition.

    An attempt at a definition may fail because of scanerrors as the
    definition is compiled.  Common causes of these are: bad syntax,
    using identifiers as names of variables not yet defined.  It is
    not a fault to have in the definition a call to a function that has
    not yet been defined; it is sufficient that the function has been
    defined when a call is made to the function.

    After fname has been defined, the definition may be removed by the command:

		undefine fname

    The definitions of all user-defined functions may be removed by:

		undefine *

    If bit 0 of config("resource_debug") is set and the define command is
    at interactive level, a message saying that fname has been defined
    or redefined is displayed.  The same message is displayed if bit 1
    of config("resource_debug") is set and the define command is read
    from a file.

    The identifiers used for the parameters in a function definition do
    not form part of the completed definition.  For example,

	define f(a,b) = a + b;
	define g(alpha, beta) = alpha + beta;

    result in identical code for the functions f, g.

    If config("trace") & 8 is nonzero, the opcodes of a newly defined
    function are displayed on completion of its definition, parameters
    being specified by names used in the definition.  For example:

	> config("trace", 8),
	> define f(a,b) = a + b
	0: PARAMADDR a
	2: PARAMADDR b
	4: ADD
	5: RETURN
	f(a,b) defined

    The opcodes may also be displayed later using the show opcodes command;
    parameters will be specified by indices instead of by names.  For example:

	> show opco f
	0: PARAMADDR 0
	2: PARAMADDR 1
	4: ADD
	5: RETURN

    When a function is defined by the statement mode, the opcodes normally
    include DEBUG opcodes which specify statement boundaries at which
    SIGINT interruptions are likely to be least risky.  Inclusion of
    the DEBUG opcodes is disabled if config("trace") & 2 is nonzero.
    For details, see help interrupt.

    While config("trace") & 1 is nonzero, the opcodes are displayed as
    they are being evaluated.  The current function is identified by its
    name, or "*" in the case of a command-line and "**" in the case of
    an eval(str) evaluation.

    When a function is called, argument values may be of any type for
    which the operations and any functions used within the body of the
    definition can be executed.  For example, whatever the intention at
    the time they were defined, the functions f1(), f2() defined above
    may be called with integer, fractional, or complex-number values, or
    with both arguments strings, or under some compatibility conditions,
    matrices or objects.

EXAMPLE
    > define f(a,b) = 2*a + b;
    > define g(alpha, beta)
    >> {
    >>	   local a, pi2;
    >>
    >>	   pi2 = 2 * pi();
    >>	   a = sin(alpha % pi2);
    >>	   if (a > 0.0) {
    >>	       return a*beta;
    >>	   }
    >>	   if (beta > 0.0) {
    >>	       a *= cos(-beta % pi2);
    >>	   }
    >>	   return a;
    >> }

LIMITS
    The number of arguments in a function-call cannot exceed 100.

LIBRARY
    none

SEE ALSO
    param, variable, undefine, show

## Copyright (C) 2000  David I. Bell, Landon Curt Noll and Ernest Bowen
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.3 $
## @(#) $Id: define,v 29.3 2000/07/17 15:36:26 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/define,v $
##
##
## Under source code control:	1991/07/21 04:37:18
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* environment
*************

Environment variables

    CALCPATH

	A :-separated list of directories used to search for
	resource filenames (*.cal files) that do not begin with
	/, ./ or ~.

	If this variable does not exist, a compiled value
	is used.  Typically compiled in value is:

		    .:./cal:~/cal:${CALC_SHAREDIR}:${CUSTOMCALDIR}

	which is usually:

		    .:./cal:~/cal:/usr/share/calc:/usr/share/calc/custom

	This value is used by the READ command.	 It is an error
	if no such readable file is found.

	The CALCBINDINGS file searches the CALCPATH as well.


    CALCRC

	On startup (unless -h or -q was given on the command
	line), calc searches for files along the :-separated
	$CALCRC environment variable.

	If this variable does not exist, a compiled value
	is used.  Typically compiled in value is:

		    ${CALC_SHAREDIR}/startup:~/.calcrc:./.calcinit

	which is usually:

		    /usr/share/calc/startup:~/.calcrc:./.calcinit

	Missing files along the $CALCRC path are silently ignored.

    CALCBINDINGS

	On startup (unless -h or -q was given on the command
	line), calc reads key bindings from the filename specified
	in the $CALCRC environment variable.  These key bindings
	are used for command line editing and the command history.

	If this variable does not exist, a compiled value is used.
	Typically compiled in value is:

		    bindings

	The bindings file is searched along the CALCPATH.  Unlike
	the READ command, a .cal extension is not added.

	If the file could not be opened, or if standard input is not
	a terminal, then calc will still run, but fancy command line
	editing is disabled.

	NOTE: If calc was compiled with GNU-readline support, the
	      CALCBINDINGS facility is ignored and the standard
	      readline mechanisms (see readline(3)) are used.

    HOME

	This value is taken to be the home directory of the
	current user.  It is used when files begin with '~/'.

	If this variable does not exist, the home directory password
	entry of the current user is used.  If that information
	is not available, '.' is used.

    PAGER

	When invoking help, this environment variable is used
	to display a help file.

	If this variable does not exist, a compiled value
	is used.  Typically compiled in value is something
	such as 'more', 'less', 'pg' or 'cat'.

    SHELL

	When a !-command is used, the program indicated by
	this environment variable is used.

	If this variable does not exist, a compiled value
	is used.  Typically compiled in value is something
	such as 'sh' is used.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.3 $
## @(#) $Id: environment,v 29.3 2004/07/26 07:10:43 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/environment,v $
##
## Under source code control:	1991/07/23 05:47:25
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* expression
*************

Expression sequences

    This is a sequence of statements, of which expression statements
    are the commonest case.  Statements are separated with semicolons,
    and the newline character generally ends the sequence.  If any
    statement is an expression by itself, or is associated with an
    'if' statement which is true, then two special things can happen.
    If the sequence is executed at the top level of the calculator,
    then the value of '.' is set to the value of the last expression.
    Also, if an expression is a non-assignment, then the value of the
    expression is automatically printed if its value is not NULL.
    Some operations such as	pre-increment and plus-equals are also
    treated as assignments.

    Examples of this are the following:

    expression		    sets '.' to		prints
    ----------		    -----------		------
    3+4				7		   7
    2*4; 8+1; fact(3)		6		8, 9, and 6
    x=3^2			9		   -
    if (3 < 2) 5; else 6	6		   6
    x++				old x		   -
    print fact(4)		-		   24
    null()			null()		   -

    Variables can be defined at the beginning of an expression sequence.
    This is most useful for local variables, as in the following example,
    which sums the square roots of the first few numbers:

    local s, i; s = 0; for (i = 0; i < 10; i++) s += sqrt(i); s

    If a return statement is executed in an expression sequence, then
    the result of the expression sequence is the returned value.  In
    this case, '.' is set to the value, but nothing is printed.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: expression,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/expression,v $
##
## Under source code control:	1991/07/21 04:37:18
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* errorcodes
*************

Calc generated error codes (see the error help file):

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: errorcodes.hdr,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/errorcodes.hdr,v $
##
## Under source code control:	1995/12/18 03:19:11
## File existed as early as:	1995
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/
    10001	Division by zero
    10002	Indeterminate (0/0)
    10003	Bad arguments for +
    10004	Bad arguments for binary -
    10005	Bad arguments for *
    10006	Bad arguments for /
    10007	Bad argument for unary -
    10008	Bad argument for squaring
    10009	Bad argument for inverse
    10010	Bad argument for ++
    10011	Bad argument for --
    10012	Bad argument for int
    10013	Bad argument for frac
    10014	Bad argument for conj
    10015	Bad first argument for appr
    10016	Bad second argument for appr
    10017	Bad third argument for appr
    10018	Bad first argument for round
    10019	Bad second argument for round
    10020	Bad third argument for round
    10021	Bad first argument for bround
    10022	Bad second argument for bround
    10023	Bad third argument for bround
    10024	Bad first argument for sqrt
    10025	Bad second argument for sqrt
    10026	Bad third argument for sqrt
    10027	Bad first argument for root
    10028	Bad second argument for root
    10029	Bad third argument for root
    10030	Bad argument for norm
    10031	Bad first argument for << or >>
    10032	Bad second argument for << or >>
    10033	Bad first argument for scale
    10034	Bad second argument for scale
    10035	Bad first argument for ^
    10036	Bad second argument for ^
    10037	Bad first argument for power
    10038	Bad second argument for power
    10039	Bad third argument for power
    10040	Bad first argument for quo or //
    10041	Bad second argument for quo or //
    10042	Bad third argument for quo
    10043	Bad first argument for mod or %
    10044	Bad second argument for mod or %
    10045	Bad third argument for mod
    10046	Bad argument for sgn
    10047	Bad first argument for abs
    10048	Bad second argument for abs
    10049	Scan error in argument for eval
    10050	Non-simple type for str
    10051	Non-real epsilon for exp
    10052	Bad first argument for exp
    10053	Non-file first argument for fputc
    10054	Bad second argument for fputc
    10055	File not open for writing for fputc
    10056	Non-file first argument for fgetc
    10057	File not open for reading for fgetc
    10058	Non-string arguments for fopen
    10059	Unrecognized mode for fopen
    10060	Non-file first argument for freopen
    10061	Non-string or unrecognized mode for freopen
    10062	Non-string third argument for freopen
    10063	Non-file argument for fclose
    10064	Non-file argument for fflush
    10065	Non-file first argument for fputs
    10066	Non-string argument after first for fputs
    10067	File not open for writing for fputs
    10068	Non-file argument for fgets
    10069	File not open for reading for fgets
    10070	Non-file first argument for fputstr
    10071	Non-string argument after first for fputstr
    10072	File not open for writing for fputstr
    10073	Non-file first argument for fgetstr
    10074	File not open for reading for fgetstr
    10075	Non-file argument for fgetline
    10076	File not open for reading for fgetline
    10077	Non-file argument for fgetfield
    10078	File not open for reading for fgetfield
    10079	Non-file argument for rewind
    10080	Non-integer argument for files
    10081	Non-string fmt argument for fprint
    10082	Stdout not open for writing to ???
    10083	Non-file first argument for fprintf
    10084	Non-string second (fmt) argument for fprintf
    10085	File not open for writing for fprintf
    10086	Non-string first (fmt) argument for strprintf
    10087	Error in attempting strprintf ???
    10088	Non-file first argument for fscan
    10089	File not open for reading for fscan
    10090	Non-string first argument for strscan
    10091	Non-file first argument for fscanf
    10092	Non-string second (fmt) argument for fscanf
    10093	Non-lvalue argument after second for fscanf
    10094	File not open for reading or other error for fscanf
    10095	Non-string first argument for strscanf
    10096	Non-string second (fmt) argument for strscanf
    10097	Non-lvalue argument after second for strscanf
    10098	Some error in attempting strscanf ???
    10099	Non-string first (fmt) argument for scanf
    10100	Non-lvalue argument after first for scanf
    10101	Some error in attempting scanf ???
    10102	Non-file argument for ftell
    10103	File not open or other error for ftell
    10104	Non-file first argument for fseek
    10105	Non-integer or negative second argument for fseek
    10106	File not open or other error for fseek
    10107	Non-file argument for fsize
    10108	File not open or other error for fsize
    10109	Non-file argument for feof
    10110	File not open or other error for feof
    10111	Non-file argument for ferror
    10112	File not open or other error for ferror
    10113	Non-file argument for ungetc
    10114	File not open for reading for ungetc
    10115	Bad second argument or other error for ungetc
    10116	Exponent too big in scanning
    10117	E_ISATTY1 is no longer used
    10118	E_ISATTY2 is no longer used
    10119	Non-string first argument for access
    10120	Bad second argument for access
    10121	Bad first argument for search
    10122	Bad second argument for search
    10123	Bad third argument for search
    10124	Bad fourth argument for search
    10125	Cannot find fsize or fpos for search
    10126	File not readable for search
    10127	Bad first argument for rsearch
    10128	Bad second argument for rsearch
    10129	Bad third argument for rsearch
    10130	Bad fourth argument for rsearch
    10131	Cannot find fsize or fpos for rsearch
    10132	File not readable for rsearch
    10133	Too many open files
    10134	Attempt to rewind a file that is not open
    10135	Bad argument type for strerror
    10136	Index out of range for strerror
    10137	Bad epsilon for cos
    10138	Bad first argument for cos
    10139	Bad epsilon for sin
    10140	Bad first argument for sin
    10141	Non-string argument for eval
    10142	Bad epsilon for arg
    10143	Bad first argument for arg
    10144	Non-real argument for polar
    10145	Bad epsilon for polar
    10146	Non-integral argument for fcnt
    10147	Non-variable first argument for matfill
    10148	Non-matrix first argument-value for matfill
    10149	Non-matrix argument for matdim
    10150	Non-matrix argument for matsum
    10151	E_ISIDENT is no longer used
    10152	Non-matrix argument for mattrans
    10153	Non-two-dimensional matrix for mattrans
    10154	Non-matrix argument for det
    10155	Matrix for det not of dimension 2
    10156	Non-square matrix for det
    10157	Non-matrix first argument for matmin
    10158	Non-positive-integer second argument for matmin
    10159	Second argument for matmin exceeds dimension
    10160	Non-matrix first argument for matmin
    10161	Second argument for matmax not positive integer
    10162	Second argument for matmax exceeds dimension
    10163	Non-matrix argument for cp
    10164	Non-one-dimensional matrix for cp
    10165	Matrix size not 3 for cp
    10166	Non-matrix argument for dp
    10167	Non-one-dimensional matrix for dp
    10168	Different-size matrices for dp
    10169	Non-string argument for strlen
    10170	Non-string argument for strcat
    10171	Non-string first argument for strcat
    10172	Non-non-negative integer second argument for strcat
    10173	Bad argument for char
    10174	Non-string argument for ord
    10175	Non-list-variable first argument for insert
    10176	Non-integral second argument for insert
    10177	Non-list-variable first argument for push
    10178	Non-list-variable first argument for append
    10179	Non-list-variable first argument for delete
    10180	Non-integral second argument for delete
    10181	Non-list-variable argument for pop
    10182	Non-list-variable argument for remove
    10183	Bad epsilon argument for ln
    10184	Non-numeric first argument for ln
    10185	Non-integer argument for error
    10186	Argument outside range for error
    10187	Attempt to eval at maximum input depth
    10188	Unable to open string for reading
    10189	First argument for rm is not a non-empty string
    10190	Unable to remove a file
    10191	Operation allowed because calc mode disallows read operations
    10192	Operation allowed because calc mode disallows write operations
    10193	Operation allowed because calc mode disallows exec operations
    10194	Unordered arguments for min
    10195	Unordered arguments for max
    10196	Unordered items for minimum of list
    10197	Unordered items for maximum of list
    10198	Size undefined for argument type
    10199	Calc must be run with a -C argument to use custom function
    10200	Calc was built with custom functions disabled
    10201	Custom function unknown, try: show custom
    10202	Non-integral length for block
    10203	Negative or too-large length for block
    10204	Non-integral chunksize for block
    10205	Negative or too-large chunksize for block
    10206	Named block does not exist for blkfree
    10207	Non-integral id specification for blkfree
    10208	Block with specified id does not exist
    10209	Block already freed
    10210	No-realloc protection prevents blkfree
    10211	Non-integer argument for blocks
    10212	Non-allocated index number for blocks
    10213	Non-integer or negative source index for copy
    10214	Source index too large for copy
    10215	E_COPY3 is no longer used
    10216	Non-integer or negative number for copy
    10217	Number too large for copy
    10218	Non-integer or negative destination index for copy
    10219	Destination index too large for copy
    10220	Freed block source for copy
    10221	Unsuitable source type for copy
    10222	Freed block destinction for copy
    10223	Unsuitable destination type for copy
    10224	Incompatible source and destination for copy
    10225	No-copy-from source variable
    10226	No-copy-to destination variable
    10227	No-copy-from source named block
    10228	No-copy-to destination named block
    10229	No-relocation destination for copy
    10230	File not open for copy
    10231	fseek or fsize failure for copy
    10232	fwrite error for copy
    10233	fread error for copy
    10234	Non-variable first argument for protect
    10235	Non-integer second argument for protect
    10236	Out-of-range second argument for protect
    10237	No-copy-to destination for matfill
    10238	No-assign-from source for matfill
    10239	Non-matrix argument for mattrace
    10240	Non-two-dimensional argument for mattrace
    10241	Non-square argument for mattrace
    10242	Bad epsilon for tan
    10243	Bad argument for tan
    10244	Bad epsilon for cot
    10245	Bad argument for cot
    10246	Bad epsilon for sec
    10247	Bad argument for sec
    10248	Bad epsilon for csc
    10249	Bad argument for csc
    10250	Bad epsilon for sinh
    10251	Bad argument for sinh
    10252	Bad epsilon for cosh
    10253	Bad argument for cosh
    10254	Bad epsilon for tanh
    10255	Bad argument for tanh
    10256	Bad epsilon for coth
    10257	Bad argument for coth
    10258	Bad epsilon for sech
    10259	Bad argument for sech
    10260	Bad epsilon for csch
    10261	Bad argument for csch
    10262	Bad epsilon for asin
    10263	Bad argument for asin
    10264	Bad epsilon for acos
    10265	Bad argument for acos
    10266	Bad epsilon for atan
    10267	Bad argument for atan
    10268	Bad epsilon for acot
    10269	Bad argument for acot
    10270	Bad epsilon for asec
    10271	Bad argument for asec
    10272	Bad epsilon for acsc
    10273	Bad argument for acsc
    10274	Bad epsilon for asin
    10275	Bad argument for asinh
    10276	Bad epsilon for acosh
    10277	Bad argument for acosh
    10278	Bad epsilon for atanh
    10279	Bad argument for atanh
    10280	Bad epsilon for acoth
    10281	Bad argument for acoth
    10282	Bad epsilon for asech
    10283	Bad argument for asech
    10284	Bad epsilon for acsch
    10285	Bad argument for acsch
    10286	Bad epsilon for gd
    10287	Bad argument for gd
    10288	Bad epsilon for agd
    10289	Bad argument for agd
    10290	Log of zero or infinity
    10291	String addition failure
    10292	String multiplication failure
    10293	String reversal failure
    10294	String subtraction failure
    10295	Bad argument type for bit
    10296	Index too large for bit
    10297	Non-integer second argument for setbit
    10298	Out-of-range index for setbit
    10299	Non-string first argument for setbit
    10300	Bad argument for or
    10301	Bad argument for and
    10302	Allocation failure for string or
    10303	Allocation failure for string and
    10304	Bad argument for xorvalue
    10305	Bad argument for comp
    10306	Allocation failure for string diff
    10307	Allocation failure for string comp
    10308	Bad first argument for segment
    10309	Bad second argument for segment
    10310	Bad third argument for segment
    10311	Failure for string segment
    10312	Bad argument type for highbit
    10313	Non-integer argument for highbit
    10314	Bad argument type for lowbit
    10315	Non-integer argument for lowbit
    10316	Bad argument type for unary hash op
    10317	Bad argument type for binary hash op
    10318	Bad first argument for head
    10319	Bad second argument for head
    10320	Failure for strhead
    10321	Bad first argument for tail
    10322	Bad second argument for tail
    10323	Failure for strtail
    10324	Failure for strshift
    10325	Non-string argument for strcmp
    10326	Bad argument type for strncmp
    10327	Varying types of argument for xor
    10328	Bad argument type for xor
    10329	Bad argument type for strcpy
    10330	Bad argument type for strncpy
    10331	Bad argument type for unary backslash
    10332	Bad argument type for setminus
    10333	Bad first argument type for indices
    10334	Bad second argument for indices
    10335	Too-large re(argument) for exp
    10336	Too-large re(argument) for sinh
    10337	Too-large re(argument) for cosh
    10338	Too-large im(argument) for sin
    10339	Too-large im(argument) for cos
    10340	Infinite or too-large result for gd
    10341	Infinite or too-large result for agd
    10342	Too-large value for power
    10343	Too-large value for root
    10344	Non-real first arg for digit
    10345	Non-integral second arg for digit
    10346	Bad third arg for digit
    10347	Bad first argument for places
    10348	Bad second argument for places
    10349	Bad first argument for digits
    10350	Bad second argument for digits
    10351	Bad first argument for ilog
    10352	Bad second argument for ilog
    10353	Bad argument for ilog10
    10354	Bad argument for ilog2
    10355	Non-integer second arg for comb
    10356	Too-large second arg for comb
    10357	Bad argument for catalan
    10358	Bad argument for bern
    10359	Bad argument for euler
    10360	Bad argument for sleep
    10361	calc_tty failure
    20000	base of user defined errors

*************
* file
*************

Using files

    The calculator provides some functions which allow the program to
    read or write text files.  These functions use stdio internally,
    and the functions appear similar to some of the stdio functions.
    Some differences do occur, as will be explained here.

    Names of files are subject to ~ expansion just like the C or
    Korn shell.	 For example, the file name:

	    ~/.rc.cal

    refers to the file '.rc.cal' under your home directory.  The
    file name:

	    ~chongo/.rc.cal

    refers to the a file 'rc.cal' under the home directory of 'chongo'.

    A file can be opened for either reading, writing, or appending.
    To do this, the 'fopen' function is used, which accepts a filename
    and an open mode, both as strings.	You use 'r' for reading, 'w'
    for writing, and 'a' for appending.	 For example, to open the file
    'foo' for reading, the following could be used:

	    fd = fopen('foo', 'r');

    If the open is unsuccessful, the numeric value of errno is returned.
    If the open is successful, a value of type 'file' will be returned.
    You can use the 'isfile' function to test the return value to see
    if the open succeeded.  You should assign the return value of fopen
    to a variable for later use.  File values can be copied to more than
    one variable, and using any of the variables with the same file value
    will produce the same results.

    If you overwrite a variable containing a file value or don't save the
    result of an 'fopen', the opened file still remains open.  Such 'lost'
    files can be recovered by using the 'files' function.  This function
    either takes no arguments or else takes one integer argument.  If no
    arguments are given, then 'files' returns the maximum number of opened
    files.  If an argument is given, then the 'files' function uses it as
    an index into an internal table of open files, and returns a value
    referring to one the open files.  If that entry in the table is not
    in use, then the null value is returned instead.  Index 0 always
    refers to standard input, index 1 always refers to standard output,
    and index 2 always refers to standard error.  These three files are
    already open by the calculator and cannot be closed.  As an example
    of using 'files', if you wanted to assign a file value which is
    equivalent to stdout, you could use:

	    stdout = files(1);

    The 'fclose' function is used to close a file which had been opened.
    When this is done, the file value associated with the file remains
    a file value, but appears 'closed', and cannot be used in further
    file-related calls (except fclose) without causing errors.	This same
    action occurs to all copies of the file value.  You do not need to
    explicitly close all the copies of a file value.  The 'fclose'
    function returns the numeric value of errno if there had been an
    error using the file, or the null value if there was no error.

    The builtin 'errno' can be use to convert an errno number into
    a slightly more meaningful error message:

	    badfile = fopen("not_a_file", "r");
	    if (!isfile(badfile)) {
		print "error #" : badfile : ":", errno(badfile);
	    }

    File values can be printed.	 When this is done, the filename of the
    opened file is printed inside of quote marks.  If the file value had
    been closed, then the null string is printed.  If a file value is the
    result of a top-level expression, then in addition to the filename,
    the open mode, file position, and possible EOF, error, and closed
    status is also displayed.

    File values can be used inside of 'if' tests.  When this is done,
    an opened file is TRUE, and a closed file is FALSE.	 As an example
    of this, the following loop will print the names of all the currently
    opened non-standard files with their indexes, and then close them:

	    for (i = 3; i < files(); i++) {
		    if (files(i)) {
			    print i, files(i);
			    fclose(files(i));
		    }
	    }

    The functions to read from files are 'fgetline' and 'fgetc'.
    The 'fgetline' function accepts a file value, and returns the next
    input line from a file.  The line is returned as a string value, and
    does not contain the end of line character.	 Empty lines return the
    null string.  When the end of file is reached, fgetline returns the
    null value.	 (Note the distinction between a null string and a null
    value.)  If the line contained a numeric value, then the 'eval'
    function can then be used to convert the string to a numeric value.
    Care should be used when doing this, however, since eval will
    generate an error if the string doesn't represent a valid expression.
    The 'fgetc' function returns the next character from a file as a
    single character string.  It returns the null value when end of file
    is reached.

    The 'printf' and 'fprintf' functions are used to print results to a
    file (which could be stdout or stderr).  The 'fprintf' function
    accepts a file variable, whereas the 'printf' function assumes the
    use of 'files(1)' (stdout).	 They both require a format string, which
    is used in almost the same way as in normal C.  The differences come
    in the interpretation of values to be printed for various formats.
    Unlike in C, where an unmatched format type and value will cause
    problems, in the calculator nothing bad will happen.  This is because
    the calculator knows the types of all values, and will handle them
    all reasonably.  What this means is that you can (for example), always
    use %s or %d in your format strings, even if you are printing a non-
    string or non-numeric value.  For example, the following is valid:

	    printf("Two values are %d and %s\n", "fred", 4567);

    and will print "Two values are fred and 4567".

    Using particular format characters, however, is still useful if
    you wish to use width or precision arguments in the format, or if
    you wish to print numbers in a particular format.  The following
    is a list of the possible numeric formats:

	    %d		print in currently defined numeric format
	    %f		print as floating point
	    %e		print as exponential
	    %r		print as decimal fractions
	    %x		print as hex fractions
	    %o		print as octal fractions
	    %b		print as binary fractions

    Note then, that using %d in the format makes the output configurable
    by using the 'config' function to change the output mode, whereas
    the other formats override the mode and force the output to be in
    the specified format.

    Using the precision argument will override the 'config' function
    to set the number of decimal places printed.  For example:

	    printf("The number is %.100f\n", 1/3);

    will print 100 decimal places no matter what the display configuration
    value is set to.

    The %s and %c formats are identical, and will print out the string
    representation of the value.  In these cases, the precision argument
    will truncate the output the same way as in standard C.

    If a matrix or list is printed, then the output mode and precision
    affects the printing of each individual element.  However, field
    widths are ignored since these values print using multiple lines.
    Field widths are also ignored if an object value prints on multiple
    lines.

    The functions 'fputc' and 'fputs' write a character and string to
    a file respectively.

    The final file-related functions are 'fflush', 'ferror', and 'feof'.
    The 'fflush' function forces buffered output to a file.  The 'ferror'
    function returns nonzero if an error had occurred to a file.  The
    'feof' function returns nonzero if end of file has been reached
    while reading a file.

    The 'strprintf' function formats output similarly to 'printf',
    but the output is returned as a string value instead of being
    printed.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: file,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/file,v $
##
## Under source code control:	1991/07/21 04:37:19
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* history
*************

Command history

    There is a command line editor and history mechanism built
    into calc, which is active when stdin is a terminal.  When
    stdin is not a terminal, then the command line editor is
    disabled.

    Lines of input to calc are always terminated by the return
    (or enter) key.  When the return key is typed, then the current
    line is executed and is also saved into a command history list
    for future recall.

    Before the return key is typed, the current line can be edited
    using emacs-like editing commands.	As examples, ^A moves to
    the beginning of the line, ^F moves forwards through the line,
    backspace removes characters from the line, and ^K kills the
    rest of the line.

    Previously entered commands can be recalled by using the history
    list.  The history list functions in a LRU manner, with no
    duplicated lines.  This means that the most recently entered
    lines are always at the end of the history list where they are
    easiest to recall.

    Typing <esc>h lists all of the commands in the command history
    and numbers the lines.  The most recently executed line is always
    number 1, the next most recent number 2, and so on.	 The numbering
    for a particular command therefore changes as lines are entered.

    Typing a number at the beginning of a line followed by <esc>g
    will recall that numbered line.  So that for example, 2<esc>g
    will recall the second most recent line that was entered.

    The ^P and ^N keys move up and down the lines in the history list.
    If they attempt to go off the top or bottom of the list, then a
    blank line is shown to indicate this, and then they wrap around
    to the other end of the list.

    Typing a string followed by a ^R will search backwards through
    the history and recall the most recent command which begins
    with that string.

    Typing ^O inserts the current line at the end of the history list
    without executing it, and starts a new line.  This is useful to
    rearrange old history lines to become recent, or to save a partially
    completed command so that another command can be typed ahead of it.

    If your terminal has arrow keys which generate escape sequences
    of a particular kind (<esc>[A and so on), then you can use
    those arrow keys in place of the ^B, ^F, ^P, and ^N keys.

    The actual keys used for editing are defined in a bindings file,
    usually called /usr/local/lib/calc/bindings.  Changing the entries
    in this file will change the key bindings used for editing.	 If the
    file is not readable, then a message will be output and command
    line editing is disabled.  In this case you can only edit each
    line as provided by the terminal driver in the operating system.

    A shell command can be executed by typing '!cmd', where cmd
    is the command to execute.	If cmd is not given, then a shell
    command level is started.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: history,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/history,v $
##
## Under source code control:	1991/07/21 04:37:20
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* interrupt
*************

Interrupts

    While a calculation is in progress, you can generate the SIGINT
    signal, and the calculator will catch it.  At appropriate points
    within a calculation, the calculator will check that the signal
    has been given, and will abort the calculation cleanly.  If the
    calculator is in the middle of a large calculation, it might be
    a while before the interrupt has an effect.

    You can generate the SIGINT signal multiple times if necessary,
    and each time the calculator will abort the calculation at a more
    risky place within the calculation.	 Each new interrupt prints a
    message of the form:

	    [Abort level n]

    where n ranges from 1 to 3.	 For n equal to 1, the calculator will
    abort calculations at the next statement boundary specified by an
    ABORT opcode as described below.  For n equal to 2, the calculator
    will abort calculations at the next opcode boundary.  For n equal to 3,
    the calculator will abort calculations at the next attempt to allocate
    memory for the result of an integer arithmetic operation; this
    level may be appropriate for stopping a builtin operation like
    inversion of a large matrix.

    If a final interrupt is given when n is 3, the calculator will
    immediately abort the current calculation and longjmp back to the
    top level command level.  Doing this may result in corrupted data
    structures and unpredictable future behavior, and so should only
    be done as a last resort.  You are advised to quit the calculator
    after this has been done.

ABORT opcodes

    If config("trace") & 2 is zero, ABORT opcodes are introduced at
    various places in the opcodes for evaluation of command lines
    and functions defined by "define ... { ... }" commands.  In the
    following, config("trace") has been set equal to 8 so that opcodes
    are displayed when a function is defined.   The function f(x)
    evaluates x + (x - 1) + (x - 2) + ... until a zero term is
    encountered.  If f() is called with a negative or fractional x,
    the calculation is never completed and to stop it, an interruption
    (on many systems, by ctrl-C) will be necessary.

	> config("trace", 8),
	> define f(x) {local s; while (x) {s += x--} return s}
	0: DEBUG line 2
	2: PARAMADDR x
	4: JUMPZ 19
	6: DEBUG line 2
	8: LOCALADDR s
	10: DUPLICATE
	11: PARAMADDR x
	13: POSTDEC
	14: POP
	15: ADD
	16: ASSIGNPOP
	17: JUMP 2
	19: DEBUG line 2
	21: LOCALADDR s
	23: RETURN
	f(x) defined

    (The line number following DEBUG refers to the line in the file
    from which the definition is read.)   If an attempt is made to
    evaluate f(-1), the effect of the DEBUG at opcode 6 ensures that
    a single SIGINT will stop the calculation at a start of
    {s += x--} loop.  In interactive mode, with ^C indicating
    input of ctrl-C, the displayed output is as in:

	> f(-1)
	^C
	[Abort level 1]
	"f": line 2: Calculation aborted at statement boundary

    The DEBUG opcodes are disabled by nonzero config("trace") & 2.
    Changing config("trace") to achieve this, and defining g(x) with
    the same definition as for f(x) gives:

	> define g(x) {local s; while (x) {s += x--} return s}
	0: PARAMADDR x
	2: JUMPZ 15
	4: LOCALADDR s
	6: DUPLICATE
	7: PARAMADDR x
	9: POSTDEC
	10: POP
	11: ADD
	12: ASSIGNPOP
	13: JUMP 0
	15: LOCALADDR s
	17: RETURN
	g(x) defined

    If g(-1) is called, two interrupts are necessary, as in:

	> g(-1)
	^C
	[Abort level 1]
	^C
	[Abort level 2]
	"g": Calculation aborted in opcode

## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.4 $
## @(#) $Id: interrupt,v 29.4 2000/07/17 15:38:52 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/interrupt,v $
##
## Under source code control:	1991/07/21 04:37:21
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* list
*************

NAME
    list - create list of specified values

SYNOPSIS
    list([x, [x, ... ]])

TYPES
    x		any, &any

    return	list

DESCRIPTION
    This function returns a list that is composed of the arguments x.
    If no args are given, an empty list is returned.

    Lists are a sequence of values which are doubly linked so that
    elements can be removed or inserted anywhere within the list.
    The function 'list' creates a list with possible initial elements.
    For example,

	    x = list(4, 6, 7);

    creates a list in the variable x of three elements, in the order
    4, 6, and 7.

    The 'push' and 'pop' functions insert or remove an element from
    the beginning of the list.	The 'append' and 'remove' functions
    insert or remove an element from the end of the list.  The 'insert'
    and 'delete' functions insert or delete an element from the middle
    (or ends) of a list.  The functions which insert elements return
    the null value, but the functions which remove an element return
    the element as their value.	 The 'size' function returns the number
    of elements in the list.

    Note that these functions manipulate the actual list argument,
    instead of returning a new list.  Thus in the example:

	    push(x, 9);

    x becomes a list of four elements, in the order 9, 4, 6, and 7.
    Lists can be copied by assigning them to another variable.

    An arbitrary element of a linked list can be accessed by using the
    double-bracket operator.  The beginning of the list has index 0.
    Thus in the new list x above, the expression x[[0]] returns the
    value of the first element of the list, which is 9.	 Note that this
    indexing does not remove elements from the list.

    Since lists are doubly linked in memory, random access to arbitrary
    elements can be slow if the list is large.	However, for each list
    a pointer is kept to the latest indexed element, thus relatively
    sequential accesses to the elements in a list will not be slow.

    Lists can be searched for particular values by using the 'search'
    and 'rsearch' functions.  They return the element number of the
    found value (zero based), or null if the value does not exist in
    the list.

EXAMPLE
    > list(2,"three",4i)

    list (3 elements, 3 nonzero):
      [[0]] = 2
      [[1]] = "three"
      [[2]] = 4i

    > list()
	    list (0 elements, 0 nonzero)

LIMITS
    none

LINK LIBRARY
    none

SEE ALSO
    append, delete, insert, islist, pop, push, remove, rsearch, search, size

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: list,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/list,v $
##
## Under source code control:	1994/03/19 03:13:19
## File existed as early as:	1994
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* mat
*************

NAME
   mat - keyword to create a matrix value

SYNOPSIS
   mat [index-range-list] [ = {value_0. ...} ]
   mat [] [= {value_0, ...}]
   mat variable_1 ... [index-range-list] [ = {value_0, ...} ]
   mat variable_1 ... [] [ = {value_0, ...} ]

   mat [index-range-list_1[index-ranges-list_2] ... [ = { { ...} ...}  ]

   decl id_1 id_2 ... [index-range-list] ...

TYPES
   index-range-list	range_1 [, range_2, ...]  up to 4 ranges
   range_1, ...		integer, or integer_1 : integer_2
   value, value_1, ...	any
   variable_1 ...	lvalue
   decl			declarator = global, static or local
   id_1, ...		identifier

DESCRIPTION
   The expression  mat [index-range-list]  returns a matrix value.
   This may be assigned to one or more lvalues A, B, ... by either

	mat A B ... [index-range-list]

   or

	A = B = ... = mat[index-range-list]

   If a variable is specified by an expression that is not a symbol with
   possibly object element specifiers, the expression should be enclosed
   in parentheses.  For example, parentheses are required in
   mat (A[2]) [3]  and	mat (*p) [3]  but  mat P.x [3] is acceptable.

   When an index-range is specified as integer_1 : integer_2, where
   integer_1 and integer_2 are expressions which evaluate to integers,
   the index-range consists of all integers from the minimum of the
   two integers to the maximum of the two integers.  For example,
   mat[2:5, 0:4] and mat[5:2, 4:0] return the same matrix value.

   If an index-range is an expression which evaluates to an integer,
   the range is as if specified by 0 : integer - 1.  For example,
   mat[4] and mat[0:3] return the same 4-element matrix; mat[-2] and
   mat[-3:0] return the same 4-element matrix.

   If the variable A has a matrix value, then for integer indices
   i_1, i_2, ..., equal in number to the number of ranges specified at
   its creation, and such that each index is in the corresponding range,
   the matrix element associated with those index list is given as an
   lvalue by the expressions A[i_1, i_2, ...].

   The elements of the matrix are stored internally as a linear array
   in which locations are arranged in order of increasing indices.
   For example, in order of location, the six element of A = mat [2,3]
   are

	A[0,0], A[0,1], A[0,2], A[1,0], A[1,,1], A[1,2].

   These elements may also be specified using the double-bracket operator
   with a single integer index as in A[[0]], A[[1]], ..., A[[5]].
   If p is assigned the value &A[0.0], the address of A[[i]] for 0 <= i < 6
   is p + i as long as A exists and a new value is not assigned to A.

   When a matrix is created, each element is initially assigned the
   value zero.	Other values may be assigned then or later using the
   "= {...}" assignment operation.  Thus

	A = {value_0, value_1, ...}

   assigns the values value_0, value_1, ... to the elements A[[0]],
   A[[1]], ...	Any blank "value" is passed over.  For example,

	A = {1, , 2}

   will assign the value 1 to A[[0]], 2 to A[[2]] and leave all other
   elements unchanged.	Values may also be assigned to elements by
   simple assignments, as in A[0,0] = 1, A[0,2] = 2;

   If the index-range is left blank but an initializer list is specified
   as in

	mat A[] = {1, 2 }
	B = mat[] = {1, , 3, }

   the matrix created is one-dimensional.  If the list contains a
   positive number n of values or blanks, the result is as if the
   range were specified by [n], i.e. the range of indices is from
   0 to n - 1.	In the above examples, A is of size 2 with A[0] = 1
   and A[1] = 2;  B is of size 4 with B[0] = 1, B[1] = B[3] = 0,
   B[2] = 3.  The specification mat[] = { } creates the same as mat[1].

   If the index-range is left blank and no initializer list is specified,
   as in  mat C[]  or  C = mat[], the matrix assigned to C has zero
   dimension; this has one element C[].	 To assign a value using "= { ...}"
   at the same time as creating C, parentheses are required as in
   (mat[]) = {value}  or  (mat C[]) = {value}.	Later a value may be
   assigned to C[] by  C[] = value  or	C = {value}.

   The value assigned at any time to any element of a matrix can be of
   any type - number, string, list, matrix, object of previously specified
   type, etc.  For some matrix operations there are of course conditions
   that elements may have to satisfy: for example, addition of matrices
   requires that addition of corresponding elements be possible.
   If an element of a matrix is a structure for which indices or an
   object element specifier is required, an element of that structure is
   referred to by appropriate uses of [ ] or ., and so on if an element
   of that element is required.	 For example, one may have an expressions
   like

		A[1,2][3].alpha[2];

   if A[1,2][3].alpha is a list with at least three elements, A[1,2][3] is
   an object of a type like  obj {alpha, beta}, A[1,2] is a matrix of
   type mat[4] and A is a mat[2,3] matrix.  When an element of a matrix
   is a matrix and the total number of indices does not exceed 4, the
   indices can be combined into one list, e.g. the A[1,2][3] in the
   above example can be shortened to A[1,2,3].	(Unlike C, A[1,2] cannot
   be expressed as A[1][2].)

   The function ismat(V) returns 1 if V is a matrix, 0 otherwise.

   isident(V) returns 1 if V is a square matrix with diagonal elements 1,
   off-diagonal elements zero, or a zero- or one-dimensional matrix with
   every element 1; otherwise zero is returned.	 Thus  isident(V) = 1
   indicates that for  V * A  and  A * V  where A is any matrix of
   for which either product is defined and the elements of A are real
   or complex numbers, that product will equal A.

   If V is matrix-valued, test(V) returns 0 if every element of V tests
   as zero; otherwise 1 is returned.

   The dimension of a matrix A, i.e. the number of index-ranges in the
   initial creation of the matrix, is returned by the function matdim(A).
   For 1 <= i <= matdim(A), the minimum and maximum values for the i-th
   index range are returned by matmin(A, i) and matmax(A,i), respectively.
   The total number of elements in the matrix is returned by size(A).
   The sum of the elements in the matrix is returned by matsum(A).

   The default method of printing matrices is to give a line of information
   about the matrix, and to list on separate lines up to 15 elements,
   the indices and either the value (for numbers, strings, objects) or
   some descriptive information for lists or matrices, etc.
   Numbers are displayed in the current number-printing mode.
   The maximum number of elements to be printed can be assigned
   any nonnegative integer value m by config("maxprint", m).

   Users may define another method of printing matrices by defining a
   function mat_print(M); for example, for a not too big 2-dimensional
   matrix A it is a common practice to use a loop like:

		for (i = matmin(A,1); i <= matmax(A,1); i++) {
			for (j = matmin(A,2); j <= matmax(A,2); j++)
				printf("%8d", A[i,j];
			print;
		}

   The default printing may be restored by

		undefine mat_print;


   The keyword "mat" followed by two or more index-range-lists returns a
   matrix with indices specified by the first list, whose elements are
   matrices as determined by the later index-range-lists.  For
   example  mat[2][3]  is a 2-element matrix, each of whose elements has
   as its value a 3-element matrix.  Values may be assigned to the
   elements of the innermost matrices by nested	 = {...} operations as in

		mat [2][3] = {{1,2,3},{4,5,6}}

   An example of the use of mat with a declarator is

		global mat A B [2,3], C [4]

   This creates, if they do not already exist, three global variables with
   names A, B, C, and assigns to A and B the value mat[2,3] and to C mat[4].

   Some operations are defined for matrices.

   A == B
	Returns 1 if A and B are of the same "shape" and "corresponding"
	elements are equal; otherwise 0 is returned.  Being of the same
	shape means they have the same dimension d, and for each i <= d,

	    matmax(A,i) - matmin(A,i) == matmax(B,i) - matmin(B,i),

	One consequence of being the same shape is that the matrices will
	have the same size.   Elements "correspond" if they have the same
	double-bracket indices; thus A == B implies that A[[i]] == B[[i]]
	for 0 <= i < size(A) == size(B).

   A + B
   A - B
	These are defined A and B have the same shape, the element
	with double-bracket index j being evaluated by A[[j]] + B[[j]] and
	A[[j]] - B[[j]], respectively.	The index-ranges for the results
	are those for the matrix A.

   A[i,j]
	If A is two-dimensional, it is customary to speak of the indices
	i, j in A[i,j] as referring to rows and columns;  the number of
	rows is matmax(A,1) - matmin(A,1) + 1; the number of columns if
	matmax(A,2) - matmin(A,2) + 1.	A matrix is said to be square
	if it is two-dimensional and the number of rows is equal to the
	number of columns.

   A * B
	Multiplication is defined provided certain conditions by the
	dimensions and shapes of A and B are satisfied.	 If both have
	dimension 2 and the column-index-list for A is the same as
	the row-index-list for B, C = A * B is defined in the usual
	way so that for i in the row-index-list of A and j in the
	column-index-list for B,

		C[i,j] =  Sum A[i,k] * B[k,j]

	the sum being over k in the column-index-list of A.  The same
	formula is used so long as the number of columns in A is the same
	as the number of rows in B and k is taken to refer to the offset
	from matmin(A,2) and matmin(B,1), respectively, for A and B.
	If the multiplications and additions required cannot be performed,
	an execution error may occur or the result for C may contain
	one or more error-values as elements.

	If A or B has dimension zero, the result for A * B is simply
	that of multiplying the elements of the other matrix on the
	left by A[] or on the right by B[].

	If both A and B have dimension 1, A * B is defined if A and B
	have the same size; the result has the same index-list as A
	and each element is the product of corresponding elements of
	A and B.  If A and B have the same index-list, this multiplication
	is consistent with multiplication of 2D matrices if A and B are
	taken to represent 2D matrices for which the off-diagonal elements
	are zero and the diagonal elements are those of A and B.
	the real and complex numbers.

	If A is of dimension 1 and B is of dimension 2, A * B is defined
	if the number of rows in B is the same as the size of A.  The
	result has the same index-lists as B; each row of B is multiplied
	on the left by the corresponding element of A.

	If A is of dimension 2 and B is of dimension 1, A * B is defined
	if number of columns in A is the same as the size of A.	 The
	result has the same index-lists as A; each column of A is
	multiplied on the right by the corresponding element of B.

	The algebra of additions and multiplications involving both one-
	and two-dimensional matrices is particularly simple when all the
	elements are real or complex numbers and all the index-lists are
	the same, as occurs, for example, if for some positive integer n,
	all the matrices start as  mat [n]  or	mat [n,n].

    det(A)
	If A is a square, det(A) is evaluated by an algorithm that returns
	the determinant of A if the elements of A are real or complex
	numbers, and if such an A is non-singular, inverse(A) returns
	the inverse of A indexed in the same way as A.	For matrix A of
	dimension 0 or 1, det(A) is defined as the product of the elements
	of A in the order in which they occur in A, inverse(A) returns
	a matrix indexed in the same way as A with each element inverted.


   The following functions are defined to return matrices with the same
	index-ranges as A and the specified operations performed on all
	elements of A.	Here num is an arbitrary complex number (nonzero
	when it is a divisor), int an integer, rnd a rounding-type
	specifier integer, real a real number.

		num * A
		A * num
		A / num
		- A
		conj(A)
		A << int, A >> int
		scale(A, int)
		round(A, int, rnd)
		bround(A, int, rnd)
		appr(A, real, rnd)
		int(A)
		frac(A)
		A // real
		A % real
		A ^ int

   If A and B are one-dimensional of the same size dp(A, B) returns
	their dot-product, i.e. the sum of the products of corresponding
	elements.

   If A and B are one-dimension and of size 3, cp(A, B) returns their
	cross-product.

   randperm(A) returns a matrix indexed the same as A in which the elements
	of A have been randomly permuted.

   sort(A) returns a matrix indexed the same as A in which the elements
	of A have been sorted.

   If A is an lvalue whose current value is a matrix, matfill(A, v)
	assigns the value v to every element of A, and if also, A is
	square, matfill(A, v1, v2) assigns v1 to the off-diagonal elements,
	v2 to the diagonal elements.  To create and assign to A the unit
	n * n matrix, one may use matfill(mat A[n,n], 0, 1).

   For a square matrix A, mattrace(A) returns the trace of A, i.e. the
	sum of the diagonal elements.  For zero- or one-dimensional A,
	mattrace(A) returns the sum of the elements of A.

   For a two-dimensional matrix A, mattrans(A) returns the transpose
	of A, i.e. if A is mat[m,n], it returns a mat[n,m] matrix with
	[i,j] element equal to A[j,i].	For zero- or one-dimensional A,
	mattrace(A) returns a matrix with the same value as A.

   The functions search(A, value, start, end]) and
   rsearch(A, value, start, end]) return the first or last index i
   for which A[[i]] == value and start <= i < end, or if there is
   no such index, the null value.   For further information on default
   values and the use of an "accept" function, see the help files for
   search and rsearch.

   reverse(A) returns a matrix with the same index-lists as A but the
   elements in reversed order.

   The copy and blkcpy functions may be used to copy data to a matrix from
   a matrix or list, or from a matrix to a list.  In copying from a
   matrix to a matrix the matrices need not have the same dimension;
   in effect they are treated as linear arrays.

EXAMPLE
	> obj point {x,y}
	> mat A[5] = {1, 2+3i, "ab", mat[2] = {4,5}. obj point = {6,7}}
	> A
	mat [5] (5 elements, 5 nonzero):
	  [0] = 1
	  [1] = 2+3i
	  [2] = "ab"
	  [3] = mat [2] (2 elements, 2 nonzero)
	  [4] = obj point {6, 7}

	> print A[0], A[1], A[2], A[3][0], A[4].x
	1 2+3i ab 4 6

	> define point_add(a,b) = obj point = {a.x + b.x, a.y + b.y}
	point_add(a,b) defined

	> mat [B] = {8, , "cd", mat[2] = {9,10}, obj point = {11,12}}
	> A + B

	mat [5] (5 elements, 5 nonzero):
	  [0] = 9
	  [1] = 2+3i
	  [2] = "abcd"
	  [3] = mat [2] (2 elements, 2 nonzero)
	  [4] = obj point {17, 19}

	> mat C[2,2] = {1,2,3,4}
	> C^10

	mat [2,2] (4 elements, 4 nonzero):
	  [0,0] = 4783807
	  [0,1] = 6972050
	  [1,0] = 10458075
	  [1,1] = 15241882

	> C^-10

	mat [2,2] (4 elements, 4 nonzero):
	  [0,0] = 14884.650390625
	  [0,1] = -6808.642578125
	  [1,0] = -10212.9638671875
	  [1,1] = 4671.6865234375

	> mat A[4] = {1,2,3,4}, A * reverse(A);

	mat [4] (4 elements, 4 nonzero):
	  [0] = 4
	  [1] = 6
	  [2] = 6
	  [3] = 4

LIMITS
   The theoretical upper bound for the absolute values of indices is
   2^31 - 1, but the size of matrices that can be handled in practice will
   be limited by the availability of memory and what is an acceptable
   runtime.  For example, although it may take only a fraction of a
   second to invert a 10 * 10 matrix, it will probably take about 1000
   times as long to invert a 100 * 100 matrix.

LINK LIBRARY
   n/a

SEE ALSO
   ismat, matdim, matmax, matmin, mattrans, mattrace, matsum, det, inverse,
   isident, test, config, search, rsearch, reverse, copy, blkcpy, dp, cp,
   randperm, sort

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: mat,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/mat,v $
##
## Under source code control:	1991/07/21 04:37:22
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* obj
*************

Using objects

    Objects are user-defined types which are associated with user-
    defined functions to manipulate them.  Object types are defined
    similarly to structures in C, and consist of one or more elements.
    The advantage of an object is that the user-defined routines are
    automatically called by the calculator for various operations,
    such as addition, multiplication, and printing.  Thus they can be
    manipulated by the user as if they were just another kind of number.

    An example object type is "surd", which represents numbers of the form

	    a + b*sqrt(D),

    where D is a fixed integer, and 'a' and 'b' are arbitrary rational
    numbers.  Addition, subtraction, multiplication, and division can be
    performed on such numbers, and the result can be put unambiguously
    into the same form.	 (Complex numbers are an example of surds, where
    D is -1.)

    The "obj" statement defines either an object type or an actual
    variable of that type.  When defining the object type, the names of
    its elements are specified inside of a pair of braces.  To define
    the surd object type, the following could be used:

	    obj surd {a, b};

    Here a and b are the element names for the two components of the
    surd object.  An object type can be defined more than once as long
    as the number of elements and their names are the same.

    When an object is created, the elements are all defined with zero
    values.  A user-defined routine should be provided which will place
    useful values in the elements.  For example, for an object of type
    'surd', a function called 'surd' can be defined to set the two
    components as follows:

	    define surd(a, b)
	    {
		    local x;

		    obj surd x;
		    x.a = a;
		    x.b = b;
		    return x;
	    }

    When an operation is attempted for an object, user functions with
    particular names are automatically called to perform the operation.
    These names are created by concatenating the object type name and
    the operation name together with an underscore.  For example, when
    multiplying two objects of type surd, the function "surd_mul" is
    called.

    The user function is called with the necessary arguments for that
    operation.	For example, for "surd_mul", there are two arguments,
    which are the two numbers.	The order of the arguments is always
    the order of the binary operands.  If only one of the operands to
    a binary operator is an object, then the user function for that
    object type is still called.  If the two operands are of different
    object types, then the user function that is called is the one for
    the first operand.

    The above rules mean that for full generality, user functions
    should detect that one of their arguments is not of its own object
    type by using the 'istype' function, and then handle these cases
    specially.	In this way, users can mix normal numbers with object
    types.  (Functions which only have one operand don't have to worry
    about this.)  The following example of "surd_mul" demonstrates how
    to handle regular numbers when used together with surds:

	    define surd_mul(a, b)
	    {
		    local x;

		    obj surd x;
		    if (!istype(a, x)) {
			    /* a not of type surd */
			    x.a = b.a * a;
			    x.b = b.b * a;
		    } else if (!istype(b, x)) {
			    /* b not of type surd */
			    x.a = a.a * b;
			    x.b = a.b * b;
		    } else {
			    /* both are surds */
			    x.a = a.a * b.a + D * a.b * b.b;
			    x.b = a.a * b.b + a.b * b.a;
		    }
		    if (x.b == 0)
			    return x.a; /* normal number */
		    return x;		/* return surd */
	    }

    In order to print the value of an object nicely, a user defined
    routine can be provided.  For small amounts of output, the print
    routine should not print a newline.	 Also, it is most convenient
    if the printed object looks like the call to the creation routine.
    For output to be correctly collected within nested output calls,
    output should only go to stdout.  This means use the 'print'
    statement, the 'printf' function, or the 'fprintf' function with
    'files(1)' as the output file.  For example, for the "surd" object:

	    define surd_print(a)
	    {
		    print "surd(" : a.a : "," : a.b : ")" : ;
	    }

    It is not necessary to provide routines for all possible operations
    for an object, if those operations can be defaulted or do not make
    sense for the object.  The calculator will attempt meaningful
    defaults for many operations if they are not defined.  For example,
    if 'surd_square' is not defined to square a number, then 'surd_mul'
    will be called to perform the squaring.  When a default is not
    possible, then an error will be generated.

    Please note: Arguments to object functions are always passed by
    reference (as if an '&' was specified for each variable in the call).
    Therefore, the function should not modify the parameters, but should
    copy them into local variables before modifying them.  This is done
    in order to make object calls quicker in general.

    The double-bracket operator can be used to reference the elements
    of any object in a generic manner.	When this is done, index 0
    corresponds to the first element name, index 1 to the second name,
    and so on.	The 'size' function will return the number of elements
    in an object.

    The following is a list of the operations possible for objects.
    The 'xx' in each function name is replaced with the actual object
    type name.	This table is displayed by the 'show objfuncs' command.

	    Name	Args	Comments

	    xx_print	1	print value, default prints elements
	    xx_one	1	multiplicative identity, default is 1
	    xx_test	1	logical test (false,true => 0,1),
				default tests elements
	    xx_add	2
	    xx_sub	2	subtraction, default adds negative
	    xx_neg	1	negative
	    xx_mul	2
	    xx_div	2	non-integral division, default multiplies
				by inverse
	    xx_inv	1	multiplicative inverse
	    xx_abs	2	absolute value within given error
	    xx_norm	1	square of absolute value
	    xx_conj	1	conjugate
	    xx_pow	2	integer power, default does multiply,
				square, inverse
	    xx_sgn	1	sign of value (-1, 0, 1)
	    xx_cmp	2	equality (equal,non-equal => 0,1),
				default tests elements
	    xx_rel	2	inequality (less,equal,greater => -1,0,1)
	    xx_quo	2	integer quotient
	    xx_mod	2	remainder of division
	    xx_int	1	integer part
	    xx_frac	1	fractional part
	    xx_inc	1	increment, default adds 1
	    xx_dec	1	decrement, default subtracts 1
	    xx_square	1	default multiplies by itself
	    xx_scale	2	multiply by power of 2
	    xx_shift	2	shift left by n bits (right if negative)
	    xx_round	2	round to given number of decimal places
	    xx_bround	2	round to given number of binary places
	    xx_root	3	root of value within given error
	    xx_sqrt	2	square root within given error
	    xx_or	2	boolean or
	    xx_and	2	boolean and
	    xx_not	1	boolean not
	    xx_fact	1	factorial


    Also see the standard resource files:

	    dms.cal
	    mod.cal
	    poly.cal
	    quat.cal
	    surd.cal

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: obj.file,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/obj.file,v $
##
## Under source code control:	1991/07/21 04:37:22
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* operator
*************

operators

    The operators are similar to C, but there are some differences in
    the associativity and precedence rules for some operators.	In
    addition, there are several operators not in C, and some C
    operators are missing.  A more detailed discussion of situations
    that may be unexpected for the C programmer may be found in
    the 'unexpected' help file.

    Below is a list giving the operators arranged in order of
    precedence, from the least tightly binding to the most tightly
    binding.  Except where otherwise indicated, operators at the same
    level of precedence associate from left to right.

    Unlike C, calc has a definite order for evaluation of terms (addends
    in a sum, factors in a product, arguments for a function or a
    matrix, etc.).  This order is always from left to right. but
    skipping of terms may occur for ||, && and ? : .  For example,
    an expression of the form:

	    A * B + C * D

    is evaluated in the following order:

	    A
	    B
	    A * B
	    C
	    D
	    C * D
	    A * B + C * D

    This order of evaluation is significant if evaluation of a
    term changes a variable on which a later term depends.  For example:

	    x++ * x++ + x++ * x++

    returns the value of:

	    x * (x + 1) + (x + 2) * (x + 3)

    and increments x as if by x += 4.  Similarly, for functions f, g,
    the expression:

	    f(x++, x++) + g(x++)

    evaluates to:

	    f(x, x + 1) + g(x + 2)

    and increments x three times.

    In A || B, B is read only if A tests as false;  in A && B, B is
    read only if A tests as true.  Thus if x is nonzero,
    x++ || x++ returns x and increments x once; if x is zero,
    it returns x + 1 and increments x twice.


    ,	Comma operator.
	    a, b returns the value of b.
	    For situations in which a comma is used for another purpose
	    (function arguments, array indexing, and the print statement),
	    parenthesis must be used around the comma operator expression.
	    E.g., if A is a matrix, A[(a, b), c] evaluates a, b, and c, and
	    returns the value of A[b, c].

    +=	-=  *=	/=  %=	//=  &=	 |=  <<=  >>=  ^=  **=
	 Operator-with-assignments.
	    These associate from left to right, e.g. a += b *= c has the
	    effect of a = (a + b) * c, where only a is required to be an
	    lvalue.  For the effect of b *= c; a += b; when both a and b
	    are lvalues, use a += (b *= c).

    =	Assignment.
	    As in C, this, when repeated, this associates from right to left,
	    e.g. a = b = c has the effect of a = (b = c).  Here both a and b
	    are to be lvalues.

    ? : Conditional value.
	    a ? b : c  returns b if a tests as true (i.e. nonzero if
	    a is a number), c otherwise.  Thus it is equivalent to:
	    if (a) return b; else return c;.
	    All that is required of the arguments in this function
	    is that the "is-it-true?" test is meaningful for a.
	    As in C, this operator associates from right to left,
	    i.e. a ? b : c ? d : e is evaluated as a ? b : (c ? d : e).

    ||	Logical OR.
	    Unlike C, the result for a || b is one of the operands
	    a, b rather than one of the numbers 0 and 1.
	    a || b is equivalent to a ? a : b, i.e. if a tests as
	    true, a is returned, otherwise b.  The effect in a
	    test like "if (a || b) ... " is the same as in C.

    &&	Logical AND.
	    Unlike C, the result for a && b is one of the operands
	    a, b rather than one of the numbers 0 and 1.
	    a && b is equivalent to a ? b : a, i.e. if a tests as
	    true, b is returned, otherwise a.  The effect in a
	    test like "if (a && b) ... " is the same as in C.

    ==	!=  <=	>=  <  >
	    Relations.

    +  -
	    Binary plus and minus and unary plus and minus when applied to
	    a first or only term.

    *  /  //  %
	    Multiply, divide, and modulo.
	    Please Note: The '/' operator is a fractional divide,
	    whereas the '//' is an integral divide.  Thus think of '/'
	    as division of real numbers, and think of '//' as division
	    of integers (e.g., 8 / 3 is 8/3 whereas 8 // 3 is 2).
	    The '%' is integral or fractional modulus (e.g., 11%4 is 3,
	    and 10%pi() is ~.575222).

    |	Bitwise OR.
	    In a | b, both a and b are to be real integers;
	    the signs of a and b are ignored, i.e.
	    a | b = abs(a) | abs(b) and the result will
	    be a non-negative integer.

    &	Bitwise AND.
	    In a & b, both a and b are to be real integers;
	    the signs of a and b are ignored as for a | b.

    ^  **  <<  >>
	    Powers and shifts.
	    The '^' and '**' are both exponentiation, e.g. 2^3
	    returns 8, 2^-3 returns .125.  In a ^ b, b has to be
	    an integer and if a is zero, nonnegative.  0^0 returns
	    the value 1.

	    For the shift operators both arguments are to be
	    integers, or if the first is complex, it is to have
	    integral real and imaginary parts.	Changing the
	    sign of the second argument reverses the shift, e.g.
	    a >> -b = a << b.  The result has the same sign as
	    the first argument except that a nonzero value is
	    reduced to zero by a sufficiently long shift to the
	    right.  These operators associate right to left,
	    e.g.  a << b ^ c = a << (b ^ c).

    +  -  !
	    Plus (+) and minus (-) have their usual meanings as unary
	    prefix operators at this level of precedence when applied to
	    other than a first or only term.

	    As a prefix operator, '!' is the logical NOT: !a returns 0 if
	    a tests as nonzero, and 1 if a tests as zero, i.e. it is
	    equivalent to a ? 0 : 1.  Be careful about
	    using this as the first character of a top level command,
	    since it is also used for executing shell commands.

	    As a postfix operator ! gives the factorial function, i.e.
	    a! = fact(a).

    ++	--
	    Pre or post incrementing or decrementing.
	    These are applicable only to variables.

    [ ]	 [[ ]]	.  ( )
	    Indexing, double-bracket indexing, element references,
	    and function calls.	 Indexing can only be applied to matrices,
	    element references can only be applied to objects, but
	    double-bracket indexing can be applied to matrices, objects,
	    or lists.

    variables  constants  .  ( )
	    These are variable names and constants, the special '.' symbol,
	    or a parenthesized expression.  Variable names begin with a
	    letter, but then can contain letters, digits, or underscores.
	    Constants are numbers in various formats, or strings inside
	    either single or double quote marks.


    The most significant difference from the order of precedence in
    C is that | and & have higher precedence than ==, +, -, *, / and %.
    For example, in C a == b | c * d is interpreted as:

	    (a == b) | (c * d)

    and calc it is:

	    a == ((b | c) * d)


    Most of the operators will accept any real or complex numbers
    as arguments.  The exceptions are:

    /  //  %
	    Second argument must be nonzero.

    ^
	    The exponent must be an integer.  When raising zero
	    to a power, the exponent must be non-negative.

    |  &
	    Both both arguments must be integers.

    <<	>>
	    The shift amount must be an integer.  The value being
	    shifted must be an integer or a complex number with
	    integral real and imaginary parts.


    See the 'unexpected' help file for a list of unexpected
    surprises in calc syntax/usage.  Persons familiar with C should
    read the 'unexpected' help file to avoid confusion.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: operator,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/operator,v $
##
## Under source code control:	1991/07/21 04:37:23
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* statement
*************

Statements

    Statements are very much like C statements.	 Most statements act
    identically to those in C, but there are minor differences and
    some additions.  The following is a list of the statement types,
    with explanation of the non-C statements.  In this list, upper
    case words identify the keywords which are actually in lower case.
    Statements are generally terminated with semicolons, except if the
    statement is the compound one formed by matching braces.  Various
    expressions are optional and may be omitted (as in RETURN).


    C-like statements
    -----------------
    { statement }
    { statement; ... statement }
    if (expr) statement
    if (expr) statement ELSE statement
    for (optionalexpr ; optionalexpr ; optionalexpr) statement
    while (expr) statement
    do statement while (expr)
    continue
    break
    goto label
	    These all work like in normal C.

	    See 'help expression' for details on expressions.
	    See 'help builtin' for details on calc builtin functions.


    return
    ------
    return optionalexpr
    return ( optionalexpr )
	    This returns a value from a function.  Functions always
	    have a return value, even if this statement is not used.
	    If no return statement is executed, or if no expression
	    is specified in the return statement, then the return
	    value from the function is the null type.


    switch
    ------
    switch (expr) { caseclauses }
	    Switch statements work similarly to C, except for the
	    following.	A switch can be done on any type of value,
	    and the case statements can be of any type of values.
	    The case statements can also be expressions calculated
	    at runtime.	 The calculator compares the switch value
	    with each case statement in the order specified, and
	    selects the first case which matches.  The default case
	    is the exception, and only matches once all other cases
	    have been tested.


    matrix
    ------
    mat variable [dimension] [dimension] ...
    mat variable [dimension, dimension, ...]
    mat variable [] = { value, ... }
	    This creates a matrix variable with the specified dimensions.
	    Matrices can have from 1 to 4 dimensions.  When specifying
	    multiple dimensions, you can use either the standard C syntax,
	    or else you can use commas for separating the dimensions.
	    For example, the following two statements are equivalent,
	    and so will create the same two dimensional matrix:

		    mat foo[3][6];
		    mat foo[3,6];

	    By default, each dimension is indexed starting at zero,
	    as in normal C, and contains the specified number of
	    elements.  However, this can be changed if a colon is
	    used to separate two values.  If this is done, then the
	    two values become the lower and upper bounds for indexing.
	    This is convenient, for example, to create matrices whose
	    first row and column begin at 1.  Examples of matrix
	    definitions are:

		    mat x[3]	one dimension, bounds are 0-2
		    mat foo[4][5]	two dimensions, bounds are 0-3 and 0-4
		    mat a[-7:7] one dimension, bounds are (-7)-7
		    mat s[1:9,1:9]	two dimensions, bounds are 1-9 and 1-9

	    Note that the MAT statement is not a declaration, but is
	    executed at runtime.  Within a function, the specified
	    variable must already be defined, and is just converted to
	    a matrix of the specified size, and all elements are set
	    to the value of zero.  For convenience, at the top level
	    command level, the MAT command automatically defines a
	    global variable of the specified name if necessary.

	    Since the MAT statement is executed, the bounds on the
	    matrix can be full expressions, and so matrices can be
	    dynamically allocated.  For example:

		    size = 20;
		    mat data[size*2];

	    allocates a matrix which can be indexed from 0 to 39.

	    Initial values for the elements of a matrix can be specified
	    by following the bounds information with an equals sign and
	    then a list of values enclosed in a pair of braces.	 Even if
	    the matrix has more than one dimension, the elements must be
	    specified as a linear list.	 If too few values are specified,
	    the remaining values are set to zero.  If too many values are
	    specified, a runtime error will result.  Examples of some
	    initializations are:

		    mat table1[5] = {77, 44, 22};
		    mat table2[2,2] = {1, 2, 3, 4};

	    When an initialization is done, the bounds of the matrix
	    can optionally be left out of the square brackets, and the
	    correct bounds (zero based) will be set.  This can only be
	    done for one-dimensional matrices.	An example of this is:

		    mat fred[] = {99, 98, 97};

	    The MAT statement can also be used in declarations to set
	    variables as being matrices from the beginning.  For example:

		    local mat temp[5];
		    static mat strtable[] = {"hi", "there", "folks");


    object
    ------
    obj type { elementnames } optionalvariables
    obj type variable
	    These create a new object type, or create one or more
	    variables of the specified type.  For this calculator,
	    an object is just a structure which is implicitly acted
	    on by user defined routines.  The user defined routines
	    implement common operations for the object, such as plus
	    and minus, multiply and divide, comparison and printing.
	    The calculator will automatically call these routines in
	    order to perform many operations.

	    To create an object type, the data elements used in
	    implementing the object are specified within a pair
	    of braces, separated with commas.  For example, to
	    define an object will will represent points in 3-space,
	    whose elements are the three coordinate values, the
	    following could be used:

		    obj point {x, y, z};

	    This defines an object type called point, whose elements
	    have the names x, y, and z.	 The elements are accessed
	    similarly to structure element accesses, by using a period.
	    For example, given a variable 'v' which is a point object,
	    the three coordinates of the point can be referenced by:

		    v.x
		    v.y
		    v.z

	    A particular object type can only be defined once, and
	    is global throughout all functions.	 However, different
	    object types can be used at the same time.

	    In order to create variables of an object type, they
	    can either be named after the right brace of the object
	    creation statement, or else can be defined later with
	    another obj statement.  To create two points using the
	    second (and most common) method, the following is used:

		    obj point p1, p2;

	    This statement is executed, and is not a declaration.
	    Thus within a function, the variables p1 and p2 must have
	    been previously defined, and are just changed to be the
	    new object type.  For convenience, at the top level command
	    level, object variables are automatically defined as being
	    global when necessary.

	    Initial values for an object can be specified by following
	    the variable name by an equals sign and a list of values
	    enclosed in a pair of braces.  For example:

		    obj point pt = {5, 6};

	    The OBJ statement can also be used in declarations to set
	    variables as being objects from the beginning.  If multiple
	    variables are specified, then each one is defined as the
	    specified object type.  Examples of declarations are:

		    local obj point temp1;
		    static obj point temp2 = {4, 3};
		    global obj point p1, p2, p3;


    print expressions
    -----------------
    print expr
    print expr, ... expr
    print expr: ... expr
	    For interactive expression evaluation, the values of all
	    typed-in expressions are automatically displayed to the
	    user.  However, within a function or loop, the printing of
	    results must be done explicitly.  This can be done using
	    the 'printf' or 'fprintf' functions, as in standard C, or
	    else by using the built-in 'print' statement.  The advantage
	    of the print statement is that a format string is not needed.
	    Instead, the given values are simply printed with zero or one
	    spaces between each value.

	    Print accepts a list of expressions, separated either by
	    commas or colons.  Each expression is evaluated in order
	    and printed, with no other output, except for the following
	    special cases.  The comma which separates expressions prints
	    a single space, and a newline is printed after the last
	    expression unless the statement ends with a colon.	As
	    examples:

		    print 3, 4;			prints "3 4" and newline.
		    print 5:;			prints "5" with no newline.
		    print 'a' : 'b' , 'c';	prints "ab c" and newline.
		    print;			prints a newline.

	    For numeric values, the format of the number depends on the
	    current "mode" configuration parameter.  The initial mode
	    is to print real numbers, but it can be changed to other
	    modes such as exponential, decimal fractions, or hex.

	    If a matrix or list is printed, then the elements contained
	    within the matrix or list will also be printed, up to the
	    maximum number specified by the "maxprint" configuration
	    parameter.	If an element is also a matrix or a list, then
	    their values are not recursively printed.  Objects are printed
	    using their user-defined routine.  Printing a file value
	    prints the name of the file that was opened.


    Also see the help topic:

	    command	    top level commands
	    expression	    calc expression syntax
	    builtin	    calc builtin functions
	    usage	    how to invoke the calc command and calc -options

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: statement,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/statement,v $
##
## Under source code control:	1991/07/21 04:37:23
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* resource
*************

Calc standard resource files
----------------------------

To load a resource file, try:

    read filename

You do not need to add the .cal extension to the filename.  Calc
will search along the $CALCPATH (see ``help environment'').

Normally a resource file will simply define some functions.  By default,
most resource files will print out a short message when they are read.
For example:

    > read lucas
    lucas(h,n) defined
    gen_u0(h,n,v1) defined
    gen_v1(h,n) defined
    ldebug(funct,str) defined

will cause calc to load and execute the 'lucas.cal' resource file.
Executing the resource file will cause several functions to be defined.
Executing the lucas function:

    > lucas(149,60)
	    1
    > lucas(146,61)
	    0

shows that 149*2^60-1 is prime whereas 146*2^61-1 is not.

=-=

Calc resource file files are provided because they serve as examples of
how use the calc language, and/or because the authors thought them to
be useful!

If you write something that you think is useful, please send it to:

    calc-contrib at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

By convention, a resource file only defines and/or initializes functions,
objects and variables.	(The regress.cal and testxxx.cal regression test
suite is an exception.)	 Also by convention, an additional usage message
regarding important object and functions is printed.

If a resource file needs to load another resource file, it should use
the -once version of read:

    /* pull in needed resource files */
    read -once "surd"
    read -once "lucas"

This will cause the needed resource files to be read once.  If these
files have already been read, the read -once will act as a noop.

The "resource_debug" parameter is intended for controlling the possible
display of special information relating to functions, objects, and
other structures created by instructions in calc resource files.
Zero value of config("resource_debug") means that no such information
is displayed.  For other values, the non-zero bits which currently
have meanings are as follows:

    n		Meaning of bit n of config("resource_debug")

    0	When a function is defined, redefined or undefined at
	interactive level, a message saying what has been done
	is displayed.

    1	When a function is defined, redefined or undefined during
	the reading of a file, a message saying what has been done
	is displayed.

    2	Show func will display more information about a functions
	arguments as well as more argument sdummary information.

    3	During execution, allow calc standard resource files
	to output additional debugging information.

The value for config("resource_debug") in both oldstd and newstd is 3,
but if calc is invoked with the -d flag, its initial value is zero.
Thus, if calc is started without the -d flag, until config("resource_debug")
is changed, a message will be output when a function is defined
either interactively or during the reading of a file.

Sometimes the information printed is not enough.  In addition to the
standard information, one might want to print:

	* useful obj definitions
	* functions with optional args
	* functions with optional args where the param() interface is used

For these cases we suggest that you place at the bottom of your code
something that prints extra information if config("resource_debug") has
either of the bottom 2 bits set:

	if (config("resource_debug") & 3) {
		print "obj xyz defined";
		print "funcA([val1 [, val2]]) defined";
		print "funcB(size, mass, ...) defined";
	}

If your the resource file needs to output special debugging informatin,
we recommend that you check for bit 3 of the config("resource_debug")
before printing the debug statement:

	if (config("resource_debug") & 8) {
		print "DEBUG: This a sample debug statement";
	}

=-=

The following is a brief description of some of the calc resource files
that are shipped with calc.  See above for example of how to read in
and execute these files.

beer.cal

    Calc's contribution to the 99 Bottles of Beer web page:

	http://www.ionet.net/~timtroyr/funhouse/beer.html#calc


bernoulli.cal

    B(n)

    Calculate the nth Bernoulli number.

    NOTE: There is now a bernoulli() builtin function.  This file is
    	  left here for backward compatibility and now simply returns
	  the buildin function.


bigprime.cal

    bigprime(a, m, p)

    A prime test, base a, on p*2^x+1 for even x>m.


chi.cal

    Z(x[, eps])
    P(x[, eps])
    chi_prob(chi_sq, v[, eps])

    Computes the Probability, given the Null Hypothesis, that a given
    Chi squared values >= chi_sq with v degrees of freedom.

    The chi_prob() function does not work well with odd degrees of freedom.
    It is reasonable with even degrees of freedom, although one must give
    a sifficently small error term as the degress gets large (>100).

    The Z(x) and P(x) are internal statistical funcions.

    eps is an optional epsilon() like error term.


chrem.cal

    chrem(r1,m1 [,r2,m2, ...])
    chrem(rlist, mlist)

    Chinese remainder theorem/problem solver.


deg.cal

    dms(deg, min, sec)
    dms_add(a, b)
    dms_neg(a)
    dms_sub(a, b)
    dms_mul(a, b)
    dms_print(a)

    Calculate in degrees, minutes, and seconds.


ellip.cal

    efactor(iN, ia, B, force)

    Attempt to factor using the elliptic functions: y^2 = x^3 + a*x + b.


hello.cal

    Calc's contribution to the Hello World! page:

	http://www.latech.edu/~acm/HelloWorld.shtml
	http://www.latech.edu/~acm/helloworld/calc.html


intfile.cal

    file2be(filename)

	Read filename and return an integer that is built from the
	octets in that file in Big Endian order.  The first octets
	of the file become the most significant bits of the integer.

    file2le(filename)

	Read filename and return an integer that is built from the
	octets in that file in Little Endian order.  The first octets
	of the file become the most significant bits of the integer.

    be2file(v, filename)

	Write the absolute value of v into filename in Big Endian order.
	The v argument must be on integer.  The most significant bits
	of the integer become the first octets of the file.

    le2file(v, filename)

	Write the absolute value of v into filename in Little Endian order.
	The v argument must be on integer.  The least significant bits
	of the integer become the last octets of the file.


lucas.cal

    lucas(h, n)

    Perform a primality test of h*2^n-1, with 1<=h<2*n.


lucas_chk.cal

    lucas_chk(high_n)

    Test all primes of the form h*2^n-1, with 1<=h<200 and n <= high_n.
    Requires lucas.cal to be loaded.  The highest useful high_n is 1000.

    Used by regress.cal during the 2100 test set.


lucas_tbl.cal

    Lucasian criteria for primality tables.


mersenne.cal

    mersenne(p)

    Perform a primality test of 2^p-1, for prime p>1.


mfactor.cal

    mfactor(n [, start_k=1 [, rept_loop=10000 [, p_elim=17]]])

    Return the lowest factor of 2^n-1, for n > 0.  Starts looking for factors
    at 2*start_k*n+1.  Skips values that are multiples of primes <= p_elim.
    By default, start_k == 1, rept_loop = 10000 and p_elim = 17.

    The p_elim == 17 overhead takes ~3 minutes on an 200 Mhz r4k CPU and
    requires about ~13 Megs of memory.	The p_elim == 13 overhead
    takes about 3 seconds and requires ~1.5 Megs of memory.

    The value p_elim == 17 is best for long factorizations.  It is the
    fastest even thought the initial startup overhead is larger than
    for p_elim == 13.

mod.cal

    lmod(a)
    mod_print(a)
    mod_one()
    mod_cmp(a, b)
    mod_rel(a, b)
    mod_add(a, b)
    mod_sub(a, b)
    mod_neg(a)
    mod_mul(a, b)
    mod_square(a)
    mod_inc(a)
    mod_dec(a)
    mod_inv(a)
    mod_div(a, b)
    mod_pow(a, b)

    Routines to handle numbers modulo a specified number.


natnumset.cal

    isset(a)
    setbound(n)
    empty()
    full()
    isin(a, b)
    addmember(a, n)
    rmmember(a, n)
    set()
    mkset(s)
    primes(a, b)
    set_max(a)
    set_min(a)
    set_not(a)
    set_cmp(a, b)
    set_rel(a, b)
    set_or(a, b)
    set_and(a, b)
    set_comp(a)
    set_setminus(a, b)
    set_diff(a,b)
    set_content(a)
    set_add(a, b)
    set_sub(a, b)
    set_mul(a, b)
    set_square(a)
    set_pow(a, n)
    set_sum(a)
    set_plus(a)
    interval(a, b)
    isinterval(a)
    set_mod(a, b)
    randset(n, a, b)
    polyvals(L, A)
    polyvals2(L, A, B)
    set_print(a)

    Demonstration of how the string operators and functions may be used
    for defining and working with sets of natural numbers not exceeding a
    user-specified bound.


pell.cal

    pellx(D)
    pell(D)

    Solve Pell's equation; Returns the solution X to: X^2 - D * Y^2 = 1.
    Type the solution to Pell's equation for a particular D.


pi.cal

    qpi(epsilon)
    piforever()

    The qpi() calculate pi within the specified epsilon using the quartic
    convergence iteration.

    The piforever() prints digits of pi, nicely formatted, for as long
    as your free memory space and system up time allows.

    The piforever() function (written by Klaus Alexander Seistrup
    <klaus@seistrup.dk>) was inspired by an algorithm conceived by
    Lambert Meertens.  See also the ABC Programmer's Handbook, by Geurts,
    Meertens & Pemberton, published by Prentice-Hall (UK) Ltd., 1990.

pix.cal

    pi_of_x(x)

    Calculate the number of primes < x using A(n+1)=A(n-1)+A(n-2).  This
    is a SLOW painful method ... the builtin pix(x) is much faster.
    Still, this method is interesting.


pollard.cal

    pfactor(N, N, ai, af)

    Factor using Pollard's p-1 method.


poly.cal

    Calculate with polynomials of one variable.	 There are many functions.
    Read the documentation in the resource file.


prompt.cal

    adder()
    showvalues(str)

    Demonstration of some uses of prompt() and eval().


psqrt.cal

    psqrt(u, p)

    Calculate square roots modulo a prime


qtime.cal

    qtime(utc_hr_offset)

    Print the time as English sentence given the hours offset from UTC.


quat.cal

    quat(a, b, c, d)
    quat_print(a)
    quat_norm(a)
    quat_abs(a, e)
    quat_conj(a)
    quat_add(a, b)
    quat_sub(a, b)
    quat_inc(a)
    quat_dec(a)
    quat_neg(a)
    quat_mul(a, b)
    quat_div(a, b)
    quat_inv(a)
    quat_scale(a, b)
    quat_shift(a, b)

    Calculate using quaternions of the form: a + bi + cj + dk.	In these
    functions, quaternions are manipulated in the form: s + v, where
    s is a scalar and v is a vector of size 3.


randbitrun.cal

    randbitrun([run_cnt])

    Using randbit(1) to generate a sequence of random bits, determine if
    the number and length of identical bits runs match what is expected.
    By default, run_cnt is to test the next 65536 random values.

    This tests the a55 generator.


randmprime.cal

    randmprime(bits, seed [,dbg])

    Find a prime of the form h*2^n-1 >= 2^bits for some given x.  The initial
    search points for 'h' and 'n' are selected by a cryptographic pseudo-random
    number generator.  The optional argument, dbg, if set to 1, 2 or 3
    turn on various debugging print statements.


randombitrun.cal

    randombitrun([run_cnt])

    Using randombit(1) to generate a sequence of random bits, determine if
    the number and length of identical bits runs match what is expected.
    By default, run_cnt is to test the next 65536 random values.

    This tests the Blum-Blum-Shub generator.


randomrun.cal

    randomrun([run_cnt])

    Perform the "G. Run test" (pp. 65-68) as found in Knuth's "Art of
    Computer Programming - 2nd edition", Volume 2, Section 3.3.2 on
    the builtin rand() function.  This function will generate run_cnt
    64 bit values.  By default, run_cnt is to test the next 65536
    random values.

    This tests the Blum-Blum-Shub generator.


randrun.cal

    randrun([run_cnt])

    Perform the "G. Run test" (pp. 65-68) as found in Knuth's "Art of
    Computer Programming - 2nd edition", Volume 2, Section 3.3.2 on
    the builtin rand() function.  This function will generate run_cnt
    64 bit values.  By default, run_cnt is to test the next 65536
    random values.

    This tests the a55 generator.

repeat.cal

    repeat(digit_set, repeat_count)

    Return the value of the digit_set repeated repeat_count times.
    Both digit_set and repeat_count must be integers > 0.

    For example repeat(423,5) returns the value 423423423423423,
    which is the digit_set 423 repeated 5 times.


regress.cal

    Test the correct execution of the calculator by reading this resource file.
    Errors are reported with '****' messages, or worse. :-)


seedrandom.cal

    seedrandom(seed1, seed2, bitsize [,trials])

    Given:
	seed1 - a large random value (at least 10^20 and perhaps < 10^93)
	seed2 - a large random value (at least 10^20 and perhaps < 10^93)
	size - min Blum modulus as a power of 2 (at least 100, perhaps > 1024)
	trials - number of ptest() trials (default 25) (optional arg)

    Returns:
	the previous random state

    Seed the cryptographically strong Blum generator.  This functions allows
    one to use the raw srandom() without the burden of finding appropriate
    Blum primes for the modulus.


solve.cal

    solve(low, high, epsilon)

    Solve the equation f(x) = 0 to within the desired error value for x.
    The function 'f' must be defined outside of this routine, and the low
    and high values are guesses which must produce values with opposite signs.


sumsq.cal

    ss(p)

    Determine the unique two positive integers whose squares sum to the
    specified prime.  This is always possible for all primes of the form
    4N+1, and always impossible for primes of the form 4N-1.


surd.cal

    surd(a, b)
    surd_print(a)
    surd_conj(a)
    surd_norm(a)
    surd_value(a, xepsilon)
    surd_add(a, b)
    surd_sub(a, b)
    surd_inc(a)
    surd_dec(a)
    surd_neg(a)
    surd_mul(a, b)
    surd_square(a)
    surd_scale(a, b)
    surd_shift(a, b)
    surd_div(a, b)
    surd_inv(a)
    surd_sgn(a)
    surd_cmp(a, b)
    surd_rel(a, b)

    Calculate using quadratic surds of the form: a + b * sqrt(D).


test1700.cal

    value

    This resource files is used by regress.cal to test the read and use keywords.


test2600.cal

    global defaultverbose
    global err
    testismult(str, n, verbose)
    testsqrt(str, n, eps, verbose)
    testexp(str, n, eps, verbose)
    testln(str, n, eps, verbose)
    testpower(str, n, b, eps, verbose)
    testgcd(str, n, verbose)
    cpow(x, n, eps)
    cexp(x, eps)
    cln(x, eps)
    mkreal()
    mkcomplex()
    mkbigreal()
    mksmallreal()
    testappr(str, n, verbose)
    checkappr(x, y, z, verbose)
    checkresult(x, y, z, a)
    test2600(verbose, tnum)

    This resource files is used by regress.cal to test some of builtin functions
    in terms of accuracy and roundoff.


test2700.cal

    global defaultverbose
    mknonnegreal()
    mkposreal()
    mkreal_2700()
    mknonzeroreal()
    mkposfrac()
    mkfrac()
    mksquarereal()
    mknonsquarereal()
    mkcomplex_2700()
    testcsqrt(str, n, verbose)
    checksqrt(x, y, z, v)
    checkavrem(A, B, X, eps)
    checkrounding(s, n, t, u, z)
    iscomsq(x)
    test2700(verbose, tnum)

    This resource files is used by regress.cal to test sqrt() for real and
    complex values.


test3100.cal

    obj res
    global md
    res_test(a)
    res_sub(a, b)
    res_mul(a, b)
    res_neg(a)
    res_inv(a)
    res(x)

    This resource file is used by regress.cal to test determinants of a matrix


test3300.cal

    global defaultverbose
    global err
    testi(str, n, N, verbose)
    testr(str, n, N, verbose)
    test3300(verbose, tnum)

    This resource file is used by regress.cal to provide for more determinant
    tests.

test3400.cal

    global defaultverbose
    global err
    test1(str, n, eps, verbose)
    test2(str, n, eps, verbose)
    test3(str, n, eps, verbose)
    test4(str, n, eps, verbose)
    test5(str, n, eps, verbose)
    test6(str, n, eps, verbose)
    test3400(verbose, tnum)

    This resource file is used by regress.cal to test trig functions.
    containing objects.

test3500.cal

    global defaultverbose
    global err
    testfrem(x, y, verbose)
    testgcdrem(x, y, verbose)
    testf(str, n, verbose)
    testg(str, n, verbose)
    testh(str, n, N, verbose)
    test3500(verbose, n, N)

    This resource file is used by regress.cal to test the functions frem,
    fcnt, gcdrem.

test4000.cal

    global defaultverbose
    global err
    global BASEB
    global BASE
    global COUNT
    global SKIP
    global RESIDUE
    global MODULUS
    global K1
    global H1
    global K2
    global H2
    global K3
    global H3
    plen(N) defined
    rlen(N) defined
    clen(N) defined
    ptimes(str, N, n, count, skip, verbose) defined
    ctimes(str, N, n, count, skip, verbose) defined
    crtimes(str, a, b, n, count, skip, verbose) defined
    ntimes(str, N, n, count, skip, residue, mod, verbose) defined
    testnextcand(str, N, n, cnt, skip, res, mod, verbose) defined
    testnext1(x, y, count, skip, residue, modulus) defined
    testprevcand(str, N, n, cnt, skip, res, mod, verbose) defined
    testprev1(x, y, count, skip, residue, modulus) defined
    test4000(verbose, tnum) defined

    This resource file is used by regress.cal to test ptest, nextcand and
    prevcand builtins.

test4100.cal

    global defaultverbose
    global err
    global K1
    global K2
    global BASEB
    global BASE
    rlen_4100(N) defined
    olen(N) defined
    test1(x, y, m, k, z1, z2) defined
    testall(str, n, N, M, verbose) defined
    times(str, N, n, verbose) defined
    powtimes(str, N1, N2, n, verbose) defined
    inittimes(str, N, n, verbose) defined
    test4100(verbose, tnum) defined

    This resource file is used by regress.cal to test REDC operations.

test4600.cal

    stest(str [, verbose]) defined
    ttest([m, [n [,verbose]]]) defined
    sprint(x) defined
    findline(f,s) defined
    findlineold(f,s) defined
    test4600(verbose, tnum) defined

    This resource file is used by regress.cal to test searching in files.

test5100.cal

    global a5100
    global b5100
    test5100(x) defined

    This resource file is used by regress.cal to test the new code generator
    declaration scope and order.

test5200.cal

    global a5200
    static a5200
    f5200(x) defined
    g5200(x) defined
    h5200(x) defined

    This resource file is used by regress.cal to test the fix of a
    global/static bug.

test8400.cal

    test8400() defined

    This resource file is used by regress.cal to check for quit-based
    memory leaks.

test8500.cal

    global err_8500
    global L_8500
    global ver_8500
    global old_seed_8500
    global cfg_8500
    onetest_8500(a,b,rnd) defined
    divmod_8500(N, M1, M2, testnum) defined

    This resource file is used by regress.cal to the // and % operators.

test8600.cal

    global min_8600
    global max_8600
    global hash_8600
    global hmean_8600

    This resource file is used by regress.cal to test a change of
    allowing up to 1024 args to be passed to a builtin function.

unitfrac.cal

    unitfrac(x)

    Represent a fraction as sum of distinct unit fractions.


varargs.cal

    sc(a, b, ...)

    Example program to use 'varargs'.  Program to sum the cubes of all
    the specified numbers.

xx_print.cal

    is_octet(a) defined
    list_print(a) defined
    mat_print (a) defined
    octet_print(a) defined
    blk_print(a) defined
    nblk_print (a) defined
    strchar(a) defined
    file_print(a) defined
    error_print(a) defined

    Demo for the xx_print object routines.

## Copyright (C) 2000  David I. Bell and Landon Curt Noll
##
## Primary author: Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.9 $
## @(#) $Id: README,v 29.9 2003/01/05 08:10:56 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/cal/RCS/README,v $
##
## Under source code control:	1990/02/15 01:50:32
## File existed as early as:	before 1990
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* types
*************

Builtin types

    The calculator has the following built-in types.

    null value
	    This is the undefined value type.  The function 'null'
	    returns this value.	 Functions which do not explicitly
	    return a value return this type.  If a function is called
	    with fewer parameters than it is defined for, then the
	    missing parameters have the null type.  The null value is
	    false if used in an IF test.

    rational numbers
	    This is the basic data type of the calculator.
	    These are fractions whose numerators and denominators
	    can be arbitrarily large.  The fractions are always
	    in lowest terms.  Integers have a denominator of 1.
	    The numerator of the number contains the sign, so that
	    the denominator is always positive.	 When a number is
	    entered in floating point or exponential notation, it is
	    immediately converted to the appropriate fractional value.
	    Printing a value as a floating point or exponential value
	    involves a conversion from the fractional representation.

	    Numbers are stored in binary format, so that in general,
	    bit tests and shifts are quicker than multiplies and divides.
	    Similarly, entering or displaying of numbers in binary,
	    octal, or hex formats is quicker than in decimal.  The
	    sign of a number does not affect the bit representation
	    of a number.

    complex numbers
	    Complex numbers are composed of real and imaginary parts,
	    which are both fractions as defined above.	An integer which
	    is followed by an 'i' character is a pure imaginary number.
	    Complex numbers such as "2+3i" when typed in, are processed
	    as the sum of a real and pure imaginary number, resulting
	    in the desired complex number.  Therefore, parenthesis are
	    sometimes necessary to avoid confusion, as in the two values:

		    1+2i ^2		(which is -3)
		    (1+2i) ^2	(which is -3+4i)

	    Similar care is required when entering fractional complex
	    numbers.  Note the differences below:

		    3/4i		(which is -(3/4)i)
		    3i/4		(which is (3/4)i)

	    The imaginary unit itself is input using "1i".

    strings
	    Strings are a sequence of zero or more characters.
	    They are input using either of the single or double
	    quote characters.  The quote mark which starts the
	    string also ends it.  Various special characters can
	    also be inserted using back-slash.	Example strings:

		    "hello\n"
		    "that's all"
		    'lots of """"'
		    'a'
		    ""

	    There is no distinction between single character and
	    multi-character strings.  The 'str' and 'ord' functions
	    will convert between a single character string and its
	    numeric value.  The 'str' and 'eval' functions will
	    convert between longer strings and the corresponding
	    numeric value (if legal).  The 'strcat', 'strlen', and
	    'substr' functions are also useful.

    matrices
	    These are one to four dimensional matrices, whose minimum
	    and maximum bounds can be specified at runtime.  Unlike C,
	    the minimum bounds of a matrix do not have to start at 0.
	    The elements of a matrix can be of any type.  There are
	    several built-in functions for matrices.  Matrices are
	    created using the 'mat' statement.

    associations
	    These are one to four dimensional matrices which can be
	    indexed by arbitrary values, instead of just integers.
	    These are also known as associative arrays.	 The elements of
	    an association can be of any type.	Very few operations are
	    permitted on an association except for indexing.  Associations
	    are created using the 'assoc' function.

    lists
	    These are a sequence of values, which are linked together
	    so that elements can be easily be inserted or removed
	    anywhere in the list.  The values can be of any type.
	    Lists are created using the 'list' function.

    files
	    These are text files opened using stdio.  Files may be opened
	    for sequential reading, writing, or appending.  Opening a
	    file using the 'fopen' function returns a value which can
	    then be used to perform I/O to that file.  File values can
	    be copied by normal assignments between variables, or by
	    using the result of the 'files' function.  Such copies are
	    indistinguishable from each other.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: types,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/types,v $
##
## Under source code control:	1991/07/21 04:37:24
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* usage
*************

Calc command line

    Calc has the following command line:

	calc [-c] [-C] [-d] [-D calc_debug[:resource_debug[:user_debug]]]
	     [-e] [-h] [-i] [-m mode] [-n] [-p] [-q] [-s] [-u] [-v]
	     [calc_cmd ...]

	#!/usr/local/bin/calc -S [other_flags]

	  -c   Continue reading command lines even after an execution
	       error has caused the abandonment of a line.

	       For example:

		    calc read many_errors.cal

	       will cause calc to abort on the first error, whereas:

		    calc -c read many_errors.cal

	       will cause calc to try to process each line being read
	       despite the errors that it encounters.

	       By default, calc startup resource files are
	       silently ignored if not found.  This flag will report
	       missing startup scripts unless -d is also given.


	  -C   Permit the execution of custom builtin functions.
	       Without this flag, calling the custom() builtin
	       function will simply generate an error.

	       Use of this flag may cause calc to execute functions
	       that are non-standard and that are not portable.
	       Custom builtin functions are disabled by default for
	       this reason.


	  -d   Disable the printing of the opening title.  The
	       printing of resource file debug and informational messages is
	       also disabled as if config("resource_debug", 0) had been
	       executed.

	       For example:

		    calc 'read qtime; qtime(2)'

	       will output something like:

		    qtime(utc_hr_offset) defined
		    It's nearly ten past six.

	       whereas:

		    calc -d 'read qtime; qtime(2)'

	       will just say:

		    It's nearly ten past six.

	       This flag disables the reporting of missing calc
	       startup scripts.


	  -D calc_debug[:resource_debug:[user_debug]]
	       Force the initial value of config("calc_debug"),
	       config("resource_debug") and config("user_debug").

	       The : separated strings are interpreted as signed 32
	       bit integers.  After an optional leading sign a leading
	       zero indicates octal conversion, and a leading ``0x''
	       or ``0X'' hexadecimal conversion.  Otherwise, decimal
	       conversion is assumed.

	       By default, calc_debug is 0, resource_debug is 3 and
	       user_debug is 0.

	       For more information use the following calc command:

		    help config


	  -e   Ignore any environment variables on startup.  The
	       getenv() builtin will still return values, however.


	  -h   Print a help message.  This option implies -q.  This is
	       equivalent to the calc command help help.  The help
	       facility is disabled unless the mode is 5 or 7.	See
	       -m.


	  -i   Become interactive if possible.	If calc_cmd args are given,
   	       by default, calc will execute them and exit.  This flag causes
	       calc to drop into interactive mode after the commands are
	       executed.

	       For example:

		    calc 2+5

	       will print the value 7 and exit whereas:

		    calc -i 2+5

	       will print the value 7 and prompt the user for more
	       calc commands.


	  -m mode
	       This flag sets the permission mode of calc.  It
	       controls the ability for calc to open files and execute
	       programs.  Mode may be a number from 0 to 7.

	       The mode value is interpreted in a way similar to that
	       of the chmod(1) octal mode:

		    0  do not open any file, do not execute progs
		    1  do not open any file
		    2  do not open files for reading, do not execute progs
		    3  do not open files for reading
		    4  do not open files for writing, do not execute progs
		    5  do not open files for writing
		    6  do not execute any program
		    7  allow everything (default mode)

	       If one wished to run calc from a privileged user, one
	       might want to use -m 0 in an effort to make calc
	       somewhat more secure.

	       Mode bits for reading and writing apply only on an
	       open.  Files already open are not effected.  Thus if
	       one wanted to use the -m 0 in an effort to make calc
	       somewhat more secure, but still wanted to read and
	       write a specific file, one might want to do in sh(1),
	       ksh(1), bash(1)-like shells:

		    calc -m 0 3<a.file

	       Files presented to calc in this way are opened in an
	       unknown mode.  Calc will attempt to read or write them
	       if directed.

	       If the mode disables opening of files for reading, then
	       the startup resource files are disabled as if -q was
	       given.  The reading of key bindings is also disabled
	       when the mode disables opening of files for reading.


	  -O   Use the old classic defaults instead of the default
	       configuration.  This flag as the same effect as executing
	       config("all", "oldcfg") at startup time.

	       NOTE: Older versions of calc used -n to setup a modified
	       form of the default calc configuration.  The -n flag
	       currently does  nothing.   Use of the -n flag is now
	       deprecated and may used for something else in the future.

	  -p   Pipe processing is enabled by use of -p.	 For example:

		    calc -p '2^21701-1' | fizzbin

	       In pipe mode, calc does not prompt, does not print
	       leading tabs and does not print the initial header.
	       The -p flag overrides -i.


	  -q   Disable the reading of the startup scripts.


	  -s   By default, all calc_cmd args are evaluated and
	       executed.  This flag will disable their evaluation and
	       instead make them available as strings for the argv()
	       builtin function.


	  -u   Disable buffering of stdin and stdout.


	  -v   Print the calc version number and exit.


	  CALC COMMAND ARGUMENTS

	  With no calc_cmd arguments, calc operates interactively.  If one
	  or more arguments are given on the command line and -s is NOT
	  given, then calc will read and execute them and either attempt
	  to go interactive according as the -i flag was present or absent.

	  If -s is given, calc will not evaluate any calc_cmd
	  arguments but instead make them available as strings to the
	  argv() builtin function.

	  Sufficiently simple commands with no no characters like
	  parentheses, brackets, semicolons, '*', which have special
	  interpretations in UNIX commands may be entered, possibly with
	  spaces, until the terminating newline.  For example:

			calc 23 + 47

	  should respond with display of 70, but:

			calc 23 * 47

	  may fail.  Such cases can usually be made to work as expected by
	  enclosing the command between single quotation marks as in:

			calc '23 * 47'

	  and

			calc 'print sqrt(2), exp(1)'

	  If '!' is to be used to indicate the factorial function, for
	  shells like csh for which '!' followed by a non-space character
	  is used for history substitution, it may be necessary to
	  include a space or use a backslash to escape the special
	  meaning of '!'.  For example, the command "print 27!^2" may have
	  to be replaced by "print 27! ^2" or "print 27\!^2".


	  CALC STARTUP FILES

	  Normally on startup, if the environment variable $CALCRC is
	  undefined and calc is invoked without the -q flag, or if
	  $CALCRC is defined and calc is invoked with -e, calc looks
	  for a file "startup" in the calc resource directory, .calcrc in
	  the user's home directory, and .calcinit in the current directory.
	  If one or more of these are found, they are read in succession
	  as calc scripts and their commands executed.  When defined,
	  $CALCRC is to contain a ':' separated list of names of files,
	  and if calc is then invoked without either the -q or -e flags,
	  these files are read in succession and their commands executed.
	  No error condition is produced if a listed file is not found.

	  If the mode specified by -m disables opening of files for
	  reading, then the reading of startup files is also disabled
	  as if -q was given.


	  CALC FILE SEARCH PATH

	  If the environment variable $CALCPATH is undefined, or if it
	  is defined and calc is invoked with the -e flag, when a file
	  name not beginning with /, ~ or ./, is specified as in:

			calc read myfile

	  calc searches in succession:

			./myfile
			./myfile.cal
			${LIBDIR}/myfile
			${LIBDIR}/myfile.cal
			${CUSTOMCALDIR}/myfile
			${CUSTOMCALDIR}/myfile.cal

	  If the file is found, the search stops and the commands in
	  the file are executed.  It is an error if no readable file
	  with the specified name is found.  An alternative search
	  path can be specified by defining $CALCPATH in the same way
	  as PATH is defined, as a ':' separated list of directories,
	  and then invoking calc without the -e flag.

	  Calc treats all open files, other than stdin, stdout and
	  stderr as files available for reading and writing.  One may
	  present calc with an already open file using sh(1), ksh(1),
	  bash(1)-like shells is to:

	       calc 3<open_file 4<open_file2


	  SHELL SCRIPT MODE

	  If first line of an executable file begins #! followed by the
	  absolute pathname of the calc program and the flag -S as in

	       #!/usr/local/bin/calc -S [other_flags]

	  the rest of the file will be processed in shell script mode.
	  Note that -S (UPPER CASE S) must be the first -flag on the
	  ``#!'' line.	Any optional ``other_flags'' must come after
	  the -S.

	  In shell script mode the contents of the file are read and
	  executed as if they were in a file being processed by a read
	  command, except that a "command" beginning with '#' followed by
	  whitespace and ending at the next newline is treated as a comment.
	  Any optional ``other_flags'' will be parsed first followed by
	  the later lines within the script itself.

	  In shell script mode, -s (lower case s) is always assumed.
	  In addition, -d and -p are automatically set if -i is not
	  given.

	  For example, if the file /tmp/mersenne:

	       #!/usr/local/bin/calc -S -q
	       #
	       # mersenne - an example of a calc shell script file

	       /* parse args */
	       if (argv() != 1) {
		   fprintf(files(2), "usage: %s exp\n", config("program"));
		   abort "must give one exponent arg";
	       }

	       /* print the mersenne number */
	       print "2^": argv(0) : "-1 =", 2^eval(argv(0))-1;

	  is made an executable file by:

	       chmod +x /tmp/mersenne

	  then the command line:

	       /tmp/mersenne 127

	  will print:

	       2^127-1 = 170141183460469231731687303715884105727

	  Note that because -s is assumed in shell script mode and
	  non-dashed args are made available as strings via the argv()
	  builtin function.  Therefore:

	       2^eval(argv(0))-1

	  will print the decimal value of 2^n-1 but

	       2^argv(0)-1

	  will not.

For more information use the following calc commands:

   help help
   help overview
   help config
   help argv
   help environment

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.6 $
## @(#) $Id: usage,v 29.6 2003/06/10 21:39:34 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/usage,v $
##
## Under source code control:	1991/07/21 04:37:25
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* script
*************

Calc shell scripts
------------------

    There are several ways calc may be used in shell scripts.  The
    syntax for these varies widely for different shells and systems,
    but common to most are commands like echo, if, for, goto, shift,
    and exit, as well as the accessing of environment parameters, shell
    variables, and command-line arguments.

    As a simple example, assuming a C or Bourne shell, let add be a
    file containing just one line:

	    calc -q -- $1 + $2

    Then:

	    ./add 1.23 4.56

    should respond with the display of:

	    5.9

    The "-q" was included in the command to avoid reading of any
    start-up calc files which could contain commands not wanted
    here.  The "--" indicates that there are no more options;
    without it, if $1 began with '-', calc would interpret it as
    the first character of another option.  To execute the file,
    the strings "1.23" and "4.56" were assigned to $1 and $2, so
    calc was in effect asked to evaluate the string "1.23 + 4.56".

    By making add executable by a command like:

	    chmod u+x add

    the command used here may be simplified to:

	    ./add 1.23 4.56

    Here we shall assume that any script we refer to has been made
    executable in this way.

    Because $1 and $2, and instructions in the script, are to read
    by calc as expressions or commands, they may be much more
    complicated than in the above example, but if they involve
    characters with special interpretations by the shell (spaces
    for word separation, * or ? or [ ...] for file-name expansion,
    ! (without immediately following space) for history expansion,
    ( ... ) for shell-function arguments, { ... } for brace
    expansion, $ for parameter or variable expansion, <, <<, >, >>
    for redirection of input or output, etc.) it will usually be
    necessary to quote or escape tho characters, or usually more
    conveniently, quote whole expressions with single or double
    quotes.

    For example, the add script should have no problem with
    commands like:

	    ./add "sqrt(2)" "3 * 4"

	    ./add "mat A[2,2] = {1,2,3,4}" "A^2"

	    ./add "2 + 3i" "(3 + 4i)^2"

    If the shell arguments are to be integers, one could use
    scripts like the following with arithmetic expansion
    for the bash and ksh:

	    declare -i a=$1
	    declare -i b=$2
	    calc -q -- $a + $b

    and for csh:

	    @ a = $1
	    @ b = $2
	    calc -q -- $a + $b

    Specifying the shell for a script may be done by including
    in the script a first line with the "magic number" "#!" and
    the full file path for the shell as in:

	    #!/bin/bash
	    declare -i a=$1
	    declare -i b=$2
	    calc -q -- $a + $b

    For a script to multiply rather than add two expressions, one
    could have a file mul with the one line:

	    calc -q -- $1 \* $2
    or:
	    calc -q -- "$1 * $2"

    which will work so long as $1 and $2 are literal numbers, but
    will not work for:

	    ./mul 2+3 4
    or:
	    ./mul "2 + 3" 4

    both of which calc interprets as evaluating 2 + 3 * 4.  What should
    work for most shells is:

	    calc -q -- "($1) * ($2)"

    For adding an arbitrary number of expressions that evaluate to
    rational numbers expressible with at most 20 decimal places,
    simple shell script could be used:

	    s=0
	    for i do
		    s=`calc -q -- $s + $i`
	    done
	    echo sum = $s

    This is not particularly efficient since it calls calc once for
    each argument.  Also, a more serious script would permit more
    general numbers.

    Another way of handling a sum of several expressions is with
    the script addall2 with a here document:

	    calc "-q -s" $* << +
	    global i, n, s;
	    n = argv();
	    for (i = 0; i < n; i++)
		    s += eval(argv(i));
	    print "sum =", s;
	    +

    In executing the command:

	    ./addall2 2 3 4

    the $* in ths script expands to  2 3 4, and because of the "-s"
    in the options, calc starts with argv(0) = "2", argv(1) = "3",
    argv(2)= "4".  As there is only one calc process involved and
    the eval() function accepts as argument any string that
    represents the body of a calc function, the strings argv(0),
    argv(1), ... could evaluate to any value types for which the
    additions to be performed are defined, and variables defined in
    one argv() can be used in later arguments.

    For systems that support interpreter files, essentially the
    same thing may be done more efficiently by using calc as an
    interpreter.  Assuming the full path for calc is
    /usr/local/bin/calc, one could use the file addall3 with contents

	    #!/usr/bin/calc -q -s -f
	    global i, n, s;
	    n = argv();
	    for (i = 1; i <= n; i++)
		    s += eval(argv(i));
	    print "sum =", s;

	IMPORTANT NOTE:

	    The -f flag must be at the very end of the #! line.
	    The #! line must be the first line of the exeuctable file.
	    The path after the #! must be the full path to the calc executable.

    After the command:

	    addall3 2 3 4

    the arguments calc receives are argv(0) = "addall3", argv(1) =
    "2", argv(3) = "3", argv(4) = "4".

    Another kind of script that can be useful is sqrts1:

	    calc -q 'global s; while (scanf("%s", s) == 1) print sqrt(eval(s));'

    or what is essentially an interpreter equivalent sqrts2:

	    #!/usr/local/bin/calc -q -f
	    global s;
	    while (scanf('%s', s) == 1)
		    print sqrt(eval(s));

    If sqrts is either of these scripts, the command:

	    echo 27 2+3i | sqrts

    or, if datafile contains the one line:

	    27 2+3i

    or the two lines:

	    27
	    2+3i

    either:

	    cat datafile | ./sqrts
    or:
	    ./sqrts < datafile

    should display the square-roots of 27 and 2+3i.  The output could
    be piped to another command by | or directed to a file by use of
    > or >>.

    With no specified input, either sqrts1 or sqrts2 will wait
    without any prompt for input from the keyboard and as each line
    is completed display the square-roots of the expressions
    entered.  Exit can be achieved by entering exit or entering
    ctrl-D (interpreted as EOF) rather than a line of input.

    One advantage of an interpreter file like sqrts2 (which has only
    options, but neither "-s" nor "--" in its first line) is that it
    can be invoked with further options as in

	    echo 2 3 4 | ./sqrts2 -i -D 32

    An advantage of non-interpreter files is that they can use shell
    features.  For example, for unquoted arguments or arguments in
    double quotes parameter expansion (indicated by unquoted '$') and
    command substitution (using backquotes) occur before lines are
    compiled by calc.  For example, if doit is an executable
    script with contents

	    calc -q -- "$1($2)"

    it may be used as in:

	    ./doit sqrt 7
    and:
	    ./doit exp 7

    to display the values of sqrt(7) and exp(7).  The "--" prevents a
    leading '-' in the $1 argument as indicating one or more additional
    options. E.g., without the "--" in doit,

	    ./doit -sqrt 7

    would be interpreted as:

	    calc -q "-sqrt(7)"

    in which the dash in the quoted part would be taken as indicating a
    list of options -s, -q, -r, etc.; this would give an "illegal option"
    error as calc has no -r option.

    In invoking the doit script it is not necessary that $1 expand to a
    calc function name and $2 to an expression; all that is required is
    that:

	    $1($2)

    expands to a string that calc will recognize as a command.  E.g.:

	    ./doit "define f(x) = x^2; 2 + mod" "f(7), 6"

    does the same as:

	    calc -q -- "define f(x) = x^2; 2 + mod(f(7), 6)"

    Essentially the same is achieved by the contents of doit is changed to:

	    calc -q -p -- << +
	    $1($2)
	    +

    The "-p" stops calc going interactive; without it the effect would be
    be the same as that of a script with the one line:

	    calc -q -i -- "$1($2)"

For more information use the following calc commands:

    help usage
    help argv
    help config
    help cscript

## Copyright (C) 2000  Landon Curt Noll and Ernest Bowen
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.7 $
## @(#) $Id: script,v 29.7 2004/10/23 00:41:11 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/script,v $
##
## Under source code control:	1999/11/30 05:29:48
## File existed as early as:	1999
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/


*************
* cscript
*************

calc shell script examples
--------------------------

These calc shell scripts are provided because they serve as examples of
how use the calc language, and/or because the authors thought them to
be useful!

If you write something that you think is useful, please send it to:

    calc-contrib at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

For more info, see:

    help script
    help cscript

=-=

4dsphere

    Determine if 6 points lie on the surface of a 4-dimensional sphere in R^4.

    4dsphere x0 y0 z0 w0   x1 y1 z1 w1   ...   x5 y5 z5 w5

	x0 y0 z0 w0     point 0 in R^4
	x1 y1 z1 w1     point 1 in R^4
	...             ...
	x5 y5 z5 w5     point 5 in R^4


fproduct filename term ...

    Write the big Endian product of terms to a file.  Use - for stdout.


mersenne exp

    Print the value of 2^exp-1.


piforever

    Print the value of pi forever, or as long as you cpu / memory allows.


plus arg ...

    Print the sum of 1 or more arguments.


powerterm [base_limit] value

    Print the value as a sum (or difference) of powers of integers up
    to and including powers <= base_limit.  By default, base_limit is 10000.


simple

    A trivial example of a calc shell script.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.10 $
## @(#) $Id: README,v 29.10 2001/06/10 19:34:40 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/cscript/RCS/README,v $
##
## Under source code control:	1999/12/17 10:23:40
## File existed as early as:	1999
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* unexpected
*************

Unexpected

    While calc is C-like, users of C will find some unexpected
    surprises in calc syntax and usage.	 Persons familiar with C should
    review this file.


    The Comma
    =========

    The comma is also used for continuation of obj and mat creation
    expressions and for separation of expressions to be used for
    arguments or values in function calls or initialization lists.  The
    precedence order of these different uses is:  continuation,
    separator, comma operator.	For example, assuming the variables a,
    b, c, d, e, and object type xx have been defined, the arguments
    passed to f in:

	    f(a, b, c, obj xx d, e)

    are a, b, c, and e, with e having the value of a newly created xx
    object.  In:

	    f((a, b), c, (obj xx d), e)

    the arguments of f are b, c, d, e, with only d being a newly
    created xx object.

    In combination with other operators, the continuation use of the
    comma has the same precedence as [] and ., the separator use the
    same as the comma operator.	 For example, assuming xx.mul() has
    been defined:

	    f(a = b, obj xx c, d = {1,2} * obj xx e = {3,4})

    passes two arguments: a (with value b) and the product d * e of two
    initialized xx objects.


    ^ is not xor
    ============

    In C, ^ is the xor operator.  Like the '**', '^' is the
    exponentiation operator.  The expression:

	    a^b

    yields "a to the b power", NOT "a xor b".

    Note that 'b' must be an integer.  Also if 'a' == 0, 'b'
    must be >= 0 as well.

    To raise to a non-integer power, use the power() builtin function.


    ** is exponentiation
    ====================

    As was suggested in the '^ is not xor' section, the expression:

	    a**b

    yields "a to the b power", NOT "a xor b".

    Note that 'b' must be an integer.  Also if 'a' == 0, 'b'
    must be >= 0 as well.

    To raise to a non-integer power, use the power() builtin function.


    op= operators associate left to right
    =====================================

    Operator-with-assignments:

	    +=	-=  *=	/=  %=	//=  &=	 |=  <<=  >>=  ^=  **=

    associate from left to right instead of right to left as in C.
    For example:

	    a += b *= c

    has the effect of:

	    a = (a + b) * c

    where only 'a' is required to be an lvalue.	 For the effect of:

	    b *= c; a += b

    when both 'a' and 'b' are lvalues, use:

	    a += (b *= c)


    || yields values other than 0 or 1
    ==================================

    In C:

	    a || b

    will produce 0 or 1 depending on the logical evaluation
    of the expression.	In calc, this expression will produce
    either 'a' or 'b' and is equivalent to the expression:

	    a ? a : b

    In other words, if 'a' is true, then 'a' is returned, otherwise
    'b' is returned.


    && yields values other than 0 or 1
    ==================================

    In C:

	    a && b

    will produce 0 or 1 depending on the logical evaluation
    of the expression.	In calc, this expression will produce
    either 'a' or 'b' and is equivalent to the expression:

	    a ? b : a

    In other words, if 'a' is true, then 'b' is returned, otherwise
    'a' is returned.


    / is fractional divide, // is integral divide
    =============================================

    In C:

	    x/y

    performs integer division when 'x' and 'y' are integer types.
    In calc, this expression yields a rational number.

    Calc uses:

	    x//y

    to perform division with integer truncation and is the equivalent to:

	    int(x/y)


    | and & have higher precedence than ==, +, -, *, / and %
    ========================================================

    Is C:

	    a == b | c * d

    is interpreted as:

	    (a == b) | (c * d)

    and calc it is interpreted as:

	    a == ((b | c) * d)


    calc always evaluates terms from left to right
    ==============================================

    Calc has a definite order for evaluation of terms (addends in a
    sum, factors in a product, arguments for a function or a matrix,
    etc.).  This order is always from left to right. but skipping of
    terms may occur for ||, && and ? : .

    Consider, for example:

	    A * B + C * D

    In calc above expression is evaluated in the following order:

	    A
	    B
	    A * B
	    C
	    D
	    C * D
	    A * B + C * D

    This order of evaluation is significant if evaluation of a
    term changes a variable on which a later term depends.  For example:

	    x++ * x++ + x++ * x++

    in calc returns the value:

	    x * (x + 1) + (x + 2) * (x + 3)

    and increments x as if by x += 4.  Similarly, for functions f, g,
    the expression:

	    f(x++, x++) + g(x++)

    evaluates to:

	    f(x, x + 1) + g(x + 2)

    and increments x three times.


    &A[0] and A are different things in calc
    ========================================

    In calc, value of &A[0] is the address of the first element, whereas
    A is the entire array.


    *X may be used to to return the value of X
    ==========================================

    If the current value of a variable X is an octet, number or string,
    *X may be used to to return the value of X; in effect X is an
    address and *X is the value at X.


    freeing a variable has the effect of assigning the null value to it
    ===================================================================

    The freeglobals(), freestatics(), freeredc() and free() free
    builtins to not "undefine" the variables, but have the effect of
    assigning the null value to them, and so frees the memory used for
    elements of a list, matrix or object.

    Along the same lines:

	    undefine *

    undefines all current user-defined functions.  After executing
    all the above freeing functions (and if necessary free(.) to free
    the current "old value"), the only remaining numbers as displayed by

	    show numbers

    should be those associated with epsilon(), and if it has been
    called, qpi().


    #! is also a comment
    ====================

    In addition to the C style /* comment lines */, lines that begin with
    #! are treated as comments.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: unexpected,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/unexpected,v $
##
## Under source code control:	1997/03/21 13:15:18
## File existed as early as:	1997
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* variable
*************

Variable declarations

    Variables can be declared as either being global, local, or static.
    Global variables are visible to all functions and on the command
    line, and are permanent.  Local variables are visible only within
    a single function or command sequence.  When the function or command
    sequence returns, the local variables are deleted.	Static variables
    are permanent like global variables, but are only visible within the
    same input file or function where they are defined.

    To declare one or more variables, the 'local', 'global', or 'static'
    keywords are used, followed by the desired list of variable names,
    separated by commas.  The definition is terminated with a semicolon.
    Examples of declarations are:

	    local	x, y, z;
	    global	fred;
	    local	foo, bar;
	    static	var1, var2, var3;

    Variables may have initializations applied to them.	 This is done
    by following the variable name by an equals sign and an expression.
    Global and local variables are initialized each time that control
    reaches them (e.g., at the entry to a function which contains them).
    Static variables are initialized once only, at the time that control
    first reaches them (but in future releases the time of initialization
    may change).  Unlike in C, expressions for static variables may
    contain function calls and refer to variables.  Examples of such
    initializations are:

	    local	a1 = 7, a2 = 3;
	    static	b = a1 + sin(a2);

    Within function declarations, all variables must be defined.
    But on the top level command line, assignments automatically define
    global variables as needed.	 For example, on the top level command
    line, the following defines the global variable x if it had not
    already been defined:

	    x = 7

    The static keyword may be used at the top level command level to
    define a variable which is only accessible interactively, or within
    functions defined interactively.

    Variables have no fixed type, thus there is no need or way to
    specify the types of variables as they are defined.	 Instead, the
    types of variables change as they are assigned to or are specified
    in special statements such as 'mat' and 'obj'.  When a variable is
    first defined using 'local', 'global', or 'static', it has the
    value of zero.

    If a procedure defines a local or static variable name which matches
    a global variable name, or has a parameter name which matches a
    global variable name, then the local variable or parameter takes
    precedence within that procedure, and the global variable is not
    directly accessible.

    The MAT and OBJ keywords may be used within a declaration statement
    in order to initially define variables as that type.  Initialization
    of these variables are also allowed.  Examples of such declarations
    are:

	    static mat table[3] = {5, 6, 7};
	    local obj point p1, p2;

    There are no pointers in the calculator language, thus all
    arguments to user-defined functions are normally passed by value.
    This is true even for matrices, strings, and lists.	 In order
    to circumvent this, the '&' operator is allowed before a variable
    when it is an argument to a function.  When this is done, the
    address of the variable is passed to the function instead of its
    value.  This is true no matter what the type of the variable is.
    This allows for fast calls of functions when the passed variable
    is huge (such as a large array).  However, the passed variable can
    then be changed by the function if the parameter is assigned into.
    The function being called does not need to know if the variable
    is being passed by value or by address.

    Built-in functions and object functions always accept their
    arguments as addresses, thus there is no need to use '&' when
    calling built-in functions.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: variable,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/variable,v $
##
## Under source code control:	1991/07/21 04:37:25
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* bindings
*************

# bindings - default key bindings for calc line editing functions
#
# Copyright (C) 1999  David I. Bell
#
# Calc is open software; you can redistribute it and/or modify it under
# the terms of the version 2.1 of the GNU Lesser General Public License
# as published by the Free Software Foundation.
#
# Calc is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU Lesser General
# Public License for more details.
#
# A copy of version 2.1 of the GNU Lesser General Public License is
# distributed with calc under the filename COPYING-LGPL.  You should have
# received a copy with calc; if not, write to Free Software Foundation, Inc.
# 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
#
# @(#) $Revision: 29.2 $
# @(#) $Id: bindings,v 29.2 2000/06/07 14:02:25 chongo Exp $
# @(#) $Source: /usr/local/src/cmd/calc/cal/RCS/bindings,v $
#
# Under source code control:	1993/05/02 20:09:19
# File existed as early as:	1993
#
# Share and enjoy!  :-) http://www.isthe.com/chongo/tech/comp/calc/

# NOTE: This facility is ignored if calc was compiled with GNU-readline.
#	In that case, the standard readline mechanisms (see readline(3))
#	are used in place of those found below.


map	base-map
default insert-char
^@	set-mark
^A	start-of-line
^B	backward-char
^D	delete-char
^E	end-of-line
^F	forward-char
^H	backward-kill-char
^J	new-line
^K	kill-line
^L	refresh-line
^M	new-line
^N	forward-history
^O	save-line
^P	backward-history
^R	reverse-search
^T	swap-chars
^U	flush-input
^V	quote-char
^W	kill-region
^Y	yank
^?	backward-kill-char
^[	ignore-char	esc-map

map	esc-map
default ignore-char	base-map
G	start-of-line
H	backward-history
P	forward-history
K	backward-char
M	forward-char
O	end-of-line
S	delete-char
g	goto-line
s	backward-word
t	forward-word
d	forward-kill-word
u	uppercase-word
l	lowercase-word
h	list-history
^[	flush-input
[	arrow-key

*************
* custom_cal
*************

Custom calc resource files
--------------------------

The following custom calc resource files are provided because they serve
as examples of how use the custom interface.  The custom interface
allows for machine dependent and/or non-portable code to be added as
builtins to the calc program.  A few example custom functions and
resource files are shipped with calc to provide you with examples.

By default, the custom builtin returns an error.  Calc have been
built with:

	ALLOW_CUSTOM= -DCUSTOM

in the top level Makefile (this is the shipped default) and calc
must be invoked with a -C argument:

	calc -C

when it is run.

See the ../cal/README or "help resource" for information about
calc resource standards and guidelines.

=-=

argv.cal

    argv(var, ...)

    print information about various args

halflen.cal

    halflen(num)

    Calculate the length of a numeric value in HALF's.

pzasusb8.cal

    Run custom("pzasusb8") on a standard set of data, print Endian
    related information and print value size information.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: CUSTOM_CAL,v 29.2 2000/06/07 14:03:03 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/custom/RCS/CUSTOM_CAL,v $
##
## Under source code control:	1997/03/08 20:51:32
## File existed as early as:	1997
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* libcalc
*************

	USING THE ARBITRARY PRECISION ROUTINES IN A C PROGRAM

Part of the calc release consists of an arbitrary precision math link library.
This link library is used by the calc program to perform its own calculations.
If you wish, you can ignore the calc program entirely and call the arbitrary
precision math routines from your own C programs.

The link library is called libcalc.a, and provides routines to handle arbitrary
precision arithmetic with integers, rational numbers, or complex numbers.
There are also many numeric functions such as factorial and gcd, along
with some transcendental functions such as sin and exp.

Take a look at the sample sub-directory.  It contains a few simple
examples of how to use libcalc.a that might be helpful to look at
after you have read this file.

------------------
FIRST THINGS FIRST
------------------

...............................................................................
.									      .
. You MUST call libcalc_call_me_first() prior to using libcalc lib functions! .
.									      .
...............................................................................

The function libcalc_call_me_first() takes no args and returns void.  You
need call libcalc_call_me_first() only once.

-------------
INCLUDE FILES
-------------

To use any of these routines in your own programs, you need to include the
appropriate include file.  These include files are:

	zmath.h		(for integer arithmetic)
	qmath.h		(for rational arithmetic)
	cmath.h		(for complex number arithmetic)

You never need to include more than one of the above files, even if you wish
to use more than one type of arithmetic, since qmath.h automatically includes
zmath.h, and cmath.h automatically includes qmath.h.

The prototypes for the available routines are listed in the above include
files.	Some of these routines are meant for internal use, and so aren't
convenient for outside use.  So you should read the source for a routine
to see if it really does what you think it does.  I won't guarantee that
obscure internal routines won't change or disappear in future releases!

When calc is installed, all of libraries are installed into /lib/calc.
All of the calc header files are installed under ${INCDIRCALC}.

If CALC_SRC is defined, then the calc header files will assume that
they are in or under the current directory.  However, most external
programs most likely will not be located under calc'c source tree.
External programs most likely want to use the installed calc header
files under ${INCDIRCALC}.  External programs most likely NOT want
to define CALC_SRC.

External programs may want to compile with:

	-L/lib/calc -lcalc

If custom functions are also used, they may want to compile with:

	-L/lib/calc -lcalc -lcustcalc

The CALC_SRC symbol should NOT be defined by default.  However if you are
feeling pedantic you may want to force CALC_SRC to be undefined:

	-UCALC_SRC

as well.

--------------
ERROR HANDLING
--------------

Your program MUST provide a function called math_error.	 This is called by
the math routines on an error condition, such as malloc failures or a
division by zero.  The routine is called in the manner of printf, with a
format string and optional arguments.  (However, none of the low level math
routines currently uses formatting, so if you are lazy you can simply use
the first argument as a simple error string.)  For example, one of the
error calls you might expect to receive is:

	math_error("Division by zero");

Your program can handle errors in basically one of two ways.  Firstly, it
can simply print the error message and then exit.  Secondly, you can make
use of setjmp and longjmp in your program.  Use setjmp at some appropriate
level in your program, and use longjmp in the math_error routine to return
to that level and so recover from the error.  This is what the calc program
does.

For convenience, the link library libcalc.a contains a math_error routine.
By default, this routine simply prints a message to stderr and then exits.
By simply linking in this link library, any calc errors will result in a
error message on stderr followed by an exit.

External programs that wish to use this math_error may want to compile with:

	-I/lib/calc -L/lib/calc -lcalc

If one sets up calc_jmp_buf, and then sets calc_jmp to non-zero then
this routine will longjmp back (with the value of calc_jmp) instead.
In addition, the last calc error message will be found in calc_error;
this error is not printed to stderr.  The calc error message will
not have a trailing newline.

For example:

    #include <setjmp.h>

    extern jmp_buf calc_jmp_buf;
    extern int calc_jmp;
    extern char *calc_error;
    int error;

    ...

    if ((error = setjmp(calc_jmp_buf)) != 0) {

	    /* reinitialize calc after a longjmp */
	    reinitialize();

	    /* report the error */
	    printf("Ouch: %s\n", calc_error);
    }
    calc_jmp = 1;

---------------
OUTPUT ROUTINES
---------------

The output from the routines in the link library normally goes to stdout.  You
can divert that output to either another FILE handle, or else to a string.
Read the routines in zio.c to see what is available.  Diversions can be
nested.

You use math_setfp to divert output to another FILE handle.  Calling
math_setfp with stdout restores output to stdout.

Use math_divertio to begin diverting output into a string.  Calling
math_getdivertedio will then return a string containing the output, and
clears the diversion.  The string is reallocated as necessary, but since
it is in memory, there are obviously limits on the amount of data that can
be diverted into it.  The string needs freeing when you are done with it.

Calling math_cleardiversions will clear all the diversions to strings, and
is useful on an error condition to restore output to a known state.  You
should also call math_setfp on errors if you had changed that.

If you wish to mix your own output with numeric output from the math routines,
then you can call math_chr, math_str, math_fill, math_fmt, or math_flush.
These routines output single characters, output null-terminated strings,
output strings with space filling, output formatted strings like printf, and
flush the output.  Output from these routines is diverted as described above.

You can change the default output mode by calling math_setmode, and you can
change the default number of digits printed by calling math_setdigits.	These
routines return the previous values.  The possible modes are described in
zmath.h.

--------------
USING INTEGERS
--------------

The arbitrary precision integer routines define a structure called a ZVALUE.
This is defined in zmath.h.  A ZVALUE contains a pointer to an array of
integers, the length of the array, and a sign flag.  The array is allocated
using malloc, so you need to free this array when you are done with a
ZVALUE.	 To do this, you should call zfree with the ZVALUE as an argument
(or call freeh with the pointer as an argument) and never try to free the
array yourself using free.  The reason for this is that sometimes the pointer
points to one of two statically allocated arrays which should NOT be freed.

The ZVALUE structures are passed to routines by value, and are returned
through pointers.  For example, to multiply two small integers together,
you could do the following:

	ZVALUE	z1, z2, z3;

	itoz(3L, &z1);
	itoz(4L, &z2);
	zmul(z1, z2, &z3);

Use zcopy to copy one ZVALUE to another.  There is no sharing of arrays
between different ZVALUEs even if they have the same value, so you MUST
use this routine.  Simply assigning one value into another will cause
problems when one of the copies is freed.  However, the special ZVALUE
values _zero_ and _one_ CAN be assigned to variables directly, since their
values of 0 and 1 are so common that special checks are made for them.

For initial values besides 0 or 1, you need to call itoz to convert a long
value into a ZVALUE, as shown in the above example.  Or alternatively,
for larger numbers you can use the atoz routine to convert a string which
represents a number into a ZVALUE.  The string can be in decimal, octal,
hex, or binary according to the leading digits.

Always make sure you free a ZVALUE when you are done with it or when you
are about to overwrite an old ZVALUE with another value by passing its
address to a routine as a destination value, otherwise memory will be
lost.  The following shows an example of the correct way to free memory
over a long sequence of operations.

	ZVALUE z1, z2, z3;

	z1 = _one_;
	atoz("12345678987654321", &z2);
	zadd(z1, z2, &z3);
	zfree(z1);
	zfree(z2);
	zsquare(z3, &z1);
	zfree(z3);
	itoz(17L, &z2);
	zsub(z1, z2, &z3);
	zfree(z1);
	zfree(z2);
	zfree(z3);

There are some quick checks you can make on integers.  For example, whether
or not they are zero, negative, even, and so on.  These are all macros
defined in zmath.h, and should be used instead of checking the parts of the
ZVALUE yourself.  Examples of such checks are:

	ziseven(z)	(number is even)
	zisodd(z)	(number is odd)
	ziszero(z)	(number is zero)
	zisneg(z)	(number is negative)
	zispos(z)	(number is positive)
	zisunit(z)	(number is 1 or -1)
	zisone(z)	(number is 1)
	zisnegone(z)	(number is -1)
	zistwo(z)	(number is 2)
	zisabstwo(z)	(number is 2 or -2)
	zisabsleone(z)	(number is -1, 0 or 1)
	zislezero(z)	(number is <= 0)
	zisleone(z)	(number is <= 1)
	zge16b(z)	(number is >= 2^16)
	zge24b(z)	(number is >= 2^24)
	zge31b(z)	(number is >= 2^31)
	zge32b(z)	(number is >= 2^32)
	zge64b(z)	(number is >= 2^64)

Typically the largest unsigned long is typedefed to FULL.  The following
macros are useful in dealing with this data type:

	MAXFULL		(largest positive FULL value)
	MAXUFULL	(largest unsigned FULL value)
	zgtmaxfull(z)	(number is > MAXFULL)
	zgtmaxufull(z)	(number is > MAXUFULL)
	zgtmaxlong(z)	(number is > MAXLONG, largest long value)
	zgtmaxulong(z)	(number is > MAXULONG, largest unsigned long value)

If zgtmaxufull(z) is false, then one may quickly convert the absolute
value of number into a full with the macro:

	ztofull(z)	(convert abs(number) to FULL)
	ztoulong(z)	(convert abs(number) to an unsigned long)
	ztolong(z)	(convert abs(number) to a long)

If the value is too large for ztofull(), ztoulong() or ztolong(), only
the low order bits converted.

There are two types of comparisons you can make on ZVALUEs.  This is whether
or not they are equal, or the ordering on size of the numbers.	The zcmp
function tests whether two ZVALUEs are equal, returning TRUE if they differ.
The zrel function tests the relative sizes of two ZVALUEs, returning -1 if
the first one is smaller, 0 if they are the same, and 1 if the first one
is larger.

---------------
USING FRACTIONS
---------------

The arbitrary precision fractional routines define a structure called NUMBER.
This is defined in qmath.h.  A NUMBER contains two ZVALUEs for the numerator
and denominator of a fraction, and a count of the number of uses there are
for this NUMBER.  The numerator and denominator are always in lowest terms,
and the sign of the number is contained in the numerator.  The denominator
is always positive.  If the NUMBER is an integer, the denominator has the
value 1.

Unlike ZVALUEs, NUMBERs are passed using pointers, and pointers to them are
returned by functions.	So the basic type for using fractions is not really
(NUMBER), but is (NUMBER *).  NUMBERs are allocated using the qalloc routine.
This returns a pointer to a number which has the value 1.  Because of the
special property of a ZVALUE of 1, the numerator and denominator of this
returned value can simply be overwritten with new ZVALUEs without needing
to free them first.  The following illustrates this:

	NUMBER *q;

	q = qalloc();
	itoz(55L, &q->num);

A better way to create NUMBERs with particular values is to use the itoq,
iitoq, or atoq functions.  Using itoq makes a long value into a NUMBER,
using iitoq makes a pair of longs into the numerator and denominator of a
NUMBER (reducing them first if needed), and atoq converts a string representing
a number into the corresponding NUMBER.	 The atoq function accepts input in
integral, fractional, real, or exponential formats.  Examples of allocating
numbers are:

	NUMBER *q1, *q2, *q3;

	q1 = itoq(66L);
	q2 = iitoq(2L, 3L);
	q3 = atoq("456.78");

Also unlike ZVALUEs, NUMBERs are quickly copied.  This is because they contain
a link count, which is the number of pointers there are to the NUMBER.	The
qlink macro is used to copy a pointer to a NUMBER, and simply increments
the link count and returns the same pointer.  Since it is a macro, the
argument should not be a function call, but a real pointer variable.  The
qcopy routine will actually make a new copy of a NUMBER, with a new link
count of 1.  This is not usually needed.

NUMBERs are deleted using the qfree routine.  This decrements the link count
in the NUMBER, and if it reaches zero, then it will deallocate both of
the ZVALUEs contained within the NUMBER, and then puts the NUMBER structure
onto a free list for quick reuse.  The following is an example of allocating
NUMBERs, copying them, adding them, and finally deleting them again.

	NUMBER *q1, *q2, *q3;

	q1 = itoq(111L);
	q2 = qlink(q1);
	q3 = qqadd(q1, q2);
	qfree(q1);
	qfree(q2);
	qfree(q3);

Because of the passing of pointers and the ability to copy numbers easily,
you might wish to use the rational number routines even for integral
calculations.  They might be slightly slower than the raw integral routines,
but are more convenient to program with.

The prototypes for the fractional routines are defined in qmath.h.
Many of the definitions for integer functions parallel the ones defined
in zmath.h.  But there are also functions used only for fractions.
Examples of these are qnum to return the numerator, qden to return the
denominator, qint to return the integer part of, qfrac to return the
fractional part of, and qinv to invert a fraction.

There are some transcendental functions in the link library, such as sin
and cos.  These cannot be evaluated exactly as fractions.  Therefore,
they accept another argument which tells how accurate you want the result.
This is an "epsilon" value, and the returned value will be within that
quantity of the correct value.	This is usually an absolute difference,
but for some functions (such as exp), this is a relative difference.
For example, to calculate sin(0.5) to 100 decimal places, you could do:

	NUMBER *q, *ans, *epsilon;

	q = atoq("0.5");
	epsilon = atoq("1e-100");
	ans = qsin(q, epsilon);

There are many convenience macros similar to the ones for ZVALUEs which can
give quick information about NUMBERs.  In addition, there are some new ones
applicable to fractions.  These are all defined in qmath.h.  Some of these
macros are:

	qiszero(q)	(number is zero)
	qisneg(q)	(number is negative)
	qispos(q)	(number is positive)
	qisint(q)	(number is an integer)
	qisfrac(q)	(number is fractional)
	qisunit(q)	(number is 1 or -1)
	qisone(q)	(number is 1)
	qisnegone(q)	(number is -1)
	qistwo(q)	(number is 2)
	qiseven(q)	(number is an even integer)
	qisodd(q)	(number is an odd integer)
	qistwopower(q)	(number is a power of 2 >= 1)

The comparisons for NUMBERs are similar to the ones for ZVALUEs.  You use the
qcmp and qrel functions.

There are four predefined values for fractions.	 You should qlink them when
you want to use them.  These are _qzero_, _qone_, _qnegone_, and _qonehalf_.
These have the values 0, 1, -1, and 1/2.  An example of using them is:

	NUMBER *q1, *q2;

	q1 = qlink(&_qonehalf_);
	q2 = qlink(&_qone_);

---------------------
USING COMPLEX NUMBERS
---------------------

The arbitrary precision complex arithmetic routines define a structure
called COMPLEX.	 This is defined in cmath.h.  This contains two NUMBERs
for the real and imaginary parts of a complex number, and a count of the
number of links there are to this COMPLEX number.

The complex number routines work similarly to the fractional routines.
You can allocate a COMPLEX structure using comalloc (NOT calloc!).
You can construct a COMPLEX number with desired real and imaginary
fractional parts using qqtoc.  You can copy COMPLEX values using clink
which increments the link count.  And you free a COMPLEX value using cfree.
The following example illustrates this:

	NUMBER *q1, *q2;
	COMPLEX *c1, *c2, *c3;

	q1 = itoq(3L);
	q2 = itoq(4L);
	c1 = qqtoc(q1, q2);
	qfree(q1);
	qfree(q2);
	c2 = clink(c1);
	c3 = cmul(c1, c2);
	cfree(c1);
	cfree(c2);
	cfree(c3);

As a shortcut, when you want to manipulate a COMPLEX value by a real value,
you can use the caddq, csubq, cmulq, and cdivq routines.  These accept one
COMPLEX value and one NUMBER value, and produce a COMPLEX value.

There is no direct routine to convert a string value into a COMPLEX value.
But you can do this yourself by converting two strings into two NUMBERS,
and then using the qqtoc routine.

COMPLEX values are always returned from these routines.	 To split out the
real and imaginary parts into normal NUMBERs, you can simply qlink the
two components, as shown in the following example:

	COMPLEX *c;
	NUMBER *rp, *ip;

	c = calloc();
	rp = qlink(c->real);
	ip = qlink(c->imag);

There are many macros for checking quick things about complex numbers,
similar to the ZVALUE and NUMBER macros.  In addition, there are some
only used for complex numbers.	Examples of macros are:

	cisreal(c)	(number is real)
	cisimag(c)	(number is pure imaginary)
	ciszero(c)	(number is zero)
	cisnegone(c)	(number is -1)
	cisone(c)	(number is 1)
	cisrunit(c)	(number is 1 or -1)
	cisiunit(c)	(number is i or -i)
	cisunit(c)	(number is 1, -1, i, or -i)
	cistwo(c)	(number is 2)
	cisint(c)	(number is has integer real and imaginary parts)
	ciseven(c)	(number is has even real and imaginary parts)
	cisodd(c)	(number is has odd real and imaginary parts)

There is only one comparison you can make for COMPLEX values, and that is
for equality.  The ccmp function returns TRUE if two complex numbers differ.

There are three predefined values for complex numbers.	You should clink
them when you want to use them.	 They are _czero_, _cone_, and _conei_.
These have the values 0, 1, and i.

----------------
LAST THINGS LAST
----------------

If you wish, when you are all doen you can call libcalc_call_me_last()
to free a small amount of storage associated with the libcalc_call_me_first()
call.  This is not required, but is does bring things to a closure.

The function libcalc_call_me_last() takes no args and returns void.  You
need call libcalc_call_me_last() only once.

## Copyright (C) 1999  David I. Bell and Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.5 $
## @(#) $Id: LIBRARY,v 29.5 2001/06/08 22:57:35 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/RCS/LIBRARY,v $
##
## Under source code control:	1993/07/30 19:44:49
## File existed as early as:	1993
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* new_custom
*************

Guidelines for adding custom functions
--------------------------------------

Step 0: Determine if is should it be done?

    The main focus for calc is to provide a portable platform for
    multi-precision calculations in a C-like environment.  You should
    consider implementing algorithms in the calc language as a first
    choice.  Sometimes an algorithm requires use of special hardware, a
    non-portable OS or pre-compiled C library.	In these cases a custom
    interface may be needed.

    The custom function interface is intended to make is easy for
    programmers to add functionality that would be otherwise
    un-suitable for general distribution.  Functions that are
    non-portable (machine, hardware or OS dependent) or highly
    specialized are possible candidates for custom functions.

    So before you go to step 1, ask yourself:

	+ Can I implement this as a calc resource file or calc shell script?

	    If Yes, write the shell script or resource file and be done with it.
	    If No, continue to the next question ...

	+ Does it require the use of non-portable features,
	  OS specific support or special hardware?

	    If No, write it as a regular builtin function.
	    If Yes, continue to step 1 ...


Step 1: Do some background work

    First ... read this file ALL THE WAY THROUGH before implementing
    anything in Steps 2 and beyond!

    If you are not familiar with calc internals, we recommend that
    you look at some examples of custom functions.  Look at the
    the following source files:

	custom.c
	custom.h
	custom/custom.h
	custom/custtbl.c
	custom/c_*.[ch]
	custom/*.cal
	help/custom		(or run:  calc help custom)

    You would be well advised to look at a more recent calc source
    such as one available in from the calc version archive.
    See the following for more details:

	help/archive		(or run:  calc help archive)


Step 2: Name your custom function

    We suggest that you pick a name that does not conflict with
    one of the builtin names.  It makes it easier to get help
    via the help interface and avoid confusion down the road.

    You should avoid picking a name that matches a file or
    directory name under ${HELPDIR} as well.  Not all help
    files are associated with builtin function names.

    For purposes of this file, we will use the name 'curds'
    as our example custom function name.


Step 3: Document your custom function

    No this step is NOT out of order.  We recommend that you write the
    help file associated with your new custom function EARLY.  By
    experience we have found that the small amount of effort made to
    write "how the custom function will be used" into a help file pays
    off in a big way when it comes to coding.  Often the effort of
    writing a help file will clarify fuzzy aspects of your design.
    Besides, unless you write the help file first, it will likely never
    be written later on.  :-(

    OK ... we will stop preaching now ...

    [[ From now on we will give filenames relative to the custom directory ]]

    Take a look at one of the example custom help files:

	custom/devnull
	custom/argv
	custom/help
	custom/sysinfo

    You can save time by using one of the custom help files
    as a template.  Copy one of these files to your own help file:

	cd custom
	cp sysinfo curds

    and edit it accordingly.


Step 4: Write your test code

    No this step is NOT out of order either.  We recommend that you
    write a simple calc script that will call your custom function and
    check the results.

    This script will be useful while you are debugging your code.  In
    addition, if you wish to submit your code for distribution, this
    test code will be an import part of your submission.  Your test
    code will also service as additional for your custom function.

    Oops ... we said we would stop preaching, sorry about that ...

    You can use one of the following as a template:

	custom/argv.cal
	custom/halflen.cal

    Copy one of these to your own file:

	cd custom
	cp halflen.cal curds.cal

    and exit it accordingly.  In particular you will want to:

	remove our header disclaimer (or put your own on)

	change the name from halflen() to curds()

	change the comment from 'halflen - determine the length ...' to
	'curds - brief description about ...'

	change the print statement near the very bottom from:

		print "halflen(num) defined";

	to:

		print "curds( ... args description here ...) defined";


Step 5: Write your custom function

    By convention, the files we ship that contain custom function
    interface code in filenames of the form:

	c_*.c

    We suggest that you use filenames of the form:

	u_*.c

    to avoid filename conflicts.

    We recommend that you use one of the c_*.c files as a template.
    Copy an appropriate file to your file:

	cd custom
	cp c_argv.c u_curds.c

    Before you edit it, you should note that there are several important
    features of this file.

	a) All of the code in the file is found between #if ... #endif:

		/*
		 * only comments and blank lines at the top
		 */

		#if defined(CUSTOM)

		... all code, #includes, #defines etc.

		#endif /* CUSTOM */

	   This allows this code to 'go away' when the upper Makefile
	   disables the custom code (because ALLOW_CUSTOM no longer
	   has the -DCUSTOM define).

	b) The function type must be:

		/*ARGSUSED*/
		VALUE
		u_curds(char *name, int count, VALUE **vals)

	   The 3 args are passed in by the custom interface
	   and have the following meaning:

		name	The name of the custom function that
			was called.  In particular, this is the first
			string arg that was given to the custom()
			builtin.  This is the equivalent of argv[0] for
			main() in C programming.

			The same code can be used for multiple custom
			functions by processing off of this value.

		count	This is the number of additional args that
			was given to the custom() builtin.  Note
			that count does NOT include the name arg.
			This is similar to argc except that count
			is one less than the main() argc interface.

			For example, a call of:

			    custom("curds", a, b, c)

			would cause count to be passed as 3.

		vals	This is a pointer to an array of VALUEs.
			This is the equivalent of argv+1 for
			main() in C programming.  The difference
			here is that vals[0] refers to the 1st
			parameter AFTER the same.

			For example, a call of:

			    custom("curds", a, b, c)

			would cause vals to point to the following array:

			    vals[0]  points to	a
			    vals[1]  points to	b
			    vals[2]  points to	c

	   NOTE: If you do not use any of the 3 function parameters,
	   then you should declare that function parameter to be UNUSED.
	   For example, if the count and vals parameters were not used
	   in your custom function, then your declaraction should be:

		/*ARGSUSED*/
		VALUE
		u_curds(char *name, int UNUSED count, VALUE UNUSED **vals)

	c) The return value is the function must be a VALUE.

	   The typical way to form a VALUE to return is by declaring
	   the following local variable:

		VALUE result;	/* what we will return */

	d) You will need to include:

		#if defined(CUSTOM)

		/* any #include <foobar.h> here */

		#include "../have_const.h"
		#include "../value.h"
		#include "custom.h"

		#include "../have_unused.h"

	    Typically these will be included just below any system
	    includes and just below the #if defined(CUSTOM) line.

    To better understand the VALUE type, read:

	../value.h

    The VALUE is a union of major value types found inside calc.
    The v_type VALUE element determines which union element is
    being used.	  Assume that we have:

	VALUE *vp;

    Then the value is determined according to v_type:

	vp->v_type	the value is	which is a	type defined in
	----------	------------	----------	---------------
	V_NULL		(none)		n/a		n/a
	V_INT		vp->v_int	long		n/a
	V_NUM		vp->v_num	NUMBER *	../qmath.h
	V_COM		vp->v_com	COMPLEX *	../cmath.h
	V_ADDR		vp->v_addr	VALUE *		../value.h
	V_STR		vp->v_str	char *		n/a
	V_MAT		vp->v_mat	MATRIX *	../value.h
	V_LIST		vp->v_list	LIST *		../value.h
	V_ASSOC		vp->v_assoc	ASSOC *		../value.h
	V_OBJ		vp->v_obj	OBJECT *	../value.h
	V_FILE		vp->v_file	FILEID		../value.h
	V_RAND		vp->v_rand	RAND *		../zrand.h
	V_RANDOM	vp->v_random	RANDOM *	../zrandom.h
	V_CONFIG	vp->v_config	CONFIG *	../config.h
	V_HASH		vp->v_hash	HASH *		../hash.h
	V_BLOCK		vp->v_block	BLOCK *		../block.h

    The V_OCTET is under review and should not be used at this time.

    There are a number of macros that may be used to determine
    information about the numerical values (ZVALUE, NUMBER and COMPLEX).
    you might also want to read the following to understand
    some of the numerical types of ZVALUE, NUMBER and COMPLEX:

	../zmath.h
	../qmath.h
	../cmath.h

    While we cannot go into full detail here are some cookbook
    code for manipulating VALUEs.  For these examples assume
    that we will manipulate the return value:

	VALUE result;	/* what we will return */

    To return NULL:

	result.v_type = V_NULL;
	return result;

    To return a long you need to convert it to a NUMBER:

	long variable;

	result.v_type = V_NUM;
	result.v_num = itoq(variable);		/* see ../qmath.c */
	return result;

    To return a FULL you need to convert it to a NUMBER:

	FULL variable;

	result.v_type = V_NUM;
	result.v_num = utoq(variable);		/* see ../qmath.c */
	return result;

    To convert a ZVALUE to a NUMBER*:

	ZVALUE variable;

	result.v_type = V_NUM;
	result.v_num = qalloc();		/* see ../qmath.c */
	result.v_num->num = variable;
	return result;

    To convert a small NUMBER* into a long:

	NUMBER *num;
	long variable;

	variable = qtoi(num);

    To obtain a ZVALUE from a NUMBER*, extract the numerator:

	NUMBER *num;
	ZVALUE z_variable;

	if (qisint(num)) {
		z_variable = num->num;
	}

    To be sure that the value will fit, use the ZVALUE test macros:

	ZVALUE z_num;
	long variable;
	unsigned long u_variable;
	FULL f_variable;
	short very_tiny_variable;

	if (zgtmaxlong(z_num)) {			/* see ../zmath.h */
		variable = ztolong(z_num);
	}
	if (zgtmaxulong(z_num)) {
		u_variable = ztoulong(z_num);
	}
	if (zgtmaxufull(z_num)) {
		f_variable = ztofull(z_num);
	}
	if (zistiny(z_num)) {
		very_tiny_variable = z1tol(z_num);
	}


Step 6: Register the function in the custom interface table

    To allow the custom() builtin to transfer control to your function,
    you need to add an entry into the CONST struct custom cust table
    found in custom/custtbl.c:

	/*
	 * custom interface table
	 *
	 * The order of the elements in struct custom are:
	 *
	 *	{ "xyz", "brief description of the xyz custom function",
	 *	   minimum_args, maximum_args, c_xyz },
	 *
	 * where:
	 *
	 *	minimum_args	an int >= 0
	 *	maximum_args	an int >= minimum_args and <= MAX_CUSTOM_ARGS
	 *
	 * Use MAX_CUSTOM_ARGS for maximum_args is the maximum number of args
	 * is potentially 'unlimited'.
	 *
	 * If the brief description cannot fit on the same line as the name
	 * without wrapping on a 80 col window, the description is probably
	 * too long and will not look nice in the show custom output.
	 */
	CONST struct custom cust[] = {

	#if defined(CUSTOM)


		/*
		 * add your own custom functions here
		 *
		 * We suggest that you sort the entries below by name
		 * so that show custom will produce a nice sorted list.
		 */

		{ "argv", "information about its args, returns arg count",
		 0, MAX_CUSTOM_ARGS, c_argv },

		{ "devnull", "does nothing",
		 0, MAX_CUSTOM_ARGS, c_devnull },

		{ "help", "help for custom functions",
		 1, 1, c_help },

		{ "sysinfo", "return a calc #define value",
		 0, 1, c_sysinfo },


	#endif /* CUSTOM */

		/*
		 * This must be at the end of this table!!!
		 */
		{NULL, NULL,
		 0, 0, NULL}
	};

    The definition of struct custom may be found in custom.h.

    It is important that your entry be placed inside the:

	#if defined(CUSTOM) ... #endif /* CUSTOM */

    lines so that when the custom interface is disabled by the upper
    level Makefile, one does not have unsatisfied symbols.

    The brief description should be brief so that 'show custom' looks well
    formatted.	If the brief description cannot fit on the same line as
    the name without wrapping on a 80 col window, the description is
    probably too long and will not look nice in the show custom output.

    The minargs places a lower bound on the number of args that
    must be supplied to the interface.	This does NOT count
    the name argument given to custom().  So if minargs is 2:

	custom("curds")		/* call blocked at high level interface */
	custom("curds", a)	/* call blocked at high level interface */
	custom("curds", a, b)	/* call passed down to "curds" interface */

    The maxargs sets a limit on the number of args that may be passed.
    If minargs == maxargs, then the call requires a fixed number of
    argument.  There is a upper limit on the number of args.  If
    one wants an effectively unlimited upper bound, use MAX_CUSTOM_ARGS.

    Note that one must have:

		0 <= minargs <= maxargs <= MAX_CUSTOM_ARGS

    To allow the curds function to take at least 2 args and up
    to 5 args, one would add the following entry to cust[]:

		{ "curds", "brief description about curds interface",
		 2, 5, u_curds },

    It is recommended that the cust[] remain in alphabetical order,
    so one would place it before the "devnull" and after "argv".

    Last, you must forward declare the u_curds near the top of the file:

	#if defined(CUSTOM)


	/*
	 * add your forward custom function declarations here
	 *
	 * Declare custom functions as follows:
	 *
	 *	extern VALUE c_xyz(char*, int, VALUE**);
	 *
	 * We suggest that you sort the entries below by name.
	 */
	extern VALUE c_argv(char*, int, VALUE**);
	extern VALUE c_devnull(char*, int, VALUE**);
	extern VALUE c_help(char*, int, VALUE**);
	extern VALUE c_sysinfo(char*, int, VALUE**);

    For u_curds we would add the line:

	extern VALUE u_curds(char*, int, VALUE**);


Step 7: Add the required information to the custom/Makefile

    The calc test script, curds.cal, should be added to the
    CUSTOM_CALC_FILES Makefile variable found in custom/Makefile:

	CUSTOM_CALC_FILES= argv.cal halflen.cal curds.cal

    The help file, curds, should be added to the CUSTOM_HELP
    Makefile variable:

	CUSTOM_HELP= argv devnull help sysinfo curds

    If you needed to create any .h files to support u_curds.c, these
    files should be added to the CUSTOM_H_SRC Makefile variable:

	CUSTOM_H_SRC= u_curds.h otherfile.h

    Your u_curds.c file MUST be added to the CUSTOM_SRC Makefile variable:

	CUSTOM_SRC= c_argv.c c_devnull.c c_help.c c_sysinfo.c u_curds.c

    and so must the associated .o file:

	CUSTOM_OBJ= c_argv.o c_devnull.o c_help.o c_sysinfo.o u_curds.o


Step 8: Compile and link in your code

    If your calc was not previously setup to compile custom code,
    you should set it up now.  The upper level Makefile (and
    the custom Makefile) should have the following Makefile
    variable defined:

	ALLOW_CUSTOM= -DCUSTOM

    It is recommended that you build your code from the top level
    Makefile.  It saves having to sync the other Makefile values.
    To try and build the new libcustcalc.a that contains u_curds.c:

	(cd ..; make custom/libcustcalc.a)

    Fix any compile and syntax errors as needed.  :-)

    Once libcustcalc.a successfully builds, compile calc:

	cd ..
	make calc

    And check to be sure that the regression test suite still
    works without errors:

	make check


Step 9: Add the Make dependency tools

    You should probably add the dependency lines to the bottom of
    the Makefile.  Given the required include files, you will at least
    have the following entries placed at the bottom of the Makefile:

	u_curds.o: ../alloc.h
	u_curds.o: ../block.h
	u_curds.o: ../byteswap.h
	u_curds.o: ../calcerr.h
	u_curds.o: ../cmath.h
	u_curds.o: ../config.h
	u_curds.o: ../endian_calc.h
	u_curds.o: ../hash.h
	u_curds.o: ../have_const.h
	u_curds.o: ../have_malloc.h
	u_curds.o: ../have_newstr.h
	u_curds.o: ../have_stdlib.h
	u_curds.o: ../have_string.h
	u_curds.o: ../longbits.h
	u_curds.o: ../nametype.h
	u_curds.o: ../qmath.h
	u_curds.o: ../shs.h
	u_curds.o: ../value.h
	u_curds.o: ../zmath.h
	u_curds.o: u_curds.c
	u_curds.o: ../custom.h

    If you have the makedepend tool from the X11 development environment
    (by Todd Brunhoff, Tektronix, Inc. and MIT Project Athena), you can
    use the following to update your dependencies:

	# cd to the top level calc directory if you are not there already

	rm -f Makefile.bak custom/Makefile.bak
	make depend

	diff -c Makefile.bak Makefile			# look at the changes
	diff -c custom/Makefile.bak custom/Makefile	# look at the changes

	rm -f Makefile.bak custom/Makefile.bak		# cleanup

Step 10: Test

    Now that you have built calc with your new custom function, test it:

	./calc -C		# run the new calc with the -C arg

    And then try out our test suite:

	C-style arbitrary precision calculator (version 2.10.3t5.1)
	[Type "exit" to exit, or "help" for help.]

	> read custom/curds.cal
	curds(a, b, [c, d, e]) defined

	> custom("curds", 2, 3, 4)


Step 11: Install

    Once you are satisfied that everything works, install the new code:

	# cd to the top level calc directory if you are not there already

	make install

    Although calc does not run setuid, you may need to be root to install
    the directories into which calc installs may be write protected.


Step 12: Contribute

    Your custom function may be of interest to some people and/or
    serve as an example of what one can do with custom functions.

    Read the file:

	help/contrib		(or run:  calc help contrib)

    and consider submitting your custom function for possible
    inclusion in later versions of calc.

## Copyright (C) 1999-2004  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.4 $
## @(#) $Id: HOW_TO_ADD,v 29.4 2004/07/29 08:38:05 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/custom/RCS/HOW_TO_ADD,v $
##
## Under source code control:	1997/03/10 03:03:21
## File existed as early as:	1997
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* resource
*************

Calc standard resource files
----------------------------

To load a resource file, try:

    read filename

You do not need to add the .cal extension to the filename.  Calc
will search along the $CALCPATH (see ``help environment'').

Normally a resource file will simply define some functions.  By default,
most resource files will print out a short message when they are read.
For example:

    > read lucas
    lucas(h,n) defined
    gen_u0(h,n,v1) defined
    gen_v1(h,n) defined
    ldebug(funct,str) defined

will cause calc to load and execute the 'lucas.cal' resource file.
Executing the resource file will cause several functions to be defined.
Executing the lucas function:

    > lucas(149,60)
	    1
    > lucas(146,61)
	    0

shows that 149*2^60-1 is prime whereas 146*2^61-1 is not.

=-=

Calc resource file files are provided because they serve as examples of
how use the calc language, and/or because the authors thought them to
be useful!

If you write something that you think is useful, please send it to:

    calc-contrib at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

By convention, a resource file only defines and/or initializes functions,
objects and variables.	(The regress.cal and testxxx.cal regression test
suite is an exception.)	 Also by convention, an additional usage message
regarding important object and functions is printed.

If a resource file needs to load another resource file, it should use
the -once version of read:

    /* pull in needed resource files */
    read -once "surd"
    read -once "lucas"

This will cause the needed resource files to be read once.  If these
files have already been read, the read -once will act as a noop.

The "resource_debug" parameter is intended for controlling the possible
display of special information relating to functions, objects, and
other structures created by instructions in calc resource files.
Zero value of config("resource_debug") means that no such information
is displayed.  For other values, the non-zero bits which currently
have meanings are as follows:

    n		Meaning of bit n of config("resource_debug")

    0	When a function is defined, redefined or undefined at
	interactive level, a message saying what has been done
	is displayed.

    1	When a function is defined, redefined or undefined during
	the reading of a file, a message saying what has been done
	is displayed.

    2	Show func will display more information about a functions
	arguments as well as more argument sdummary information.

    3	During execution, allow calc standard resource files
	to output additional debugging information.

The value for config("resource_debug") in both oldstd and newstd is 3,
but if calc is invoked with the -d flag, its initial value is zero.
Thus, if calc is started without the -d flag, until config("resource_debug")
is changed, a message will be output when a function is defined
either interactively or during the reading of a file.

Sometimes the information printed is not enough.  In addition to the
standard information, one might want to print:

	* useful obj definitions
	* functions with optional args
	* functions with optional args where the param() interface is used

For these cases we suggest that you place at the bottom of your code
something that prints extra information if config("resource_debug") has
either of the bottom 2 bits set:

	if (config("resource_debug") & 3) {
		print "obj xyz defined";
		print "funcA([val1 [, val2]]) defined";
		print "funcB(size, mass, ...) defined";
	}

If your the resource file needs to output special debugging informatin,
we recommend that you check for bit 3 of the config("resource_debug")
before printing the debug statement:

	if (config("resource_debug") & 8) {
		print "DEBUG: This a sample debug statement";
	}

=-=

The following is a brief description of some of the calc resource files
that are shipped with calc.  See above for example of how to read in
and execute these files.

beer.cal

    Calc's contribution to the 99 Bottles of Beer web page:

	http://www.ionet.net/~timtroyr/funhouse/beer.html#calc


bernoulli.cal

    B(n)

    Calculate the nth Bernoulli number.

    NOTE: There is now a bernoulli() builtin function.  This file is
    	  left here for backward compatibility and now simply returns
	  the buildin function.


bigprime.cal

    bigprime(a, m, p)

    A prime test, base a, on p*2^x+1 for even x>m.


chi.cal

    Z(x[, eps])
    P(x[, eps])
    chi_prob(chi_sq, v[, eps])

    Computes the Probability, given the Null Hypothesis, that a given
    Chi squared values >= chi_sq with v degrees of freedom.

    The chi_prob() function does not work well with odd degrees of freedom.
    It is reasonable with even degrees of freedom, although one must give
    a sifficently small error term as the degress gets large (>100).

    The Z(x) and P(x) are internal statistical funcions.

    eps is an optional epsilon() like error term.


chrem.cal

    chrem(r1,m1 [,r2,m2, ...])
    chrem(rlist, mlist)

    Chinese remainder theorem/problem solver.


deg.cal

    dms(deg, min, sec)
    dms_add(a, b)
    dms_neg(a)
    dms_sub(a, b)
    dms_mul(a, b)
    dms_print(a)

    Calculate in degrees, minutes, and seconds.


ellip.cal

    efactor(iN, ia, B, force)

    Attempt to factor using the elliptic functions: y^2 = x^3 + a*x + b.


hello.cal

    Calc's contribution to the Hello World! page:

	http://www.latech.edu/~acm/HelloWorld.shtml
	http://www.latech.edu/~acm/helloworld/calc.html


intfile.cal

    file2be(filename)

	Read filename and return an integer that is built from the
	octets in that file in Big Endian order.  The first octets
	of the file become the most significant bits of the integer.

    file2le(filename)

	Read filename and return an integer that is built from the
	octets in that file in Little Endian order.  The first octets
	of the file become the most significant bits of the integer.

    be2file(v, filename)

	Write the absolute value of v into filename in Big Endian order.
	The v argument must be on integer.  The most significant bits
	of the integer become the first octets of the file.

    le2file(v, filename)

	Write the absolute value of v into filename in Little Endian order.
	The v argument must be on integer.  The least significant bits
	of the integer become the last octets of the file.


lucas.cal

    lucas(h, n)

    Perform a primality test of h*2^n-1, with 1<=h<2*n.


lucas_chk.cal

    lucas_chk(high_n)

    Test all primes of the form h*2^n-1, with 1<=h<200 and n <= high_n.
    Requires lucas.cal to be loaded.  The highest useful high_n is 1000.

    Used by regress.cal during the 2100 test set.


lucas_tbl.cal

    Lucasian criteria for primality tables.


mersenne.cal

    mersenne(p)

    Perform a primality test of 2^p-1, for prime p>1.


mfactor.cal

    mfactor(n [, start_k=1 [, rept_loop=10000 [, p_elim=17]]])

    Return the lowest factor of 2^n-1, for n > 0.  Starts looking for factors
    at 2*start_k*n+1.  Skips values that are multiples of primes <= p_elim.
    By default, start_k == 1, rept_loop = 10000 and p_elim = 17.

    The p_elim == 17 overhead takes ~3 minutes on an 200 Mhz r4k CPU and
    requires about ~13 Megs of memory.	The p_elim == 13 overhead
    takes about 3 seconds and requires ~1.5 Megs of memory.

    The value p_elim == 17 is best for long factorizations.  It is the
    fastest even thought the initial startup overhead is larger than
    for p_elim == 13.

mod.cal

    lmod(a)
    mod_print(a)
    mod_one()
    mod_cmp(a, b)
    mod_rel(a, b)
    mod_add(a, b)
    mod_sub(a, b)
    mod_neg(a)
    mod_mul(a, b)
    mod_square(a)
    mod_inc(a)
    mod_dec(a)
    mod_inv(a)
    mod_div(a, b)
    mod_pow(a, b)

    Routines to handle numbers modulo a specified number.


natnumset.cal

    isset(a)
    setbound(n)
    empty()
    full()
    isin(a, b)
    addmember(a, n)
    rmmember(a, n)
    set()
    mkset(s)
    primes(a, b)
    set_max(a)
    set_min(a)
    set_not(a)
    set_cmp(a, b)
    set_rel(a, b)
    set_or(a, b)
    set_and(a, b)
    set_comp(a)
    set_setminus(a, b)
    set_diff(a,b)
    set_content(a)
    set_add(a, b)
    set_sub(a, b)
    set_mul(a, b)
    set_square(a)
    set_pow(a, n)
    set_sum(a)
    set_plus(a)
    interval(a, b)
    isinterval(a)
    set_mod(a, b)
    randset(n, a, b)
    polyvals(L, A)
    polyvals2(L, A, B)
    set_print(a)

    Demonstration of how the string operators and functions may be used
    for defining and working with sets of natural numbers not exceeding a
    user-specified bound.


pell.cal

    pellx(D)
    pell(D)

    Solve Pell's equation; Returns the solution X to: X^2 - D * Y^2 = 1.
    Type the solution to Pell's equation for a particular D.


pi.cal

    qpi(epsilon)
    piforever()

    The qpi() calculate pi within the specified epsilon using the quartic
    convergence iteration.

    The piforever() prints digits of pi, nicely formatted, for as long
    as your free memory space and system up time allows.

    The piforever() function (written by Klaus Alexander Seistrup
    <klaus@seistrup.dk>) was inspired by an algorithm conceived by
    Lambert Meertens.  See also the ABC Programmer's Handbook, by Geurts,
    Meertens & Pemberton, published by Prentice-Hall (UK) Ltd., 1990.

pix.cal

    pi_of_x(x)

    Calculate the number of primes < x using A(n+1)=A(n-1)+A(n-2).  This
    is a SLOW painful method ... the builtin pix(x) is much faster.
    Still, this method is interesting.


pollard.cal

    pfactor(N, N, ai, af)

    Factor using Pollard's p-1 method.


poly.cal

    Calculate with polynomials of one variable.	 There are many functions.
    Read the documentation in the resource file.


prompt.cal

    adder()
    showvalues(str)

    Demonstration of some uses of prompt() and eval().


psqrt.cal

    psqrt(u, p)

    Calculate square roots modulo a prime


qtime.cal

    qtime(utc_hr_offset)

    Print the time as English sentence given the hours offset from UTC.


quat.cal

    quat(a, b, c, d)
    quat_print(a)
    quat_norm(a)
    quat_abs(a, e)
    quat_conj(a)
    quat_add(a, b)
    quat_sub(a, b)
    quat_inc(a)
    quat_dec(a)
    quat_neg(a)
    quat_mul(a, b)
    quat_div(a, b)
    quat_inv(a)
    quat_scale(a, b)
    quat_shift(a, b)

    Calculate using quaternions of the form: a + bi + cj + dk.	In these
    functions, quaternions are manipulated in the form: s + v, where
    s is a scalar and v is a vector of size 3.


randbitrun.cal

    randbitrun([run_cnt])

    Using randbit(1) to generate a sequence of random bits, determine if
    the number and length of identical bits runs match what is expected.
    By default, run_cnt is to test the next 65536 random values.

    This tests the a55 generator.


randmprime.cal

    randmprime(bits, seed [,dbg])

    Find a prime of the form h*2^n-1 >= 2^bits for some given x.  The initial
    search points for 'h' and 'n' are selected by a cryptographic pseudo-random
    number generator.  The optional argument, dbg, if set to 1, 2 or 3
    turn on various debugging print statements.


randombitrun.cal

    randombitrun([run_cnt])

    Using randombit(1) to generate a sequence of random bits, determine if
    the number and length of identical bits runs match what is expected.
    By default, run_cnt is to test the next 65536 random values.

    This tests the Blum-Blum-Shub generator.


randomrun.cal

    randomrun([run_cnt])

    Perform the "G. Run test" (pp. 65-68) as found in Knuth's "Art of
    Computer Programming - 2nd edition", Volume 2, Section 3.3.2 on
    the builtin rand() function.  This function will generate run_cnt
    64 bit values.  By default, run_cnt is to test the next 65536
    random values.

    This tests the Blum-Blum-Shub generator.


randrun.cal

    randrun([run_cnt])

    Perform the "G. Run test" (pp. 65-68) as found in Knuth's "Art of
    Computer Programming - 2nd edition", Volume 2, Section 3.3.2 on
    the builtin rand() function.  This function will generate run_cnt
    64 bit values.  By default, run_cnt is to test the next 65536
    random values.

    This tests the a55 generator.

repeat.cal

    repeat(digit_set, repeat_count)

    Return the value of the digit_set repeated repeat_count times.
    Both digit_set and repeat_count must be integers > 0.

    For example repeat(423,5) returns the value 423423423423423,
    which is the digit_set 423 repeated 5 times.


regress.cal

    Test the correct execution of the calculator by reading this resource file.
    Errors are reported with '****' messages, or worse. :-)


seedrandom.cal

    seedrandom(seed1, seed2, bitsize [,trials])

    Given:
	seed1 - a large random value (at least 10^20 and perhaps < 10^93)
	seed2 - a large random value (at least 10^20 and perhaps < 10^93)
	size - min Blum modulus as a power of 2 (at least 100, perhaps > 1024)
	trials - number of ptest() trials (default 25) (optional arg)

    Returns:
	the previous random state

    Seed the cryptographically strong Blum generator.  This functions allows
    one to use the raw srandom() without the burden of finding appropriate
    Blum primes for the modulus.


solve.cal

    solve(low, high, epsilon)

    Solve the equation f(x) = 0 to within the desired error value for x.
    The function 'f' must be defined outside of this routine, and the low
    and high values are guesses which must produce values with opposite signs.


sumsq.cal

    ss(p)

    Determine the unique two positive integers whose squares sum to the
    specified prime.  This is always possible for all primes of the form
    4N+1, and always impossible for primes of the form 4N-1.


surd.cal

    surd(a, b)
    surd_print(a)
    surd_conj(a)
    surd_norm(a)
    surd_value(a, xepsilon)
    surd_add(a, b)
    surd_sub(a, b)
    surd_inc(a)
    surd_dec(a)
    surd_neg(a)
    surd_mul(a, b)
    surd_square(a)
    surd_scale(a, b)
    surd_shift(a, b)
    surd_div(a, b)
    surd_inv(a)
    surd_sgn(a)
    surd_cmp(a, b)
    surd_rel(a, b)

    Calculate using quadratic surds of the form: a + b * sqrt(D).


test1700.cal

    value

    This resource files is used by regress.cal to test the read and use keywords.


test2600.cal

    global defaultverbose
    global err
    testismult(str, n, verbose)
    testsqrt(str, n, eps, verbose)
    testexp(str, n, eps, verbose)
    testln(str, n, eps, verbose)
    testpower(str, n, b, eps, verbose)
    testgcd(str, n, verbose)
    cpow(x, n, eps)
    cexp(x, eps)
    cln(x, eps)
    mkreal()
    mkcomplex()
    mkbigreal()
    mksmallreal()
    testappr(str, n, verbose)
    checkappr(x, y, z, verbose)
    checkresult(x, y, z, a)
    test2600(verbose, tnum)

    This resource files is used by regress.cal to test some of builtin functions
    in terms of accuracy and roundoff.


test2700.cal

    global defaultverbose
    mknonnegreal()
    mkposreal()
    mkreal_2700()
    mknonzeroreal()
    mkposfrac()
    mkfrac()
    mksquarereal()
    mknonsquarereal()
    mkcomplex_2700()
    testcsqrt(str, n, verbose)
    checksqrt(x, y, z, v)
    checkavrem(A, B, X, eps)
    checkrounding(s, n, t, u, z)
    iscomsq(x)
    test2700(verbose, tnum)

    This resource files is used by regress.cal to test sqrt() for real and
    complex values.


test3100.cal

    obj res
    global md
    res_test(a)
    res_sub(a, b)
    res_mul(a, b)
    res_neg(a)
    res_inv(a)
    res(x)

    This resource file is used by regress.cal to test determinants of a matrix


test3300.cal

    global defaultverbose
    global err
    testi(str, n, N, verbose)
    testr(str, n, N, verbose)
    test3300(verbose, tnum)

    This resource file is used by regress.cal to provide for more determinant
    tests.

test3400.cal

    global defaultverbose
    global err
    test1(str, n, eps, verbose)
    test2(str, n, eps, verbose)
    test3(str, n, eps, verbose)
    test4(str, n, eps, verbose)
    test5(str, n, eps, verbose)
    test6(str, n, eps, verbose)
    test3400(verbose, tnum)

    This resource file is used by regress.cal to test trig functions.
    containing objects.

test3500.cal

    global defaultverbose
    global err
    testfrem(x, y, verbose)
    testgcdrem(x, y, verbose)
    testf(str, n, verbose)
    testg(str, n, verbose)
    testh(str, n, N, verbose)
    test3500(verbose, n, N)

    This resource file is used by regress.cal to test the functions frem,
    fcnt, gcdrem.

test4000.cal

    global defaultverbose
    global err
    global BASEB
    global BASE
    global COUNT
    global SKIP
    global RESIDUE
    global MODULUS
    global K1
    global H1
    global K2
    global H2
    global K3
    global H3
    plen(N) defined
    rlen(N) defined
    clen(N) defined
    ptimes(str, N, n, count, skip, verbose) defined
    ctimes(str, N, n, count, skip, verbose) defined
    crtimes(str, a, b, n, count, skip, verbose) defined
    ntimes(str, N, n, count, skip, residue, mod, verbose) defined
    testnextcand(str, N, n, cnt, skip, res, mod, verbose) defined
    testnext1(x, y, count, skip, residue, modulus) defined
    testprevcand(str, N, n, cnt, skip, res, mod, verbose) defined
    testprev1(x, y, count, skip, residue, modulus) defined
    test4000(verbose, tnum) defined

    This resource file is used by regress.cal to test ptest, nextcand and
    prevcand builtins.

test4100.cal

    global defaultverbose
    global err
    global K1
    global K2
    global BASEB
    global BASE
    rlen_4100(N) defined
    olen(N) defined
    test1(x, y, m, k, z1, z2) defined
    testall(str, n, N, M, verbose) defined
    times(str, N, n, verbose) defined
    powtimes(str, N1, N2, n, verbose) defined
    inittimes(str, N, n, verbose) defined
    test4100(verbose, tnum) defined

    This resource file is used by regress.cal to test REDC operations.

test4600.cal

    stest(str [, verbose]) defined
    ttest([m, [n [,verbose]]]) defined
    sprint(x) defined
    findline(f,s) defined
    findlineold(f,s) defined
    test4600(verbose, tnum) defined

    This resource file is used by regress.cal to test searching in files.

test5100.cal

    global a5100
    global b5100
    test5100(x) defined

    This resource file is used by regress.cal to test the new code generator
    declaration scope and order.

test5200.cal

    global a5200
    static a5200
    f5200(x) defined
    g5200(x) defined
    h5200(x) defined

    This resource file is used by regress.cal to test the fix of a
    global/static bug.

test8400.cal

    test8400() defined

    This resource file is used by regress.cal to check for quit-based
    memory leaks.

test8500.cal

    global err_8500
    global L_8500
    global ver_8500
    global old_seed_8500
    global cfg_8500
    onetest_8500(a,b,rnd) defined
    divmod_8500(N, M1, M2, testnum) defined

    This resource file is used by regress.cal to the // and % operators.

test8600.cal

    global min_8600
    global max_8600
    global hash_8600
    global hmean_8600

    This resource file is used by regress.cal to test a change of
    allowing up to 1024 args to be passed to a builtin function.

unitfrac.cal

    unitfrac(x)

    Represent a fraction as sum of distinct unit fractions.


varargs.cal

    sc(a, b, ...)

    Example program to use 'varargs'.  Program to sum the cubes of all
    the specified numbers.

xx_print.cal

    is_octet(a) defined
    list_print(a) defined
    mat_print (a) defined
    octet_print(a) defined
    blk_print(a) defined
    nblk_print (a) defined
    strchar(a) defined
    file_print(a) defined
    error_print(a) defined

    Demo for the xx_print object routines.

## Copyright (C) 2000  David I. Bell and Landon Curt Noll
##
## Primary author: Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.9 $
## @(#) $Id: README,v 29.9 2003/01/05 08:10:56 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/cal/RCS/README,v $
##
## Under source code control:	1990/02/15 01:50:32
## File existed as early as:	before 1990
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* archive
*************

Where to get the the latest versions of calc

    Landon Noll maintains the official calc home page at:

	    http://www.isthe.com/chongo/tech/comp/calc/

    See:

	    http://www.isthe.com/chongo/tech/comp/calc/calc-download.html

    for information on how to obtain up a recent version of calc.

Landon Curt Noll
http://www.isthe.com/chongo/

chongo <was here> /\../\

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: archive,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/archive,v $
##
## Under source code control:	1996/06/13 02:51:48
## File existed as early as:	1996
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* bugs
*************

If you notice something wrong, strange or broken, try rereading:

   README.FIRST
   HOWTO.INSTALL
   BUGS (this file)

If that does not help, cd to the calc source directory and try:

   make check

Look at the end of the output, it should say something like:

    9998: passed all tests  /\../\
    9999: Ending regression tests

If it does not, then something is really broken!

If you made and modifications to calc beyond the simple Makefile
configuration, try backing them out and see if things get better.

To be sure that your version of calc is up to date, check out:

	http://www.isthe.com/chongo/tech/comp/calc/calc-download.html

The calc web site is located at:

	http://www.isthe.com/chongo/tech/comp/calc/index.html

=-=

If you have tried all of the above and things still are not right,
then it may be time to send in a bug report.  You can send bug
and bug fixes reports to:

    calc-bugs at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe', the web site URL uses 'isthe' ]]

Your subject must contain the words:

       calc bug report

You may have additional words in your subject line.

When you send your report, please include the following information:

    * a description of the problem
    * the version of calc you are using (if you cannot get calc
      to run, then send us the 4 #define lines from version.c)
    * if you modified calc from an official patch, send me the mods you made
    * the type of system you were using
    * the type of compiler you were using
    * any compiler warnings or errors that you saw
    * cd to the calc source directory, and type:

	make debug > debug.out 2>&1		(sh, ksh, bash users)
	make debug >& debug.out			(csh, tcsh users)

      and send the contents of the 'debug.out' file.

Stack traces from core dumps are useful to send as well.

Fell free to use the above address to send in big fixes (in the form
of a context diff patch).

=-=

Known bugs:

    We are sure some more bugs exist.  When you find them, please let
    us know!  See the above for details on how to report and were to
    EMail your bug reports and hopefully patches to fix them.

    * The following command:

	calc 'read ellip; efactor(13*17*19)'

      will generate the following error:

	efactor(iN,ia,B,force) defined
	point_print(p) defined
	point_mul(p1,p2) defined
	point_square(p) defined
	point_pow(p,pow) defined
	A = 1
	2 (1,1)
	"point_square": line 165: Not initializing matrix, object or list
	Error in commands

     This is not an error in the ellip standard calc resource files.
     It is a bug inside calc.  Versions going back as far as version
     2.11.4t2 in the year 2000 (and perhaps even further) alll have
     this bug.

     Anyone want to track down and fix this bug?

=-=

mis-features in calc:

    Some problems are not bugs but rarther mis-features / things that could
    work better.  The following is a list of mis-features that should be
    addressed and improved someday.

    * The chi.cal resource file does not work well with odd degrees
      of freedom.  Can someone improve this algorithm?

    * The intfile.cal resource file reads and writes big or little Endian
      integers to/from files the hard way.  It does NOT use blkcpy.  The
      following code:

	i = (ord("\n") << 16) | (ord("i") << 8) | ord("H")
	b = blk()
	copy(i, b)
	fd = fopen("file", "w")
	copy(b, fd);
	fclose(fd)

      will write an extra NUL octet to the file.  Where as:

	read intfile
	i = (ord("\n") << 16) | (ord("i") << 8) | ord("H")
	be2file(i, "file2")

      will not.

=-=

Problems with old systems that have known work-a-rounds:

    * The gcc as shipped with Redhat 7 perhaps other Linux distributions
      has a bug causes calc to dump core on startup when calc is:

	  compiled optimized (-O, -O1, -O2 or -O3)

	  	AND

      	  compiled with debugging (-g or -g3)

	  	AND

	  when calc is compiled with readline (see USE_READLINE,
	  READLINE_LIB and READLINE_INCLUDE in the Makefile)

      This is known as the Redhat 7 readlne problem.

      On Redhat, the gcc -v which has this problem is:

	gcc version 2.96 20000731 (Red Hat Linux 7.1 2.96-85)

      there may be other gcc versions that also suffer this fate.

      The readlines associated with problem are:

	readline-4.1-5
	readline2.2.1-2.2.1-2
	readline-devel-4.1-5

      One work-a-round is to compile calc WITHOUT readline.  In the
      Makefile be sure that:

	USE_READLINE=
	READLINE_LIB=
	READLINE_INCLUDE=

      i.e., these Makefile vars are empty.

      If you must use readline, then an alternate work-a-round is to
      change the DEBUG Makefile variable to either:

	compile for speed:  -O3		(or -O2 if you do not have -O3)
	compile to debug:   -g3		(or -g if you do not have -g3)

      but not both.

      See RH bug #57889 for details:

	http://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=57889

    * There is a bug in gcc-2.95 that causes calc, when compiled with -O2,
      to fail the regression test.  The work-a-round is to compile with -O
      or to use gcc-2.96 or later.

      This bug has been observed on the Sparc and the PowerPC machine.

      On the PowerPC with gcc-2.95 when compiled with -O2, the following
      patch seems to help:

*** zfunc.c.orig        Fri Feb 23 18:18:39 2001
--- zfunc.c     Fri Feb 23 18:39:33 2001
***************
*** 1481,1487 ****
  {
        HALF *a, *A, *b, *a0, u;
        int i, j, j1, j2, k, k1, m, m0, m1, n, n0, o;
!       FULL d, e, f, g, h, s, t, x, topbit;
        int remsign;
        BOOL up, onebit;
        ZVALUE sqrt;
--- 1481,1488 ----
  {
        HALF *a, *A, *b, *a0, u;
        int i, j, j1, j2, k, k1, m, m0, m1, n, n0, o;
!       volatile FULL d;
!       FULL e, f, g, h, s, t, x, topbit;
        int remsign;
        BOOL up, onebit;
        ZVALUE sqrt;
*** zmath.c	2000/06/07 14:02:13	29.2
--- zmath.c	2001/03/13 19:47:03
***************
*** 1608,1614 ****
  void
  zbitvalue(long n, ZVALUE *res)
  {
! 	ZVALUE z;

  	if (n < 0) n = 0;
  	z.sign = 0;
--- 1608,1614 ----
  void
  zbitvalue(long n, ZVALUE *res)
  {
! 	volatile ZVALUE z;

  	if (n < 0) n = 0;
  	z.sign = 0;

    * Solaris cc somtimes barfs while compiling zrand.c.  In particular, calc
      barfs on on the SVAL macro.  The work-a-round is to use the Solaric cc
      Makefile set sets -DFORCE_STDC.  I.e,:

	    CCWARN=
	    CCOPT= ${DEBUG} ${NO_SHARED}
	    CCMISC= -DFORCE_STDC
	    #
	    CFLAGS= ${CCWARN} ${CCOPT} ${CCMISC}
	    ICFLAGS= ${CCWARN} ${CCMISC}
	    #
	    LCFLAGS=
	    LDFLAGS= ${NO_SHARED} ${LD_NO_SHARED}
	    ILDFLAGS=
	    #
	    LCC= cc
	    CC= ${PURIFY} ${LCC}

    * There is a bug in some versions of the Dec/Compaq cc for the Alpha
      where the following:

	    #include <stdio.h>
	    #define SVAL(a,b) (unsigned long)(0x ## a ## b ## ULL)
	    main(){SVAL(b8a8aeb0,8168eadc);}

      fails because it puts a space inside the concatenated hex.  Calc
      has code that is affected by this bug.  This bug has been reported
      to Compaq and may be fixed in the future.	 A work-a-round is to
      compile with cc -std0 or to use a later version of their compiler.

    * On a Digital UNIX V4.0F (Rev. 1229) on a 500 Mhz 21264, make check
      dies a horrible death starting in test 600 and 622 gives 100s of
      messages for calc version 2.11.0t9.4 using the Dec's cc with -O2:

	600: Beginning test_bignums
	601: muldivcheck 1
	**** abc != acb: 602: muldivcheck 2
	**** acb != bac: 602: muldivcheck 2
	...
	**** t4 != a4: 622: algcheck 1
	**** t5 != a5: 622: algcheck 1
	**** t6 != a6: 622: algcheck 1
	**** t4 != a4: 622: algcheck 1
	...

	it finally hangs at test 2000.

      The work-a-round is to compile calc without the optimizer.  If this
      happens to you, try compiling without -O and without -O2.	 I.e., in
      the Makefile, set:

	DEBUG= -g

    * There are problems compiling calc on the sparcv9 under 64 bit
      Solaris.	On that platform, gcc-2.96 is able to compile calc, but
      calc dumps core very early on in startup.	 It is said that sparcv9
      support in gcc-2.96 is very unofficial and thus there is no
      work-a-round for gcc-2-96.

      There is a work-a-round for this architecture us one is using the
      Solaris CC on the sparcv9.  It has been reported that setting the
      following Makefile variables will produce a working version of
      calc on the sparcv9 under 64 bit Solaris:

	    LCC="cc -xarch=v9"
	    CCWARN="-DFORCE_STDC -w"
	    DEBUG="-fast -xarch=v9"

    * Under BSDI v4, the warnings of the form:

	/usr/include/ctype.h:147: warning: `__runetype' defined but not used
	/usr/include/ctype.h:161: warning: `__isctype' defined but not used
	/usr/include/ctype.h:170: warning: `toupper' defined but not used
	/usr/include/ctype.h:177: warning: `tolower' defined but not used

      are seen.	 These warnings are the result of mis-features in BSDI
      include files.  They do not have an impact on the operation
      or performance.  The work-a-round is to ignore these warnings
      under BSDI.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.21 $
## @(#) $Id: BUGS,v 29.21 2004/10/23 01:13:51 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/RCS/BUGS,v $
##
## Under source code control:	1994/03/18 14:06:13
## File existed as early as:	1994
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* changes
*************

The following are the changes from calc version 2.11.10.1 to date:

    Fixed a bug reported by the sourceforge user: cedars where:

    	ln(exp(6)) == 3		/* WRONG!!! */

    incorrectly returned 1.  This bug was fixed by Ernest Bowen
    <ernie at turing dot une dot edu dot au>.  The regression test
    was expanded to cover this issue.

    Added minor improvements to hash regression testing of pi().

    Fixed "help script" and the calc man page regarding the requirement
    of -f to be the last -flag in shell script mode.  Further clarified
    the meaning and placement of the -f flag.

    Moved issues with chi.cal intfile.cal into a "mis-features" section
    of the BUGS file.  See "help bugs" or the BUGS source file for details.

    Added the bug about:

	calc 'read ellip; efactor(13*17*19)'

    to the BUGS file.  See "help bugs" or the BUGS source file for details.
    Anyone want to track down and fix this bug?


The following are the changes from calc version 2.11.10 to 2.11.10:

    The cygwin config value is correctly tested while doing comparisons
    between config states.

    Added config("compile_custom") to determine if calc was compiled
    with -DCUSTOM.  By default, the Makefile uses ALLOW_CUSTOM= -DCUSTOM
    so by default, config("compile_custom") is TRUE.  If, however,
    calc is compiled without -DCUSTOM, then config("compile_custom")
    will be FALSE.  NOTE: The config("compile_custom") value is only
    affected by compile flags.  The calc -D runtime command line option
    does not change the config("compile_custom") value.  This is a
    read-only configuration value.

    Added config("allow_custom") to determine if the use of custom
    functions are allowed.  To allow the use of custom functions, calc
    must be compiled with -DCUSTOM (which it is by default) AND calc run
    be run with the -D runtime command line option (which it is not by
    default).  If config("allow_custom") is TRUE, then custom functions
    are allowed.  If config("allow_custom") is FALSE, then custom
    functions are not allowed.  This is a read-only configuration value.

    Correctly hash config state for windows and cygwin values.  The value
    of config("compile_custom") and config("allow_custom") also affect
    the hash of the config state.

    Fixed the custom/argv.cal test code to avoid use of a reserved
    builtin function name.

    Fixed custom/*.cal scripts to conform better with the cal/*.cal
    resource files.

    Removed the Makefile variables ${LONGLONG_BITS}, ${HAVE_LONGLONG},
    and ${L64_FORMAT}.  Removed longlong.c and longlong.h.  The use
    of HAVE_LONGLONG=0 was problematic.  The lack of complaints about
    the HAVE_LONGLONG=0 shows that the 'long long' type is wide spread
    enough warrent not trying to support compilers without 'long long'.

    Removed the SVAL and SHVAL macros from zrand.c, zrand.h, and zmath.h
    as they were causing too many broken C pre-processors and C checkers
    to become confused.

    Added a 'make splint' rule to use the splint statically checking
    tool on the calc source.

    Removed support of the BSDI platform.  The BSDI platform is no longer
    directly supported and we lost our last BSDI machine on which we
    could test calc.  Best wishes to the former BSDI folk and thanks
    for breaking important ground in the Open Source Movement!

    Fixed several typos found in the documentation and buildin
    function output by C Smith <smichr at hotmail dot com>.

    Fixed -d so that:

    	calc -d 2/3

    will print 0.66666666666666666667 without the leading tilde as
    advertised in the man page.

    Added a missing help file for the display builtin function as
    requested by Igor Furlan <primorec at sbcglobal dot net>.

    Changed the "help environment" file to reflect modern default
    values of CALCPATH and CALCRC.

    Added missing variables for printing by the "make env" rule.

    Added EXT Makefile variable so that Cygwin can install calc as
    calc.exe.  By default, EXT is empty so that calc is calc on most
    modern operating systems.  Thanks goes to Ullal Devappa Kini <wmbfqj
    at vsnl dot net> for helping identify this problem and testing our fix.

    Added custom function:

    	custom("pmodm127", q)

    to compute 2^(2^127-1) mod q.  While currently slower than just
    doing pmod(2,2^127-1,q), it is added to give an example of a
    more complex custom function.  Call calc with the -C flag to
    use custom functions.

    Made slight changes to the custom/HOW_TO_ADD documentation.

    Fixed some \ formatting man page problems as reported by Keh-Cheng
    Chu <kehcheng at quake dot Stanford dot edu>.

    Fixed some comparison between signed and unsigned in md5.c
    that was reported for the PowerMac G5 2GHz MacOS 10.3 by
    Guillaume VERGNAUD <vergnaud at via dot ecp dot fr>.


The following are the changes from calc version 2.11.9 to 2.11.9.3:

    Fixed calc man page examples to move -f to the end of the line.
    Thanks goes to Michael Somos <somos at grail dot cba dot csuohio
    dot edu> for pointing this out.

    Linux and gcc now compiled with -Wall -W -Wno-comment.

    Fixed a post increment that was reported by R. Trinler <trinler at
    web dot de> and fixed by Ernest Bowen <ernie at turing dot une dot
    edu dot au>.

    Fixed pi.cal to not depend on the buggy pre-2.11.9 post increment
    behavior.

    Added config("cygwin") to determine if calc was compiled under Cygwin.
    The config("cygwin") is a read-only configuration value that is 1
    when calc was compiled under Cygwin and 0 otherwise.  Regression
    tests 949 and 950 are skipped when config("cygwin") is true.

    The Makefile variable HAVE_NO_IMPLICIT is empty by default so that
    the Makefile will test if the compiler has a -Wno-implicit flag.

    Added HAVE_UNUSED Makefile variable.  If HAVE_UNUSED is empty,
    then the Makefile will run the have_unused program to determine
    if the unused attribute is supported.  If HAVE_UNUSED is set to
    -DHAVE_NO_UNUSED, then the unused attribute will not be used.

    The Makefile builds have_unused.h which defines, if the unused
    attribute is supported:

	#define HAVE_UNUSED /* yes */
	#define UNUSED __attribute__((unused)) /* yes */

    or defines, if the unused is not supported (or if the Makefile
    variable is HAVE_UNUSED= -DHAVE_NO_UNUSED):

	#undef HAVE_UNUSED /* no */
	#define UNUSED /* no */

    Fixed numerous warnings about comparison between signed and unsigned
    value warnings and unused parameter warnings in version.c, zrand.c,
    string.c, shs1.c, shs.c, qtrans.c, qmath.c, qfunc.c, md5.c, matfunc.c,
    hist.c, file.c, const.c, blkcpy.c, seed.c, opcodes.c, func.c, qio.c,
    zrandom.c, custom/c_argv.c, custom/c_devnull.c, custom/c_help.c,
    custom/c_sysinfo.c, addop.c and calc.c.

    Fixed some typos in this file.

    By default, compile with -O3 -g3.  The Makefile comments on how some
    distributions might need to use -O2 -g or -O -g.


The following are the changes from calc version 2.11.8.0 to 2.11.8.1:

    Updated HOWTO.INSTALL to reflect the new RPM files.

    Clarify that the internal hash as well as the hash builtin
    function used by calc, while based on the Fowler/Noll/Vo
    hash is NOT an FNV hash.

    Made slight performance improvements to calc by an optimization of how
    calc's internal hash is computed.  The "make chk" regression test
    runs about 1.5% faster (when compiled with -O3 on an AMD Athlon)
    NO_HASH_CPU_OPTIMIZATION is not defined.  Calc's internal hash values
    have not changed.  By default, NO_HASH_CPU_OPTIMIZATION is NOT defined
    and the slightly faster expression is used.

    A slight modification of what was known as the "calc new standard"
    configuration (calc -n or config("all", "newstd")) is now the default
    calc configuration.  The flag:

    	calc -O

    was added to get the old classic calc configuration.  The flag command
    line flag, -n, now does nothing.  Use of -n is deprecated and may go
    away / be used for something else in the future.

    The following table gives the summary of these changes:

	     pre v2.11.8		     v2.11.8
	     default         pre v2.11.8     -O & oldstd      v2.11.8
	     and oldstd	     -n & newstd     classic cfg      default
	     --------------------------------------------------------
    epsilon	1e-20		1e-10		1e-20		1e-20
    quo	    	2		2		2		2
    outround	2		24		2		24
    leadzero	0		1		0		1
    fullzero	0		1		0		0
    prompt	>		;		>		;
    more	>>		;;		>>		;;

    With the exception of epsilon being 1e-20, and fullzero being unset,
    the new default calc config is like it was (pre-2.11.8) with calc -n /
    config("all", "newstd").

    The new default config is the old classic config with outround being
    24, leadzero being set, and the prompts being ;'s.

    Fixed a bug in the evaluation of tanh(1e-23) with an epsilon(1e-100).
    Thanks goes to Dmitry G. Baksheyev <bd at nbsp dot nsk dot su>
    for reporting the problem, and thanks goes to Ernest Bowen
    <ernie at turing dot une dot edu dot au> for the fix.


The following are the changes from calc version 2.11.7.0 to 2.11.7.1:

    Added support to build calc RPMs thanks to Petteri Kettunen
    <petterik at users dot sourceforge dot net>.

    Added rpm rule to Makefile to build rpm set.  The rpm rule
    uses the rpm.mk Makefile and the calc.spec.in spec template.

    The default Makefile is now the Makefile used during rpm
    creation.  This Makefile assumes that system has readline,
    ncurses (-lreadline -lhistory -lncurses), and less.
    It compiled with a high gcc optimization level (-O3 -g3).
    The Makefile used during rpm creation is the Makefile
    that appears in the calc-src rpm as well.

    The Makefile shipped with the old style gziped tarball
    is still the same generic Makefile.

    The Makefile now uses ${MKDIR} ${MKDIR_ARG} when creating
    directories during installation.  By default, it does
    a mkdir -p when forming directories.

    Fixed attributes on include and lib calc-devel files.

    Adjusted the interaction between rpm.mk, and the calc.spec.in.
    Release number now comes from calc.spec.in only.

    Renamed calc and calc-devel RPMs to use .i686 instead of .i386.


The following are the changes from calc version 2.11.6.3 to date:

    Fixed a bug in deg.cal where fixdms() was being called with
    the wrong type of argument.

    Changed the value of digits(1) and digits(0) to be 1.  Now digits()
    returns number of digits in the standard base-b representation
    when x is truncated to an integer and the sign is ignored.
    To be more precise: when abs(int(x)) > 0, this function returns
    the value 1 + ilog(x, b).  When abs(int(x)) == 0, then this
    function returns the value 1.

    As the result of the above digits() change, the repeat.cal
    resource file script was modified to remove the special
    case for repeating a value of 1.  Also the regress tests
    #715, #977 and #978 were changed.

    Made a minor improvement to the "help places" documentation.

    Fixed dms_neg(a) in deg.cal thanks to a bug report by kaa
    <kaa76 at pochtamt dot ru>.


The following are the changes from calc version 2.11.6.0 to 2.11.6.2:

    Clarified remark in lucas.cal about use of n mod 2^n == 0.

    Fixed help typos reported by Marc Mezzarobba <mm at mm dot ovh dot org>.

    Forced system("") to return 0 under windoz.

    The direct.h include file is not used when compiling under Cygwin.

    Fixed bug where random(10,11) caused calc to dump core when issued
    the 2nd time.

    Moved the setting of the Makefile variable ${CALC_INCDIR} to
    the section where things like ${BINDIR} and ${LIBDIR} are set.
    Idea from Clifford Kite <kite_public1 at ev1 dot net>.

    The Makefile is shipped mode 0644 since a number of folks
    edit it (to build and check calc) as a non-root user and later
    on su to root to install.  Idea from Clifford Kite <kite_public1
    at ev1 dot net>.

    Added base2() builtin function to calc.  Normally calc prints
    values according to base().  Frequently some users want to see
    a value in two bases.  Flipping back and forth between to bases
    is a bit of a pain.  With base2(), calc will output a value twice:

	; 234567
		234567
	; base2(16),
	; 234567
		234567 /* 0x39447 */
	; 131072
		131072 /* 0x20000 */
	; base2(0),
	; 131072
        131072

    By default, base2() is disabled.  Calling base2(0) will also turn
    off the double base mode.  Thanks goes to Erik Anggard
    <erik dot anggard at packetfront dot com> for his idea and
    his initial patch.

    Added repeat.cal as a calc resource file script:

	repeat(digit_set, repeat_count)

	Return the value of the digit_set repeated repeat_count times.
	Both digit_set and repeat_count must be integers > 0.

	For example repeat(423,5) returns the value 423423423423423,
	which is the digit_set 423 repeated 5 times.

    Makefile no longer makes a direct reference to Red Hat 6.0.

    Added missing math_setmode2() prototype to zmath.h.

    Fixed some implicit declarations of functions by either making
    them explicit or by including the proper system .h files.

    Makefile no longer uses -Wno-implicit flag, by default, for
    gcc based compiles on calc source.  Makefile now attempts to
    compile no_implicit.c with an explicit -Wno-implicit arg in an
    effort to determine of -Wno-implicit is a valid compiler flag.
    If no_implicit.c is compiled with -Wno-implicit, then
    the file no_implicit.arg is created with the contents
    of the -Wno-implicit flag.  Otherwise no_implicit.arg
    is created as an empty file.

    Added the Makefile variable ${HAVE_NO_IMPLICIT}, which if
    not set to YES will prevent no_implicit.c from being
    compiled and prevent the -Wno-implicit flag from being used.
    If ${HAVE_NO_IMPLICIT} is not YES, then an empty no_implicit.arg
    file is created and no_implicit.c is not compiled.

    The seed.c file, because the pseudo_seed() function contains
    calls to a number of various system functions, attempts to
    compile with the -Wno-implicit flag (if allowed by the
    formation of the no_implicit.arg file).

    Misc make depend fixes and cleanup.

    Fixed formation of the custom/.all file.

    Fixed repeat(1, repeat_count) bug.


The following are the changes from calc version 2.11.5.5 to 2.11.5.9:

    Now using version numbers of one of these forms:

    	x.y.z.w
    	x.y.z
    	x.y

    Changed the READLINE_LIB Makefile variable to not link with -lreadline
    by default.  If you do have readline, we recommend that you use it.
    If you can install the GNU readline:

	http://freshmeat.net/projects/gnureadline/
    	http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html

    we recommend it.  But if not, you should set the USE_READLINE,
    READLINE_LIB, and READLINE_INCLUDE Makefile variables to empty.
    NOTE: See the BUGS file for a Linux issue when compiling calc
    with -O (or -O2 or -O3) AND with -g (or -g3) AND with readline.

    Removed an obsolete reference to TOPDIR.  This was fixed thanks to
    a bug report by Clifford Kite <kite_public1 at ev1 dot net>.
    Fixed other inconsistencies related to things like BINDIR.

    Fixed calc man page so that is refers to -f instead of the old -S flag.
    Fixed thanks to Clifford Kite <kite_public1 at ev1 dot net> for
    point this out.

    All for loops end with /dev/null to avoid any problems related
    to systems that cannot grok empty for loops.

    Changed the libcalc functions creal and cimag to c_real and c_imag
    to about conflicts with new libc such as those used by gcc v3.
    Thanks Eli Zaretskii <eliz at is dot elta dot co dot il> and
    Martin Buck <m at rtin-buck dot de> for alerting us to this conflict.

    The Makefile no longer hard code's /usr/include.  Instead it uses
    the ${INCDIR} Makefile variable.  Thanks goes to Eli Zaretskii
    <eliz at is dot elta dot co dot il> for pointing out this inconsistency.

    Added mods to support compilation under DJGPP.  DJGPP runs on 386
    and newer PCs running DOS or dos-compatible operating systems.
    See http://www.delorie.com/djgpp/.  Thanks goes to Eli Zaretskii
    <eliz at is dot elta dot co dot il> for sending in these mods.

    Updated README.WINDOWS to include information on building with DJGPP.

    The pld folks are building RPMs based on our calc distributions.
    See:  ftp://ftp.pld.org.pl/dists/ra/PLD/i686/PLD/RPMS or
    http://ftp.pld.org.pl/dists/ra/PLD/i686/PLD/RPMS more information.
    We appreciate their work in this regard.  In the next release, we
    plan to also build and release our own RPMs based on their efforts.

    Changed the Makefile variable CUSTOMLIBDIR to CUSTOMCALDIR.
    Changed the Makefile variable CSHAREDIR to CALC_SHAREDIR.
    Changed the Makefile variable INCDIRCALC to CALC_INCDIR.
    Removed the Makefile variable SHAREDIR.

    Updated the HOWTO.INSTALL and README.WINDOWS files.

    Fixed definition of MAXUFULL.  Thanks to a bus report from
    Jill Poland <jpoland at cadence dot com>.

The following are the changes from calc version 2.11.5t4.1 to 2.11.5t4.4:

    Updated dependency rules in Makefiles.

    NOTE: -DSRC, as used in 2.11.5t4.1 was renamed -DCALC_SRC
    in a later version.

    Calc include files use #include "foo.h" to include other calc
    header files if -DCALC_SRC.  Otherwise they use <calc/foo.h>.
    The -DCALC_SRC symbol is defined by default in calc's Makefile
    and so it uses the header files from within the calc src tree.
    If an external non-calc program includes an installed calc
    header file (from under /usr/include), and it does NOT define
    CALC_SRC, then it will obtain the calc header files from the
    correct system location (such as /usr/include/calc/foo.h).

    Added calc builtin function: version() which returns the calc
    version string.

    Added subject requirements for the calc-tester-request and
    calc-bugs-mail EMail aliases.  See:

    	http://www.isthe.com/chongo/tech/comp/calc/email.html

    for details.

    Corrected a bug that incorrectly set the default calc path
    back in version 2.11.5t4.  The default CALCPATH is now:

	.:./cal:~/.cal:/usr/share/calc:/usr/share/calc/custom

    and the default CALCRC is now:

	/usr/share/calc/startup:~/.calcrc:./.calcinit

    This fixes the missing bindings error and it places the calc
    resource files into the default path.

    If you are using the GNU readline then the Makefile recommends that
    you link with the ncurses library.

    Applied Makefile, cscript/Makefile and custom/Makefile patches to
    fix install mode problems, to deal with sorting and dates in I18n
    environments (such as Japanese), to fix some problems with calc.spec
    and to fix the cscript #! header lines.  Thanks goes to KAWAMURA Masao
    (kawamura at mlb.co.jp) for the bug report and patch!

    Fixed headers on fproduct.calc powerterm.calc 4dsphere.calc so
    that they are correcly changed on installation.

    Added ${GREP} Makefile variable.

    The top level Makefile now sets LANG=C and passes it down to
    lower level Makefiles.

    Updated URLs in cal/lucas.cal comments.

    Now shipping calc.spec, inst_files, spec-template and Makefile.linux
    with the standard calc source distribution.  Note that the standard
    Makefile has not changed.  The Makefile.linux only in minor ways
    needed to build calc rpms.

    Added $T Makefile variable.  $T is the top level directory under
    which calc will be installed.  The calc install is performed under $T,
    the calc build is performed under /.  The purpose for $T is to allow
    someone to install calc somewhere other than into the system area.
    For example when forming the calc rpm, the Makefile is called with
    T=$RPM_BUILD_ROOT.  If $T is empty, calc is installed under /.

    Removed all echo_XXX rules except for echo_inst_files from lower
    level makefile.  The calc.spec will use a make install rule
    with T=$RPM_BUILD_ROOT.

    Updated LIBRARY file with instructions related to -DCALC_SRC,
    the new default include file location and -lcustcalc.


The following are the changes from calc version 2.11.5t3 to 2.11.5t4:

    The Makefile will now send both stdout and stderr to /dev/null
    when compiling hsrc intermediates.

    The config("verbose_quit") value was restored to a default
    value of FALSE.

    Added the cscript:

	powerterm [base_limit] value

    to write the value as the sum (or difference) of powers <= base_limit
    where base_limit by default is 10000.

    Applied a bug fix by Dr.D.J.Picton <dave at aps5.ph.bham.ac.uk>
    to have help with no args print the default help file.

    Renamed lavarand to LavaRnd.

    Added rules to build a calc rpm.

    All installed files are first formed as foo.new, and then moved
    into place as foo via a atomic rename.

    During installation, only files that are different are installed.
    If the built file and the installed file are the same, no
    installation is performed.

    Calc has new default installation locations:

    Makefile var   old location			      new location
    ------------   ------------			      ------------
    TOPDIR	   /usr/local/lib		        <<no longer used>>
    BINDIR	   /usr/local/bin		      /usr/bin
    SHAREDIR	      <<not set>>		      /usr/share
    INCDIR	   /usr/local/include		      /usr/include
    LIBDIR	   /usr/local/lib/calc		      /usr/lib
    CSHAREDIR	      <<not set>>		      /usr/share/calc
    HELPDIR	   /usr/local/lib/calc/help           /usr/share/calc/help
    INCDIRCALC	   /usr/local/include/calc	      /usr/include/calc
    CUSTOMLIBDIR   /usr/local/lib/calc/custom	      /usr/share/calc/custom
    CUSTOMHELPDIR  /usr/local/lib/calc/help/custhelp  /usr/share/calc/custhelp
    CUSTOMINCDIR     <<not set>>		      /usr/include/calc/custom
    SCRIPTDIR	   /usr/local/bin/cscript	      /usr/bin/cscript
    MANDIR	     <<not set>>		      /usr/share/man/man1
    CATDIR	     <<not set>>		        <<not set>>

    The Makefile variable ${TOPDIR} is no longer used.  In some places
    it has been replaced by a new Makefile variable ${SHAREDIR}.  Some
    of the old TOPDIR functionality has been replaced by ${CSHAREDIR}.

    The install rules no longer remove old obsolete files.  We assume
    that these old files have long since vanished!  :-)

    Reduced the amount of output when doing a make all where nothing
    needs to be made.

    Reduced the amount of output when doing a make install where nothing
    needs to be installed.

    If you install using the new default locations, you can remove
    old calc files installed in the old default location by doing:

	make olduninstall


The following are the changes from calc version 2.11.5t2 to 2.11.5t2.1:

    Fixed a bug, reported by Ernest Bowen <ernie at turing dot
    une dot edu dot au> that caused command lines to be echoed in
    interactive mode.  Fixed a bug that sometimes left the terminal
    in a non-echoing state when calc exited.

    Renamed error codes E_FGETWORD1 and E_FGETWORD2 symbols to
    E_FGETFIELD1 and E_FGETFIELD2.

    Made a minor format change to the top of the calc man page.

    The findid() function in file.c 2nd argument changed.  The argument
    is now mostly a writable flag.  This function now finds the file
    I/O structure for the specified file id, and verifies that
    it is opened in the required manner (0 for reading or 1 for writing).
    If the 2nd argument is -1, then no open checks are made at all and
    NULL is then returned if the id represents a closed file.

    The calc builtin function, fopen(), now allows one to specify
    opening files in binary modes.  On POSIX / Linux / Un*x-like systems,
    text file is the same as a binary file and so 'b' to an fopen has
    no effect and is ignored.  However on systems such as MS Windoz
    the 'b' / binary mode has meaning.  See 'help fopen' for details.

    On systems (such as MS Windoz), calc will produce a different error
    message when it attempts to open /dev/tty.  This will condition
    will occur in things like calc scripts when they switch from ``batch
    processing'' commands from and want to start interactive mode.

    Regression tests fopen in binary mode in a few places where a
    difference between text and binary string lengths matter.
    The intfile calc resource file also uses binary mode.

    Changed the rand() builtin and its related functions srand() and
    randbit() to use the Subtractive 100 generator instead of the
    additive 55 generator.  This generator as improved random properties.
    As a result, of this change, the values produced by rand(),
    rand() and randbit() are now different.

    Updated regression tests for new rand() and randbit() output.

    Applied a bug fix from Ernest Bowen <ernie at turing dot une dot
    edu dot au> dealing with one-line "static" declaration like:

    	static a = 1, b;

    Added regression test 8310 to test for the static bug fix.


The following are the changes from calc version 2.11.5t0 to 2.11.5t1.1:

    Fixed a compile problem with Linux 2.4 / Debian.  Thanks goes
    to Martin Buck <m at rtin-buck dot de> for help with this issue.

    Fixed a bug in how L64_FORMAT (it determined if "%ld" or "%lld"
    is appropriate for printing of 64 bit long longs) was determined.
    Thanks goes to Martin Buck <m at rtin-buck dot de> for reporting
    this bug and testing the fix.

    An effort was made to make calc easier to build under Windoz
    using the Cygwin project (http://sources.redhat.com/cygwin/).
    Thanks to the work of Thomas Jones-Low (tjoneslo at softstart
    dot com), a number of #if defined(_WIN32)'s have been added
    to calc source.  These changes should not effect Windoz
    free system such as GNU/Linux, Solaris, POSIX-like, etc ...

    Added windll.h to deal with Windoz related DLL issues.
    Using the convention of 'extern DLL' instead of 'DLL extern'
    to deal with symbols that export to or import from a DLL.

    Added HAVE_MALLOC_H, HAVE_STDLIB_H, HAVE_STRING_H, HAVE_TIMES_H,
    HAVE_SYS_TIMES_H, HAVE_TIME_H, HAVE_SYS_TIME_H, HAVE_UNISTD_H
    and HAVE_URANDOM to the Makefile.  If these symbols are empty,
    then the Makefile looks for the appropriate system include file.
    If they are YES, then the Makefile will assume they exist.
    If they are NO, then the Makefile will assume they do not exist.

    Changed HAVE_URANDOM to match the empty, YES, NO values.
    If HAVE_URANDOM is empty, then the Makefile will look for /dev/urandom.
    If HAVE_URANDOM is YES, then the Makefile will assume /dev/urandom exists.
    If HAVE_URANDOM is NO, then the Makefile will assume /dev/urandom does
    not exist.

    If TERMCONTROL is -DUSE_WIN32, then the Windoz terminal control
    (no TERMIOS, no TERMIO, no SGTTY) will be assumed.

    Added a win32_hsrc Makefile rule to create hsrc files appropriate
    for a Windoz system using Cygwin gcc environment.  Added win32.mkdef
    which is used by the win32_hsrc rule to set the Windoz specific
    Makefile values to build hsrc files.  The hsrc files are built
    under the win32 directory.

    Added FPOS_POS_BITS, OFF_T_BITS, DEV_BITS and INODE_BITS Makefile
    symbols to allow one to force the size of a file position, file
    offset, dev and inode value.  Leaving these values blank will
    Makefile to determine their size.

    Fixed a bug in the way file offsets, device and inode values are copied.

    Added chi.cal for a initial stab as a Chi^2 function.  The chi_prob()
    function does not work well with odd degrees of freedom, however.

    Added big 3 to config("resource_debug").  Calc resource file scripts
    check for config("resource_debug") & 8 prior to printing internal debug
    statements.  Thus by default they do not print them.

    Added intfile.cal as a calc resource file script:

	file2be(filename)

	    Read filename and return an integer that is built from the
	    octets in that file in Big Endian order.  The first octets
	    of the file become the most significant bits of the integer.

	file2le(filename)

	    Read filename and return an integer that is built from the
	    octets in that file in Little Endian order.  The first octets
	    of the file become the most significant bits of the integer.

	be2file(v, filename)

	    Write the absolute value of v into filename in Big Endian order.
	    The v argument must be on integer.  The most significant bits
	    of the integer become the first octets of the file.

	le2file(v, filename)

	    Write the absolute value of v into filename in Little Endian order.
	    The v argument must be on integer.  The least significant bits
	    of the integer become the last octets of the file.

    Added the following help aliases:

	copy	blkcpy
	read	command
	write	command
	quit	command
	exit	command
	abort	command
	cd	command
	show	command

    Added the cscript:

	fproduct filename term ...

    to write the big Endian product of terms to a filename.  Use - for stdout.

    Fixed calc path in help/script.

    Added read-only parameter, config("windows") to indicate if the system
    is MS windowz WIN32 like system.

    Configuration values that used to return "true" or "false" now return
    1 (a true value) or 0 (a false value).  Thus one can do:

    	if (config("tab")) { ... } else { ... }

    The configuration values that now return 1 or 0 are:

	config("tilde")
	config("tab")
	config("leadzero")
	config("blkverbose")
	config("verbose_quit")
	config("windows")

    Now shipping a win32 sub-directory that contains hsrc .h files
    that have been attempted to be built for windoz.


The following are the changes from calc version 2.11.4t1 to 2.11.4t2:

    Added missing test8600.cal test file.

    Fixes cscript files to deal with the -S flag being replaced by
    -f and possibly other flags.

    Added regression tests for builtin functions bernoulli, catalan,
    euler, freeeuler, and sleep.  Added non-base 10 regression tests
    for digit, digits and places.

    The bernoulli.cal script now just calls the bernoulli() builtin
    function.  It remains for backward compatibility.

    The Makefile now builds have_fpos_pos.h to determine if the
    a non-scalar FILEPOS has a __pos stucture element.  If it does,
    the FILEPOS_BITS is taken to be the size of just the __pos element.

    Misc fixes related to non-scalar (e.g., structure) FILEPOS.  Fixed
    a compile problems where non-scalar FILEPOS were incorrectly assigned.

    Fixed make depend rule.

    Return an error on malloc / realloc failures for bernoulli and
    euler functions.

    Added MAKEFILE_REV make variable to help determine Makefile version.
    Fixed the way the env rule reports Makefile values.


The following are the changes from calc version 2.11.3t0 to 2.11.4:

    Increased the maximum number of args for functions from 100 to 1024.
    Increased calc's internal evaluation stack from 1024 to 2048 args.
    Added test8600.cal to the regression suite to test these new limits.

    Updated and fixed misc typos in calc/README.

    Clarified in the COPYING file that ALL calc source files, both
    LGPL covered and exceptions to the LGPL files may be freely used
    and distributed.

    Added help files or updated for: bernoulli, calc_tty, catalan,
    digit, digits, euler, freeeuler, places and sleep.

    A collection of 18 patches from Ernest Bowen
    <ernie at turing dot une dot edu dot au>:

    (1)  A new flag -f has been defined which has the effect of a read
    command without the need to terminate the file name with a semicolon
    or newline.  Thus:

	    calc "read alpha; read beta;"

    may be replaced by:

	    calc -f alpha -f beta

    Quotations marks are recognized in a command like

	    calc -f 'alpha beta'

    in which the name of the file to be read includes a space.

    (2) Flags are interpreted even if they are in a string, as in:

	    calc "-q -i define f(x) = x^2;"

    which has the effect of:

	    calc -q -i "define f(x) = x^2;"

    To achieve this, the use of getopts() in calc.c has been dropped in
    favor of direct reading of the arguments produced by the shell.
    In effect, until a "--" or "-s" or a calc command (recognized
    by not starting with '-') is encountered, the quotation signs in
    command lines like the above example are ignored.  Dropping getopts()
    permits calc to specify completely the syntax rules calc will apply
    to whatever it is given by the shell being used.

    (3) For executable script (also called interpreter) files with first
    line starting with "#!", the starting of options with -S has been
    replaced by ending the options with -f.  For example, the first line:

	    #! full_pathname_for_calc -S -q -i

    is to be replaced by:

	    #! full_pathname_for_calc -q -i -f

    Thus, if the pathname is /usr/bin/calc and myfile contains:

	    #!/usr/bin/calc -q -i -f
	    global deg = pi()/180;
	    define Sin(x) = sin(x * deg);

    and has been made executable by:

	    chmod u+x myfile

    myfile would be like a version of calc that ignored any startup
    files and had an already defined global variable deg and a function
    Sin(x) which will return an approximation to the sine of x degrees.
    The invocation of myfile may be followed by other options (since
    the first line in the script has only flagged options) and/or calc
    commands as in:

	    ./myfile -c read alpha '; define f(x) = Sin(x)^2'

    (The quotation marks avoid shell interpretation of the semicolon and
    parentheses.)

    (4) The old -S syntax for executable scripts implied the -s flag so that
    arguments in an invocation like

	    ./myfile alpha beta

    are passed to calc; in this example argv(0) = 'alpha', argv(1) =
    'beta'.  This has been changed in two ways: an explicit -s is required
    in the first line of the script and then the arguments passed in the
    above example are argv(0) = 'myfile', argv(1) = 'alpha', argv(1) = 'beta'.

    In an ordinary command line, "-s" indicates that the shell words
    after the one in which "-s" occurred are to be passed as arguments
    rather than commands or options.  For example:

	    calc "-q -s A = 27;" alpha beta

    invokes calc with the q-flag set, one command "A = 27;", and two arguments.

    (5) Piping to calc may be followed by calc becoming interactive.
    This should occur if there is no -p flag but -i is specified, e.g.:

	    cat beta | calc -i -f alpha

    which will do essentially the same as:

	    calc -i -f alpha -f beta

    (6) The read and help commands have been  changed so that several
    files may be referred to in succession by separating their names
    by whitespace.  For example:

	    > read alpha beta gamma;

    does essentially the same as:

	    > read alpha; read beta; read gamma;

    This is convenient for commands like:

	    calc read file?.cal

    when file?.cal expands to something like file1.cal file2.cal file3.cal:

	    myfiles='alpha beta gamma'
	    calc read $myfiles

    or for C-shell users:

	    set myfiles=(alpha beta gamma)
	    calc read $myfiles


    (7) The -once option for read has been extended to -f.  For example,

	    calc -f -once alpha

    will ignore alpha if alpha has been read in the startup files.  In a
    multiple read statement, -once applies only to the next named file.
    For example

	    > read -once alpha beta -once gamma;

    will read alpha and gamma only if they have not already been read,
    but in any case, will read beta.

    (8) A fault in the programming for the cd command has been corrected
    so that specifying a directory by a string constant will work.  E.g:

	    > cd "my work"

    should work if the current directory has a directory with name "my work".

    (9) new functions bernoulli(n) and euler(n) have been defined to
    return the Bernoulli number and the Euler number with index n.
    After evaluation for an even positive n, this value and these for
    smaller positive even n are stored in a table from which the values
    can be reread when required.  The memory used for the stored values
    can be freed by calling the function freebernoulli() or freeeuler().

    The function catalan(n) returns the catalan number with index n.
    This is evaluated using essentially comb(2*n, n)/(n+1).

    (10) A function sleep(n) has been defined which for positive n calls
    the system function sleep(n) if n is an integer, usleep(n) for other
    real n.  This suspends operation for n seconds and returns the null
    value except when n is integral and the sleep is interrupted by a
    SIGINT, in which case the remaining number of seconds is returned.

    (11) The effect of config("trace", 8) which displays opcodes of
    functions as they are successfully defined has been restricted to
    functions defined with explicit use of "define".  Thus, it has been
    deactivated for the ephemeral functions used for evaluation of calc
    command lines or eval() functions.

    (12) The functions digit(), digits(), places() have been extended to
    admit an optional additional argument for an integral greater-than-one
    base which defaults to 10.  There is now no builtin limit on the
    size of n in digit(x, n, b), for example, digit(1/7, -1e100) which
    would not work before can now be handled.

    (13) The function, digits(x), which returns the number of decimal
    digits in the integer part of x has been changed so that if abs(x) <
    1, it returns 0 rather than 1.  This also now applies to digits(x,b).

    (14) Some programming in value.c has been improved.  In particular,
    several occurrences of:

	    vres->v_type = v1->v_type;
	    ...
	    if (v1->v_type < 0) {
		    copyvalue(v1, vres);
		    return;
	    }

    have been replaced by code that achieves exactly the same result:

	    vres->v_type = v1->v_type;
	    ...
	    if (v1->v_type < 0)
		    return;

    (15) Some operations and functions involving null-valued arguments
    have been changed so that they return null-value rather than "bad
    argument-type" error-value.  E.g. null() << 2 is now null-valued
    rather than a "bad argument for <<" error-value.

    (16) "global" and "local" may now be used in expressions.  For example:

	    > for (local i = 0; i < 5; i++) print i^2;

    is now acceptable, as is:

	    > define f(x = global x) = (global x = x)^2;

    which breaks wise programming rules and would probably better be handled
    by something like:

	    > global x
	    > define f(t = x) = (x = t)^2;

    Both definitions produce the same code for f.  For non-null t, f(t)
    returns t^2 and assigns the value of t to x;  f() and f(t) with null t
    return x^2.

    Within expressions, "global" and "local" are to be followed by just one
    identifier.  In "(global a = 2, b)" the comma is a comma-operator; the
    global variable a is created if necessary and assigned the value 2, the
    variable b has to already exist.   The statement "global a = 2, b" is
    a declaration of global variables and creates both a and b if they
    don't already exist.

    (18) In a config object, several components have been changed from
    long to LEN so that they will now be 32 bit integers for machines with
    either 32 or 64-bit longs.  In setting such components, the arguments
    are now to less than 2^31.  Before this change:

	    > config("mul2", 2^32 + 3)

    would be accepted on a 64-bit machine but result in the same as:

	    > config("mul2", 3)


The following are the changes from calc version 2.11.2t0 to 2.11.2t1.0:

    Fixed a bug whereby help files are not displayed correctly on
    systems such as NetBSD 1.4.1.  Thanks to a fix from Jakob Naumann.

    Changed EMail addresses to use asthe.com.  Changed URLs to use
    www.isthe.com.  NOTE: The EMail address uses 'asthe' and the web
    site URL uses 'isthe'.

    Using calc-bugs at asthe dot com for calc bug reports,
    calc-contrib at asthe dot com for calc contributions,
    calc-tester-request at asthe dot com for requests to join calc-tester and
    calc-tester at asthe dot com for the calc tester mailing list.

    Replaced explicit EMail addresses found this file with the <user at
    site dot domain> notation to reduce the potential for those folks
    to be spammed.

    The Makefile attempts to detect the existence of /dev/urandom with -e
    instead of the less portable -c.

    Misc Makefile fixes.


The following are the changes from calc version 2.11.1t3 to 2.11.1t4:

    Removed non-portable strerror() tests (3715, 3724 and 3728) from
    calc/regress.cal.

    Fixed missing strdup() from func.c problem.

    Fixed a problem that would have come up on a very long #! command line
    if the system permitted it.


The following are the changes from calc version 2.11.1 to 2.11.1t2.2:

    Placed calc under version 2.1 of the GNU Lesser General Public License.

	The calc commands:

	    help copyright
	    help copying
	    help copying-lgpl

	should display the generic calc copyright as well as the contents
	of the COPYING and COPYING-LGPL files.

	Those files contain information about the calc's GNU Lesser General
	Public License, and in particular the conditions under which you
	are allowed to change it and/or distribute copies of it.

    Removed the lint facility from the Makefile.  Eliminated Makefile
    variables: ${LCFLAGS}, ${LINT}, ${LINTLIB} and ${LINTFLAGS}.
    Removed the lint.sed file.

    Cleaned up help display system.  Help file lines that begin with
    '##' are not displayed.

    Calc source and documentation now uses the the these terms:

	*.cal files	calc resource file
	*.a files	calc binary link library
	#! files	calc shell script

    Renamed 'help stdlib' to 'help resource'.	The 'help stdlib' is
    aliased to 'help resource' for arg compatibility.

    Renamed config("lib_debug") to config("resource_debug").
    The config("lib_debug") will have the same effect as
    config("resource_debug") for backward compatibility.

    Renamed the source sub-directory lib to cal.  The default $CALCPATH
    now uses ./cal:~/cal (instead of ./lib:~/lib).  Changed LIB_PASSDOWN
    Makefile variable to CAL_PASSDOWN.

    Fixed misc compile warnings and bugs.

    Fixed problem of incorrect paths in the formation of installed
    calc shell scripts.

    Changed the recommended Comqaq cc compile to be -std0 -fast -O4 -static.

    Fixed a problem related to asking for help for a non-existent file.

    Added ./.calcinit to the default calcrc.

    Added cscript/README and help cscript to document the calc shell
    script supplied with calc.


The following are the changes from calc version 2.11.0t10 to 2.11.0t11:

    Misc code cleanup.	Removed dead code.  Removed trailing whitespace.
    Fixed whitespace to make the best use of 8 character tabs.

    Fixed some bugs relating to '// and %' in combination with some
    of the the rounding modes based on a patch from Ernest Bowen
    <ernie at turing dot une dot edu dot au>.

    A patch from Klaus Alexander Seistrup <klaus at seistrup dot dk>, when
    used in combination with the GNU-readline facility, will prevent
    it from saving empty lines.

    Minor typos fixed in regress.cal

    Added 8500 test series and test8500.cal to perform more extensive
    tests on // and % with various rounding modes.

    The 'unused value ignored' messages now start with Line 999: instead
    of just 999:.

    Fixed the long standing issue first reported by Saber-C in the
    domul() function in zmil.c thanks to a patch by Ernest Bowen
    <ernie at turing dot une dot edu dot au>.

    Added zero dimensional matrices.  A zero dimensional matrix is defined as:

	mat A[]	  or	A = mat[]

    Updated the help/mat file to reflect the current status of matrices
    including zero dimensional matrices.

    Added indices() builtin function as written by Ernest Bowen <ernie
    at turing dot une dot edu dot au> developed from an idea of Klaus
    Seistrup <klaus at seistrup dot dk>.  See help/indices for details.

    Fixed a number of insure warnings as reported by Michel van der List
    <vanderlistmj at sbphrd dot com>.

    Fixed a number of help file typos discovered by Klaus Alexander
    Seistrup <klaus at seistrup dot .dk>.

    Removed REGRESS_CAL as a Makefile variable.

    Added calcliblist and calcliblistfmt utility Makefile rules to allow
    one to print the list of distribution files that are used (but not
    built) to form either the libcalc.a or the libcustcalc.a library.

    Added a patch from <Randall.Gray at marine dot csiro dot au> to make
    ^D terminate, but *only* if the line it is on is completely empty.
    Removed lib/altbind and removed the CALCBINDINGS Makefile variable.

    A new config("ctrl_d") value controls how the ``delete_char'', which
    by default is bound to ^D (Control D), will or will not exit calc:

	config("ctrl_d", "virgin_eof")

	    If ^D is the only character that has been typed on a line,
	    then calc will exit.  Otherwise ^D will act according to the
	    calc binding, which by default is a Emacs-style delete-char.

	    This is the default mode.

	config("ctrl_d", "never_eof")

	    The ^D never exits calc and only acts according calc binding,
	    which by default is a Emacs-style delete-char.

	    Emacs purists may want to set this in their ~/.calcrc startup file.

	config("ctrl_d", "empty_eof")

	    The ^D always exits calc if typed on an empty line.	 This
	    condition occurs when ^D either the first character typed,
	    or when all other characters on the line have been removed
	    (say by deleting them).

	    Users who always want to exit when ^D is typed at the beginning
	    of a line may want to set this in their ~/.calcrc startup file.

	Note that config("ctrl_d") apples to the character bound to each
	and every ``delete_char''.  So if an alternate binding it setup,
	then those char(s) will have this functionality.

    Updated help/config and help/mode, improved the readability and
    fixed a few typos.	Documented modes, block formats and block bases
    ("mode", "blkfmt" & "blkbase") that were previously left off out of
    the documentation.

    The config("blkbase") and config("blkfmt") values return strings
    instead of returning integers.  One cannot use integers to set
    these values, so returning integers was useless.

    Applied the dangling name fix from Ernest Bowen
    <ernie at turing dot une dot edu dot au>.

    Show func prints function on order of their indices, and with
    config("lib_debug") & 4 == 4  some more details about the functions
    are displayed.

    Fixed another ``dangling name'' bug for when the object types list
    exceeded 2000.

    Fixed a bug related to opening to a calc session:

	define res_add(a,b) = obj res {r} = {a.r + b.r};
	...
	obj res A = {1,2}. obj res B = {3,4}

    A hash of an object takes into account the object type.  If X and Y
    are different kinds of objects but have the same component values,
    they will probably return different rather than the same values for
    hash(X) and hash(Y).

    Added support for config("ctrl_d") to the GNU-readline interface
    as written by Klaus Alexander Seistrup <klaus at seistrup dot dk>.

	Currently, the config("ctrl_d", "virgin_eof") is not fully
	supported.  Under GNU-readline, it acts the same way as
	config("ctrl_d", "empty_eof").	Emacs users may find this
	objectionable as ``hi^A^D^D^D'' will cause calc to exit due to
	the issuing of one too many ^D's.

	Emacs users may want to put:

	    config("ctrl_d", "never_eof"),;

	into their ~/.calcrc startup files to avoid this problem.

    Made misc documentation fixes.

    Fixed the make depend rule.

    Applied Ernest Bowen's <ernie at turing dot une dot edu dot au>
    complex function power(), exp() and transcendental function patch:

	Calc will return a "too-large argument" error-value for exp(x,
	epsilon) if re(x) >= 2^30 or if an estimate indicates that the
	result will have absolute value greater than 2^2^30 * epsilon.
	Otherwise the evaluation will be attempted but may fail due to
	shortage of memory or may require a long runtime if the result
	will be very large.

	The power(a, b, epsilon) builtin will return a "too-large result"
	if an estimate indicates that the result will have absolute value
	> 2^2^30 * epsilon.  Otherwise the evaluation will be attempted
	but may fail due to shortage of memory or may require a long
	runtime if the result will be very large.

	Changes have been made to the algorithms used for some special
	functions sinh(), cosh(), tanh(), sin(), cos(), etc., that make
	use of exp().  In particular  tanh(x)  is now much faster and
	doesn't run out of memory when x is very large - the value to
	be returned is then 1 to a high degree of accuracy.

	When the true value of a transcendental function is 1, as is
	cos(x) for x == 0, calc's version of the function will now return
	1 rather than the nearest multiple of epsilon.	E.g. cos(0, 3/8)
	no longer returns 9/8.

	The restriction of abs(n) < 1000000 on scale(x, n) has been
	removed.  The only condition n now has to satisfy for calc to
	attempt the operation is  n < 2^31, the same as for calc to
	attempt x << n and x^n.

	Changed root(x,n) so that when x is negative and n is odd it
	returns the principal complex n-th root of x rather than -1, e.g.
	root(-1,3) now returns -.5+.8660...i.

	Changed power(a,b) to permit a to be negative when b is real.
	E.g. power(-2,3) will now return 8 rather than cause a "negative
	base" error.

	Fixed several improper free and link problems in the comfunc.c code.

    Removed BOOL_B64 symbol from Makefile.

    The following config values return "true" or "false" strings:

	    tilde  tab	leadzero  fullzero  blkverbose	verbose_quit

	These config values can still be set with same boolean strings
	("on", "off", "true", "false", "t", ...) as well as via the
	numerical values 0 (for "false") and non-0 (for "true"), however.

    Added -s to the calc command line.	The -s flag will cause unused
    args (args after all of the -options on the command line) to remain
    as unevaluated strings.

    If calc is called with -s, then the new function argv() will return
    the number of strings on the command line.	Also argv(n) will return
    the n-th such string or null is no such string exists.

    Calc now handles calc shell scripts.  A calc shell script is an
    executable file that starts with:

	    #!/usr/local/bin/calc -S

	Where ``/usr/local/bin/calc'' is the path to the calc binary.
	Additional -options may be added to the line, but it MUST
	start with -S.	For example, the the executable file ``plus''
	contain the following:

	    #!/usr/local/bin/calc -S -e
	    /*
	     * This is a simple calc shell script to add two values
	     */
	    print eval(argv(0)) + eval(argv(1));

	then the following command:

	    ./plus 23 'pi(1e-5)'

	will print:

	    26.14159

    If calc is called with -S as the first arg, then calc will assume that
    it is being called from a #! calc shell script file.  The -S implies
    the -s flag.  If -i is not given, -S also implies -d and -p.

    Fixed the problem with non-literal string type checking for the
    C printf-like functions.  Able to determine if "%ld" or "%lld"
    is appropriate for printing of 64 bit long longs by way of the C
    symbol L64_FORMAT in the longlong.h header file.

    The following lines are treated as comments by calc:

	#! this is a comment
	# this is a comment
	#	this is a comment
	#
	# The lone # above was also a comment
	## is also a comment

    Improved how calc makes changes to file descriptor interactive state.
    Moved state changing code to calc_tty() and orig_tty() in lib_calc.c.
    The libcalc_call_me_last() function will restore all changed descriptor
    states that have not already been restored.

    Added the following read-only config values:

	config("program")	path to calc program or calc shell script
	config("basename")	basename of config("program")
	config("version")	calc version string


The following are the changes from calc version 2.11.0t8.9.1 to 2.11.0t9.4.5:

    The config("verbose_quit") will control the printing of the message:

	    Quit or abort executed

	when a non-interactive ABORT, QUIT or EXIT is encountered.  By default,
	config("verbose_quit") is TRUE and the message is printed.  If one does:

	    config("verbose_quit", 0)

	the message is disabled.

    Added 8400 regression test set and test8400.cal to test the new
    quit and config("verbose_quit") functionality.

    Fixed the BigEndian BASEB==16 regression bugs by correctly swapping
    16 bit HALFs in a 64 bit value (such as a 64 bit file pointer).

    Added calclevel() builtin to calculation level at which it is called.

    Added help/calclevel and help/inputlevel help files.

    Removed regression tests 951 and 5984 so that the regress test will
    run in non-interactively / without a TTY such as under Debian's
    build daemon.

    The eval(str) builtin will return an error-value rather than cause
    an execution error str has a scan-error.

    Declarations are permitted to end with EOF as well as a newline or ';'.

    When prompt() occurs while reading a file, it will take input from
    the terminal rather than taking it from a file.  For example:

	    /* This demonstrates the use of prompt() and some other things  */
	    config("verbose_quit", 0);
	    define getnumber() {
		local x;
		for (;;) {
		    x = eval(prompt(">>> "));
		    if (isnum(x))
			return x;
		    print "Not a number! Try again";
		}
	    }
	    print "This will display the sqrt of each number you enter";
	    print "Enter quit to stop";
	    for (;;) {
		print sqrt(getnumber());
	    }
	    print "Good bye";

	Comments entered at input terminal level may be spread over several
	lines.	For example:

	    /*
	     * Assume that this calc script is called: comment.cal
	     * Then these commands now work:
	     *	cat comment.cal | calc
	     *	calc < comment.cal
	     */
	    print "Hello";

    Added:

	-D calc_debug[:lib_debug:[user_debug]]

    to set the initial value of config("calc_debug"), config("lib_debug")
    and config("user_debug").

    The : separated strings of -D are interpreted as signed 32 bit values.
    After an optional leading sign a leading zero indicates octal
    conversion, and a leading ``0x'' or ``0X'' hexadecimal conversion.
    Otherwise, decimal conversion is assumed.

    Reordered the config structure moving calc_debug ahead of lib_debug.

    Added bits 4 and 5 to config("calc_debug"):

	4	Report on changes to the state of stdin as well as changes
		to internal variables that control the setting and restoring
		of stdin.

	5	Report on changes to the run state of calc.

    Fixed portability issue in seed.c relating to /dev/urandom and ustat.

    Added a fix from Martin Buck <mb at netwings dot ch> to detect when
    calc aborts early instead of completing the regression test.
    Now 'make chk' will require the last line of calc output to
    end in the string ``Ending regression tests''.

    Added a patch from Martin Buck <mb at netwings dot ch> to allow use of
    GNU-readline.  Note that GNU-readline is not shipped with calc.
    His patch only provides the hooks to use it.  One must comment out:

	    USE_READLINE=
	    READLINE_LIB=
	    READLINE_INCLUDE=

	and comment in:

	    USE_READLINE= -DUSE_READLINE
	    READLINE_LIB= -lreadline -lhistory
	    READLINE_INCLUDE= -I/usr/include/readline

	in addition to pre-installing GNU-readline in your system to use
	this facility.

    Changed the "object already defined" math_error to a scanerror message.

    Removed the limit on the number of object types.

    Calc tarballs are now named calc-version.tar.gz and untar into
    a sub-directory called calc-version.

    Made a small change to declarations of static variables to reduce
    the internal opcodes needed to declare them.

    Fixed a permission problem on ranlib-ed *.a files that was reported
    by Michael Somos <somos at grail dot cba dot csuohio dot edu>.

    Added patch by Klaus Alexander Seistrup <klaus at seistrup dot dk>
    related to GNU-readline:

	+ enable calc specific bindings in ~/.inputrc
	+ save a copy of your session to disk and reload them next
	  time you're using calc
	+ only add a line to the history if it is different from
	  the previous line

    Added the Makefile symbol HAVE_GETRUSAGE to determine if the
    system supports the getrusage() system call.

    Fixed the make depend code in the custom and sample Makefiles.

    Fixed how the help/builtin file is formed.	The help/Makefile is
    now given the name of the native C compiler by the top level Makefile.

    The include files are installed under INCDIRCALC (a new Makefile variable)
    which by default is ${INCDIR}/calc.	 The INCDIR (also a new Makefile var)
    by default is /usr/local/include.  Include files previously installed
    directly under ${LIBDIR} will be removed.

    Added the piforever() function to lib/pi.cal.  It was written by
    Klaus Alexander Seistrup <klaus at seistrup dot dk> and was inspired by
    an algorithm conceived by Lambert Meertens.	 (See also the ABC
    Programmer's Handbook, by Geurts, Meertens & Pemberton, published
    by Prentice-Hall (UK) Ltd., 1990.)	The piforever() function prints
    digits of pi for as long as your memory and system uptime allows.  :-)

    Fixed the URLs found thruout the source and documentation which did
    not and in /, but should for performance and server load reasons.

    Cleaned up and improved handling of "mat" and "obj".  The comma in:

	    mat A[2], B[3];

	is changed to whatever is appropriate in the context:

	    + comma operator
	    + separator of arguments in a function call
	    + separator of arguments in a definition
	    etc.

	The expression (mat A[2]), B[3] returns B[3], assuming B already
	exists as something created by a statement like: global mat B[4].

	What used to be done by the expression:

	    mat A[2], B[3]

	will now require something like:

	    mat A[2], mat B[3]	or	A = mat[2], B = mat[3]

	For example, if obj point and obj pair are known types, the
	following is now allowed:

	    L = list(mat[2], mat[3], obj point, obj pair)

	As another example, the following is allowed:

	    define f(a = mat[2] = {3,4}) = 5 * a;

	as well as the following:

	    obj point {x,y}, PP = obj pair {A,B} = {obj point, obj point}

	which creates two object types at compile time and when executed,
	assigns a pair-object value to a variable PP.

    Fixed a bug whereby a for loop would behave incorrectly.  For example:

	    config("trace", 2),
	    global x;
	    define f() {for ( ; x > 0; x--) {print x;}}
	    x = 5, f()

	will stop after printing 1 instead of looping forever.

    Added values l_format, which when CHECK_L_FORMAT is defined ahead
    of including longlong.h will help detect when a system can deal with
    'long long' but not '%lld' in printf.  If a system with 'long long'
    uses '%ld' to print a 64 bit value, then l_format will be > 0;
    otherwise if "%lld" is required, l_format will be < 0.

    Added HAVE_STRDUP Makefile variable as well as the have_strdup.c
    program that forms the have_strdup.h file.	The have_strdup.h file
    will define HAVE_STRDUP is the system has strdup().	 If HAVE_STRDUP
    is not defined, then calc will use calc_strdup() to simulate
    the real strdup() function.

    Calc no longer makes use of sys_errlist and sys_nerr.  Some systems
    no longer support these values (even though they should from a
    legacy prospective).  Calc now relies on the fact that strerror()
    will return NULL of no such system error exists.  System errors >=
    10000 will be considered calc errors instead.  The Makefile symbol
    ERRNO_DECL has gone away as well as calc_errno.c and calc_errno.h.

    System errors that are are not known to to the libc strerror()
    function, will now print (via the strerror() calc builtin function)
    something such as:

	    Unknown error 9999

    Fixed some insure code inspection tool issues that were discovered
    and investigated by Michel van der List <vanderlistmj at sbphrd dot com>.

    Made an effort to ensure that the v_subtype of VALUES are initialized
    to V_NOSUBTYPE thruout the source code.

    Established a separate calc-bugs address from the calc-tester
    mailing list.  Using anti-spam address forms in order to try and
    stay under the radar of spammers as much as one can do so.


The following are the changes from calc version 2.11.0t8 to 2.11.0t8.9:

    Moved 'wishlist' enhancements from the help/todo file to a new
    help/wishlist file.	 Ordered, by priority, help/todo items into
    Very High, High and Medium priority items.

    The BUGS file now has a 'bugs' section as well as a 'mis-features'
    section.

    Improved how calc internally dealt with reading EOF or '\0' characters.

    Calc now allows multiple defines to occur on the same line:
    (Thanks goes to Ernest Bowen <ernie at turing dot une dot edu dot au>)

	define f8300(x) = x^2; define g8300(x) = 1 - x;

    Improved calc's ability to deal with and recover from errors.

    Added inputlevel() builtin to return the input processing level.
    In an interact mode, inputlevel() returns 0.  When directly reading
    a calc script, inputlevel() returns 1.  When reading a script which
    in turn reads another script, inputlevel() returns 2.  etc...

    If $CALCRC has more than one file as in file1:file2 and an error
    occurs in file1, then calc -c will not read file2.

    Fixed some of the old EMail addresses found in calc documentation.

    Added HAVE_USTAT, HAVE_GETSID, HAVE_GETPGID, HAVE_GETTIME, HAVE_GETPRID
    and HAVE_URANDOM symbols to the Makefile.  These symbols, along with
    have_ustat.c, have_getsid.c, have_getpgid.c, have_gettime.c and
    have_getprid.c form: have_ustat.h, have_getsid.h, have_getpgid.h,
    have_gettime.h, have_getprid.h and have_urandom.h which in turn
    are used by pseudo_seed() in seed.c to determine what types of
    system services can be used to form a pseudo-random seed.

    Fixed the way calc -c will continue processing $CALCRC when errors
    are encountered.  Unless -d is also given, calc -c will report
    when calc is unable to open a $CALCRC file.

    Fixed the lower level make depend rules.

    Misc cleanup on the have_*.c support source files.

    Misc source file cleanup for things such as } else { style consistency.

    Fixed the basis for FNV-1 hashes.  Prior to this fix, the hash()
    builtin produced FNV hash values that did not match the FNV-1
    algorithm as specified in:

	http://www.isthe.com/chongo/tech/comp/fnv/index.html

    Removed an unused argument in the function getbody() in codegen.c.

    Encountering of EOF in getbody() will cause a scanerror rather then
    stop activity.  This will now result in a scanerror:

	echo 'define f(x) { ' > myfile
	calc -i read myfile

    A '{' at the start of a command and a later matching '}' surrounding zero
    or more statements (and possibly newlines) results in a function body to
    be "evaluated".   This permits another command to follow on the same
    line as the '}' as in:

		{display(5)} read something;
	and:
		{static a = 5} define f(x) = a + x;

    String constants can now be concatenated.  For example:

	s = "curds" ' and ' "whey";

    Added FNV hash to the regression test suite.

    Added Ernest Bowen's <ernie at turing dot une dot edu dot au> fix for the
    FNV regression test of the hash() builtin function.

    Added Ernest Bowen's <ernie at turing dot une dot edu dot au> patch to
    improve the way config("calc_debug").  Now the lower 4 bits of the
    config("calc_debug") parameter have the following meaning:

       n	       Meaning of bit n of config("calc_debug")

       0       Outputs shell commands prior to execution.

       1       Outputs currently active functions when a quit instruction
	       is executed.

       2       Some details of shs, shs1 and md5 hash states are included
	       in the output when these are printed.

       3       When a function constructs a block value, tests are
	       made that the result has the properties required for use of
	       that block, e.g. that the pointer to the start of the
	       block is not NULL, and that its "length" is not negative.
	       A failure will result in a runtime error.

    Changed the meaning of (config("calc_debug") & 1) from only printing
    the shell commands (and pausing) while displaying help files into
    the printing of any shell command prior to execution.

    Documented the meaning of config("lib_debug"):

	n		Meaning of bit n of config("lib_debug")

	0	When a function is defined, redefined or undefined at
		interactive level, a message saying what has been done
		is displayed.

	1	When a function is defined, redefined or undefined during
		the reading of a file, a message saying what has been done
		is displayed.

	The value for config("lib_debug") in both oldstd and newstd is
	3, but if calc is invoked with the -d flag, its initial value
	is zero.  Thus, if calc is started without the -d flag, until
	config("lib_debug") is changed, a message will be output when a
	function is defined either interactively or during the reading
	of a file.

    Changed the calc lib files to reflect the new config("lib_debug")
    bit field meaning.	Calc lib files that need to print extra information
    should now do something such as:

	if (config("lib_debug") & 3) {
		print "obj xyz defined";
		print "funcA([val1 [, val2]]) defined";
		print "funcB(size, mass, ...) defined";
	}

    Fixed the help/custom_cal, help/new_custom, and help/copy files so
    that they contain the correct contents instead of the 'usage' file.

    Fixed problem with loss of bindings when calc -i args runs into
    an error while processing 'args' and drops into interactive mode
    without the terminal bindings being set.

    Added patch from Ernest Bowen to establish the abort command as
    well as to clarify the roles of quit and exit.  See the help/command
    file for details.

    Updated to some extend, the help/statement and help/command help
    files with new information about SHOW, QUIT, EXIT and ABORT.

    Added show sizes to pzasusb8.cal.

    Updated calc man page and help/usage file to reflect recent
    command line changes.

    Fixed a bug, reported by Michael Somos <somos at grail dot cba dot
    csuohio dot edu>, which prevented calc -m from being used.

    Fixed misc compiler warnings.


The following are the changes from calc version 2.11.0t7 to 2.11.0t7.5:

    Calc has some new command line flags / command line meaning:
    (Thanks goes to Ernest Bowen <ernie at turing dot une dot edu dot au>)

	-i	Go into interactive mode if possible.

	-c	Continue reading command lines even after an execution
		error has caused the abandonment of a line

	To understand the -i and -c effects, consider the following
	file (call it myfile.cal) which has deliberate errors in it:

	    print 1;
	    mat A[1] = {2,3};
	    print 2;
	    epsilon(-1);
	    print 3;

	calc read myfile

	    Reports an error on the 2nd line and exits; prints 1 only.

	calc -c read myfile

	    Report errors on the 2nd and 4th lines and exits; prints 1,2 and 3.

	calc -i read myfile

	    Report errors on the 2nd and gives you a prompt; prints 1 only.

	calc -i -c read myfile

	    Report errors on the 2nd and 4th and gives you a prompt;
	    prints 1, 2 and 3.

	cat myfile | calc

	    Reports an error on the 2nd line and exits; prints 1 only.

	cat myfile | calc -c

	    Report errors on the 2nd and 4th lines and exits; prints 1,2 and 3.

	Note that continuation refers to command lines, not to statements.  So:

	    calc -c 'print "start"; mat A[1] = {2,3}; print "end";'

	since it contains no newline, the whole string is compiled,
	but execution is abandoned when the error is encountered and
	the string ``end'' is not printed.

	You can use your shell to supply newlines in your command line
	arguments.  For example in sh, ksh, bash:

	    calc -c 'print "start";
	    mat A[1] = {2,3};
	    print "end";'

	will print both ``start'' and ``end''.	C-shell users can do:

	    calc -c 'print "start"; \
	    mat A[1] = {2,3}; \
	    print "end";'

	however sh, ksh, bash will not see ``end'' printed because their
	shell will remove the internal newlines.

    Added display(n) builtin which does almost the same as config("display",n)
    except that rather than causing an execution with an out-of-range or
    bad-type argument type, it simply writes a message to stderr.  This
    also now happens to the errmax() builtin.

    Added qtime.cal to the standard calc library.

    Added another command line flag to calc:

	-d	Disable display of the opening title and config("lib_debug",0)

	The command:

	    calc 'read qtime; qtime(2)'

	will output something like:

	    qtime(utc_hr_offset) defined
	    It's nearly ten past six.

	whereas:

	    calc -d 'read qtime; qtime(2)'

	will just say:

	    It's nearly ten past six.

    A call of errmax(-1) will prevent errcount from aborting calc.

    Add the function stoponerror(n) which, as the name implies, controls
    if calc stop on an error based on the value of n:

	n > 0	stop on error even if -c was given on the command line
	n == 0	if -c, continue, without -c, stop
	n < 0	continue on error, even if -c was given on the command line

    Calc compilation now stops at the first scanerror.

    Restored the feature where -p disables the printing of leading tabs
    as of config("tab",0) had been executed.  So using calc in a pipe:

	calc -p 2+17 | whey

    will write '19' instead of '\t19' to the whey command.

    Updated calc man page and help/usage file to reflect recent
    command line changes.

    Converted start_done into a general calc run state enum called
    run_state within the calc source.

    Removed README.OLD.

    Added the Makefile variable ${LCC} to invoke the local c compiler.
    By default, ${CC} also run the ${LCC} compiler.  The distinction is
    useful when using something such as purify.	 In the case of ${LCC},
    only the local C compiler is invoked.  In the case of ${CC} a purify
    compile is invoked.	 Only the source that must be compiled and run
    on the local machine use ${LCC}; everything else uses ${CC}.

    Fixed memory buffer related problem in eatstring() in token.c.

    Fixed memory leaks related to putenv().

    Fixed memory leaks related to srandom().

    Fixed compilation warnings and problems on BSDI.

    Removed ${CCMAIN} as a variable from the Makefile.	Now files
    use either ${CFLAGS} for general C source and ${ICFLAGS} for
    intermediate C source (e.g., special code for building hsrc files).

    The main calc URL is now:

	http://www.isthe.com/chongo/tech/comp/calc/

    Misc calc man page fixes.


The following are the changes from calc version 2.11.0t1 to 2.11.0t6.3:

    Removed the makefile symbol MAIN.  Now forcing all functions to correctly
    be declared main.  To satisfy some old broken compilers, a return 0;
    (instead of an exit(0);) is used at the end of main().

    A few of files that were added to calc used 4 character indentation
    whereas most of calc uses 8 character indentation.	These imported
    sources have been changed to conform better with the calc style.

    Added the program calc_errno.c and the Makefile symbol ERRNO_DECL.
    If ERRNO_DECL is empty, calc_errno.c will try various ways to
    declare errno, sys_errlist and sys_nerr.  On success or when
    it gives up, calc_errno will output the middle of the calc_errno.h
    header file.  If ERRNO_DECL is  -DERRNO_NO_DECL, or -DERRNO_STD_DECL
    or -DERRNO_OLD_DECL then the Makefile will build the middle
    of the calc_errno.h header file without calc_errno.c's help.

    The func.c file now includes the constructed header file calc_errno.h
    to ensure that errno, sys_errlist and sys_nerr are declared correctly.

    Changed check.awk to be more 'old awk' friendly.

    Made some of the source a little more ++ friendly.	We are NOT
    porting calc to C++!  We will NOT support C++ compilation of calc.
    Calc will written ANSI C.  We just compiled with a suggestion from
    Love-Jensen, John <jlove-jensen at globalmt dot com> to make calc's version
    of C a little more to C++ compilers.  We are simply avoiding symbols
    such as new or try for example.

    Renamed README to README.OLD.  Renamed README.FIRST to README.
    Updated README, lib/README and BUGS to reflect new URLs and addresses.

    Added a HOWTO.INSTALL file.

    Reordered cc Makefile variable sets in the main Makefile.

    Fixed a bug in hnrmod() and applied a fix that was reported by Ernest
    Bowen <ernie at turing dot une dot edu dot au>.  Added regression tests
    1103 to 1112 to confirm the fix.

    Fixed a bug in version.c related to MINOR_PATCHs in both the
    empty and non-empty MINOR_PATCH cases.

    Fixed malloc and bad storage issues reported by Michel van der List
    <vanderlistmj at sbphrd dot com>.

    Fixed some problems related to path processing while opening files.
    Under extreme cases, an excessively long filename or CALCPATH value
    could create problems.  Placed guards in opensearchfile() function
    in input.c to catch these cases.

    Fixed cases were malloc failures were silently ignored in input.c.

    Eliminated the PATHSIZE limit and the PATHSIZE symbol.

    Added MAX_CALCRC to limit the length of the $CALCRC environment
    variable to 1024 chars.

    Fixed the magic number relating to the initial number of constants
    declared by initconstants().  It is now related to the length
    of the initnumbs[] NUMBER array.

    Added a 'Dec Alpha / Compaq Tru64 cc (non-gnu) compiler set'
    section to the main Makefile.

    Fixed a string handling bug discovered by Dr.D.J.Picton
    <dave at aps5 dot ph dot bham dot ac dot uk> in the custom demo code.

    Fixed a bug in the hnrmod() builtin that was discovered by
    Ernest Bowen <ernie at turing dot une dot edu dot au>.

    Added FORCE_STDC symbol.  When defined it will force __STDC__ like
    conditions.	 Thus for compilers with as the Solaris cc compiler
    that are ANSI-like but still define __STDC__ as 0, one can use
    -DFORCE_STDC and make use of ANSI-like features.

    Removed the CCSHS symbol from the Makefile.	 The shs.c and shs1.c
    files are now compiled with full ${CFLAGS}.

    The custom.c file is now compiled with full ${CFLAGS}.

    Rewrote command line / argument processing code.  Calc is now
    using getopt(3) argument processing.

    Fixed a memory leak related to converting strings to numbers
    in the str2q() function in qio.c.

    Fixed a problem with reading uninitialized memory in the
    v_subtype of a VALUE in the copyvalue() function in value.c.

    Fixed problems in func.c where temporary VALUEs were not
    having their v_type elements initialized.

    Fixed a memory leak in qpi() in qtrans.c.

    Fixed a memory leak in math_getdivertedio() in zio.c.

    Fixed a problem with points going beyond the end of allocated
    memory in addstring() in string.c.

    Fixed a memory leak in zgcdrem(), f_putenv(), zlog() and
    zlog10() in zfunc.c.

    Fixed a memory leak in zdiv() and zshift() in zmath.c.

    Fixed memory leaks in zsrand() in zrand.c.

    Fixed a memory leak in zsrandom1() in zrandom.c.  Fixed memory
    leaks associated with replacing the internal random state with
    another random state.

    Added seed() builtin to return a 64 bit seed for a
    pseudo-random generator.

    Added functionality from Ernest Bowen <ernie at turing dot une dot
    edu dot au> to permit nested "= {...}" assignments for lists as well
    as matrices and objects.  Now one can have a list, matrix or object,
    some of whose elements are lists, matrices or objects, to any depth
    of recursion, and assign values to any number of particular elements
    by an appropriate "initialization" expression.  For example:

	A = mat[2] = {list(1,2), list(3,4,list(5,6))};

    and then assign values to the 6 number elements by:

	A = {{7,8}, {9,10,{11,12}}};

    Closed files that were previously left open from test4600.cal
    as executed by regress.cal and from opening /dev/null by
    regress.cal itself.

    Fixed memory leaks from f_strprintf() and f_putenv() in func.c.

    The regress.cal test suite calls freeredc(), freestatics() and
    freeglobals() at the end of the test suite to free storage
    consumed during the regression.

    Added custom function custom("pzasusb8", n) and lib/pzasusb8.cal based on
    Ernest Bowen's diagnostic patch.

    Thanks to the efforts of Ernest Bowen <ernie at turing dot une dot
    edu dot au> and Dr.D.J.Picton <dave at aps5 dot ph dot bham dot ac
    dot uk>, a nasty endian-ness bug in the sha and sha1 hash functions
    that showed up on machines such as the Sparc was fixed.

    Added functionality from Ernest Bowen <ernie at turing dot une
    dot edu dot au> to give arguments as well as function names after
    definitions when config("lib_debug") >= 0.

    Removed if (config("lib_debug") >= 0) { ... } the ends of most
    of the calc library scripts because it was redundant with the
    new config("lib_debug") >= 0 functionality.	 Some of the calc
    library still has a partial section because some useful
    additional information was being printed:

	chrem.cal	deg.cal	     lucas_tbl.cal   randrun.cal
	mfactor.cal	mod.cal	     poly.cal	     seedrandom.cal
	surd.cal	varargs.cal

    Fixed ellip.cal so that its defined function does not conflict with
    the factor() builtin function.

    Fixed mod.cal so that a defined function does not conflict with
    the mod() builtin function.

    The regression test suite now reads in most calc libs.  A few
    libs are not read because they, by design, produce output
    when read even when config("lib_debug") is set to -1.

    Increased the maximum number of object types that one can define
    from 10 to 128.

    Added a patch from Ernest Bowen <ernie at turing dot une dot edu
    dot au> to correctly hash a V_STR value-type that has an \0 byte
    inside it.

    A patch from Ernest Bowen <ernie at turing dot une dot edu dot au> now
    defines special meaning to the first 2 bits of config("lib_debug"):

	bit 0 set => messages printed when inputisterminal
	bit 1 set => messages printed when reading from a file

    The lib/regress.cal regression suite does:

	config("lib_debug", -4);

    to eliminate lib messages (both bit 0 and bit 1 are not set).

    Fixed misc compile warnings and notices.


The following are the changes from calc version 2.10.3t5.38 to 2.11.0t0:

    Fixed a few compile problems found under Red Hat 6.0 Linux.


The following are the changes from calc version 2.10.3t5.38 to 2.11.3t5.46:

    Fixed a bug discovered by Ernest Bowen related to matrix-to-matrix copies.

    Bitwise operations on integers have been extended so that negative
    integers are treated in the same way as the integer types in C.

    Some changes have been made to lib/regress.cal and lib/natnumset.cal.

    Removed V_STRLITERAL and V_STRALLOC string type constants and
    renumbered the V_protection types.

    Added popcnt(x, bitval) builtin which counts the number of
    bits in x that match bitval.

    Misc compiler warning fixes.

    Fixed improper use of putchar() and printf() when printing rationals
    (inside qio.c).

    Fixed previously reported bug in popcnt() in relation to . values.

    Calc man page changes per suggestion from Martin Buck
    <Martin-2.Buck at student dot uni-ulm dot de>.  The calc man page is
    edited with a few more parameters from the Makefile.

    Misc Makefile changes per Martin Buck <Martin-2.Buck at student dot
    uni-ulm dot de>.

    Removed trailing blanks from files.

    Consolidated in the Makefile, where the debug and check rules are found.
    Fixed the regress.cal dependency list.

    Make chk and check will exit with an error if check.awk detects
    a problem in the regression output.	 (Martin Buck)

    Fixed print line for test #4404.

    Moved custom.c and custom.h to the upper level to fix unresolved symbols.

    Moved help function processing into help.c.

    Moved nearly everything into libcalc.a to allow programs access to
    higher level calc objects (e.g., list, assoc, matrix, block, ...).

    Renamed PATCH_LEVEL to MAJOR_PATCH and SUB_PATCH_LEVEL to MINOR_PATCH.
    Added integers calc_major_ver, calc_minor_ver, calc_major_patch
    and string calc_minor_patch to libcalc.a.  Added CALC_TITLE to hold
    the "C-style arbitrary precision calculator" string.

    The function version(), now returns a malloced version string
    without the title.

    Consolidated multiple SGI IRIX -n32 sections (for r4k, r5k and r10k)
    into a single section.


The following are the changes from calc version 2.10.3t5.34 to 2.10.3t5.37:

    Per request from David I Bell, the README line:

      I am allowing this calculator to be freely distributed for personal uses

    to:

      I am allowing this calculator to be freely distributed for your enjoyment

    Added help files for:

	address agd arrow dereference free freeglobals freeredc freestatics
	gd isptr mattrace oldvalue saveval & * -> and .

    Fixed blkcpy() and copy() arg order and processing.	 Now:

	A = blk() = {1,2,3,4}
	B = blk()
	blkcpy(B,A)
	blkcpy(B,A)

    will result in B being twice as long as A.

    Since "make chk" pipes the regression output to awk, we cannot
    assume that stdout and stderr are ttys.  Tests #5985 and #5986
    have been removed for this reason.	(thanks to Martin Buck
    <Martin-2.Buck at student dot uni-ulm dot de> for this report)

    Fixed the order of prints in regress.cal.  By convention, a print
    of a test line happens after the test.  This is because function
    parsed messages occur after the function is parsed.	 Also the
    boolean test will verify before any print statements.  Therefore
    a non-test line is tested and printed as follows:

	y = sha();
	print '7125: y = sha()';

    The perm(a,b) and comb(a,b) have been extended to arbitrary real a and
    integer b.

    Fixed a bug in minv().

    Moved string.c into libcalc.a.

    The NUMBER union was converted back into a flat structure.	Changes
    where 'num' and 'next' symbols were changed to avoid #define conflicts
    were reverse since the #define's needed to support the union went away.

    Removed trailing blanks from files.

    Ernest Bowen <ernie at turing dot une dot edu dot au> sent in the
    following patch which is described in the next 34 points:

    (0) In the past:

		    A = B = strcat("abc", "def");

	would store "abc" and "def" as literal strings never to be freed, and
	store "abcdef" once each for both A and	 B.  Now the "abc" and "bcd"
	are freed immediately after they are concatenated and "abcdef" is stored
	only once, just as the number 47 would be stored only once for

		    A = B = 47;

	The new STRING structure that achieves this stores not only the
	address of the first character in the string, but also the "length"
	with which the string was created, the current "links" count, and
	when links == 0 (which indicates the string has been freed) the
	address of the next freed STRING.  Except for the null string "",
	all string values are "allocated"; the concept of literal string
	remains for names of variables, object types and elements, etc.

    (1) strings may now include '\0', as in A = "abc\0def".  In normal printing
	this prints as "abc" and strlen(A) returns 3, but its "real" length
	of 7 is given by size(A). (As before there is an 8th zero character
	and sizeof(A) returns 8.)

    (2) If A is an lvalue whose current value is a string of size n, then
	for 0 <= i < n, A[i] returns the character with index i as an addressed
	octet using the same structure as for blocks, i.e. there is no
	distinction between a string-octet and a block-octet.  The same
	operations and functions can be used for both, and as before, an octet
	is in some respects a number in [0,256) and in others a one-character
	string.	 For example, for A = "abc\0def" one will have both A[0] == "a"
	and A[0] == 97.	 Assignments to octets can be used to change
	characters in the string, e.g. A[0] = "A", A[1] = 0, A[2] -= 32,
	A[3] = " " will change the above A to "A\0C def".

    (3) "show strings" now displays the indices, links, length, and some or all
	of the early and late characters in all unfreed strings which are values
	of lvalues or occur as "constants" in function definitions,
	using "\n", "\t", "\0", "\252", etc. when appropriate.	For example,
	the string A in (1) would be displayed as in the definition there.
	Only one line is used for each string.	I've also changed the
	analogous "show numbers" so that only some digits of numbers that
	would require more than one line are displayed.

    (4) "show literals" is analogous to "show constants" for number "constants"
	in that it displays only the strings that have been introduced by
	literal strings as in A = "abc".  There is a major difference between
	strings and numbers in that there are operations by which characters
	in any string may be changed.  For example, after A = "abc",
	A[0] = "X" changes A to "Xbc".	It follows that if a literal string
	is to be constant in the sense of never changing, such a character-
	changing operation should never be applied to that string.

	In this connection, it should be noted that if B is string-valued, then

			    A = B

	results in A referring to exactly the same string as B rather than to
	a copy of what is in B.	 This is like the use of character-pointers in
	C, as in

			    char *s1, *s2;
			    s1 = "abc";
			    s2 = s1;

	To achieve the effect of

			    s2 = (char *) malloc(4);
			    strcpy(s2, s1);

	I have extended the str() function to accept a string as argument.  Then

			    A = str(B);

	will create a new string at a different location from that of B but
	with the same length and characters.  One will then have A == B,
	*A == *B, but &*A != &*B, &A[0] != &B[0].

	To assist in analyzing this sort of thing, I have defined a links()
	function which for number or string valued argument returns the number
	of links to the occurrence of that argument that is being referred to.
	For example, supposing "abc" has not been used earlier:

			    > A = "abc"
			    > links(A)
				    2
			    > links(A)
				    1

	The two links in the first call are to A and the current "oldvalue";
	in the second call, the only link is to A, the oldvalue now being 2.


    (5) strcat(S1, S2, ...) works as before; contribution of a string stops when
	'\0' is encountered.  E.g.

		    strcat("abc\0def", "ghi")

	will return "abcghi".

    (6) For concatenation of full strings I have chosen to follow
	some other languages (like Java, but not Mathematica which uses "<>")
	and use "+" so that, e.g.

		    "abc\0def" + "ghi"

	returns the string "abc\0defghi".  This immediately gives obvious
	meanings to multiplication by positive integers as in

		    2 * "abc" = "abc" + "abc" = "abcabc",

	to negation to reverse as string as in

		    - "abc" = "cba",

	to multiplication by fractions as in

		    0.5 * "abcd" = "ab",

	(where the length is int(0.5 * size("abcd")), and finally, by combining
	these to

		     k * A    and      A * k

	for any real number k and any string A.	  In the case of k == 1, these
	return a new string rather than A itself.  (This differs from
	"" + A and A + "" which return A.)

    (7) char(x) has been changed so that it will accept any integer x or octet
	as argument and return a string of size one with character value
	x % 256.  In the past calc has required 0 <= x < 256; now negative
	x is acceptable; for example, 1000 * char(-1) will now produce the
	same as 1000 * "\377" or 1000 * "\xff".

    (8) For a string s, test(s) now returns zero not only for the null string
	"" but also for a string all of whose characters are '\0'.

    (9) Similarly <, <=, etc. now compare all characters including occurrences
	of '\0' until a difference is encountered or the end of a string is
	reached.  If no difference is encountered but one string is longer than
	the other, the longer string is considered as greater even if the
	remaining characters are all '\0'.

    (10) To retain the C sense of comparison of null-terminated strings I have
	 defined strcmp(S1, S2), and then, for completeness, strncmp(S1, S2, n).
	 For similar reasons, strcpy(S1, S2) and strncpy(S1, S2, n) have been
	 defined.

    (11) For strings, I have defined | and & as bitwise "or" and "and"
	 functions, with S1 | S2 having the size of the larger of S1 and S2,
	 S1 & S2 having the size of the smaller of S1 and S2.  By using, say,
	 4-character strings, one can simulate a C integral type so far as the
	 | and & operations are concerned.   It then seemed appropriate to
	 use the operator ~ for a "bitwise complement" as in C.	 Thus I have
	 defined ~s for a string s to be the string of the same size as s
	 with each character being complemented by the C ~ operation.

    (12) For boolean algebra work on strings it is convenient also to have
	 the bitwise xor and setminus binary operations.  Using C's '^' for xor
	 would be confusing when this is used elsewhere for powers, so I
	 decided to use ~.  For setminus, I adopted the commonly used '\'.
	 Strings of fixed size n can now be used for a boolean algebra
	 structure with 8 * n elements.	 The zero element is n * char(0),
	 the unity is n * char(-1), and one have all of the usual laws like
	 A & (B | C) == A & B | A * C,	A \ B = A & ~B, etc.

    (13) Having extended the bitwise operations for strings, it was appropriate
	 to do the same for integers.  Definitions of the binary ~ and \
	 operations for non-negative integers are straightforward.  For
	 the unary ~ operation, I decided to do what C does with integer
	 types, and defined ~N to be -N - 1.  With the appropriate extensions of
	 |, &, \ and the binary ~, one gets in effect the boolean algebra of
	 finite sets of natural numbers and their complements, by identifying
	 the set with distinct integer elements i_1, i_2, ... with the integer

		    2^i_1 + 2^i_2 + ...

	 For ~N for non-integer real N, I have simply used -N.	There is some
	 logic in this and it is certainly better than an error value.
	 I have not defined the binary operations |, &, ~, \ for non-integral
	 arguments.

	 The use of ~N in this way conflicts with calc's method of displaying
	 a number when it has to be rounded to config("display") decimals.
	 To resolve this, my preference would be to replace the printing of
	 "~" as a prefix by a trailing ellipsis "...", the rounding always
	 being towards zero.  E.g. with config("display", 5), 1/7 would print
	 as ".14285..." rather than "~.14285".	 The config("outround")
	 parameter would determine the type of rounding only for the
	 equivalent of config("tilde", 0).

    (14) For objects, users may create their own definitions for binary |,
	 &, ~ and \ with xx_or, xx_and, xx_xor, xx_setminus functions.
	 For unary ~ and \ operations, I have used the names xx_comp and
	 xx_backslash.

    (15) For the obviously useful feature corresponding to cardinality of a
	 set, I have defined #S for a string S to be the number of nonzero bits
	 in S.	 For a degree of consistency, it was then appropriate to
	 define #N for a nonnegative integer N to be the number of nonzero bits
	 in the binary representation of N.  I've extended this to arbitrary
	 real N by using in effect #(abs(num(N))).  I feel it is better to make
	 this available to users rather than having #N invoke an error message
	 or return an error value.  For defining #X for an xx-object X, I
	 have used the name xx_content to suggest that it is appropriate for
	 something which has the sense of a content (like number of members of,
	 area, etc.).

    (16) Having recognized # as a token, it seemed appropriate to permit its
	 use for a binary operation.  For real numbers x and y I have defined
	 x # y to be abs(x - y).  (This is often symbolized by x ~ y, but it
	 would be confusing to have x ~ y meaning xor(x,y) for strings and
	 abs(x-y) for numbers.)	 Because '#' is commonly called the hash symbol,
	 I have used xx_hashop to permit definition of x # y for xx-objects.

    (17) For a similar reason I've added one line of code to codegen.c so that
	 /A returns the inverse of A.

    (18) Also for a list L, +L now returns the sum of the elements of L.  For
	 an xx object A, +A requires and uses the definition of xx_plus.

    (19) I have given the unary operators ~, #, /, \, and except at the
	 beginning of an expression + and -, the same precedence with
	 right-to-left associativity.  This precedence is now weaker than
	 unary * and &, but stronger than binary & and the shift and power
	 operators.  One difference from before is that now

			    a ^ - b ^ c

	 evaluates as a ^ (- (b ^ c)) rather than a ^ ((- b) ^ c).


    (20) For octets o1, o2, I've defined o1 | o2, o1 & o2, o1 ~ o2, ~o1 so
	 that they return 1-character strings.	#o for an octet o returns the
	 number of nonzero bits in o.

    (21) For substrings I've left substr() essentially as before, but
	 for consistency with the normal block/matrix indexing, I've extended
	 the segment function to accept a string as first argument.  Then

		    segment(A, m, n)

	 returns essentially the string formed from the character with index m
	 to the character with index n, ignoring indices < 0 and indices >=
	 len(A); thus, if m and n are both in [0, size(A))
	 the string is of length abs(m - n) + 1, the order of the characters
	 being reversed if n < m.  Here the indices for a list of size len are
	 0, 1, ..., len - 1.  As it makes some sense, if 0 <= n < size(A),

		    segment(A, n)

	 now returns the one-character string with its character being that with
	 index n in A.	(I've made a corresponding modification to the segment
	 function for lists.)  Some examples, if A = "abcdef",

		    segment(A,2,4) = "cde",

		    segment(A,4,2) = "edc",

		    segment(A,3) = "d",

		    segment(A, -2, 8) = "abcdef",

		    segment(A,7,8) = "".

    (22) As essentially particular cases of segment(), I've defined
	 head(A, n) and tail(A, n) to be the strings formed by the first
	 or last abs(n) characters of A, the strings being4]5O~? reversed '
	 if n is negative.   I've changed the definitions of head and tail for
	 lists to be consistent with this interpretation of negative n.

    (23) Similarly I've left strpos essentially as at present, but search
	 and rsearch have been extended to strings.  For example,

		    search(A, B, m, n)

	 returns the index i of the first occurrence of the string B in A
	 if m <= i < n, or the null value if there is no such occurrence.
	 As for other uses of search, negative m is interpreted as
	 size(A) + m, negative n as size(A) + n.  For a match in this
	 search, all size(B) characters, including occurrences of '\0',
	 in B must match successive characters in A.

	 The function rsearch() behaves similarly but searches in reverse order
	 of the indices.

    (24) A string A of length N determines in obvious ways arrays of M = 8 * N
	 bits.	If the characters in increasing index order are c_0, c_1, ...
	 and the bits in increasing order in c_i are b_j, b_j+1, ..., b_j+7
	 where j = 8 * i, I've taken the array of bits determined by A to be

		    b_0, b_1, ..., b_M-1

	 For example, since "a" = char(97) and 97 = 0b01100001, and
	 "b" = char(98) = 0b01100010, the string "ab" determines the 16-bit
	 array

		    1000011001000110

	 in which the bits in the binary representations of "a" and "b" have
	 been reversed.

	 bit with index n in this array.   This is consistent with the use of
	 bit for a number ch in [0,256), i.e. bit(char(ch), n) = bit(ch, n).
	 For n < 0 or n >= size(A), bit(A,n) returns the null value.

    (25) For assigning values to specified bits in a string, I've defined
	 setbit(A, n) and setbit(A, n, v).  The first assigns the value 1 to
	 bit(A, n), the second assigns test(v) to bit(A, n).

    (26) For consistency with the corresponding number operations, the shift
	 operations A << n and A >> n have been defined to give what look
	 like right- and left-shifts, respectively.  For example, "ab" << 2
	 returns the 16-bit array

		    0010000110010001

	 in which the array for "ab" has been moved 2 bits to the right.

    (27) To achieve much the same as the C strcpy and strncpy functions for
	 null-terminated strings, strcpy(S1, S2) and strncpy(S1, S2, n) have
	 been defined.	Unlike the blkcpy() and copy() functions, the copying
	 for these is only from the beginning of the strings.  Also, unlike C,
	 no memory overflow can occur as the copying ceases when size(S1) is
	 reached.  Note that these overwrite the content of S1 (which affects
	 all strings linked to it) as well as returning S1.  Examples:

	    S = strcpy(6 * "x", "abc")	    <=>	 S = "abc\0xx"

	    S = strcpy(3 * "x", "abcdef")   <=>	 S = "abc"

	    S = strncpy(6 * "x", "abcd", 2) <=>	 S = "ab\0xxx"

	    S = strncpy(6 * "x", "ab", 4)   <=>	 S = "ab\0\0xx"

	    S = strncpy(6 * "x", "ab", 20)  <=>	 S = "ab\0\0\0\0"

	 If a new string S not linked to S1 is to be created, this can be
	 achieved by using str(S1) in place of S1.  For example, the strcpy in

	    A = "xxxxxx"
	    S = strcpy(str("xxxxxx"), "abc")

	 would not change the value of A.

    (28) I've extended the definitions of copy(A, B, ssi, num, dsi) and
	 blkcpy(B, A, num, ssi, dsi) to allow for string-to-string copying
	 and block-to-string copying, but num is now an upper bound for the
	 number of characters to be copied - copying will cease before num
	 characters are copied if the end of the data in the source A or the
	 end of the destination B is reached.  As with other character-changing
	 operations, copying to a string B will not change the locations of
	 B[0], B[1], ... or the size of B.

	 In the case of copying a string to itself, characters are copied in
	 order of increasing index, which is different from block-to-block
	 copying where a memmove is used.  This affects only copy from a
	 string to itself.  For example,

		    A = "abcdefg";
		    copy(A, A, , , 2);

	 will result in A == "abababa".	 If the overwriting that occurs here
	 is not wanted, one may use

		    A = "abcdefg";
		    copy(str(A), A, , , 2);

	  which results in A == "ababcde".

    (29) perm(a,b) and comb(a,b) have been extended to accept any real a and
	 any integer b except for perm(a, b) with integer a such that b <= a < 0
	 which gives a "division by zero" error.  For positive b, both functions
	 are polynomials in a of degree b;  for negative b, perm(a,b) is a
	 rational function (1/((a + 1) * (a+2) ...) with abs(b) factors in the
	 denominator), and comb(a,b) = 0.  (An obvious "todo" is to extend this
	 to complex or other types of a.)

    (30) Although it is not illegal, it seems pointless to use a comma operator
	 with a constant or simple variable as in

		    > 2 * 3,14159
			    14159
		    > a = 4; b = 5;
		    > A = (a , b + 2);
		    > A
			    7

	 I have added a few lines to addop.c so that when this occurs a
	 "unused value ignored" message and the relevant line number are
	 displayed.  I have found this useful as I occasionally type ','
	 when I mean '.'.

	 There may be one or two other changes resulting from the way I have
	 rewritten the optimization code in addop.c.  I think there was a bug
	 that assumed that PTR_SIZE would be the same as sizeof(long).	By
	 the way, the new OP_STRING is now of index rather than pointer type.
	 It follows that pointers are now used in opcodes only for global
	 variables.  By introducing a table of addresses of global variables
	 like those used for "constants" and "literal strings", the use of
	 pointers in opcodes could be eliminated.

    (31) When calc has executed a quit (or exit) statement in a function or
	 eval evaluation, it has invoked a call to math_error() which causes
	 a long jump to an initial state without freeing any data on the
	 stack, etc.  Maybe more detail should be added to math_error(), but
	 to achieve the freeing of memory for a quit statement and at the same
	 time give more information about its occurrence I have changed the
	 way opcodes.c handles OP_QUIT.	 Now it should free the local variables
	 and whatever is on the stack, and display the name and line-number,
	 for each of the functions currently being evaluated.  The last
	 function listed should be the "top-level" one with name "*".
	 Strings being eval-ed will have name "**".

	 Here is a demo:

	    > global a;
	    >
	    > define f(x) {local i = x^2; a++;
	    >> if (x > 5) quit "Too large!"; return i;}
	    f() defined
	    > define g(x) = f(x) + f(2*x);
	    g() defined
	    > g(2)
		    20
	    > g(3)
	    Too large!
		    "f": line 3
		    "g": line 0
		    "*": line 6
	    > eval("g(3)")
	    Too large!
		    "f": line 3
		    "g": line 0
		    "**": line 1
		    "*": line 7
	    > a
		    6

    (32) I've made several small changes like removing

		    if (vp->v_type == V_NUM) {
			    q = qinv(vp->v_num);
			    if (stack->v_type == V_NUM)
				    qfree(stack->v_num);
			    stack->v_num = q;
			    stack->v_type = V_NUM;
			    return;
		    }

	 from the definition of o_invert.  Presumably these lines were intended
	 to speed up execution for the common case of numerical argument.
	 Comparing the runtimes with and without these lines for inverting
	 thousands of large random numbers in a matrix suggest that execution
	 for real numbers is slightly faster without these lines.

	 Maybe this and other similar treatment of "special cases" should be
	 looked at more closely.

    (33) The new lib script lib/natnumset.cal demonstrates how the new
	 string operators and functions may be used for defining and
	 working with sets of natural numbers not exceeding a
	 user-specified bound.


The following are the changes from calc version 2.10.3t5.28 to 2.10.3t5.33:

    Added hnrmod(v, h, n, r) builtin to compute:

	v % (h * 2^n + r), h>0, n>0, r = -1, 0 or 1

    Changed lucas.cal and mersenne.cal to make use of hnrmod().

    A number of changes from Ernest Bowen:

	(1) introduction of unary & and * analogous to those in C;

	    For an lvalue var, &var returns what I call a
	    value-pointer; this is a constant which may be assigned to
	    a variable as in p = &var, and then *p in expressions has
	    the same effect as var.  Here is a simple example of their use:

		> define s(L) {local v=0; while (size(L)) v+= *pop(L);return v;}
		s() defined
		> global a = 1, b = 2;
		> L = list(&a, &b);
		> print s(L)
		3
		> b = 3;
		> print s(L)
		4

	    Octet-pointers, number-pointers, and string-pointers in
	    much the same way, but have not attempted to do much with
	    the latter two.

	    To print a pointer, use the "%p" specifier.

	    Some arithmetic operations has been defined for corresponding
	    C operations.  For example:

		> A = mat[4];
		> p = &A[0];
		> *(p+2) == A[2]
		> ++p
		> *p == A[1]

	    There is at present no protection against "illegal" use of &
	    and *, e.g. if one attempts here to assign a value to *(p+5),
	    or to use p after assigning another value to A.

	    NOTE: Unlike C, in calc &A[0] and A are quite different things.

	    NOTE: If the current value of a variable X is an octet,
	    number or string, *X may be used to to return the value of
	    X; in effect X is an address and *X is the value at X.

	    Added isptr(p) builtin to return 0 is p is not a pointer,
	    >0 if it is a pointer.  The value of isptr(p) comes from the
	    V_XYZ #define (see the top of value.h) of the value to which
	    p points.

	    To allow & to be used as a C-like address operator, use of it
	    has been dropped in calls to user-defined functions.  For the
	    time being I have replaced it by the back-quote `.	For example:

		> global a
		> define f(a,b) = a = b
		> f(&a,5)
		> print a
		0
		> f(`a,5)
		> print a
		5

	   However, one may use & in a similar way as in:

		> define g(a,b) = *a = b
		> g(&a, 7)
		> print a
		7

	   There is no hashvalue for pointers. Thus, like error values,
	   they cannot be used as indices in an association.

	   The -> also works in calc. For example:

		> obj xy {x,y}
		> obj uvw {u, v, w}
		> obj xy A = {1,2}
		> obj uvw B = {3,4,5}
		> p = &A
		> q = &B
		> p->x
			1
		> p->y = 6
		> A
			obj xy {1, 6}
		> q -> u
			3
		> p->y = q
		> A
			obj xy {1, v-ptr: 1400474c0}
		> p->y->u
			3
		> p->y->u = 7
		> B
			obj uvw {7, 4, 5}
		> p -> y = p
		> A
			obj xy {1, v-ptr: 140047490}
		> p -> y -> x
			1
		> p->y->y
			v-ptr: 140047490
		> p->y->y-> x
			1
		> p->y->y->x = 8
		> A
			obj xy {8, v-ptr: 140047490}


	(2) a method of "protecting" variables;

	    For the various kinds of "protection", of an l_value var,
	    bits of var->v_subtype, of which only bits 0 and 1 have been
	    used in the past to indicate literal and allocated strings.
	    This has meant initialization of var->v_subtype when a new var
	    is introduced, and for assignments, etc., examination of the
	    appropriate bits to confirm that the operation is to be permitted.

	    See help/protect for details.

	(3) automatic "freeing" of constants that are no longer required.

	    For the "freeing" of constants, the definition of a NUMBER
	    structure so that a NUMBER * q could be regarded as a
	    pointing to a "freed number" if q->links = 0.

	    The old q->num was changed to a union q->nu which had a pointer
	    to the old q->num if q->links > 0 and to the next freed number
	    if q->links = 0.  The old "num" is #defined to "nu->n_num".

	    The prior method calc has used for handling "constants" amounted
	    to leakage.	 After:

		> define f(x) = 27 + x;
		> a = 27;

	    It is of course necessary for the constant 27 to be stored, but
	    if one now redefines f and a by:

		> define f(x) = 45 + x;
		> a = 45;

	    There seems little point in retaining 27 as a constant and
	    therefore using up memory.	If this example seems trivial,
	    replace 27 with a few larger numbers like 2e12345, or better,
	    -2e12345, for which calc needs memory for both 2e12345 and
	    -2e12345!

	    Constants are automatically freed a definition when a
	    function is re- or un-defined.

	    The qalloc(q) and qfree(q) functions have been changed so
	    that that q->links = 0 is permitted and indicates that q
	    has been freed.  If a number has been introduced as a
	    constant, i.e. by a literal numeral as in the above
	    examples, its links becoming zero indicates that it is no
	    longer required and its position in the table of constants
	    becomes available for a later new constant.

	(4) extension of transcendental functions like tan, tanh, etc.
	    to complex arguments

	(5) definition of gd(z) and agd(z), i.e. the gudermannian and
	    inverse gudermannian

	(6) introduction of show options for displaying information about
	    current constants, global variables, static variables, and cached
	    redc moduli.

	    To help you follow what is going on, the following show
	    items have been introduced:

		show constants ==> display the currently stored constants
		show numbers   ==> display the currently stored numbers
		show redcdata  ==> display the currently stored redc moduli
		show statics   ==> display info about static variables
		show real      ==> display only real-valued variables

	    The constants are automatically initialized as constants and
	    should always appear, with links >= 1, in in the list of constants.

	    The show command:

		show globals

	    has been redefined so that it gives information about all
	    current global and still active static variables.

	(7) definition of functions for freeing globals, statics, redc values

	    To free memory used by different kinds of variable, the following
	    builtins have been added:

		freeglobals();		/* free all globals */
		freestatics();		/* free all statics */
		freeredc();		/* free redc moduli */
		free(a, b, ...);	/* free specific variables */

	   NOTE: These functions do not "undefine" the variables, but
	   have the effect of assigning the null value to them, and so
	   frees the memory used for elements of a list, matrix or object.

	   See 10) below for info about "undefine *".

	(8) enhancement of handling of "old value": having it return an
	    lvalue and giving option of disabling updating.

	    Now, by default, "." return an lvalue with the appropriate
	    value instead of copying the old value.

	    So that a string of commands may be given without changing
	    the "oldvalue", the new builtin:

		saveval(0)

	    function simply disables the updating of the "." value.
	    The default updating can be resumed by calling:

		saveval(1)

	    The "." value:

		> 2 + 2
		4
		> .
		4

	    can now be treated as an unnamed variable.	For example:

		> mat x[3,3]={1,2,3,4,5,6,7,8,9}
		> x
		> print .[1,2]
		6

	(9) for a list L defining L[i] to be same as L[[i]]

	(10) extending undefine to permit its application to all user-defined
	     functions by using "undefine *".

	     The command:

		undefine *

	     undefines all current user-defined functions.  After
	     executing all the above freeing functions (and if
	     necessary free(.) to free the current "old value"), the
	     only remaining numbers as displayed by:

		show numbers

	     should be those associated with epsilon(), and if it has been
	     called, qpi().

	(11) storing the most recently calculated value of qpi(epsilon)i and
	     epsilon so that when called again with the same epsilon it
	     is copied rather than recalculated.

	(12) defining trace() for square matrices

	(13) expression in parentheses may now be followed by a qualifier
	     computable with its type

	     When an expression in parentheses evaluates to an lvalue
	     whose current value is a matrix, list or object, it may
	     now be followed by a qualifier compatible with its type.

	     For example:

		> A = list(1,2,4);
		> B = mat[2,2] = {5,6,7,8};
		> define f(x) = (x ? A : B)[[1]];
		> print f(1), f(0)
		2 6

		> obj xy {x,y}
		> C = obj xy = {4,5}
		> p = &C
		> *p.x
		Not indexing matrix or object
		> (*p).x
		4

	(14) swap(a,b) now permits swapping of octets in the same or different
	     blocks.

	     For example:

		> A = blk() = {1,2,3}
		> B = blk() = {4,5,6}
		> swap(A[0], B[2])
		> A
			chunksize = 256, maxsize = 256, datalen = 3
			060203

    A few bug fixes from Ernest Bowen:

	B1: qcmpi(q, n) in qmath.c sometimes gave the wrong result if
		LONG_BITS > BASEB, len = 1 and nf = 0, since it then
		reduces to the value of (nf != q->num.v[1]) in which
		q->num.v[1] is not part of the size-1 array of HALFs for
		q->num.	 At present this is used only for changing opcodes
		for ^2 and ^4 from sequences involving OP_POWER to
		sequences using OP_SQUARE, which has no effect on the
		results of calculations.

	B2: in matdet(m) in matfunc.c, a copy of the matrix m was not freed
		when the determinant turned out have zero value.

	B3: in f_search() in func.c, a qlinking of the NUMBER * storing the
		the size of a file was not qfreed.

	B4: in comalloc() in commath.c the initial zero values for real and
		imag parts are qlinked but not qfreed when nonzero values are
		assigned to them.  Rather than changing
		the definition of comalloc(), I have included any relevant
		qfrees with the calls to comalloc() as in
			c = comalloc();
			qfree(c->real);
			c->real = ...

	B5: in calls to matsum(), zeros are qlinked but not qfreed.  Rather
		than changing addnumeric(), I have changed the definition
		of matsum(m) so that it simply adds the components of m,
		which requires only that the relevant additions be defined,
		not that all components of m be numbers.


    Simple arithmetic expressions with literal numbers are evaluated
    during compilation rather than execution.  So:

	define f(x) = 2 + 3 + x;

    will be stored as if defined by:

	define f(x) = 5 + x;

    Fixed bug with lowhex2bin conversation in lib_util.c.  It did not
    correctly convert from hex ASCII to binary values due to a table
    loading error.

    Fixed porting problem for NetBSD and FreeBSD by renaming the
    qdiv() function in qmath.c to qqdiv().

    Improved the speed of mfactor (from mfactor.cal library) for
    long Mersenne factorizations.  The default reporting loop
    is now 10000 cycles.

    SGI Mips r10k compile set is speced for IRIX6.5 with v7.2
    compilers.	A note for pre-IRIX6.5 and/or pre-v7.2 compilers
    is given in the compile set.

    Added regression tests related to saveval(), dot and pointers.


The following are the changes from calc version 2.10.3t5.11 to 2.10.3t5.27:

    The todo help file as been updated with the in-progress items:

	xxx - block print function is not written yet ...

    Expanded the role of blk() to produce unnamed blocks as in:

		B = blk(len, chunk)

    and named blocks as in:

		B = blk(str, len, chunk)

    A block may be changed (with possible loss of data only if len is less
    than the old len) by:

		C = blk(B, len, chunk)

    For an unnamed block B, this creates a new block C and copies
    min(len, oldlen) octets to it, B remaining unchanged.   For a named
    block, the block B is changed and C refers to the same block as B,
    so that for example, C[i] = x will result in B[i] == x.  Thus, for a
    named block, "B = " does nothing (other than B = B) in:

		B = blk(B, len, chunk)

    but is necessary for changing an unnamed block.

    Renamed rmblk() to blkfree().

    The builtin function blkfree(val) will free memory allocated to block.
    If val is a named block, or the name of a named block, or the
    identifying index for a named block, blkfree(val) frees the
    memory block allocated to this named block.	 The block remains
    in existence with the same name, identifying index, and chunksize,
    but its size and maxsize becomes zero and the pointer for the start
    of its data block null.

    The builtin function blocks() returns the number of blocks that
    have been created but not freed by the blkfree() function.	When called
    as blocks(id) and the argument id less than the number of named
    blocks that have been created, blocks(id) returns the named block
    with identifying index id.

    Removed the artificial limit of 20 named blocks.

    Added name() builtin to return the name of a type of value
    as a string.

    Added isdefined() to determine of a value is defined.

    Added isobjtype() to determine the type of an object.

    The isatty(v) builtin will return 1 if v is a file that associated
    with a tty (terminal, xterm, etc.) and 0 otherwise.	 The isatty(v)
    builtin will no longer return an error if v is not a file or
    is a closed file.

    The isident(m) builtin will return 1 if m is a  identity matrix
    and 0 otherwise.  The isident(m) builtin will no longer return an
    error if m is not a matrix.

    Added extensive testing of isxxx() builtins and their operations
    on various types.

    Added md5() builtin to perform the MD5 Message-Digest Algorithm.

    Renamed isset() to bit().

    Blocks will expand when required by the copy() builtin function:

	> f = fopen("help/full", "r")
	> B = blk()
	> B
		chunksize = 256, maxsize = 256, datalen = 0
	> copy(B, f)
	> B
		chunksize = 256, maxsize = 310272, datalen = 310084
		2a2a2a2a2a2a2a2a2a2a2a2a2a0a2a20696e74726f0a2a2a2a2a2a2a2a2a...

	NOTE: Your results will differ because changes to help/full.

    The blkcpy() builtin args now more closely match that
    of memcpy(), strncpy:

	blkcpy(dst, src [, num [, dsi [, ssi]]])

    The copy() builtin args now more closely match that the cp command:

	copy(src, dst [, num [, ssi [, dsi]]])

    but otherwise does the same thing as blkcpy.

    Fixed lint problems for SunOS.

    Added have_memmv.c and HAVE_MEMMOVE Makefile variable to control
    use of memmove().  If empty, then memmove() is tested for and if
    not found, or if HAVE_MEMMOVE= -DHAVE_NO_MEMMOVE then an internal
    version of memmove() is used instead.

    Added regression tests for sha, sha1 and md5 builtin hash functions.

    Added xx_print to to the list of object routines are definable.
    Added xx_print.cal to the library to demo this feature.

    Moved blkcpy() routines have been moved to blkcpy.[ch].

    The blkcpy() & copy() builtins can not copy to/from numbers.
    For purposes of the copy, only the numerator is ignored.

    Resolved a number of missing symbols for libcalc users.

    Added lib_util.{c,h} to the calc source to support users of
    libcalc.a.	These utility routines are not directly used by
    calc but are otherwise have utility to those programmers who
    directly use libcalc.a instead.

    Added sample sub-directory.	 This sub-directory contains a few
    sample programs that use libcalc.a.	 These sample programs are
    built via the all rule because they will help check to see that
    libcalc.a library does not contain external references that
    cannot be resolved.	 At the current time none of these sample
    programs are installed.

    Added a libcalc_call_me_last() call to return storage created
    by the libcalc_call_me_first() call.  This allows users of libcalc.a
    to free up a small amount of storage.

    Fixed some memory leaks associated with the random() Blum generator.

    Fixed fseek() file operations for SunOS.

    Fixed convz2hex() fencepost error.	It also removes leading 0's.

    Plugged a memory leak relating to pmod.  The following calculation:

	pmod(2, x, something)

    where x was not 2^n-1 would leak memory.  This has been fixed.


The following are the changes from calc version 2.10.3t5.1 to 2.10.3t5.10:

    Misc printf warning bug fixes.

    Calc now permits chains of initializations as in:

		obj point {x,y} P = {1,2} = {3,4} = {5,6}

    Here the initializations are applied from left to right.  It may
    look silly, but the 1, 2, ... could be replaced by expressions with
    side effects.  As an example of its use suppose A and B are
    expressions with side effects:

		P = {A, B}

    has the effect of P.x = A; P.y = B.	 Sometimes one might want these in
    the reverse order: P.y = B; P.x = A.  This is achieved by:

		P = { , B} = {A}

    Another example of its use:

		obj point Q = {P, P} = {{1, 2}, {3, 4}}

    which results in Q having Q.x.x = 1, Q.x.y = 2, etc.

    The role of the comma in has been changed.	Expressions such as:

		mat A[2], B[3]

    are equivalent to:

		(mat A[2]), (mat B[3])

    Now, expr1, expr2  returns type of expr2 rather than EXPR_RVALUE.  This
    permits expressions such as:

		(a = 2, b) = 3

    Also, expr1 ? expr2 : expr3	 returns type(expr2) | type(expr3).
    This will make the result an lvalue (i.e. EXPR_RVALUE bit not set)
    For example, if both expr2 and expr3 are lvalues.  Then:

		a ? b : c = d

    has the effect of b = d if a is "nonzero", otherwise c = d.

    This may be compared with

		d = a ? b : c

    which does d = b if a is "nonzero", otherwise d = c.

    And now, expr1 || expr2 and expr1 && expr2 each return
    htype(expr1)| type(expr2).	So for example:

		a || b = c

    has the effect of a = c if a is "nonzero", otherwise b = c.
    And for example:

		a && b = c

    has the effect of a = c if a is "zero", otherwise b = c.

    At top level, newlines are neglected between '(' and the matching
    ')' in expressions and function calls.  For example, if f() has been
    already defined, then:


		a = (
			2
			+
			f
			(
			3
			)
		    )

    and

		b = sqrt (
			20
			,
			1
		    )

    will be accepted, and in interactive mode the continue-line prompt
    will be displayed.

    When calc sees a "for", "while", "do", or "switch", newlines will be
    ignored (and the line-continuation prompt displayed in interactive mode)
    until the expected conditions and statements are completed.
    For example:

	s = 0;
	for (i = 0; i < 5; i++)
	{
		s += i;
	}
	print s;

    Now 's' will print '10' instead of '5'.

    Added more regression tests to regress.cal.	 Changed the error
    counter from 'err' to 'prob'.  The errmax() is set very high and
    the expected value of errcount() is kept in ecnt.

    Added the 'unexpected' help file which gives some unexpected
    surprises that C programmers may encounter.

    Updated the 'help', 'intro' and 'overview' to reflect the
    full list of non-builtin function help files.  Reorered the
    'full' help file.

    The blkalloc() builtin has been renamed blk().

    Only a "fixed" type of BLOCK will be used.	Other types of
    blocks in the future will be different VALUE types.

    Introduced an undefine command so that

		    undefine f, g, ...

    frees the memory used to store code for user-defined functions f,
    g, ..., effectively removing them from the list of defined
    functions.

    When working from a terminal or when config("lib_debug") > 0 advice
    that a function has been defined, undefined, or redefined is
    displayed in format "f() defined".

    Some experimental changes to block and octet handling, so that after:

		    B = blk(N)

    B[i] for 0 <= i < N behaves for some operations like an lvalue for
    a USB8 in B.

    xx_assign added to object functions to permit the possibility of
    specifying what A = B will do if A is an xx-object.	 Normal
    assignment use of = is restored by the command: undefine
    xx_assign.

    For error-value err, errno(err) returns the error-code for err and
    stores this in calc_errno;	error(err) returns err as if
    error(errno(err)) were called.

    Anticipating probable future use, names have been introduced for
    the four characters @, #, $, `.  This completes the coverage of
    printable characters on a standard keyboard.

    Added sha() builtin to perform the old Secure Hash Algorithm
    (SHS FIPS Pub 180).

    Added sha1() builtin to perform the new Secure Hash Standard-1
    (SHS-1 FIPS Pub 180-1).

    Added ${LD_DEBUG} Makefile variable to allow for additional
    libraries to be compiled into calc ... for debugging purposes.
    In most cases, LD_DEBUG= is sufficient.

    Added ${CALC_ENV} makefile variable to allow for particular
    environment variables to be supplied for make {check,chk,debug}.
    In most cases, CALC_ENV= CALCPATH=./lib is sufficient.

    Added ${CALC_LIBS} to list the libraries created and used to
    build calc.	 The CALC_LIBS= custom/libcustcalc.a libcalc.a
    is standard for everyone.

    Improved how 'make calc' and 'make all' rules work with respect
    to building .h files.

    Added 'make run' to only run calc interactively with the
    ${CALC_ENV} calc environment.  Added 'make cvd', 'make dbx'
    and 'make gdb' rules to run debug calc with the respective
    debugger with the ${CALC_ENV} calc environment.

    Added cvmalloc_error() function to lib_calc.c as a hook for
    users of the SGI Workshop malloc debugging library.

    Cut down on places where *.h files include system files.
    The *.c should do that instead where it is reasonable.

    To avoid symbol conflicts, *.h files produced and shipped
    with calc are enclosed that as similar to the following:

	#if !defined(__CALC_H__)
	#define __CALC_H__
	..
	#endif /* !__CALC_H__ */

    Added memsize(x) builtin to print the best approximation of the
    size of 'x' including overhead.  The sizeof(x) builtin attempts
    to cover just the storage of the value and not the overhead.
    Because -1, 0 and 1 ZVALUES are static common values, sizeof(x)
    ignores their storage.  Also sizeof(x) ignores the denominator of
    integers, and the imaginary parts of pure real numbers.  Added
    regression tests for memsize(), sizeof() and size().


The following are the changes from calc version 2.10.3t4.16 to 2.10.3t5.0:

    The calc source now comes with a custom sub-directory which
    contains the custom interface code.	 The main Makefile now
    drives the building and installing of this code in a similar
    way that it drives the lib and help sub-directories.  (see below)

    Made minor edits to most help files beginning with a thru e.

    The errno(n) sets a C-like errno to the value n; errno() returns
    the current errno value.  The argument for strerror() and error()
    defaults to this errno.

    Added more error() and errno() regression tests.

    The convention of using the global variable lib_debug at the
    end of calc library scripts has been replaced with config("lib_debug").
    The "lib_debug" is reserved by convention for calc library scripts.
    This config parameter takes the place of the lib_debug global variable.
    By convention, "lib_debug" has the following meanings:

	<-1	no debug messages are printed though some internal
		    debug actions and information may be collected

	-1	no debug messages are printed, no debug actions will be taken

	0	only usage message regarding each important object are
		    printed at the time of the read (default)

	>0	messages regarding each important object are
		    printed at the time of the read in addition
		    to other debug messages

    The "calc_debug" is reserved by convention for internal calc routines.
    The output of "calc_debug" will change from release to release.
    Generally this value is used by calc wizards and by the regress.cal
    routine (make check).  By convention, "calc_debug" has the following
    meanings:

	<-1	reserved for future use

	-1	no debug messages are printed, no debug actions will be taken

	0	very little, if any debugging is performed (and then mostly
		    in alpha test code).  The only output is as a result of
		    internal fatal errors (typically either math_error() or
		    exit() will be called). (default)

	>0	a greater degree of debugging is performed and more
		    verbose messages are printed (regress.cal uses 1).

    The "user_debug" is provided for use by users.  Calc ignores this value
    other than to set it to 0 by default (for both "oldstd" and "newstd").
    No calc code or shipped library will change this value other than
    during startup or during a config("all", xyz) call.

    The following is suggested as a convention for use of "user_debug".
    These are only suggestions: feel free to use it as you like:

	<-1	no debug messages are printed though some internal
		    debug actions and information may be collected

	-1	no debug messages are printed, no debug actions will be taken

	0	very little, if any debugging is performed.  The only output
		    are from fatal errors. (default)

	>0	a greater degree of debugging is performed and more
		    verbose messages are printed

    Added more code related to the BLOCK type.

    Added blkalloc() builtin.

    Split NAMETYPE definition out into nametype.h.

    Added OCTET type for use in processing block[i].

    Added free, copy, cmp, quickhash and print functions for
    HASH, BLOCK and OCTET.

    Added notes to config.h about what needs to be looked at when
    new configuration items are added.

    The null() builtin now takes arguments.

    Given the following:

	obj point {x,y}
	obj point P, Q

    will will now create P and Q as obj point objects.

    Added xx_or, xx_and, xx_not and xx_fact objfuncs.

    Added the custom() builtin function.  The custom() builtin
    interface is designed to make it easier for local custom
    modification to be added to calc.  Custom functions are
    non-standard or non-portable code.	For these reasons, one must can
    only execute custom() code by way of an explicit action.

    By default, custom() returns an error.  A new calc command line
    option of '-C' is required (as well as ALLOW_CUSTOM= -DCUSTOM
    Makefile variable set) to enable it.

    Added -C as a calc command line option.  This permits the
    custom() interface to be used.

    Added ALLOW_CUSTOM Makefile variable to permanently disable
    or selective enable the custom builtin interface.

    The rm() builtin now takes multiple filenames.  If the first
    arg is "-f", then 'no-such-file' errors are ignored.

    Added errcount([count]) builtin to return or set the error
    counter.  Added errmax([limit]) to return or set the error
    count limiter.

    Added -n as a calc command line option.  This has the effect
    of calling config("all", "newstd") at startup time.

    Added -e as a calc command line option to ignore all environment
    variables at startup time.	The getenv() builtin function will
    still return values, however.

    Added -i as a calc command line option.  This has the effect
    ignoring when errcount() exceeds errmax().

    Changed the config("maxerr") name to config("maxscan").  The
    old name of "maxerr" is kept for backward compatibility.

    Using an unknown -flag on the calc command like will
    generate a short usage message.

    Doing a 'help calc' displays the same info as 'help usage'.

    The 'make check' rule now uses the -i calc command line flag
    so that regress.cal can continue beyond when errcount exceeds
    errmax.  In regress.cal, vrfy() reports when errcount exceeds
    errmax and resets errmax to match errcount.	 This check
    and report is independent of the test success of failure.

    Fixed missing or out of order tests in regress.cal.

    Misc Makefile cleanup in lib/Makefile and help/Makefile.

    The default errmax() value on startup is now 20.

    The custom() interface is now complete.  See help/custom and
    custom/HOW_TO_ADD files, which show up as the custom and new_custom
    help files, for more information.

    The help command will search ${LIBDIR}/custhelp if it fails to find
    a file in ${LIBDIR}.  This allows the help command to also print
    help for a custom function.	 However if a standard help file and a
    custom help file share the same name, help will only print the
    standard help file.	 One can skip the standard help file and print
    the custom help file by:

	help custhelp/name

    or by:

	custom("help", "name")

    Added minor sanity checks the help command's filename.

    Added show custom to display custom function information.

    Added the contrib help page to give information on how
    and where to submit new calc code, modes or custom functions.

    Added comment information to value.h about what needs to be
    checked or modified when a new value type is added.

    Both size(x) and sizeof(x) return information on all value types.
    Moved size and sizeof information from func.c and into new file: size.c.

    Added custom("devnull") to serve as a do-nothing interface tester.

    Added custom("argv" [,arg ...]) to print information about args.

    Added custom("sysinfo", "item") to print an internal calc #define
    parameter.

    The make depend rule also processes the custom/Makefile.

    Added xx_max and xx_min for objfuncs.

    The max(), min() builtins work for lists.


The following are the changes from calc version 2.10.3t3 to 2.10.3t4.15:

    The priority of unary + and - to that of binary + and - when they are
    applied to a first or only term.  Thus:

	-16^-2 == -1/256
	-7^2 == -49
	-3! == -6

    Running ranlib is no longer the default.  Systems that need RANLIB
    should edit the Makefile and comment back in:

	RANLIB=ranlib

    Dropped support of SGI r8k.

    Added support for the SGI r5k.

    Added support for SGI Mips compiler version 7.1 or later.

    Removed "random" as a config() option.

    Removed CCZPRIME Makefile variable.

    Added zsquaremod() back into zmod.c to be used by the Blum-Blum-Shub
    generator for the special case of needing x^2 mod y.

    Moved the Blum-Blum-Shub code and defines from zrand.c and zrand.h
    into zrandom.c and zrandom.h.  Now only the a55 generator resides
    in zrand.c and zrand.h.

    Added random, srandom and randombit help files.

    Added random(), srandom() and randombit() builtin functions.  The
    cryptographically strong random number generator is code complete!

    Removed cryrand.cal now that a Blum-Blum-Shub generator is builtin.

    Improved the speed of seedrandom.cal.  It now uses the 13th
    builtin Blum-Blum-Shub seed.

    The randmprime.cal script makes use of the Blum-Blum-Shub generator.

    Added randombitrun.cal and randomrun.cal calc library files.
    These are the Blum-Blum-Shub analogs to the randbitrun.cal
    and randrun.cal a55 tests.

    Improved hash.c interface to lower level hash functions.  The hash
    interface does not yet have a func.c interface ...	it is still
    under test.

    Added randombitrun.cal to test the Blum-Blum-Shub generator.

    Added calc.h, hash.h, shs.h and value.h to LIB_H_SRC because some
    of the libcalc.a files need them.

    In the original version, each call to newerror(str) created a new
    error-value.  Now a new value will be created only if str has not
    been used in a previous call to newerror().	 In effect, the string
    serves to identify the error-value; for example:

	    return newerror("Non-integer argument");

    can be used in one or more functions, some of which may be
    repeatedly called, but after it has been called once, it will
    always return the same value as if one had initially used the
    assignment:

	    non_integer_argument_error = newerror("Non-integer argument")

    and then in each function used:

	    return non_integer_argument_error;

    The new definition of newerror() permits its freer use in cases like:

	    define foo(a) {

		    if (!isint(a))
			    return newerror("Non-integer argument");
		    ...
	    }

    One might say that "new" in "newerror" used to mean being different
    from any earlier error-value.  Now it means being not one of the
    "original" or "old" error-values defined internally by calc.

    As newerror() and newerror("") specify no non-null string, it has
    been arranged that they return the same as newerror("???").

    Added "show errors" command analogous to "show functions" for
    user-defined functions.  One difference is that whereas the
    functions are created by explicit definitions, a new described
    error is created only when a newerror(...) is executed.

    Fixed macro symbol substitution problem uncovered by HPUX cpp bug in
    HVAL and related zrand.h macros.

    Added +e to CCMISC for HP-UX users.

    Fixed the prompt bug.

    Eliminated the hash_init() initialization function.

    The 'struct block' has been moved from value.c to a new file: block.h.

    Added "blkmaxprint" config value, which limits the octets to print
    for a block.  A "blkmaxprint" of 0 means to print all octets of a
    block, regardless of size.	The default is to print only the first
    256 octets.

    The "blkverbose" determines if all lines, including duplicates
    should be printed.	If TRUE, then all lines are printed.  If false,
    duplicate lines are skipped and only a "*" is printed in a style
    similar to od.  This config value has not meaning if "blkfmt" is
    "str".  The default value for "blkverbose" is FALSE: duplicate
    lines are not printed.

    The "blkbase" determines the base in which octets of a block
    are printed.  Possible values are:

	"hexadecimal"		Octets printed in 2 digit hex
	"hex"

	"octal"			Octets printed in 3 digit octal
	"oct"

	"character"		Octets printed as chars with non-printing
	"char"			    chars as \123 or \n, \t, \r

	"binary"		Octets printed as 0 or 1 chars
	"bin"

	"raw"			Octets printed as is, i.e. raw binary
	"none"

    The default "blkbase" is "hex".

    The "blkfmt" determines for format of how block are printed:

	"line"		print in lines of up to 79 chars + newline
	"lines"

	"str"		print as one long string
	"string"
	"strings"

	"od"		print in od-like format, with leading offset,
	"odstyle"	   followed by octets in the given base
	"od_style"

	"hd"		print in hex dump format, with leading offset,
	"hdstyle"	   followed by octets in the given base, followed
	"hd_style"	   by chars or '.' if no-printable or blank

    The default "blkfmt" is "hd".

    Fixed a bug in coth() when testing acoth using coth(acoth(x)) == x
    within the rounding error.

    Assignments to matrices and objects has been changed.  The assignments in:

	A = list(1,2,3,4);
	B = makelist(4) = {1,2,3,4};

    will result in A == B.  Then:

	A = {,,5}

    will result in A == list(1,2,5,4).

    Made minor edits to most help files beginning with a thru d.

    Fixed error in using cmdbuf("").


The following are the changes from calc version 2.10.3t0 to 2.10.3t2:

    Bumped to version 2.10.3 due to the amount of changes.

    Renamed qabs() to qqabs() to avoid conflicts with stdlib.h.

    Fixed a casting problem in label.c.

    A lot of work was performed on the code generation by Ernest Bowen
    <ernie at turing dot une dot edu dot au>.	 Declarations no longer
    need to precede code:

	define f(x) {
		local i = x^2;
		print "i = ":i;
		local j = i;
		...
	}

    The scope of a variable extends from the end of the declaration (including
    initialization code for the variable) at which it is first created
    to the limit given by the following rules:

	local variable: to the end of the function being defined

	global variable: to the end of the session with calc

	static within a function definition: to the the first of:

	    an end of a global, static or local declaration (including
	    initialization code) with the same identifier

	    the end of the definition

	static at top level within a file: to the first of:

	    the next static declaration of the identifier at top level
	    in the file,

	    the next global declaration of the identifier at top level
	    in the file or in any function definition in the file,

	    the next global declaration of the identifier at any level
	    in a file being read as a result of a "read" command,

	    the end of the file.

    The scope of a top-level global or static variable may be
    interrupted by the use of the identifier as a parameter or local or
    static variable within a function definition in the file being
    read; it is restored (without change of value) after the definition.

    For example, The two static variables a and b are created,
    with zero value, when the definition is read; a is initialized
    with the value x if and when f(x) is first called with a positive
    even x, b is similarly initialized if and when f(x) is first called
    positive odd x.  Each time f(x) is called with positive integer x,
    a or b is incremented.  Finally the values of the static variables
    are assigned to the global variables a and b, and the resulting
    values displayed.  Immediately after the last of several calls to
    f(x), a = 0 if none of the x's have been positive even, otherwise
    a = the first positive even x + the number of positive even x's,
    and b = 0 if none of the x's have been positive odd, otherwise
    b = the first positive odd x + the number of positive odd x's:

	define f(x) {
		if (isint(x) && x > 0) {
			if (iseven(x)) {
				static a = x;
				a++;
			} else {
				static b = x;
				b++;
			}
		}
		global a = a, b = b;
		print "a =",a,"b =",b;
	}

    Fixed some faults in the handling of syntax errors for the matrix
    and object creation operators mat and obj.	In previous versions of calc:

	mat;				<- Bad dimension 0 for matrix
	mat A;				<- Bad dimension 0 for matrix
	global mat A;			<- Bad dimension 0 for matrix
	mat A[2], mat B[3]		<- Semicolon expected
	global mat A[2], mat B[3]	<- Bad syntax in declaration statement

    Now:

	this statement			has the same effect as
	--------------			----------------------
	mat A[2], B[3]			(A = mat[2]), B[3]

	global mat A[2], B[3]		global A, B; A = mat[2]; B = mat[3];

    Initialization remains essentially as before except that for objects,
    spaces between identifiers indicate assignments as in simple variable
    declarations.  Thus, after:

	obj point {x,y};
	obj point P, Q R = {1,2}

    P has {0,0}, Q and R have {1,2}.  In the corresponding expression with
    matrices commas between identifiers before the initialization are ignored.
    For example:

	this statement			has the same effect as
	--------------			----------------------
	mat A, B C [2] = {1,2}		A = B = C = (mat[2] = {1,2})

    One can also do things like:

	L = list(mat[2] = {1,2}, obj point = {3,4}, mat[2] = {5,6})
	A = mat[2,2] = {1,2,3,4}^2
	B = mat[2,2] = {1,2,3,4} * mat[2,2] = {5,6,7,8}

    where the initialization = has stronger binding than the assignment = and
    the * sign.

    Matrices and objects can be mixed in declarations after any simple
    variables as in:

	global a, b, mat A, B[2] = {3,4}, C[2] = {4,5}, obj point P = {5,6}, Q

    Fixed some bugs related to global and static scoping.  See the the
    5200 regress test and lib/test5200.cal for details.

    Optimized opcode generator so that functions defined using '=' do not
    have two unreached opcodes.	 I.e.,:

	define f(x) = x^2
	show opcodes f

    Also unreachable opcodes UNDEF and RETURN are now not included at
    the end of any user-defined function.

    Changed the "no offset" indicator in label.c from 0 to -1; this
    permits goto jumps to the zero opcode position.

    Changed the opcode generation for "if (...)" followed by
    "break", "continue", or "goto", so that only one jump opcode is
    required.

    A label can now be immediately by a right-brace.  For example:

	define test_newop3(x) {if (x < 0) goto l132; ++x; l132: return x;}

    The LONG_BITS make variable, if set, will force the size of a long
    as well as forcing the USB8, SB8, USB16, SB16, USB32, SB32,
    HAVE_B64, USB64, SB64, U(x) and L(x) types.	 If the longbits
    program is given an arg (of 32 or 64), then it will output
    based on a generic 32 or 64 bit machine where the long is
    the same size as the wordsize.

    Fixed how the SVAL and HVAL macros were formed for BASEB==16 machines.

    Dropped explicit Makefile support for MIPS r8k since these processors
    no longer need special compiler flags.

    SGI 6.2 and later uses -xansi.


The following are the changes from calc version 2.10.2t33 to 2.10.2t34:

    Fixed a bug related to fact().

    Thanks to Ernest Bowen <ernie at turing dot une dot edu dot au>,
    for two or three arguments,

	    search(x, val, start);
	    rsearch(x, val, start);

    and for matrix, list or association x:

	    search(f, str, start);
	    rsearch(f, str, start);

    for a file stream f open for reading, behave as before except for a few
    differences:

	(1) there are no limits on the integer-valued start.

	(2) negative values of start are interpreted as offsets from the size of
	    x and f.  For example,

		    search(x, val, -100)

	    searches the last 100 elements of x for the first i for which
	    x[[i]] = val.

	(3) for a file f, when start + strlen(str) >= size(f) and
	    search(f, str, start) returns null, i.e. str is
	    not found, the file position after the search will be

		    size(f) - strlen(str) + 1

	    rather than size(f).

    For four arguments:

	    search(a, b, c, d)
	    rsearch(a, b, c, d),

    a has the role of x or f, and b the role of val or str as described
    above for the three-argument case, and for search(), c is
    essentially "start" as before, but for rsearch() is better for c
    and d to be the same as for search().  For a non-file case, if:

	     0 <= c < d <= size(a),

    the index-interval over which the search is to take place is:

	     c <= i < d.

    If the user has defined a function accept(v,b), this is used rather
    than the test v == b to decide for matrix, list, or association
    searches when a "match" of v = a[[i]] with b occurs. E.g.  after:

	     define accept(v,b) = (v >= b);

    then calling:

	     search(a, 5, 100, 200)

    will return, if it exists, the smallest index i for which
    100 <= i < 200 and a[[i]] >= 5.  To restore the effect of
    the original "match" function, one would then have to:

	     define accept(v,b) == (v == b).

    Renamed the calc symbol BYTE_ORDER to CALC_BYTE_ORDER in order
    to avoid conflict.

    Added beer.cal and hello.cal lib progs in support of:   :-)

	http://www.ionet.net/~timtroyr/funhouse/beer.html
	http://www.latech.edu/~acm/HelloWorld.shtml


The following are the changes from calc version 2.10.2t25 to 2.10.2t32:

    Eliminated use of VARARG and <varargs.h>.  Calc supports only
    <stdarg.h>.	 The VARARGS Makefile variable has been eliminated.

    Source is converted to ANSI C.  In particular, functions
    will now have ANSI C style args.  Any comments from old K&R
    style args have been moved to function comment section.

    Removed prototype.h.  The PROTO() macro is no longer needed
    or supported.

    Added mfactor.cal to find the smallest factor of a Mersenne number.

    The built .h file: have_times.h, determines if the system has
    <time.h>, <times.h>, <sys/time.h> and <sys/times.h>.

    Because shs.c depends on HASHFUNC, which in turn depends on
    VALUE, shs.o has been moved out of libcalc.a.  For the same
    reasons, hash.h and shs.h are not being installed into
    the ${LIBDIR} for now.

    A number of the regression tests that need random numbers now
    use different seeds.

    Fixes for compiling under BSDI's BSD/OS 2.0.  Added a Makefile
    section for BSD/OS.

    Added a Makefile compile section for Dec Alpha without gcc ...
    provides a hack-a-round for Dec Alpha cc bug.

    Minor comment changes to lucas.cal.

    Added pix.cal, a slow painful but interesting way to compute pix(x).

    Confusion over the scope of static and global values has been reduced
    by a patch from Ernest Bowen <ernie at turing dot une dot edu dot au>.

	The change introduced by the following patch terminates the
	scope of a static variable at any static declaration with the
	same name at the same level, or at any global declaration with
	the same name at any level.  With the example above, the scope
	of the static "a" introduced in the third line ends when the
	"global a" is read in the last line.  Thus one may now use the
	same name in several "static" areas as in:

			> static a = 10;
			> define f(x) = a + x;
			> static a = 20;
			> define g(x) = a + x;
			> global a;

	The first "a" exists only for the definition of f(); the second
	"a" only for the definition of g().  At the end one has only
	the global "a".

	Ending the scope of a static variable in this way is consistent
	with the normal use of static variables as in:

			> static a = 10;
			> define f(x) {static a = 20; return a++ + x;}
			> define g(x) = a + x;
			> global a;

	The scope of the first "a" is temporarily interrupted by the
	"static a" in the second line; the second "a" remains active
	until its scope ends with the ending of the definition of f().
	Thus one ends with g(x) = 10 + x and on successive calls to
	f(), f(x) returns 20 + x, 21 + x, etc.	With successive "static
	a" declarations at the same level, the active one at any stage
	is the most recent; if the instructions are being read from a
	file, the scope of the last "static a" ends at the end-of-file.

	Here I have assumed that no "global a" is encountered.	As
	there can be only one global variable with name "a", it seems
	to me that its use must end the scope of any static "a".  Thus
	the changes I introduce are such that after:

			> global a = 10;
			> define f(x) = a + x;
			> static a = 20;
			> define g(x) = a + x;
			> define h(x) {global a = 30; return a + x;}
			> define i(x) = a + x;

	g(x) will always return 20 + x, and until h(x) has been called,
	f(x) and i(x) will return 10 + x; when h(x) is called, it
	returns 30 + x and any later call to f(x) or i(x) will return
	30 + x.	 It is the reading of "global a" in the definition of
	h() that terminates the scope of the static a = 20, so that the
	"a" for the last line is the global variable defined in the
	first line.  The "a = 30" is executed only when h() is called.

	Users who find this confusing might be well advised to use
	different names for different variables at the same scope level.

	The other changes produced by the patch are more straightforward,
	but some tricky programming was needed to get the possibility of
	multiple assignments and what seems to be the appropriate order
	of executions and assignments.	For example, the order for the
	declaration:

		global a, b = expr1, c, d = expr2, e, f

	will be:

		evaluation of expr1;
		assignment to b;
		evaluation of expr2;
		assignment to d;

	Thus the effect is the same as for:

		a = 0; b = expr1; c = 0; d = expr2; e = 0; f = 0;

	The order is important when the same name is used for different
	variables in the same context.	E.g. one may have:

		define f(x) {
			global a = 10;
			static a = a;
			local a = a--;

			while (--a > 0)
				x++;
			return x;
		}

	Every time this is called, the global "a" is assigned the value
	10.  The first time it is called, the value 10 is passed on to
	the static "a" and then to the local "a".  In each later call
	the "static a = a" is ignored and the static "a" is one less than
	it was in the preceding call.  I'm not recommending this style of
	programming but it is good that calc will be able to handle it.

	I've also changed dumpop to do something recent versions do not do:
	distinguish between static and global variables with the same name.

	Other changes: commas may be replaced by spaces in a sequence of
	identifiers in a declaration. so one may now write:

		global a b c = 10, d e = 20

	The comma after the 10 is still required.  Multiple occurrences
	of an identifier in a local declaration are now acceptable as
	they are for global or static declarations:

		local a b c = 10, a = 20;

	does the same as:

		local a b c;
		a = b = c = 10;
		a = 20;

	The static case is different in that:

		static a b c = 10, a = 20;

	creates four static variables, the first "a" having a very short and
	useless life.

    Added new tests to verify the new assignments above.

    Added the builtin test(x) which returns 1 or 0 according as x tests
    as true or false for conditions.

    Added have_posscl.c which attempts to determine if FILEPOS is
    a scalar and defines HAVE_FILEPOS_SCALAR in have_posscl.h
    accordingly.  The Makefile variable HAVE_POSSCL determines
    if have_posscl.c will test this condition or assume non-scalar.

    Added have_offscl.c which attempts to determine if off_t is
    a scalar and defines HAVE_OFF_T_SCALAR in have_posscl.h
    accordingly.  The Makefile variable HAVE_OFFSCL determines
    if have_offscl.c will test this condition or assume non-scalar.

    Reading to EOF leaves you positioned one character beyond
    the last character in the file, just like Un*x read behavior.

    Calc supports files and offsets up to 2^64 bytes, if the OS
    and file system permits.


The following are the changes from calc version 2.10.2t4 to 2.10.2t24:

    Added makefile debugging rules:

	make chk	like a 'make check' (run the regression tests)
			except that only a few lines around interesting
			(and presumable error messages) are printed.
			No output if no errors are found.

	make env	print important makefile values

	make mkdebug	'make env' + version information and a
			make with verbose output and printing of
			constructed files

	make debug	'make mkdebug' with a 'make clobber'
			so that the entire make is verbose and
			a constructed files are printed

     Improved instructions in 'BUGS' section on reporting problems.
     In particular we made it easy for people to send in a full
     diagnostic output by sending 'debug.out' which is made as follows:

	make debug > debug.out

     Added -v to calc command line to print the version and exit.

     Fixed declarations of memcpy(), strcpy() and memset() in the
     case of them HAVE_NEWSTR is false.

     Fixed some compile time warnings.

     Attempting to rewind a file this is not open generates an error.

     Noted conversion problems in file.c in triple X comments.

     Some extremely brain dead shells cannot correctly deal with if
     clauses that do not have a non-empty else statement.  Their
     exit bogosity results in make problems.  As a work-a-round,
     Makefile if clauses have 'else true;' clauses for if statements
     that previously did not have an else clause.

     Fixed problems where the input stack depth reached the 10 levels.

     The show keyword is now a statement instead of a command:

	> define demo() {local f = open("foo", "w"); show files; fclose(f);}
	> demo()

     Added a new trace option for display of links to real and complex
     numbers.  This is activated by config("trace", 4).  The printing of
     a real number is immediately followed by "#" and the number of links
     to that number; complex numbers are printed in the same except for
     having "##" instead of "#".  <ernie at turing dot une dot edu dot au>

     The number of links for a number value is essentially the number of value
     locations at which it is either stored or deemed to be stored.  Here a
     number value is the result of a reading or evaluation; when the result
     is assigned to lvalues, "linking" rather than copying occurs.  Different
     sets of mutually linked values may contain the same number.  For example:

	a = b = 2 + 3; x, y = 2 + 3;

     a and b are linked, and x and y are linked, but a and x are not linked.

     Revised the credits help file and man page.  Added archive help
     file to indicate where recent versions of calc are available.

     The regression test suite output has been changed so that it will
     output the same information regardless of CPU performance.	 In
     particular, cpu times of certain tests are not printed.  This allows
     one to compare the regression output of two different systems easier.

     A matrix or object declaration is now considered an expression
     and returns a matrix or object of the specified type.  Thus one may
     use assignments like:

	A = mat[2];		/* same as: mat A[2]; */
	P = obj point;		/* same as: obj point P; */

     The obj and mat keywords may be with "local", "global", "static" as in:

	local mat A[2];

     Several matrices or objects may be assigned or declared in the one
     statement, as in:

	mat A, B[2], C[3];	/* same as: mat A[2], B[2], C[3] */

     except that only one matrix creation occurs and is copied as in:

	A = B = mat[2];

     Initialization of matrices and objects now occur before assignments:

	mat A, B [2] = {1,2};	/* same as: A = B = (mat[2] = {1,2}); */

     Missing arguments are considered as "no change" rather than
     "assign null values".  As in recent versions of calc, the default
     value assigned to matrix elements is zero and the default for object
     elements is a null value).	 Thus:

	mat A[2] = {1,2};
	A = { , 3};

     will change the value of A to {1,3}.

     If the relevant operation exists for matrices or has been defined for
     the type of object A is, the assignment = may be combined with +, -, *,
     etc. as in:

	A += {3, 4};		/* same as: A[0] += 3; A[1] += 4; */
	A += { };		/* same as: A += A; */

     In (non-local) declarations, the earlier value of a variable may be
     used in the initialization list:

	mat A[3]={1,2,3}; mat A[3]={A[2],A[1],A[0]}; /* same as: A={3,2,1} */

     Also:

	mat A[3] = {1,2,3};
	mat A[3] = {A, A, A};

     produces a 3-element matrix, each of whose elements is a 3-element matrix.

     The notation A[i][j] requires A[i] to be a matrix, whereas B[i,j]
     accesses an element in a 2-dimensional matrix.  Thus:

	B == A[i]	implies		A[i][j] = B[j]

     There is requirement in the use of A[i][j] that the matrices A[i]
     for i = 0, 1, ... all be of the same size.	 Thus:

	mat A[3] = {(mat[2]), (mat[3]), (mat[2])};

     produces a matrix with a 7-element structure:

	A[0][0], A[0][1], A[1][0], A[1][1], A[1][2], A[2][0], A[2][1]

     One can initialize matrices and objects whose elements are matrices
     and/or objects:

	obj point {x,y}
	obj point P;
	obj point A = {P,P};

     or:

	obj point {x,y};
	obj point P;
	mat A[2] = {P,P};
	A = {{1,2}, {3,4}};

     The config("trace", 8) causes opcodes of newly defined functions
     are displayed.  Also show can now show the opcodes for a function.
     For example:

	config("trace", 8);
	define f(x) = x^2;
	show opcodes f;
	define g(x,y) {static mat A[2]; A += {x,y}; return A;}
	show opcodes g
	g(2,3);
	show opcodes g;
	g(3,4);

     The two sequences displayed for f should show the different ways
     the parameter is displayed.  The third sequence for g should also
     show the effects of the static declaration of A.

     Fixed a number of compiler warning and type cast problems.

     Added a number of new error codes.

     Misc bug fixes for gcc2 based Sparc systems.

     Fixed a bug in the SVAL() macro on systems with 'long long'
     type and on systems with 16 bit HALFs.

     Reduced the Makefile CC set:

	 CCOPT are flags given to ${CC} for optimization
	 CCWARN are flags given to ${CC} for warning message control
	 CCMISC are misc flags given to ${CC}

	 CFLAGS are all flags given to ${CC}
		[[often includes CCOPT, CCWARN, CCMISC]]
	 ICFLAGS are given to ${CC} for intermediate progs

	 CCMAIN are flags for ${CC} when files with main() instead of CFLAGS
	 CCSHS are flags given to ${CC} for compiling shs.c instead of CFLAGS

	 LCFLAGS are CC-style flags for ${LINT}
	 LDFLAGS are flags given to ${CC} for linking .o files
	 ILDFLAGS are flags given to ${CC} for linking .o files
		  for intermediate progs

	 CC is how the the C compiler is invoked

    Added more tests to regress.cal.

    Port to HP-UX.

    Moved config_print() from config.c to value.c so prevent printvalue()
    and freevalue() from being unresolved symbols for libcalc.a users.

    Calc will generate "maximum depth reached" messages or errors when
    reading or eval() is attempted at maximum input depth.

    Now each invocation of make is done via ${MAKE} and includes:

	MAKE_FILE=${MAKE_FILE}
	TOPDIR=${TOPDIR}
	LIBDIR=${LIBDIR}
	HELPDIR=${HELPDIR}

    Setting MAKE_FILE= will cause make to not re-make if the Makefile
    is edited.

    Added libinit.c which contains the function libcalc_call_me_first().
    Users of libcalc.a MUST CALL libcalc_call_me_first BEFORE THEY USE
    ANY OTHER libcalc.a functions!

    Added support for the SGI IRIX6.2 (or later) Mongoose 7.0 (or later)
    C Compiler for the r4k, r8k and r10k.  Added LD_NO_SHARED for
    non-shared linker support.

    Re-ordered and expanded options for the DEBUG make variable.

    Make a few minor cosmetic comment changes/fixes in the main Makefile.

    Statements such as:

		mat A[2][3];

    now to the same as:

		mat M[3];
		mat A[2] = {M, M};

    To initialize such an A one can use a statement like

		A = {{1,2,3}, {4,5,6}};

    or combine initialization with creation by:

		mat A[2][3] = {{1,2,3}, {4,5,6}};

    One would then have, for example, A[1][0] = 4.  Also, the inner braces
    cannot be removed from the initialization for A:

		mat A[2][3] = {1,2};

    results in exactly the same as:

		mat A[2] = {1,2};

    Added rm("file") builtin to remove a file.

    The regress test sections that create files also use rm() to remove
    them before and afterward.

    Added 4400-4500 set to test new mat and obj initialization rules.

    Added 4600 to test version file operations.

    Added CCZPRIME Makefile variable to the set for the short term
    to work around a CC -O2 bug on some SGI machines.

    Added regression test of _ variables and function names.

    Added read of read and write, including read and write test for
    long strings.

    Fixed bug associated with read of a long string variable.

    Renumbered some of the early regress.cal test numbers to make room
    for more tests.  Fixed all out of sequence test numbers.  Fixed some
    malformed regression reports.

    Renamed STSIZE_BITS to OFF_T_BITS.	Renamed SWAP_HALF_IN_STSIZE to
    SWAP_HALF_IN_OFF_T.


The following are the changes from calc version 2.10.2t1 to 2.10.2t3:

    Fixed bug in the regression suite that made test3400 and test4100
    fail on correct computations.

    The randbit() builtin, when given to argument, returns 1 random bit.

    Fixed a bug in longlong.c which made is generate a syntax error
    on systems such as the PowerPC where the make variable LONGLONG
    was left empty.

    By default, the Makefile leaves LONGLONG_BITS empty to allow for
    testing of 64 bit data types.  A few hosts may have problems with
    this, but hopefully not.  Such hosts can revert back to LONGLONG_BITS=0.

    Improved SGI support.  Understands SGI IRIX6.2 performance issues
    for multiple architectures.

    Fixed a number of implicit conversion from unsigned long to long to avoid
    unexpected rounding, sign extension, or loss of accuracy side effects.

    Added SHSCC because shs.c contains a large expression that some
    systems need help in optimizing.

    Added "show files" to display information about all currently open files.

    Calc now prevents user-defined function having the same name as a
    builtin function.

    A number of new error codes (more than 100) have been added.

    Added ctime() builtin for date and time as string value.
    Added time() builtin for seconds since 00:00:00 1 Jan 1970 UTC.
    Added strerror() builtin for string describing error type.
    Added freopen() builtin to reopen a file.
    Added frewind() builtin to rewind a file.
    Added fputstr() builtin to write a null-terminated string to a file.
    Added fgetstr() builtin to read a null-terminated string from a file.
    Added fgetfield() builtin to read next field from file.
    Added strscan() builtin to scan a string.
    Added scan() builtin to scan of a file.
    Added fscan() builtin to scan of a file.
    Added fscanf() builtin to do a formatted scan of a file.
    Added scanf() builtin to do a formatted scan of stdin.
    Added strscanf() builtin to do a formatted scan of a string.
    Added ungetc() builtin to unget character read from a file.

    As before, files opened with fopen() will have an id different from
    earlier files.  But instead of returning the id to the FILEIO slot
    used to store information about it, calc simply uses consecutive
    numbers starting with 3.  A calc file retains its id, even when the
    file has been closed.

    The builtin files(i) now returns the file opened with id == i
    rather than the file with slot number i.  For any i <= lastid,
    files(i) has at some time been opened.  Whether open or closed, it
    may be "reopened" with the freopen() command.  This write to a file
    and then read it, use:

	f = fopen("junk", "w")
	freopen(f, "r")

	To use the same stream f for a new file, one may use:

	    freopen(f, mode, newfilename)

	which closes f (assuming it is open) and then opens newfilename on f.

	And as before:

	    f = fopen("curds", "r")
	    g = fopen("curds", "r")

	results in two file ids (f and g) that refer to the same file
	name but with different pointers.

    Calc now understands "w+", "a+" and "r+" file modes.

    If calc opens a file without a mode there is a "guess" that mode
    "r+" will work for any files with small descriptors found to be
    open.  In case it doesn't (as apparently happens if the file had
    not been opened for both reading and reading) the function now also
    tries "w" and "r", and if none work, gives up.  This avoids having
    "open" files with null fp.

    The builtin rewind() calls the C rewind() function, but one may
    now rewind several files at once by a call like rewind(f1, f2).
    With no argument, rewind() rewinds all open files with id >= 3.

    The functions fputstr(), fgetstr() have been defined to include the
    terminating '\0' when writing a string to a file.  This can be done
    at present with a sequence of instructions like:

	fputs(f, "Landon"); fputc(f, 0);
	fputs(f, "Curt"); fputc(f, 0);
	fputs(f, "Noll"); fputc(f, 0);

	One may now do:

	    fputstr(f, "Landon", "Curt", "Noll");

	and read them back by:

	    rewind(f);
	    x = fgetstr(f);	/* returns "Landon" */
	    y = fgetstr(f);	/* returns "Curt" */
	    z = fgetstr(f);	/* returns "Noll" */

    The builtin fgetfield() returns the next field of non-whitepsace
    characters.

    The builtins scan(), fscan(), strscan() read tokens (fields of
    non-whitepsace characters) and evaluates them.  Thus:

	global a,b,c;
	strscan("2+3  4^2\n c=a+b", a, b, 0);

	results in a = 5, b = 16, c = 21

    The functions scanf, fscanf, strscanf behave like the C functions
    scanf, fscanf, sscanf.   The conversion specifiers recognized are "%c",
    "%s", "%[...]" as in C, with the options of *, width-specification,
    and complementation (as in [^abc]), and "%n" for file-position, and
    "%f", "%r", "%e", "%i" for numbers or simple number-expressions - any
    width-specification is ignored; the expressions are not to include any
    white space or characters other than decimal digits, +, -, *, /, e, and i.
    E.g. expressions like 2e4i+7/8 are acceptable.

    The builtin size(x) now returns the size of x if x is an open file
    or -1 if x is a file but not open.	If s is a string, size(s) returns
    characters in s.

    Added builtin access("foo", "w") returns the null value if a file
    "foo" exists and is writable.

    Some systems has a libc symbolic qadd() that conflicted with calc's
    qadd function.  To avoid this, qadd() has been renamed to qqadd().

    The calc error codes are produced from the the calcerr.tbl file.
    Instead of changing #defines in value.h, one can not edit calcerr.tbl.
    The Makefile builds calcerr.h from this file.

    Calc error codes are now as follows:

	<0			invalid
	0 .. sys_nerr-1		system error ala C's errno values
	sys_nerr .. E__BASE-1	reserved for future system errors
	E__BASE .. E__HIGHEST	calc internal errors
	E__HIGHEST+1 .. E_USERDEF-1	invalid
	E_USERDEF ..		user defined errors

    Currently, E__BASE == 10000 and E_USERDEF == 20000.	 Of course,
    sys_nerr is system defined however is likely to be < E__BASE.

    Renamed CONST_TYPE (as defined in have_const.h) to just CONST.
    This symbol will either be 'const' or an empty string depending
    on if your compiler understands const.

    CONST is beginning to be used with read-only tables and some
    function arguments.	 This allows certain compilers to better
    optimize the code as well as alerts one to when some value
    is being changed inappropriately.  Use of CONST as in:

	int foo(CONST int curds, char *CONST whey)

    while legal C is not as useful because the caller is protected
    by the fact that args are passed by value.	However, the
    in the following:

	int bar(CONST char *fizbin, CONST HALF *data)

    is useful because it calls the compiler that the string pointed
    at by 'fizbin' and the HALF array pointer at by 'data' should be
    treated as read-only.


The following are the changes from calc version 2.10.1t21 to 2.10.2t0:

    Bumped patch level 2.10.2t0 in honor of having help files for
    all builtin functions.  Beta release will happen at the end of
    the 2.10.2 cycle!!!

    Fewer items listed in BUGS due to a number of bug fixes.

    Less todo in the help/todo file because more has already been done.	 :-)

    All builtin functions have help files!  While a number need cleanup
    and some of the LIMITS, LIBRARY and SEE ALSO sections need fixing
    (or are missing), most of it is there.  A Big round of thanks goes to
    <ernie at turing dot une dot edu dot au> for his efforts in initial
    write-ups for many of these files!

    The recognition of '\' as an escape character in the format argument
    of printf() has been dropped.  Thus:

	printf("\\n");

    will print the two-character string "\n" rather than the a
    one-character carriage return.  <ernie at turing dot une dot edu dot au>

    Missing args to printf-like functions will be treated as null values.

    The scope of of config("fullzero") has been extended to integers,
    so that for example, after config("mode","real"), config("display", 5),
    config("fullzero", 1), both:

	print 0, 1, 2;
	printf("%d %d %d\n", 0, 1, 2);

    print:

	.00000 1.00000, 2.00000

    The bug which caused calc to exit on:

	b = "print 27+"
	eval(b)

    has been fixed.  <ernie at turing dot une dot edu dot au>

    Fixed bugs in zio.c which caused eval(str(x)) == x to fail
    in non-real modes such as "oct".  <ernie at turing dot une dot edu dot au>

    The following:

	for (i = 1; i < 10; i++) print i^2,;

    now prints the same as:

	for (i = 1; i < 10; i++) print i^2,;

    The show globals will print '...' in the middle of large values.
    <ernie at turing dot une dot edu dot au>

    The param(n) builtin, then n > 0, returns the address rather than
    the value of the n-th argument to save time and memory usage.  This
    is useful when a matrix with big number entries is passed as an arg.
    <ernie at turing dot une dot edu dot au>

    The param(n) builtin, then n > 0, may be used as an lvalue:

	> define g() = (param(2) = param(1));
	> define h() = (param(1)++, param(2)--);
	> u = 5
	> v = 10
	> print g(u, &v), u, v;
	5 5 5
	> print h(&u, &v), u, v;
	5 6 4

    Missing args now evaluate to null as in:

	A = list(1,,3)
	B = list(,,)
	mat C[] = {,,}
	mat D[] = { }


The following are the changes from calc version 2.10.1t20 to 2.10.1t20:

    Changes made in preparation for Blum Blum Shub random number generator.

    REDC bug fixes: <ernie at turing dot une dot edu dot au>

	Fixed yet another bug in zdiv which occasionally caused the "top digit"
	of a nonzero quotient to be zero.

	Fixed a bug in zredcmul() where a rarely required "topdigit" is
	sometimes lost rather than added to the appropriate carry.

    A new function zredcmodinv(ZVALUE z, ZVALUE *res) has been defined
    for evaluating rp->inv in zredcalloc().  <ernie at turing dot une
    dot edu dot au>

    New functions zmod5(ZVALUE *zp) and zmod6(ZVALUE z, ZVALUE *res)
    have been defined to give O(N^1.585)-runtime evaluation of z % m
    for large N-word m.  These require m and BASE^(2*N) // m to have
    been stored at named locations lastmod, lastmodinv.  zmod5() is
    essentially for internal use by zmod6() and zpowermod().  <ernie at
    turing dot une dot edu dot au>

    Changes to rcmul(x,y,m) so that the result is always in [0, m-1].
    <ernie at turing dot une dot edu dot au>

    Changes to some of the detail of zredcmul() so that it should run slightly
    faster.  Also changes to zredcsq() in the hope that it might achieve
    something like the improvement in speed of x^2 compared with x * x.
    <ernie at turing dot une dot edu dot au>

    A new "bignum" algorithm for evaluating pmod(x,k,m) when
    N >= config("pow2").  For the multiplications and squaring
    modulo m, or their equivalent, when N >= config("redc2"),
    calc has used evaluations corresponding to rcout(x * y, m),
    for which the runtime is essentially that of three multiplications.
    <ernie at turing dot une dot edu dot au>

    Yet more additions to the regress.cal test suite.

    Fixed some ANSI-C compile nits in shs.c and quickhash.c.

    Plugs some potential memory leaks in definitions in func.c.
    Expressions such as qlink(vals[2]) in some circumstances are
    neither qfreed nor returned as function values.
    <ernie at turing dot une dot edu dot au>

    The nextcand() and prevcand() functions handle modval, modulus
    and skip by using ZVALUE rather than ZVALUE * and dropping
    the long modulus, etc.  <ernie at turing dot une dot edu dot au>

    Changed a couple of occurrences of itoq(1) or itoq(0) to &_qone_
    and &_qzero_.  <ernie at turing dot une dot edu dot au>

    In definition of f_primetest, changed ztolong(q2->num) to ztoi(q2->num)
    so that the sign of count in ptest(n, count, skip) is not lost; and
    ztolong(q3->num) to q3->num so that skip can be any integer.
    <ernie at turing dot une dot edu dot au>

    In zprime.c, in definition of small_factor(), adds "&& *tp != 1" to
    the exit condition in the for loop so that searching for a factor
    will continue beyond the table of primes, as required for e.g.
    factor(2^59 - 1).  <ernie at turing dot une dot edu dot au>

    Changed zprimetest() so that skip in ptest(n, count, skip)
    determines the way bases for the tests are selected.  Neg values of
    n are treated differently.	 When considering factorization,
    primeness, etc. one is concerned with equivalence classes which for
    the rational integers are {0}, {-1, 1}, {-2, 2}, etc.  To refer to
    an equivalence class users may use any of its elements but when
    returning a value for a factor the computer normally gives the
    non-negative member.  The same sort of thing happens with integers
    modulo an integer, with fractions, etc., etc.  E.g. users may refer
    to 3/4 as 6/8 or 9/12, etc.	 A simple summary of the way negative n
    is treated is "the sign is ignored". E.g. isprime(-97) and
    nextprime(-97) now return the same as isprime(97) and nextprime(97).
    <ernie at turing dot une dot edu dot au>


The following are the changes from calc version 2.10.1t11 to 2.10.1t19:

    Added many more regression tests to lib/regress.cal.  Some
    due to <ernie at turing dot une dot edu dot au>.

    Added many help files, most due to <ernie at turing dot une dot edu dot au>.

    Fixed exp() and ln() so that when they return a complex value with
    a zero imaginary component, isreal() is true.  <ernie at turing dot
    une dot edu dot au>

    Fixed cast problem in byteswap.c.  <ernie at turing dot une dot edu dot au>

    Fixed memory leak problem where repeated assignments did not
    free the previous value.  <ernie at turing dot une dot edu dot au>

    Complex number ordering/comparison has been changed such that:

	a < b implies a + c < b + c
	a < b and c > 0 implies a * c < b * c
	a < b implies -a > -b

    To achieve a "natural" partial ordering of the complex numbers
    with the above properties, cmp(a,b) for real or complex numbers
    may be considered as follows:

	cmp(a,b) = sgn(re(a) - re(b)) + sgn(im(a) - im(b)) * 1i

    The cmp help file has been updated.

    Change HASH type to QCKHASH.  The HASH type is a name better suited
    for the upcoming one-way hash interface.

    Added the CONFIG type; a structure containing all of the configuration
    values under the control of config().  Added V_CONFIG data type.
    The call config("all") returns a V_CONFIG.	One may now save/restore
    the configuration state as follows:

	x = config("all")
	...
	config("all",x)

    Added two configuration aliases, "oldstd" (for old backward compatible
    standard configuration) and "newstd" (for new style configuration).
    One may set the historic configuration state by:

	config("all", "oldstd")

    One may use what some people consider to be a better but not backward
    compatible configuration state by:

	config("all", "newstd")

    Renamed config.h (configuration file built during the make) to conf.h.
    Added a new config.h to contain info on thw V_CONFIG type.

    Fixed some ANSI C compile warnings.

    The show config output is not indented by only one tab, unless
    config("tab",0) in which case it is not indented.

    The order of show config has been changed to reflect the config
    type values.

    Changed declaration of sys_errlst in func.c to be char *.

    Added quo(x,y,rnd) and mod(x,y,rnd) to give function interfaces
    to // and % with rounding mode arguments.  Extended these functions
    to work for list-values, complex numbers and matrices.
    <ernie at turing dot une dot edu dot au>

    For integer x, cfsim(x,8) returns 0.
    <ernie at turing dot une dot edu dot au>

    Fixed config("leadzero").  <ernie at turing dot une dot edu dot au>

    Set config("cfsim",8) by default (in "oldstd").  Setup initial idea for
    config("all", "newstd") to be the default with the following changes:

	display		10
	epsilon		1e-10
	quo		0
	outround	24
	leadzero	1
	fullzero	1
	prompt		"; "		(allows full line cut/paste)
	more		";; "		(allows full line cut/paste)

    The "newstd" is a (hopefully) more preferred configuration than the
    historic default.

    The fposval.h file defines DEV_BITS and INODE_BITS giving the
    bit size of the st_dev and st_ino stat elements.  Also added
    SWAP_HALF_IN_DEV and SWAP_HALF_IN_STSIZE.

    Added sec(), csc(), cot(), sech(), csch(), coth(), asec(), acsc(),
    acot(), asech(), acsch() and acoth() builtins. <ernie at turing dot
    une dot edu dot au>

    The initmasks() call is no longer needed.  The bitmask[] array
    is a compiled into zmath.c directly.

    Added isconfig(), ishash(), isrand() and israndom() builtins to
    test is something is a configuration state, hash state, RAND
    state or RANDOM state.

    The lib/cryrand.cal library now no longer keeps the Blum prime
    factors used to form he Blum modulus.  The default modulus has
    been expanded to 1062 bits product of two Blum primes.

    The function hash_init() is called to initialize the hash function
    interface.

    Misc calc man page fixes and new command line updates.

    Fixed bug related to srand(1).

    Cleaned up some warning messages.

    All calls to math_error() now have a /*NOTREACHED*/ comment after
    them.  This allows lint and compiler flow progs to note the jumpjmp
    nature of math_error().  Unfortunately some due to some systems
    not dealing with /*NOTREACHED*/ comments correctly, calls of the form:

	if (foo)
		math_error("bar");

    must be turned into:

	if (foo) {
		math_error("bar");
		/*NOTREACHED*/
	}

    The ploy() function can take a list of coefficients.  See the
    help/poly file.  Added poly.c.  <ernie at turing dot une dot edu
    dot au>

    Fixes and performance improvements to det().  <ernie at turing dot
    une dot edu dot au>

    Renamed atoq() and atoz() to str2q() and str2z() to avoid conflicts
    with libc function names.

    Fixed use of ${NROFF_ARG} when ${CATDIR} and ${NROFF} are set.

    Fixed SWAP_HALF_IN_B64 macro use for Big Endian machines without
    long long or with LONGLONG_BITS=0.

    Added error() and iserror() to generate a value of a given error type.
    See help/error for details.	 <ernie at turing dot une dot edu dot au>

    Added singular forms of help files.	 For example one can now get
    help for binding, bug, change, errorcode and type.

    The builtin mmin(x, md) has been changed to return the same as
    mod(x, md, 16).  The old mmin(x, md) required md to be a positive
    integer and x to be an integer.  Now md can be any real number; x
    can be real, complex, or a matrix or list with real elements, etc.
    <ernie at turing dot une dot edu dot au>

    The builtin avg(x_1, x_2, ...) has been changed to accept list-valued
    arguments:	a list x_i contributes its elements to the list of
    items to be averaged.  E.g. avg(list(1,2,list(3,4)),5) is treated
    as if it were avg(1,2,3,4,5).  If an error value is encountered in
    the items to be averaged, the first such value is returned.  If the
    number of items to be averaged is zero, the null value is returned.
    <ernie at turing dot une dot edu dot au>

    The builtin hmean(x_1, x_2, ...) has been changed to admit types
    other than real for x_1, x_2, ...; list arguments are treated in
    the same way as in avg().  <ernie at turing dot une dot edu dot au>

    The builtin eval(str) has been changed so that when str has a
    syntax error, instead of call to math_error(), an error value is
    returned.  <ernie at turing dot une dot edu dot au>

    The old frem(x,y) builtin returned the wrong value when y was a power of
    2 greater than 2, e.g. f(8,4) is returned as 4 when its value should be 2.
    This has been fixed by a small change to the definition of zfacrem().
    Calc used to accept with no warning or error message, gcdrem(0,2) or
    generally gcdrem(0,y) for any y with abs(y) > 1, but then went into an
    infinite loop.  This has been fixed by never calling zfacrem() with zero x.
    Both frem(x,y) and gcdrem(x,y) now reject y = -1, 0 or 1 as errors.	 For
    nonzero x, and y == -1 or 1, defining frem(x,y) and gcdrem(x,y) to equal
    abs(x) is almost as natural as defining x^0 to be 1.  Similarly, if x is
    not zero then gcdrem(x,0) == 1.  <ernie at turing dot une dot edu dot au>

    Plugged some more memory leaks.

    Fixed bug related randbit(x) skip (where x < 0).

    Added seedrandom.cal to help users use the raw random() interface well.

    Made extensive additions and changes to the rand() and random() generator
    comments in zrand.c.

    Fixed a bug in fposval.c that prevented calc from compiling on systems
    with 16 bit device and/or inodes.  Fixed error messages in fposval.c.

    Fixed bug that would put calc into an infinite loop if it is ran
    with errors in startup files (calc/startup, .calcrc).
    Ha Lam <hl at kuhep5 dot phsx dot ukans dot edu>


The following are the changes from calc version 2.10.0t13 to 2.10.1t10:

    Added SB8, USB8, SB16, USB16, SB32, USB32 typedefs, determined by
    longbits and declared in longbits.h, to deal with 8, 16 and 32 bit
    signed and unsigned values.

    The longbits.h will define HAVE_B64 with a 64 bit type (long or
    longlong) is available.   If one is, then SB64 and US64 typedefs
    are declared.

    The U(x) and L(x) macros only used to define 33 to 64 bit signed
    and unsigned constants.  Without HAVE_B64, these macros cannot
    be used.

    Changed the way zmath.h declares types such as HALF and FULL.

    Changed the PRINT typedef.

    The only place where the long long type might be used is in longlong.c
    and if HAVE_LONGLONG, in longbits.h if it is needed.  The only place
    were a long long constant might be used is in longlong.c.  Any
    long long constants, if HAVE_LONGLONG, are hidden under the U(x) and
    L(x) macros on longbits.h.	And of course, if you don't have long long,
    then HAVE_LONGLONG will NOT be defined and long long's will not be used.

    The longlong.h file is no longer directly used by the main calc source.
    It only comes into play when compiling the longbits tool.

    Added config("prompt") to change the default interactive prompt ("> ")
    and config("more") to change the default continuation prompt (">> ").

    Makefile builds align32.h with determines if 32 bit values must always
    be aligned on 32 bit boundaries.

    The CALCBINDINGS file is searched for along the CALCPATH.  The Makefile
    defines the default CALCBINDINGS is "bindings" (or "altbind") which
    is now usually found in ./lib or ${LIBDIR}.

    Per Ernest Bowen <ernie at turing dot une dot edu dot au>, an optional
    third argument was added  sqrt() so that in sqrt(x,y,z), y and z have
    essentially the same role as in appr(x,y,z) except that of course
    what is being approximated is the sqrt of x.  Another difference is
    that two more bits of z are used in sqrt: bit 5 gives the option of
    exact results when they exist (the value of y is then ignored) and
    bit 6 returns the non-principal root rather than the principal value.

    If commands are given on the command line, leading tabs are not
    printed in output.	Giving a command on the command line implies
    that config("tab",0) was given.

    Pipe processing is enabled by use of -p.  For example:

	echo "print 2^21701-1, 2^23209-1" | calc -p | fizzbin

    In pipe mode, calc does not prompt, does not print leading tabs
    and does not print the initial version header.

    Calc will now form FILE objects for any open file descriptor > 2
    and < MAXFILES.  Calc assumes they are available for reading
    and writing.  For example:

	$ echo "A line of text in the file on descriptor 5" > datafile
	$ calc 5<datafile
	C-style arbitrary precision calculator (version 2.10.1t3)
	[Type "exit" to exit, or "help" for help.]

	> files(5)
		FILE 5 "descriptor[5]" (unknown_mode, pos 0)
	> fgetline(files(5))
		"A line of text in the file on descriptor 5"

    The -m mode flag now controls calc's ability to open files
    and execute programs.  This mode flag is a single digit that
    is processed in a similar way as the octal chmod values:

	0   do not open any file, do not execute progs
	1   do not open any file
	2   do not open files for reading, do not execute progs
	3   do not open files for reading
	4   do not open files for writing, do not execute progs
	5   do not open files for writing
	6   do not execute any program
	7   allow everything (default mode)

    Thus if one wished to run calc from a privileged user, one might
    want to use -m 0 in an effort to make calc more secure.

    The -m flags for reading and writing apply on open.
    Files already open are not effected.  Thus if one wanted to use
    the -m 0 in an effort to make calc more secure, but still be
    able to read and write a specific file, one might do:

	calc -m 0 3<a.file 4>b.file

	NOTE: Files presented to calc in this way are opened in an unknown
	      mode.  Calc will try to read or write them if directed.

    The maximum command line size it MAXCMD (16384) bytes.  Calc objects to
    command lines that are longer.

    The -u flag cause calc to un-buffer stdin and stdout.

    Added more help files.  Improved other help files.

    Removed trailing blanks from files.

    Removed or rewrite the formally gross and disgusting hacks for
    dealing with various sizes and byte sex FILEPOS and off_t types.

    Defined ilog2(x), ilog10(x), ilog(x,y) so that sign of x is ignored,
    e.g. ilog2(x) = ilog2(abs(x)).

    The sixth bit of rnd in config("round", rnd) and config("bround", rnd)
    is used to specify rounding to the given number of significant
    digits or bits rather than places, e.g. round(.00238, 2, 32)
    returns .0023, round(.00238, 2, 56) returns .0024.


The following are the changes from calc version 2.9.3t11 to 2.10.0t12:

    The default ${LIBDIR}/bindings CALCBINDINGS uses ^D for editing.
    The alternate CALCBINDINGS ${LIBDIR}/altbind uses ^D for EOF.

    The Makefile CC flag system has been changed.  The new CC flag system
    includes:

	CCMAIN are flags for ${CC} when compiling only files with main()
	CCOPT are flags given to ${CC} for optimization
	CCWARN are flags given to ${CC} for warning message control
	CCMISC are misc flags given to ${CC}

	CNOWARN are all flags given to ${CC} except ${CCWARN} flags
	CFLAGS are all flags given to ${CC}
	ICFLAGS are given to ${CC} for intermediate progs

	LCFLAGS are CC-style flags for ${LINT}
	LDFLAGS are flags given to ${CC} for linking .o files
	ILDFLAGS are given to ${CC} for linking .o's for intermediate progs

	CC is how the the C compiler is invoked

    The syntax error:

	print a[3][[4]]

    used to send calc into a loop printing 'missing expression'.  This
    has been fixed.

    Added config("maxerr") and config("maxerr",val) to control the
    maximum number of errors before a computation is aborted.

    Removed regress.cal test #952 and #953 in case calc's stdout or
    stderr is re-directed to a non-file by some test suite.

    Changed how <stdarg.h>, <varags.h> or simulate stdarg is determined.
    Changed how vsprintf() vs sprintf() is determined.	The args.h file
    is created by Makefile to test which combination works.  Setting
    VARARG and/or HAVE_VSPRINTF in the Makefile will alter these tests
    and direct a specific combination to be used.  Removed have_vs.c,
    std_arg.h and try_stdarg.c.	 Added have_stdvs.c and have_varvs.c.

    Added 3rd optional arg to round(), bround(), appr() to specify the type of
    rounding to be used.

    Moved fnvhash.c to quickhash.c.

    Fixed a bug in appr rounding mode when >= 16.

    Added test2600.cal and test2700.cal. They are used by the regress.cal
    to provide a more extensive test suite for some builtin numeric
    functions.


The following are the changes from calc version 2.9.3t9.2+ to 2.9.3t10:

    Added many help files for builtin functions and some symbols.
    More help files are needed, see help/todo.

    Removed the calc malloc code.  Calc now uses malloc and free to
    manage storage since these implementations are often written to
    work best for the local system.  Removed CALC_MALLOC code and
    Makefile symbol.  Removed alloc.c.

    Added getenv("name"), putenv("name=val") and putenv("name, "val")
    builds for environment variable support thanks to "Dr." "D.J." Picton
    <dave at aps2 dot ph dot bham dot ac dot uk>.

    Added system("shell command") builtin to execute shell commands,
    thanks to "Dr." "D.J." Picton <dave at aps2 dot ph dot bham dot ac dot uk>.

    Added isatty(fd) builtin to determine if fd is attached to a tty
    thanks to "Dr." "D.J." Picton <dave at aps2 dot ph dot bham dot ac dot uk>.

    Added cmdbuf() builtin to return the command line executed by calc's
    command line args thanks to "Dr." "D.J." Picton <dave at aps2 dot
    ph dot bham dot ac dot uk>.

    Added strpos(str1,str2) builtin to determine the first position where
    str2 is found in str1 thanks to "Dr." "D.J." Picton
    <dave at aps2 dot ph dot bham dot ac dot uk>.

    Fixed bug that caused:

	global a,b,c		(newline with no semicolon)
	read test.cal

    the read command to not be recognized.

    The show command looks at only the first 4 chars of the argument so
    that:

	show globals
	show global
	show glob

    do the same thing.

    Added show config to print the config values and parameters thanks
    to Ernest Bowen <ernie at turing dot une dot edu dot au>.

    Added show objtypes to print the defined objects thanks to Ernest Bowen
    <ernie at turing dot une dot edu dot au>.

    Added more builtin function help files.

    Fixed the 3rd arg usage of the root builtin.

    Expanded the regress.cal regression test suite.

    Fixed -- and ++ with respect to objects and assignment (see the 2300
    series in regress.cal).

    Added isident(m) to determine if m is an identity matrix.

    The append(), insert() and push() builtins can now append between
    1 to 100 values to a list.

    Added reverse() and join() builtins to reverse and join lists
    thanks to Ernest Bowen <ernie at turing dot une dot edu dot au>.

    Added sort() builtin to sort lists thanks to Ernest Bowen
    <ernie at turing dot une dot edu dot au>.

    Added head(), segment() and tail() builtins to return the head,
    middle or tail of lists thanks to Ernest Bowen <ernie at turing dot
    une dot edu dot au>.

    Added more and fixed some help files.

    The builtin help file is generated by the help makefile.  Thus it will
    reflect the actual calc builtin list instead of the last time someone
    tried to update it correctly.  :-)

    Fixed non-standard void pointer usage.

    Fixed base() bug with regards to the default base.

    Renamed MATH_PROTO() and HIST_PROTO() to PROTO().  Moved PROTO()
    into prototype.h.

    Fixed many function prototypes.  Calc does not declare functions
    as static in one place and extern in another.  Where reasonable
    function prototypes were added.  Several arg mismatch problems
    were fixed.

    Added support for SGI MIPSpro C compiler.

    Changes the order that args are declared to match the order
    of the function.  Some source tools got confused when:
    arg order did not match as in:

	void
	funct(foo,bar)
		int bar;	/* this caused a problem */
		char *foo;	/* even though it should not! */
	{
	}


The following are the changes from calc version 2.9.3t8 to 2.9.3t9.2:

    Use of the macro zisleone(z) has been clarified.  The zisleone(z) macro
    tests if z <= 1.  The macro zisabsleone(z) tests of z is 1, 0 or -1.
    Added zislezero(z) macro.  Bugs are related to this confusion have
    been fixed.

    Added zge64b(z) macro to zmath.h.

    Added the macro zgtmaxufull(z) to determine if z will fit into a FULL.
    Added the macro zgtmaxlong(z) to determine if z will fit into a long.
    Added the macro zgtmaxulong(z) to determine if z will fit into a unsigned
    long.

    Added the macro ztoulong(z) to convert an absolute value of a ZVALUE to
    an unsigned long, or to convert the low order bits of a ZVALUE.
    Added the macro ztolong(z) to convert an absolute value of a ZVALUE to
    an long, or to convert the low order bits of a ZVALUE.

    Some non-ANSI C compilers define __STDC__ to be 0, whereas all ANSI
    C compiles define it as non-zero.  Code that depends on ANSI C now
    uses #if defined(__STDC__) && __STDC__ != 0.

    Fixed ptest(a,b) bug where (a mod 2^32) < b.  Previously ptest()
    incorrectly returned 1 in certain cases.

    The second ptest() argument, which is now optional, defaults to 1.
    This ptest(x) is the same as ptest(x,1).

    Added an optional 3rd argument to ptest().	The 3rd arg tells how many
    tests to skip.  Thus ptest(a,10) performs the same probabilistic
    tests as ptest(a,3) and ptest(a,7,3).

    The ptest() builtin by default will determine if a value is divisible
    by a trivial prime.	 Thus, ptest(a,0) will only perform a quick trivial
    factor check.  If the test count is < 0, then this trivial factor check
    is omitted.	 Thus ptest(a,10) performs the same amount of work as
    ptest(a,3) and ptest(a,-7,3) and the same amount of work as
    ptest(a,-3) and ptest(a,7,3).

    Added nextcand(a[,b[,c]]) and prevcand(a[,b[,c]]) to search for the
    next/previous value v > a (or v < a) that passes ptest(v[,b[,c]]).
    The nextcand() and prevcand() builtins take the same arguments
    as ptest().

    Added nextprime(x) and and prevprime(x) return the next and
    previous primes with respect to x respectively.  As of this
    release, x must be < 2^32.	With one argument, they will return
    an error if x is out of range.  With two arguments, they will
    not generate an error but instead will return y.

    Fixed some memory leaks, particularly those related with pmod().

    Fixed some of the array bounds reference problems in domult().

    Added a hack-a-round fix for the uninitialized memory reference
    problems in zsquare/dosquare.

    The LIBRARY file has been updated to include a note about calling
    zio_init() first.  Also some additional useful macros have been noted.

    The lfactor() function returns -1 when given a negative value.
    It will not search for factors beyond 2^32 or 203280221 primes.
    Performance of lfactor() has been improved.

    Added factor(x,y) to look for the smallest factor < min(sqrt(x),y).

    Added libcalcerr.a for a math_error() routine for the convince of
    progs that make use of libcalc.a.  This routine by default will
    print an message on stderr and exit.  It can also be made to
    longjump instead.  See the file LIBRARY under ERROR HANDING.

    Added isprime() to test if a value is prime.  As of this release,
    isprime() is limited to values < 2^32.  With one argument,
    isprime(x) will return an error if x is out of range.  With
    two arguments, isprime(x,y) will not generate an error but
    instead will return y.

    Added pix(x) to return the number of primes <= x.  As of this
    release, x must be < 2^32.	With one argument, pix(x) will
    return an error if x is out of range.  With two arguments,
    pix(x,y) will not generate an error but instead will return y.

    Fixed the way *.h files are formed.	 Each file guards against
    multiple inclusion.

    Fixed numeric I/O on 64 bit systems.  Previously the print and
    constant conversion routines assumed a base of 2^16.

    Added support for 'long long' type.	 If the Makefile is setup
    with 'LONGLONG_BITS=', then it will attempt to detect support
    for the 'long long' type.  If the Makefile is setup with
    'LONGLONG_BITS=64', then a 64 bit 'long long' is assumed.
    Currently, only 64 bit 'long long' type is supported.
    Use of 'long long' allows one to double the size of the
    internal base, making a number of computations much faster.
    If the Makefile is setup with 'LONGLONG_BITS=0', then the
    'long long' type will not be used, even if the compiler
    supports it.

    Fixed avg() so that it will correctly handle matrix arguments.

    Fixed btrunc() limit.

    The ord("string") function can now take a string of multiple
    characters.	 However it still will only operate on the first
    character.

    Renamed stdarg.h to std_arg.h and endian.h endian_calc.h to
    avoid name conflicts with /usr/include on some systems that
    have make utilities that are too smart for their own good.

    Added additive 55 shuffle generator functions rand(), randbits()
    and its seed function srand().  Calling rand(a,b) produces a
    random value over the open half interval [a,b).  With one arg,
    rand(a) is equivalent to rand(0,a).	 Calling rand() produces
    64 random bits and is equivalent to rand(0,2^64).

    Calling randbit(x>0) produces x random bits.  Calling randbit(skip<0)
    skips -skip bits and returns -skip.

    The srand() function will return the current state.	 The call
    srand(0) returns the initial state.	 Calling srand(x), where
    x > 0 will seed the generator to a different state.	 Calling
    srand(mat55) (mat55 is a matrix of integers at least 55 elements long)
    will seed the internal table with the matrix elements mod 2^64.
    Finally calling srand(state) where state is a generator state
    also sets/seeds the generator.

    The cryrand.cal library has been modified to use the builtin
    rand() number generator.  The output of this generator is
    different from previous versions of this generator because
    the rand() builtin does not match the additive 55 / shuffle
    generators from the old cryrand.cal file.

    Added Makfile support for building BSD/386 releases.

    The cmp() builtin can now compare complex values.

    Added the errno() builtin to return the meaning of errno numbers.

    Added fputc(), fputs(), fgets(), ftell(), fseek() builtins.

    Added fsize() builtin to determine the size of an open file.

    Supports systems where file positions and offsets are longer than 2^32
    byte, longer than long and/or are not a simple type.

    When a file file is printed, the file number is also printed:

	FILE 3 "/etc/motd" (reading, pos 127)

    Added matsum() to sum all numeric values in a matrix.

    The following code now works, thanks to a fix by <ernie at turing
    dot une dot edu dot au> (Ernest Bowen):

		mat A[3] = {1, 2, 3};
		A[0] = A;
		print A[0];

    Also thanks to ernie, calc can process compound expressions
    such as 1 ? 2 ? 3 : 4 : 5.

    Also^2 thanks to ernie, the = operator is more general:

		(a = 3) = 4		(same as a = 3; a = 4)
		(a += 3) *= 4		(same as a += 3; a *= 4)
		matfill(B = A, 4)	(same as B = A; matfill(B, 4);)

    Also^3 thanks to ernie, the ++ and -- operators are more general.

		a = 3
		++(b = a)		(a == 3, b == 4)
		++++a			(a == 5)
		(++a)++ == 6		(a == 7)
		(++a) *= b		(a == 32, b == 4)

    Fixed a bug related to calling epsilon(variable) thanks to ernie.

    Removed trailing whitespace from source and help files.

    Some compilers do not support the const type.  The file have_const.h,
    which is built from have_const.c will determine if we can or should
    use const.	See the Makefile for details.

    Some systems do not have uid_t.  The file have_uid_t.h, which is
    built from have_uid_t.c will determine if we can or should depend
    on uid_t being typefed by the system include files.	 See the Makefile
    for details.

    Some systems do not have memcpy(), memset() and strchr().  The
    file have_newstr.h, which is built from have_newstr.c will
    determine if we can or should depend libc providing these
    functions.	See the Makefile for details.

    The Makefile symbol DONT_HAVE_VSPRINTF is now called HAVE_VSPRINTF.
    The file have_vs.h, which is built from have_vs.c will determine if
    we can or should depend libc providing vsprintf().	See the Makefile
    for details.

    Removed UID_T and OLD_BSD symbols from the Makefile.

    A make all of the upper level Makefile will cause the all rule
    of the lib and help subdirs to be made as well.

    Fixed bug where reserved keyword used as symbol name caused a core dump.


The following are the changes from calc version 2.9.3t7 to 2.9.3t7:

    The 'show' command by itself will issue an error message
    that will remind one of the possible show arguments.
    (thanks to Ha S. Lam <hl at kuhep4 dot phsx dot ukans dot edu>)

    Fixed an ANSI-C related problem with the use of stringindex()
    by the show command.  ANSI-C interprets "bar\0foo..." as if
    it were "bar\017oo...".

    Added a cd command to change the current directory.
    (thanks to Ha S. Lam <hl at kuhep4 dot phsx dot ukans dot edu>)

    Calc will not output the initial version string, startup
    message and command prompt if stdin is not a tty.  Thus
    the shell command:

	echo "fact(100)" | calc

    only prints the result.  (thanks to Ha S. Lam <hl at kuhep4 dot phsx
    dot ukans dot edu>)

    The zmath.h macro zisbig() macro was replaced with zlt16b(),
    zge24b(), zge31b(), zge32b() and zgtmaxfull() which are
    independent of word size.

    The 'too large' limit for factorial operations (e.g., fact, pfact,
    lcmfact, perm and comb) is now 2^24.  Previously it depended on the
    word size which in the case of 64 bit systems was way too large.

    The 'too large' limit for exponentiation, bit position (isset,
    digit, ), matrix operations (size, index, creation), scaling,
    shifting, rounding and computing a Fibonacci number is 2^31.
    For example, one cannot raise a number by a power >= 2^31.
    One cannot test for a bit position >= 2^31.	 One cannot round
    a value to 2^31 decimal digit places.  One cannot compute
    the Fibonacci number F(2^31).

    Andy Fingerhut <jaf at dworkin dot wustl dot edu> (thanks!) supplied
    a fix to a subtle bug in the code generation routines.  The basic
    problem was that addop() is sometimes used to add a label to
    the opcode table of a function.  The addop() function did some
    optimization tricks, and if one of these labels happens to be an
    opcode that triggers optimization, incorrect opcodes were generated.

    Added utoz(), ztou() to zmath.c, and utoq(), qtou() to qmath.c
    in preparation for 2.9.3t9 mods.


The following are the changes from calc version 2.9.2 to 2.9.3t7:

    Calc can now compile on OSF/1, SGI and IBM RS6000 systems.

    A number of systems that have both <varargs.h> and <stdarg.h> do
    not correctly implement both types.	 On some System V, MIPS and DEC
    systems, vsprintf() and <stdarg.h> do not mix.  While calc will
    pass the regression test, use of undefined variables will cause
    problems.  The Makefile has been modified to look for this problem
    and work around it.

    Added randmprime.cal which find a prime of the form h*2^n-1 >= 2^x
    for some given x.  The initial search points for 'h' and 'n'
    are selected by a cryptographic pseudo-random generator.

    The library script nextprim.cal is now a link to nextprime.cal.
    The lib/Makefile will take care of this link and install.

    The show command now takes singular forms.	For example, the
    command 'show builtin' does the same as 'show builtins'.  This
    allows show to match the historic singular names used in
    the help system.

    Synced 'show builtin' output with 'help builtin' output.

    Fixed the ilog2() builtin.	Previously ilog2(2^-20) returned
    -21 instead of -20.

    The internal function qprecision() has been fixed.	The changes
    ensure that for any e for which 0 < e <= 1:

	1/4 < sup(abs(appr(x,e) - x))/e	 <= 1/2.

    Here 'sup' denotes the least upper bound over values of x (supremum).
    Previously calc did: 1/4 <= sup(abs(appr(x,e) - x))/e  < 1.

    Certain 64 bit processors such as the Alpha are now supported.

    Added -once to the READ command.  The command:

	read -once filename

    like the regular READ expect that it will ignore filename if
    is has been previously read.

    Improved the makefile.  One now can select the compiler type.  The
    make dependency lines are now simple foo.o: bar.h lines.  While
    this makes for a longer list, it is easier to maintain and will
    make future Makefile patches smaller.  Added special options for
    gcc version 1 & 2, and for cc on RS6000 systems.

    Calc compiles cleanly under the watchful eye of gcc version 2.4.5
    with the exception of warnings about 'aggregate has a partly
    bracketed initializer'.  (gcc v2 should allow you to disable
    this type of warning with using -Wall)

    Fixed a longjmp bug that clobbered a local variable in main().

    Fixed a number of cases where local variables or malloced storage was
    being used before being set.

    Fixed a number of fence post errors resulting in reads or writes
    just outside of malloced storage.

    A certain parallel processor optimizer would give up on
    code in cases where math_error() was called.  The obscure
    work-a-rounds involved initializing or making static, certain
    local variables.

    The cryrand.cal library has been improved.	Due to the way
    the initial quadratic residues are selected, the random numbers
    produced differ from previous versions.

    The printing of a leading '~' on rounded values is now a config
    option.  By default, tilde is still printed.  See help/config for
    details.

    The builtin function base() may be used to set the output mode or
    base.  Calling base(16) is a convenient shorthand for typing
    config("mode","hex").  See help/builtin.

    The printing of a leading tab is now a config option.  This does not
    alter the format of functions such as print or printf.  By default,
    a tab is printed.  See help/config for details.

    The value atan2(0,0) now returns 0 value in conformance with
    the 4.3BSD ANSI/IEEE 754-1985 math library.

    For all values of x, x^0 yields 1.	The major change here is
    that 0^0 yields 1 instead of an error.

    Fixed gcd() bug that caused gcd(2,3,1/2) to ignore the 1/2 arg.

    Fixed ltol() rounding so that exact results are returned, similar
    to the way sqrt() and hypot() round, when they exist.

    Fixed a bug involving ilog2().

    Fixed quomod(a,b,c,d) to give correct value for d when a is between
    0 and -b.

    Fixed hmean() to perform the necessary multiplication by the number of
    arguments.

    The file help/full is now being built.

    The man page is not installed by default.  One may install either
    the man page source or the cat (formatted man) page.  See the
    Makefile for details.

    Added a quit binding.  The file lib/bindings2 shows how this new
    binding may be used.

    One can now do a 'make check' to run the calc regression test
    within in the source tree.

    The regression test code is now more extensive.

    Updated the help/todo list.	 A BUGS file was added.	 Volunteers are
    welcome to send in patches!


The following are the changes from calc version 2.9.1 to 2.9.1:

    Fixed floor() for values -1 < x < 0.

    Fixed ceil() for values -1 < x < 0.

    Fixed frac() for values < 0 so that int(x) + frac(x) == x.

    Fixed wild fetch bug in zdiv, zquo and zmod code.

    Fixed bug which caused regression test #719 to fail on some machines.

    Added more regression test code.


The following are the changes from calc version 2.9.0 to 2.9.0:

    A major bug was fixed in subtracting two numbers when the first
    number was zero.  The problem caused wrong answers and core dumps.


The following are the changes from calc version 1.27.0 to 2.8.0:

    Full prototypes have been provided for all C functions, and are used
    if calc is compiled with an ANSI compiler.

    Newly defined variables are now initialized to the value of zero instead
    of to the null value.  The elements of new objects are also initialized
    to the value of zero instead of null.

    The gcd, lcm, and ismult functions now work for fractional values.

    A major bug in the // division for fractions with a negative divisor
    was fixed.

    A major bug in the calculation of ln for small values was fixed.

    A major bug in the calculation of the ln and power functions for complex
    numbers was fixed.

    A major lack of precision for sin and tan for small values was fixed.

    A major lack of precision for complex square roots was fixed.

    The "static" keyword has been implemented for variables.  So permanent
    variables can be defined to have either file scope or function scope.

    Initialization of variables during their declaration are now allowed.
    This is most convenient for the initialization of static variables.

    The matrix definition statement can now be used within a declaration
    statement, to immediately define a variable as a matrix.

    Initializations of the elements of matrices are now allowed.  One-
    dimensional matrices may have implicit bounds when initialization is
    used.

    The obj definition statement can now be used within a declaration
    statement, to immediately define a variable as an object.

    Object definitions can be repeated as long as they are exactly the same
    as the previous definition.	 This allows the rereading of files which
    happen to define objects.

    The integer, rational, and complex routines have been made into a
    'libcalc.a' library so that they can be used in other programs besides
    the calculator.  The "math.h" include file has been split into three
    include files: "zmath.h", "qmath.h", and "cmath.h".

Following is a list of visible changes to calc from version 1.26.4 to 1.26.4:

    Added an assoc function to return a new type of value called an
    association.  Such values are indexed by one or more arbitrary values.
    They are stored in a hash table for quick access.

    Added a hash() function which accepts one or more values and returns
    a quickly calculated small non-negative hash value for those values.

Following is a list of visible changes to calc from version 1.26.2 to 1.26.4:

    Misc fixes to Makefiles.

    Misc lint fixes.

    Misc portability fixes.

    Misc typo and working fixes to comments, help files and the man page.

Following is a list of visible changes to calc from version 1.24.7 to 1.26.1:

    There is a new emacs-like command line editing and edit history
    feature.  The old history mechanism has been removed.  The key
    bindings for the new editing commands are slightly configurable
    since they are read in from an initialization file.	 This file is
    usually called /usr/lib/calc/bindings, but can be changed by the
    CALCBINDINGS environment variable.	All editing code is
    self-contained in the new files hist.c and hist.h, which can be
    easily extracted and used in other programs.

    Two new library files have been added: chrem.cal and cryrand.cal.
    The first of these solves the Chinese remainder problem for a set
    of modulo's and remainders.	The second of these implements several
    very good random number generators for large numbers.

    A small bug which allowed division by zero was fixed.

    A major bug in the mattrans function was fixed.

    A major bug in the acos function for negative arguments was fixed.

    A major bug in the strprintf function when objects were being printed
    was fixed.

    A small bug in the library file regress.cal was fixed.

## Copyright (C) 2001  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.70 $
## @(#) $Id: CHANGES,v 29.70 2004/10/23 01:16:23 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/RCS/CHANGES,v $
##
## Under source code control:	1993/06/02 18:12:57
## File existed as early as:	1989
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* contrib
*************

We welcome and encourage you to send us:

    * calc resource files
    * calc shell scripts
    * any builtin functions that you have modified or written
    * custom functions that you have modified or written
    * any other source code modifications

Prior to doing so, you should consider applying your changes to the most
recent version of calc.

Landon Noll maintains the official calc home page at:

	http://www.isthe.com/chongo/tech/comp/calc/

See:

	http://www.isthe.com/chongo/tech/comp/calc/calc-download.html

for information on how to obtain up a recent version of calc.

=-=

In order to consider integrating your code, we need:

    * the calc version you are working with (use the latest calc, see above)
    * new help files or help file patches, if applicable (documentation)
    * proposed text for the CHANGES file (brief description of what it does)
    * regress.cal test patch, if applicable
    * your source code and/or source code changes (:-))

The best way to send us new code, if your changes are small, is
via a patch (diff -c from the latest alpha code to your code).
If your change is large, you should send entire files (either
as a diff -c /dev/null your-file patch, or as a uuencoded and
gziped (or compressed) tar file).

To contribute code, scripts, resource files and/or to help please
join the low volume calc mailing list by sending EMail to:

    calc-contrib at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

Your subject must contain the words:

    calc mailing list subscription

You may have additional words in your subject line.

Feel free to follow the name line with additional EMail text as desired.

Thanks for considering submitting code to calc.	 Calc is a collective
work by a number of people.  It would not be what it is today without
your efforts and submissions!

=-=

Calc bug reports and calc bug fixes should be sent to:

    calc-bugs at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

Your subject must contain the words:

       calc bug report

You may have additional words in your subject line.

See the BUGS file or try the help command:

    help bugs

for details on bug reporting.

=-=

Landon Curt Noll
http://www.isthe.com/chongo/

chongo (share and enjoy) /\../\

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.4 $
## @(#) $Id: contrib,v 29.4 2001/06/01 11:37:14 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/contrib,v $
##
## Under source code control:	1997/03/09 16:33:22
## File existed as early as:	1997
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* credit
*************

Credits

    The majority of calc was written by David I. Bell.

    The Calc primary mirror, calc mailing list and calc bug report
    processing is performed by Landon Curt Noll.

    Landon Curt Noll maintains the master reference source, performs
    release control functions as well as other calc maintenance functions.

    Thanks for suggestions and encouragement from Peter Miller,
    Neil Justusson, Ernest W. Bowen and Landon Noll.

    Thanks to Stephen Rothwell for writing the original version of
    hist.c which is used to do the command line editing.

    Thanks to Ernest W. Bowen for supplying many improvements in
    accuracy and generality for some numeric functions.	 Much of
    this was in terms of actual code which I gratefully accepted.
    Ernest also supplied the original text for many of the help files.

    Portions of this program are derived from an earlier set of
    public domain arbitrarily precision routines which was posted
    to the net around 1984.  By now, there is almost no recognizable
    code left from that original source.

    Most of this source and binary has one of the following copyrights:

	    Copyright (C) year David I. Bell
	    Copyright (C) year David I. Bell and Landon Curt Noll
	    Copyright (C) year David I. Bell and Ernest Bowen
	    Copyright (C) year David I. Bell, Landon Curt Noll and Ernest Bowen
	    Copyright (C) year Landon Curt Noll
	    Copyright (C) year Ernest Bowen and Landon Curt Noll
	    Copyright (C) year Ernest Bowen


Copying / Calc GNU Lesser General Public License

    Calc is open software, and is covered under version 2.1 of the GNU
    Lesser General Public License.  You are welcome to change it and/or
    distribute copies of it under certain conditions.  The calc commands:

	help copying
	help copying-lgpl

    should display the contents of the COPYING and COPYING-LGPL files.
    Those files contain information about the calc's GNU Lesser General
    Public License, and in particular the conditions under which you
    are allowed to change it and/or distribute copies of it.

    You should have received a copy of the version 2.1 GNU
    Lesser General Public License.  If you do not have these
    files, write to:

	Free Software Foundation, Inc.
	59 Temple Place
	Suite 330
	Boston, MA  02111-1307
	USA

See also:

    help copyright
    help copying
    help copying-lgpl

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: credit,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/credit,v $
##
## Under source code control:	1991/07/23 05:47:24
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* COPYING
*************

		calc - arbitrary precision calculator


This file is Copyrighted
------------------------

    This file is covered under the following Copyright:

	Copyright (C) 1999  Landon Curt Noll
	All rights reserved.

	Everyone is permitted to copy and distribute verbatim copies
	of this license document, but changing it is not allowed.

    # @(#) $Revision: 29.7 $
    # @(#) $Id: COPYING,v 29.7 2003/02/26 16:54:59 chongo Exp $
    # @(#) $Source: /usr/local/src/cmd/calc/RCS/COPYING,v $

=-=

Calc is covered by the GNU Lesser General Public License
--------------------------------------------------------

    Calc is open software; you can redistribute it and/or modify it under
    the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation version 2.1 of the License.

    Calc is several binary link libraries, several modules, associated
    interface definition files and scripts used to control its compilation
    and installation.

    Calc is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General
    Public License for more details.

    A copy of the GNU Lesser General Public License is distributed with
    calc under the filename:

	    COPYING-LGPL

    You may display this file by the calc command:	help copying

    You may display the GNU Lesser General
    Public License by the calc command:			help copying-lgpl

    You should have received a copy of the version 2.1 GNU Lesser General
    Public License with calc; if not, write to:

	    Free Software Foundation, Inc.
	    59 Temple Place
	    Suite 330
	    Boston, MA	02111-1307
	    USA

    The contact addresses for calc is as follows:

	Web:	http://www.isthe.com/chongo/tech/comp/calc/email.html

    To join the low volume calc mailing list.  Send a EMail message to:

	calc-tester-request at asthe dot com

    Your subject must contain the words:

	calc mailing list subscription

    You may have additional words in your subject line.

    Your message body (not the subject) should consist of:

	 subscribe calc-tester address
	 end
	 name your_full_name

    where ``address'' is your EMail address and ``your_full_name'' is
    your full name.

    Feel free to follow the name line with additional EMail text as desired.

=-=

    Calc bug reports and calc bug fixes should be sent to:

	calc-bugs at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

    Your subject must contain the words:

	   calc bug report

    You may have additional words in your subject line.

=-=

Calc's relationship to the GNU Lesser General Public License
------------------------------------------------------------

    In section 0 of the GNU Lesser General Public License, one finds
    the following definition:

	The "Library", below, refers to any such software library or
	work which has been distributed under these terms.

    Calc is distributed under the terms of the GNU Lesser
    General Public License.

    In the same section 0, one also find the following:

	For a library, complete source code means all the source code
	for all modules it contains, plus any associated interface
	definition files, plus the scripts used to control compilation
	and installation of the library.

    There are at least two calc binary link libraries found in calc:

	libcalc.a	libcustcalc.a

    Clearly all files that go into the creation of those binary link
    libraries are covered under the License.

    The ``scripts used to control compilation and installation of the
    of the library'' include:

	* Makefiles
	* source files created by the Makefiles
	* source code used in the creation of intermediate source files

     All of those files are covered under the License.

     The ``associated interface definition files'' are those files that:

	* show how the calc binary link libraries are used
	* test the validity of the binary link libraries
	* document routines found in the binary link libraries
	* show how one can interactively use the binary link libraries

     Calc provides an extensive set of files that perform the above
     functions.

	* files under the sample sub-directory
	* files under the help sub-directory
	* files under the lib sub-directory
	* the main calc.c file

     The ``complete source code'' includes ALL files shipped with calc,
     except for the exception files explicitly listed in the ``Calc
     copyrights and exception files'' section below.

=-=

Calc copyrights and exception files
-----------------------------------

    With the exception of the files listed below, Calc is covered under
    the following GNU Lesser General Public License Copyrights:

	Copyright (C) year  David I. Bell
	Copyright (C) year  David I. Bell and Landon Curt Noll
	Copyright (C) year  David I. Bell and Ernest Bowen
	Copyright (C) year  David I. Bell, Landon Curt Noll and Ernest Bowen
	Copyright (C) year  Landon Curt Noll
	Copyright (C) year  Ernest Bowen and Landon Curt Noll
	Copyright (C) year  Ernest Bowen
	Copyright (C) year  Petteri Kettunen and Landon Curt Noll

    These files are not covered under one of the Copyrights listed above:

	    shs1.c	    shs1.h	 shs.c		shs.h
	    md5.c	    md5.h	 COPYING	COPYING-LGPL
	    cal/qtime.cal

    The file COPYING-LGPL, which contains a copy of the version 2.1
    GNU Lesser General Public License, is itself Copyrighted by the
    Free Software Foundation, Inc.  Please note that the Free Software
    Foundation, Inc. does NOT have a copyright over calc, only the
    COPYING-LGPL that is supplied with calc.

    This file, COPYING, is distributed under the Copyright found at the
    top of this file.  It is important to note that you may distribute
    verbatim copies of this file but you may not modify this file.

    Some of these exception files are in the public domain.  Other
    exception files have non-LGPL Copyrights.  Other files are under a
    LGPL Copyright but have different authors.

    In all cases one may use and distribute these exception files freely.
    And because one may freely distribute the LGPL covered files, the
    entire calc source may be freely used and distributed.

=-=

General Copyleft and License info
---------------------------------

    For general information on Copylefts, see:

	http://www.gnu.org/copyleft/

    For information on GNU Lesser General Public Licenses, see:

	http://www.gnu.org/copyleft/lesser.html
	http://www.gnu.org/copyleft/lesser.txt

=-=

Why calc did not use the GNU General Public License
---------------------------------------------------

    It has been suggested that one should consider using the GNU General
    Public License instead of the GNU Lesser General Public License:

	http://www.gnu.org/philosophy/why-not-lgpl.html

    As you can read in the above URL, there are times where a library
    cannot give free software any particular advantage.	 One of those
    times is when there is significantly similar versions available
    that are not covered under a Copyleft such as the GNU General Public
    License.

    The reason why calc was placed under the GNU Lesser General Public
    License is because for many years (1984 thru 1999), calc was offered
    without any form of Copyleft.  At the time calc was placed under
    the GNU Lesser General Public License, a number of systems and
    distributions distributed calc without a Copyleft.

*************
* COPYING-LGPL
*************

		  GNU LESSER GENERAL PUBLIC LICENSE
		       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

		  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.
  
  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

			    NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

		     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!



*************
* wishlist
*************

Calc Enhancement Wish List:

    Send calc comments, suggestions, bug fixes, enhancements and
    interesting calc scripts that you would like you see included in
    future distributions to:

	    calc-contrib at asthe dot com

    The following items are in the calc wish list.  Programs like this
    can be extended and improved forever.

    Calc bug reports, however, should be sent to:

	    calc-bugs at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

    See the 'todo' help file for higher priority todo items.

=-=

    *  In general use faster algorithms for large numbers when they
       become known.  In particular, look at better algorithms for
       very large numbers -- multiply, square and mod in particular.

    *  Implement an autoload feature.  Associate a calc resource filename
       with a function or global variable.  On the first reference of
       such item, perform an automatic load of that file.

    *  Add error handling statements, so that QUITs, errors from the
       'eval' function, division by zeroes, and so on can be caught.
       This should be done using syntax similar to:

		ONERROR statement DO statement;

       Something like signal isn't versatile enough.

    *  Add a debugging capability so that functions can be single stepped,
       breakpoints inserted, variables displayed, and so on.

    *  Figure out how to write all variables out to a file, including
       deeply nested arrays, lists, and objects.

       Add the ability to read and write a value in some binary form.
       Clearly this is easy for non-neg integers.  The question of
       everything else is worth pondering.

    *  Eliminate the need for the define keyword by doing smarter parsing.

    *  Allow results of a command (or all commands) to be re-directed to a
       file or piped into a command.

    *  Add some kind of #include and #define facility.	Perhaps use
       the C pre-processor itself?

    *  Support a more general input and output base mode other than
       just dec, hex or octal.

    *  Implement a form of symbolic algebra.  Work on this has already
       begun.  This will use backquotes to define expressions, and new
       functions will be able to act on expressions.  For example:

	    x = `hello * strlen(mom)`;
	    x = sub(x, `hello`, `hello + 1`);
	    x = sub(x, `hello`, 10, `mom`, "curds");
	    eval(x);

       prints 55.

    *  Place the results of previous commands into a parallel history list.
       Add a binding that returns the saved result of the command so
       that one does not need to re-execute a previous command simply
       to obtain its value.

       If you have a command that takes a very long time to execute,
       it would be nice if you could get at its result without having
       to spend the time to reexecute it.

    *  Add a binding to delete a value from the history list.

       One may need to remove a large value from the history list if
       it is very large.  Deleting the value would replace the history
       entry with a null value.

    *  Add a binding to delete a command from the history list.

       Since you can delete values, you might as well be able to
       delete commands.

    *  All one to alter the size of the history list thru config().

       In some cases, 256 values is too small, in others it is too large.

    *  Add a builtin that returns a value from the history list.
       As an example:

	    histval(-10)

       returns the 10th value on the history value list, if such
       a value is in the history list (null otherwise).	 And:

	    histval(23)

       return the value of the 23rd command given to calc, if
       such a value is in the history list (null otherwise).

       It would be very helpful to use the history values in
       subsequent equations.

    *  Add a builtin that returns command as a string from the
       history list.  As an example:

	    history(-10)

       returns a string containing the 10th command on the
       history list, if a such a value is in the history list
       (empty string otherwise).  And:

	    history(23)

       return the string containing the 23rd command given to calc, if
       such a value is in the history list (empty string otherwise).

       One could use the eval() function to re-evaluate the command.

    *  Allow one to optionally restore the command number to calc
       prompts.	 When going back in the history list, indicate the
       command number that is being examined.

       The command number was a useful item.  When one is scanning the
       history list, knowing where you are is hard without it.	It can
       get confusing when the history list wraps or when you use
       search bindings.	 Command numbers would be useful in
       conjunction with positive args for the history() and histval()
       functions as suggested above.

    *  Add a builtin that returns the current command number.
       For example:

	    cmdnum()

       returns the current command number.

       This would allow one to tag a value in the history list.	 One
       could save the result of cmdnum() in a variable and later use
       it as an arg to the histval() or history() functions.

    *  Add a factoring builtin functions.  Provide functions that perform
       multiple polynomial quadratic sieves, elliptic curve, difference
       of two squares, N-1 factoring as so on.	Provide a easy general
       factoring builtin (say factor(foo)) that would attempt to apply
       whatever process was needed based on the value.

       Factoring builtins would return a matrix of factors.

       It would be handy to configure, via config(), the maximum time
       that one should try to factor a number.	By default the time
       should be infinite.  If one set the time limit to a finite
       value and the time limit was exceeded, the factoring builtin
       would return whatever if had found thus far, even if no new
       factors had been found.

       Another factoring configuration interface, via config(), that
       is needed would be to direct the factoring builtins to return
       as soon as a factor was found.

    *  Allow one to config calc break up long output lines.

       The command:  calc '2^100000'  will produce one very long
       line.  Many times this is reasonable.  Long output lines
       are a problem for some utilities.  It would be nice if one
       could configure, via config(), calc to fold long lines.

       By default, calc should continue to produce long lines.

       One option to config should be to specify the length to
       fold output.  Another option should be to append a trailing
       \ on folded lines (as some symbolic packages use).

    *  Allow one to use the READ and WRITE commands inside a function.

    *  Remove or increase limits on factor(), lfactor(), isprime(),
       nextprime(), and prevprime().  Currently these functions cannot
       search for factors > 2^32.

    *  Add read -once -try "filename" which would do nothing
       if "filename" was not a readable file.

## Copyright (C) 1999  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.2 $
## @(#) $Id: wishlist,v 29.2 2000/06/07 14:02:33 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/wishlist,v $
##
## Under source code control:	1991/07/21 04:37:24
## File existed as early as:	1991
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/

*************
* todo
*************

Calc Todo Items:

    The following items should be addressed sometime in the short to
    medium term future, if not before the next release.

    Code contributions are welcome.  Send patches to:

	    calc-contrib at asthe dot com

    Calc bug reports, however, should send to:

	    calc-bugs at asthe dot com

    [[ NOTE: Replace 'at' with @, 'dot' is with . and remove the spaces ]]
    [[ NOTE: The EMail address uses 'asthe' and the web site URL uses 'isthe' ]]

    See the BUGS file or try the calc command:

	    help bugs

    See also the 'wishlist' help files for the calc enhancement wish list.

=-=

Very High priority items:

    * Write the help file for the display() builtin function.

    * Write the help file for the stoponerror() builtin function.

    * Update the errmax about the meaning of errmax(-1).

    * Review and if needed, correct/update the help topics:

	    topic		description
	    -----		-----------
	    intro		introduction to calc
	    overview		overview of calc
	    assoc		using associations
	    command		top level commands
	    define		how to define functions
	    environment		how environment variables effect calc
	    errorcodes		calc generated error codes
	    expression		expression sequences
	    file		using files
	    history		command history
	    interrupt		how interrupts are handled
	    list		using lists
	    obj			user defined data types
	    operator		math, relational, logic and variable access ...
	    statement		flow control and declaration statements
	    types		builtin data types
	    unexpected		unexpected syntax/usage surprises for C ...
	    variable		variables and variable declarations
	    libcalc		using the arbitrary precision routines in ...
	    bugs		known bugs and mis-features
	    wishlist		wish list of future enhancements of calc

    * Fix any 'Known bugs' as noted in the BUGS file or as
      displayed by 'calc help bugs'.

    * Internationalize calc by converting calc error messages and
      text strings (e.g., calc startup banner, show output, etc.)
      into calls to the GNU gettext internationalization facility.
      If somebody translated these strings into another language,
      setting $LANG would allow calc to produce error messages
      and text strings in that language.

    * Consider using GNU autoconf / configure to build the calc Makefile.

=-=

High priority items:

    * Verify, complete or fix the 'SEE ALSO' help file sections.

    * Verify, complete or fix the 'LINK LIBRARY' help file sections.

    * Verify, complete or fix the 'LIMITS' help file sections.

    * Verify, complete or fix the 'SYNOPSIS' and 'TYPES' help file sections.

    * Where reasonable, be sure that regress.cal tests builtin functions.

    * Perform a code coverage analysis of the 'make check' action
      and improve the coverage (within reason) of the regress.cal suite.

    * Address, if possible and reasonable, any Calc Mis-features
      as noted in the BUGS file or as displayed by 'calc help bugs'.

=-=

Medium priority items:

    * Complete the use of CONST where appropriate:

	CONST is beginning to be used with read-only tables and some
	function arguments.  This allows certain compilers to better
	optimize the code as well as alerts one to when some value
	is being changed inappropriately.  Use of CONST as in:

	    int foo(CONST int curds, char *CONST whey)

	while legal C is not as useful because the caller is protected
	by the fact that args are passed by value.  However, the
	in the following:

	    int bar(CONST char *fizbin, CONST HALF *data)

	is useful because it calls the compiler that the string pointed
	at by 'fizbin' and the HALF array pointer at by 'data' should be
	treated as read-only.

    * It is overkill to have nearly everything wind up in libcalc.a.

      One should make available a the fundamental math operations
      on ZVALUE, NUMBER and perhaps COMPLEX (without all of the
      other stuff) in a separate library.

    * Clean the source code and document it better.

    * Add a builtin function to access the 64 bit FNV hash which
      is currently being used internally in seed.c.

## Copyright (C) 1999-2003  Landon Curt Noll
##
## Calc is open software; you can redistribute it and/or modify it under
## the terms of the version 2.1 of the GNU Lesser General Public License
## as published by the Free Software Foundation.
##
## Calc is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU Lesser General
## Public License for more details.
##
## A copy of version 2.1 of the GNU Lesser General Public License is
## distributed with calc under the filename COPYING-LGPL.  You should have
## received a copy with calc; if not, write to Free Software Foundation, Inc.
## 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
##
## @(#) $Revision: 29.5 $
## @(#) $Id: todo,v 29.5 2003/02/25 20:26:17 chongo Exp $
## @(#) $Source: /usr/local/src/cmd/calc/help/RCS/todo,v $
##
## Under source code control:	1999/10/20 07:42:55
## File existed as early as:	1999
##
## chongo <was here> /\oo/\	http://www.isthe.com/chongo/
## Share and enjoy!  :-)	http://www.isthe.com/chongo/tech/comp/calc/
