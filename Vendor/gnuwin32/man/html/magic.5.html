     <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>magic(5) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>NAME</a></h2>
  
<h2><a name='sect1' href='#toc1'>DESCRIPTION</a></h2>
This manual page documents the format of the magic
file as used by the  command, version 5.03. The  command identifies the type
of a file using, among other tests, a test for whether the file contains
certain  The file  specifies what patterns are to be tested for, what message
or MIME type to print if a particular pattern is found, and additional
information to extract from the file.  Each line of the file specifies a
test to be performed. A test compares the data starting at a particular
offset in the file with a byte value, a string or a numeric value. If the
test succeeds, a message is printed. The line consists of the following
fields:   A number specifying the offset, in bytes, into the file of the
data which is to be tested.  The type of the data to be tested. The possible
values are:   A one-byte value.  A two-byte value in this machine&rsquo;s native
byte order.  A four-byte value in this machine&rsquo;s native byte order.  An eight-byte
value in this machine&rsquo;s native byte order.  A 32-bit single precision IEEE
floating point number in this machine&rsquo;s native byte order.  A 64-bit double
precision IEEE floating point number in this machine&rsquo;s native byte order.
 A string of bytes. The string type specification can be optionally followed
by /[Bbc]*. The  flag compacts whitespace in the target, which must contain
at least one whitespace character. If the magic has  consecutive blanks,
the target needs at least  consecutive blanks to match. The  flag treats
every blank in the target as an optional blank. Finally the  flag, specifies
case insensitive matching: lowercase characters in the magic match both
lower and upper case characters in the target, whereas upper case characters
in the magic only match uppercase characters in the target.  A Pascal-style
string where the first byte is interpreted as the an unsigned length. The
string is not NUL terminated.  A four-byte value interpreted as a UNIX date.
 A eight-byte value interpreted as a UNIX date.  A four-byte value interpreted
as a UNIX-style date, but interpreted as local time rather than UTC.  An
eight-byte value interpreted as a UNIX-style date, but interpreted as local
time rather than UTC.  A 32-bit ID3 length in big-endian byte order.  A two-byte
value in big-endian byte order.  A four-byte value in big-endian byte order.
 An eight-byte value in big-endian byte order.  A 32-bit single precision IEEE
floating point number in big-endian byte order.  A 64-bit double precision
IEEE floating point number in big-endian byte order.  A four-byte value in
big-endian byte order, interpreted as a Unix date.  An eight-byte value in
big-endian byte order, interpreted as a Unix date.  A four-byte value in big-endian
byte order, interpreted as a UNIX-style date, but interpreted as local time
rather than UTC.  An eight-byte value in big-endian byte order, interpreted
as a UNIX-style date, but interpreted as local time rather than UTC.  A two-byte
unicode (UCS16) string in big-endian byte order.  A 32-bit ID3 length in little-endian
byte order.  A two-byte value in little-endian byte order.  A four-byte value
in little-endian byte order.  An eight-byte value in little-endian byte order.
 A 32-bit single precision IEEE floating point number in little-endian byte
order.  A 64-bit double precision IEEE floating point number in little-endian
byte order.  A four-byte value in little-endian byte order, interpreted as
a UNIX date.  An eight-byte value in little-endian byte order, interpreted
as a UNIX date.  A four-byte value in little-endian byte order, interpreted
as a UNIX-style date, but interpreted as local time rather than UTC.  An
eight-byte value in little-endian byte order, interpreted as a UNIX-style
date, but interpreted as local time rather than UTC.  A two-byte unicode
(UCS16) string in little-endian byte order.  A four-byte value in middle-endian
(PDP-11) byte order.  A four-byte value in middle-endian (PDP-11) byte order,
interpreted as a UNIX date.  A four-byte value in middle-endian (PDP-11) byte
order, interpreted as a UNIX-style date, but interpreted as local time rather
than UTC.  Starting at the given offset, consult the magic database again.
 A regular expression match in extended POSIX regular expression syntax
(like egrep). Regular expressions can take exponential time to process,
and their performance is hard to predict, so their use is discouraged. When
used in production environments, their performance should be carefully
checked. The type specification can be optionally followed by  The  flag
makes the match case insensitive, while the  flag update the offset to
the start offset of the match, rather than the end. The regular expression
is tested against line  onwards, where  is the given offset. Line endings
are assumed to be in the machine&rsquo;s native format.  and  match the beginning
and end of individual lines, respectively, not beginning and end of file.
 A literal string search starting at the given offset. The same modifier
flags can be used as for string patterns. The modifier flags (if any) must
be followed by  the range, that is, the number of positions at which the
match will be attempted, starting from the start offset. This is suitable
for searching larger binary expressions with variable offsets, using  escapes
for special characters. The offset works as for regex.  This is intended
to be used with the test  (which is always true) and a message that is
to be used if there are no other matches.   Each top-level magic pattern
(see below for an explanation of levels) is classified as text or binary
according to the types used. Types  and  are classified as text tests, unless
non-printable characters are used in the pattern. All other tests are classified
as binary. A top-level pattern is considered to be a test text when all its
patterns are text patterns; otherwise, it is considered to be a binary
pattern. When matching a file, binary patterns are tried first; if no match
is found, and the file looks like text, then its encoding is determined
and the text patterns are tried.  The numeric types may optionally be followed
by  and a numeric value, to specify that the value is to be AND&rsquo;ed with
the numeric value before any comparisons are done. Prepending a  to the
type indicates that ordered comparisons should be unsigned.  The value to
be compared with the value from the file. If the type is numeric, this value
is specified in C form; if it is a string, it is specified as a C string
with the usual escapes permitted (e.g. \n for new-line).  Numeric values may
be preceded by a character indicating the operation to be performed. It
may be  to specify that the value from the file must equal the specified
value,  to specify that the value from the file must be less than the specified
value,  to specify that the value from the file must be greater than the
specified value,  to specify that the value from the file must have set
all of the bits that are set in the specified value,  to specify that the
value from the file must have clear any of the bits that are set in the
specified value, or  the value specified after is negated before tested.
 to specify that any value will match. If the character is omitted, it is
assumed to be  Operators   and  don&rsquo;t work with floats and doubles. The operator
 specifies that the line matches if the test does  succeed.  Numeric values
are specified in C form; e.g.  is decimal,  is octal, and  is hexadecimal.
 For string values, the string from the file must match the specified string.
The operators   and  (but not  can be applied to strings. The length used
for matching is that of the string argument in the magic file. This means
that a line can match any non-empty string (usually used to then print the
string), with  (because all non-empty strings are greater than the empty
string).  The special test  always evaluates to true.  The message to be
printed if the comparison succeeds. If the string contains a  format specification,
the value from the file (with any specified masking performed) is printed
using the message as the format string. If the string begins with  the message
printed is the remainder of the string with no whitespace added before
it: multiple matches are normally separated by a single space.   An APPLE
4+4 character APPLE creator and type can be specified as:  !:apple<tt> </tt>&nbsp;<tt> </tt>&nbsp;CREATYPE
  A MIME type is given on a separate line, which must be the next non-blank
or comment line after the magic line that identifies the file type, and
has the following format:  !:mime<tt> </tt>&nbsp;<tt> </tt>&nbsp;MIMETYPE   i.e. the literal string  followed
by the MIME type.  An optional strength can be supplied on a separate line
which refers to the current magic description using the following format:
 !:strength OP VALUE   The operand  can be:     or  and  is a constant
between 0 and 255. This constant is applied using the specified operand
to the currently computed default magic strength.  Some file formats contain
additional information which is to be printed along with the file type
or need additional tests to determine the true file type. These additional
tests are introduced by one or more  characters preceding the offset. The
number of  on the line indicates the level of the test; a line with no
 at the beginning is considered to be at level 0. Tests are arranged in
a tree-like hierarchy: If a the test on a line at level  succeeds, all following
tests at level  are performed, and the messages printed if the tests succeed,
untile a line with level  (or less) appears. For more complex files, one
can use empty messages to get just the "if/then" effect, in the following
way:  0      string   MZ Gt]0x18  leshort  Lt]0x40   MS-DOS executable Gt]0x18
 leshort  Gt]0x3f   extended PC executable (e.g., MS Windows)   Offsets do
not need to be constant, but can also be read from the file being examined.
If the first character following the last  is a  then the string after
the parenthesis is interpreted as an indirect offset. That means that the
number after the parenthesis is used as an offset in the file. The value
at that offset is read, and is used again as an offset in the file. Indirect
offsets are of the form:  The value of  is used as an offset in the file.
A byte, id3 length, short or long is read at that offset depending on the
 type specifier. The capitalized types interpret the number as a big endian
value, whereas the small letter versions interpret the number as a little
endian value; the  type interprets the number as a middle endian (PDP-11)
value. To that number the value of  is added and the result is used as an
offset in the file. The default type if one is not specified is long.  That
way variable length structures can be examined:  # MS Windows executables
are also valid MS-DOS executables 0           string  MZ Gt]0x18       leshort
Lt]0x40   MZ executable (MS-DOS) # skip the whole block below if it is not
an extended executable Gt]0x18       leshort Gt]0x3f Gt]Gt](0x3c.l)  string
 PE\0\0  PE executable (MS-Windows) Gt]Gt](0x3c.l)  string  LX\0\0  LX executable
(OS/2)   This strategy of examining has a drawback: You must make sure
that you eventually print something, or users may get empty output (like,
when there is neither PE\0\0 nor LE\0\0 in the above example)  If this indirect
offset cannot be used directly, simple calculations are possible: appending
 inside parentheses allows one to modify the value read from the file before
it is used as an offset:  # MS Windows executables are also valid MS-DOS
executables 0           string  MZ # sometimes, the value at 0x18 is less
that 0x40 but there&rsquo;s still an # extended executable, simply appended to
the file Gt]0x18       leshort Lt]0x40 Gt]Gt](4.s*512) leshort 0x014c  COFF
executable (MS-DOS, DJGPP) Gt]Gt](4.s*512) leshort !0x014c MZ executable
(MS-DOS)   Sometimes you do not know the exact offset as this depends on
the length or position (when indirection was used before) of preceding
fields. You can specify an offset relative to the end of the last up-level
field using  as a prefix to the offset:  0           string  MZ Gt]0x18
      leshort Gt]0x3f Gt]Gt](0x3c.l)  string  PE\0\0    PE executable (MS-Windows)
# immediately following the PE signature is the CPU type Gt]Gt]Gt]Am]0
      leshort 0x14c     for Intel 80386 Gt]Gt]Gt]Am]0       leshort 0x184
    for DEC Alpha   Indirect and relative offsets can be combined:  0 
           string  MZ Gt]0x18         leshort Lt]0x40 Gt]Gt](4.s*512)  
leshort !0x014c MZ executable (MS-DOS) # if it&rsquo;s not COFF, go back 512 bytes
and add the offset taken # from byte 2/3, which is yet another way of finding
the start # of the extended executable Gt]Gt]Gt]Am](2.s-514) string  LE 
    LE executable (MS Windows VxD driver)   Or the other way around:  0
                string  MZ Gt]0x18             leshort Gt]0x3f Gt]Gt](0x3c.l)
       string  LE\0\0  LE executable (MS-Windows) # at offset 0x80 (-4, since
relative offsets start at the end # of the up-level match) inside the LE
header, we find the absolute # offset to the code area, where we look for
a specific signature Gt]Gt]Gt](Am]0x7c.l+0x26) string  UPX     \b, UPX compressed
  Or even both!  0                string  MZ Gt]0x18            leshort
Gt]0x3f Gt]Gt](0x3c.l)       string  LE\0\0 LE executable (MS-Windows) # at
offset 0x58 inside the LE header, we find the relative offset # to a data
area where we look for a specific signature Gt]Gt]Gt]Am](Am]0x54.l-3)  string
 UNACE  \b, ACE self-extracting archive   Finally, if you have to deal with
offset/length pairs in your file, even the second value in a parenthesized
expression can be taken from the file itself, using another set of parentheses.
Note that this additional indirect offset is always relative to the start
of the main indirect offset.  0                 string       MZ Gt]0x18
            leshort      Gt]0x3f Gt]Gt](0x3c.l)        string       PE\0\0
PE executable (MS-Windows) # search for the PE section called ".idata"... Gt]Gt]Gt]Am]0xf4
         search/0x140 .idata # ...and go to the end of it, calculated from
start+length; # these are located 14 and 10 bytes after the section name
Gt]Gt]Gt]Gt](Am]0xe.l+(-4)) string       PK\3\4 \b, ZIP self-extracting archive
 
<h2><a name='sect2' href='#toc2'>SEE ALSO</a></h2>
 - the command that reads this file. 
<h2><a name='sect3' href='#toc3'>BUGS</a></h2>
The formats           
  and  are system-dependent; perhaps they should be specified as a number
of bytes (2B, 4B, etc), since the files being recognized typically come
from a system on which the lengths are invariant.              <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>NAME</a></li>
<li><a name='toc1' href='#sect1'>DESCRIPTION</a></li>
<li><a name='toc2' href='#sect2'>SEE ALSO</a></li>
<li><a name='toc3' href='#sect3'>BUGS</a></li>
</ul>
</body>
</html>
