             <!-- manual page source format generated by PolyglotMan v3.0.9, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>MBSRTOWCS(3) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>

<H2><A NAME="sect0" HREF="#toc0">Name</A></H2>
mbsrtowcs - convert a multibyte string to a wide character
string 
<H2><A NAME="sect1" HREF="#toc1">Synopsis</A></H2>
<BR>
<PRE>#include &lt;wchar.h&gt;
size_t mbsrtowcs (wchar_t* dest, const char** src,                  size_t
len, mbstate_t* ps);</PRE>
<H2><A NAME="sect2" HREF="#toc2">Description</A></H2>
If <I>dest</I> is not a NULL pointer, the <B>mbsrtowcs</B>
function converts the multibyte string <I>*src</I> to a wide-character string starting
at <I>dest</I>. At most <I>len</I> wide characters are written to <I>dest</I>. The shift state
<I>*ps</I> is updated. The conversion is effectively performed by repeatedly calling
mbrtowc(<I>dest</I>,<I>*src</I>,<I>n</I>,<I>ps</I>) where <I>n</I> is some positive number, as long as this
call succeeds, and then incrementing <I>dest</I> by one and <I>*src</I> by the number
of bytes consumed. The conversion can stop for three reasons: <P>
1. An invalid
multibyte sequence has been encountered. In this case <I>*src</I> is left pointing
to the invalid multibyte sequence, (size_t)(-1) is returned, and <B>errno</B> is
set to <B>EILSEQ</B>. <P>
2. <I>len</I> non-L'\0' wide characters have been stored at <I>dest</I>. In this
case <I>*src</I> is left pointing to the next multibyte sequence to be converted,
and the number of wide characters written to <I>dest</I> is returned. <P>
3. The multibyte
string has been completely converted, including the terminating '\0' (which
has the side effect of bringing back <I>*ps</I> to the initial state). In this
case <I>*src</I> is set to NULL, and the number of wide characters written to
<I>dest</I>, excluding the terminating L'\0' character, is returned. <P>
If <I>dest</I> is NULL,
<I>len</I> is ignored, and the conversion proceeds as above, except that the converted
wide characters are not written out to memory, and that no length limit
exists. <P>
In both of the above cases, if <I>ps</I> is a NULL pointer, a static anonymous
state only known to the mbsrtowcs function is used instead. <P>
The programmer
must ensure that there is room for at least <I>len</I> wide characters at <I>dest</I>.

<H2><A NAME="sect3" HREF="#toc3">Return Value</A></H2>
The <B>mbsrtowcs</B> function returns the number of wide characters
that make up the converted part of the wide character string, not including
the terminating null wide character. If an invalid multibyte sequence was
encountered, (size_t)(-1) is returned, and <B>errno</B> set to <B>EILSEQ</B>. 
<H2><A NAME="sect4" HREF="#toc4">Conforming
to</A></H2>
ISO/ANSI C, UNIX98 
<H2><A NAME="sect5" HREF="#toc5">See Also</A></H2>
<B><A HREF="mbstowcs.3.html">mbstowcs</B>(3)</A>
, <B><A HREF="mbsnrtowcs.3.html">mbsnrtowcs</B>(3)</A>
, <B><A HREF="iconv.3.html">iconv</B>(3)</A>
 
<H2><A NAME="sect6" HREF="#toc6">Notes</A></H2>
The
behaviour of <B>mbsrtowcs</B> depends on the LC_CTYPE category of the current
locale. <P>
Passing NULL as <I>ps</I> is not multi-thread safe. <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Return Value</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Conforming to</A></LI>
<LI><A NAME="toc5" HREF="#sect5">See Also</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Notes</A></LI>
</UL>
</BODY></HTML>
