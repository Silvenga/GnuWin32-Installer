<!-- manual page source format generated by PolyglotMan v3.0.9, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>POPT(3) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>

<H2><A NAME="sect0" HREF="#toc0">Name</A></H2>
popt - Parse command line options 
<H2><A NAME="sect1" HREF="#toc1">Synopsis</A></H2>
<BR>
<PRE>#include &lt;popt.h&gt;
poptContext poptGetContext(const char * name, int argc,               
           const char ** argv,                           const struct poptOption
* options,                           int flags);
void poptFreeContext(poptContext con);
void poptResetContext(poptContext con);
int poptGetNextOpt(poptContext con);
const char * poptGetOptArg(poptContext con);
const char * poptGetArg(poptContext con);
const char * poptPeekArg(poptContext con);
const char ** poptGetArgs(poptContext con);
const char *const poptStrerror(const int error);
const char * poptBadOption(poptContext con, int flags);
int poptReadDefaultConfig(poptContext con, int flags);
int poptReadConfigFile(poptContext con, char * fn);
int poptAddAlias(poptContext con, struct poptAlias alias,             
   int flags);
int poptParseArgvString(char * s, int *  argcPtr,                     
  const char *** argvPtr);
int poptDupArgv(int argc, const char ** argv, int * argcPtr,          
             const char *** argvPtr);
int poptStuffArgs(poptContext con, const char ** argv);
</PRE>
<H2><A NAME="sect2" HREF="#toc2"></B>Description</A></H2>
The popt library exists essentially for parsing command-line
 options. It is found superior in many ways when compared to  parsing the
argv array by hand or using the getopt functions  <B>getopt()</B> and  <B>getopt_long()</B>
[see  <B><A HREF="getopt.3.html">getopt</B>(3)</A>
].<B></B> Some specific advantages of popt are: it does not utilize
global  variables, thus enabling multiple passes in parsing <I>argv</I> ; it can
parse an arbitrary array of <I>argv</I>-style elements, <I></I> allowing parsing of command-line-strings
from any source;  it provides a standard method of option aliasing (to
be  discussed at length below.); it can exec external option filters; and,
finally, it can automatically generate help and usage messages for the
application. <P>
Like <B>getopt_long()</B>, the popt library supports short and long
style options.  Recall  that a  <B>short option</B> consists of a - character followed
by a single alphanumeric character. A  <B>long option</B>, common in GNU utilities,
consists of two - characters followed by a string made up of letters, numbers
and hyphens.  Long options are optionally allowed to begin with a single
-, primarily to allow command-line compatibility between popt applications
and X toolkit applications. Either type of option may be followed by an
argument.  A space separates a  short option from its arguments; either
a space or an = separates a long  option from an argument.  <P>
The popt library
is highly portable and should work on any POSIX  platform.  The latest version
is distributed with rpm and is always available from: ftp://ftp.rpm.org/pub/rpm/dist.
<P>
It may be redistributed under the X consortium license, see the file COPYING
in the popt source distribution for details. 
<H2><A NAME="sect3" HREF="#toc3">Basic Popt Usage</A></H2>

<H3><A NAME="sect4" HREF="#toc4">1. the Option
Table</A></H3>
Applications provide popt with information on their command-line  options
by means of an "option table," i.e., an array of  <B>struct poptOption </B> structures:
<P>
#include &lt;popt.h&gt; <P>
<BR>
<PRE>struct poptOption {
    const char * longName; /* may be NULL */
    char shortName;        /* may be '\0' */
    int argInfo;
    void * arg;            /* depends on argInfo */
    int val;               /* 0 means don't return, just update flag */
    char * descrip;        /* description for autohelp -- may be NULL */
    char * argDescrip;     /* argument description for autohelp */
};
</PRE><P>
Each member of the table defines a single option that may be  passed to
the program.  Long and short options are considered  a single option that
may occur in two different forms.  The  first two members,  <I>longName</I> and
<I>shortName</I>, define the names of the option; the first is a long name, while
the latter is a single character. <P>
The  <I>argInfo</I> member tells popt what type
of argument is expected<I></I> after the argument.  If no option is expected, <B>POPT_ARG_NONE</B>
should be used. The rest of the valid values are shown in the following
table: <P>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT>Value</TD><TD ALIGN=LEFT>Description</TD><TD ALIGN=LEFT>arg Type</TD></TR>
<TR><TD ALIGN=LEFT>POPT_ARG_NONE</TD><TD ALIGN=LEFT>No argument expected</TD><TD ALIGN=LEFT>int</TD></TR>
<TR><TD ALIGN=LEFT>POPT_ARG_STRING</TD><TD ALIGN=LEFT>No
type checking to be performed</TD><TD ALIGN=LEFT>char *</TD></TR>
<TR><TD ALIGN=LEFT>POPT_ARG_INT</TD><TD ALIGN=LEFT>An integer argument is expected</TD><TD ALIGN=LEFT>int</TD></TR>
<TR><TD ALIGN=LEFT>POPT_ARG_LONG</TD><TD ALIGN=LEFT>A
long integer is expected</TD><TD ALIGN=LEFT>long</TD></TR>
<TR><TD ALIGN=LEFT>POPT_ARG_VAL</TD><TD ALIGN=LEFT>Integer value taken from CWval</TD><TD ALIGN=LEFT>int</TD></TR>
<TR><TD ALIGN=LEFT>POPT_ARG_FLOAT</TD><TD ALIGN=LEFT>An
float argument is expected</TD><TD ALIGN=LEFT>float</TD></TR>
<TR><TD ALIGN=LEFT>POPT_ARG_DOUBLE</TD><TD ALIGN=LEFT>A double argument is expected</TD><TD ALIGN=LEFT>double</TD></TR>
</TABLE>
<P>
For
numeric values, if the <I>argInfo</I> value is bitwise or'd with one of <B>POPT_ARGFLAG_OR</B>,
<B>POPT_ARGFLAG_AND</B>, or <B>POPT_ARGFLAG_XOR</B>, the value is saved by performing
an OR, AND, or XOR. If the <I>argInfo</I> value is bitwise or'd with <B>POPT_ARGFLAG_NOT</B>,
the value will be negated before saving. For the common operations of setting
and/or clearing bits, <B>POPT_BIT_SET</B> and <B>POPT_BIT_CLR</B> have the appropriate
flags set to perform bit operations. <P>
If the <I>argInfo</I> value is bitwise or'd
with <B>POPT_ARGFLAG_ONEDASH</B>, the long argument may be given with a single
- instead of two. For example, if <B>--longopt</B> is an option with <B>POPT_ARGFLAG_ONEDASH</B>,
is specified, <B>-longopt</B> is accepted as well. <P>
The next element, <I>arg</I>, allows
popt to automatically update <I></I> program variables when the option is used.
If <I>arg</I> is <I></I> <B>NULL</B>, it is ignored and popt takes no special action. <B></B> Otherwise
it should point to a variable of the type indicated in the  right-most column
of the table above. <P>
If the option takes no argument (<I>argInfo</I> is <I></I> <B>POPT_ARG_NONE</B>),
the variable pointed to by <B></B> <I>arg</I> is set to 1 when the option is used.  (Incidentally,
it  will perhaps not escape the attention of hunt-and-peck typists that 
the value of <B>POPT_ARG_NONE</B> is 0.)  If the option does take  an argument,
the variable that  <I>arg</I> points to is updated to reflect the value of the
argument.<I></I> Any string is acceptable for <B>POPT_ARG_STRING</B> arguments, but  <B>POPT_ARG_INT</B>,
<B>POPT_ARG_LONG</B>, <B>POPT_ARG_FLOAT</B>, and  <B>POPT_ARG_DOUBLE</B> are converted to the
appropriate type, and an  error returned if the conversion fails. <P>
<B>POPT_ARG_VAL</B>
causes <I>arg</I> to be set to the (integer) value of <I>val</I> when the argument is
found.  This is most often useful for mutually-exclusive arguments in cases
where it is not an error for multiple arguments to occur and where you
want the last argument specified to win; for example, "rm -i -f".  <B>POPT_ARG_VAL</B>
causes the parsing function not to return a value, since the value of <I>val</I>
has already been used. <P>
If the <I>argInfo</I> value is bitwise or'd with <B>POPT_ARGFLAG_OPTIONAL</B>,
the argument to the long option may be omitted. If the long option is used
without an argument, a default value of zero or NULL will be saved (if
the arg pointer is present), otherwise behavior will be identical to a
long option with argument. <P>
The next option, <I>val</I>, is the value popt's parsing
function <I></I> should return when the option is encountered.  If it is 0, the
parsing function does not return a value, instead parsing the next  command-line
argument. <P>
The last two options, <I>descrip</I> and <I>argDescrip</I> are only required<I></I>
if automatic help messages are desired (automatic usage messages can be
generated without them). <I>descrip</I> is a text description of the<I></I> argument and
<I>argdescrip</I> is a short summary of the type of arguments<I></I> the option expects,
or NULL if the option doesn't require any <I></I> arguments. <P>
If popt should automatically
provide <B>--usage</B> and <B>--help</B> (<B>-?</B>) options, one line in the table should be the
macro <B>POPT_AUTOHELP</B>. This macro includes another option table (via <B>POPT_ARG_INCLUDE_TABLE;</B>
see below) in the main one which provides the table entries for these arguments.
When <B>--usage</B> or <B>--help</B> are passed to programs which use popt's automatical help,
popt displays the appropriate message on  stderr as soon as it finds the
option, and exits the program with a return code of 0. If you want to use
popt's automatic help generation in a different way, you need to explicitly
add the option entries to your programs  option table instead of using
<B>POPT_AUTOHELP</B>. <P>
If the <I>argInfo</I> value is bitwise or'd with <B>POPT_ARGFLAG_DOC_HIDDEN</B>,
the argument will not be shown in help output. <P>
If the <I>argInfo</I> value is bitwise
or'd with <B>POPT_ARGFLAG_SHOW_DEFAULT</B>, the inital value of the arg will be
shown in help output. <P>
The final structure in the table should have all the
pointer values set to <B>NULL</B> and all the arithmetic values set to 0, marking
the  end of the table. The macro <B>POPT_TABLEEND</B> is provided to do that. <P>
There
are two types of option table entries which do not specify command line
options. When either of these types of entries are used, the <I>longName</I> element
must be <B>NULL</B> and the <B>shortName</B> element must be <B>'\0'</B>. <P>
The first of these special
entry types allows the application to nest another option table in the
current one; such nesting may extend quite deeply (the actual depth is
limited by the program's stack). Including other option tables allows a library
to provide a standard set of command-line options to every program which
uses it (this is often done in graphical programming toolkits, for example).
To do this, set the <I>argInfo</I> field to <B>POPT_ARG_INCLUDE_TABLE</B> and the arg
field to point to the table which is being included. If automatic help generation
is being used, the <I>descrip</I> field should contain a overall description of
the option table being included. <P>
The other special option table entry type
tells popt to call a function (a callback) when any option in that table
is found. This is especially usefull when included option tables are being
used, as the program which provides the top-level option table doesn't need
to be aware of the other options which are provided by the included table.
When a callback is set for a table, the parsing function never returns
information on an option in the table. Instead, options information must
be retained via the callback or by having popt set a variable through the
option's <I>arg</I> field. Option callbacks should match the following prototype:
<P>
<BR>
<PRE>void poptCallbackType(poptContext con,                       const struct
poptOption * opt,                       const char * arg, void * data);</PRE><P>
</B>The
first parameter is the context which is being parsed (see the next section
for information on contexts), <I>opt</I> points to the option which triggered
this callback, and <I>arg</I> is the option's argument. If the option does not take
an argument, <I>arg</I> is <B>NULL</B>.  The final parameter, <I>data</I> is taken from the <I>descrip</I>
field of the option table entry which defined the callback. As <I>descrip</I> is
a pointer, this allows callback functions to be passed an arbitrary set
of data (though a typecast will have to be used). <P>
The option table entry
which defines a callback has an <I>argInfo</I> of <B>POPT_ARG_CALLBACK</B>, an <I>arg</I> which
points to the callback function, and a <I>descrip</I> field which specifies an
arbitrary pointer to be passed to the callback. 
<H3><A NAME="sect5" HREF="#toc5">2. Creating a Context</A></H3>
popt
can interleave the parsing of multiple command-line sets. It allows this
by keeping all the state information for a particular set of command-line
arguments in a  <B>poptContext</B> data structure, an opaque type that should
not be  modified outside the popt library. <P>
New popt contexts are created
by <B>poptGetContext()</B>: <P>
<BR>
<PRE>poptContext poptGetContext(const char * name, int argc,               
           const char ** argv,                           const struct poptOption
* options,                           int flags);</PRE><P>
</B>The first parameter,  <I>name</I>,
is used only for alias handling (discussed later). It  should be the name
of the application whose options are being parsed, or should be <B>NULL</B> if
no option aliasing is desired. The next  two arguments specify the command-line
arguments to parse. These are  generally passed to <B>poptGetContext()</B> exactly
as they were  passed to the program's <B>main()</B> function. The <B></B> <I>options</I> parameter
points to the table of command-line options,  which was described in the
previous section. The final parameter,  <I>flags</I>, can take one of three values:
<BR>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT>Value</TD><TD ALIGN=LEFT>Description</TD></TR>
<TR><TD ALIGN=LEFT>POPT_CONTEXT_NO_EXEC</TD><TD ALIGN=LEFT>Ignore exec expansions</TD></TR>
<TR><TD ALIGN=LEFT>POPT_CONTEXT_KEEP_FIRST</TD><TD ALIGN=LEFT>Do
not ignore argv[0]</TD></TR>
<TR><TD ALIGN=LEFT>POPT_CONTEXT_POSIXMEHARDER</TD><TD ALIGN=LEFT>Options cannot follow arguments</TD></TR>
</TABLE>
<P>
A
<B>poptContext</B> keeps track of which options have already been  parsed and
which remain, among other things. If a program wishes to  restart option
processing of a set of arguments, it can reset the  <B>poptContext</B> by passing
the context as the sole argument to  <B>poptResetContext()</B>. <P>
When argument processing
is complete, the process should free the  <B>poptContext</B> as it contains dynamically
allocated components. The  <B>poptFreeContext()</B> function takes a <B></B> <B>poptContext</B>
as its sole argument and frees the resources the  context is using. <P>
Here
are the prototypes of both <B>poptResetContext()</B> and  <B>poptFreeContext()</B>: <P>
<BR>
<PRE>#include &lt;popt.h&gt;void poptFreeContext(poptContext con);void poptResetContext(poptContext
con);</PRE><P>

<H3><A NAME="sect6" HREF="#toc6"></B>3. Parsing the Command Line</A></H3>
After an application has created a <B>poptContext</B>,
it may begin  parsing arguments. <B>poptGetNextOpt()</B> performs the actual  argument
parsing. <P>
<BR>
<PRE>#include &lt;popt.h&gt;int poptGetNextOpt(poptContext con);</PRE><P>
</B>Taking the context as
its sole argument, this function parses the next command-line argument found.
After finding the next argument in the option table, the function fills
in the object pointed to by the option  table entry's <I>arg</I><I></I> pointer if it
is not <B>NULL</B>. If the val entry for the option is  non-0, the function then
returns that value. Otherwise,  <B>poptGetNextOpt()</B> continues on to the next
argument. <P>
<B>poptGetNextOpt()</B> returns -1 when the final argument has been  parsed,
and other negative values when errors occur. This makes it a  good idea
to  keep the <I>val</I> elements in the options table greater than 0.<I></I> <P>
If all of
the command-line options are handled through <I>arg</I><I></I> pointers, command-line parsing
is reduced to the following line of code: <P>
<BR>
<PRE>rc = poptGetNextOpt(poptcon);
</PRE><P>
Many applications require more complex command-line parsing than this, however,
and use the following structure: <P>
<BR>
<PRE>while ((rc = poptGetNextOpt(poptcon)) &gt; 0) {
     switch (rc) {
          /* specific arguments are handled here */
     }
}
</PRE><P>
When returned options are handled, the application needs to know the value
of any arguments that were specified after the option. There are two ways
to discover them. One is to ask popt to fill in a variable with the  value
of the option through the option table's <I>arg</I> elements. The <I></I> other is to use
<B>poptGetOptArg()</B>: <P>
<BR>
<PRE>#include &lt;popt.h&gt;const char * poptGetOptArg(poptContext con);</PRE><P>
</B>This function
returns the argument given for the final option returned by <B>poptGetNextOpt()</B>,
or it returns <B>NULL</B> if no argument was specified. <P>

<H3><A NAME="sect7" HREF="#toc7">4. Leftover Arguments</A></H3>
Many
applications take an arbitrary number of command-line arguments, such as
a list of file names. When popt encounters an argument that does not begin
with a -, it assumes it is such an argument and adds it to a list of leftover
arguments. Three functions allow applications to access such arguments:
<BR>
<PRE></PRE>
<DL>

<DT><B>const char * poptGetArg(poptContext </B><I>con</I><B>);</B>This function returns the next
leftover argument and marks it as </DT>
<DD>processed. </DD>
</DL>
<P>
<BR>
<PRE></PRE>
<DL>

<DT><B>const char * poptPeekArg(poptContext </B><I>con</I><B>);</B>The next leftover argument is
returned but not marked as processed. </DT>
<DD>This allows an application to look
ahead into the argument list, without modifying the list. </DD>
</DL>
<P>
<BR>
<PRE></PRE>
<DL>

<DT><B>const char ** poptGetArgs(poptContext </B><I>con</I><B>);</B>All the leftover arguments are
returned in a manner identical to  </DT>
<DD><I>argv</I>.  The final element in the returned
array points to  <B>NULL</B>, indicating the end of the arguments. <P>
</DD>
</DL>

<H3><A NAME="sect8" HREF="#toc8">5. Automatic
Help Messages</A></H3>
The <B>popt</B> library can automatically generate help messages
which describe the options a program accepts. There are two types of help
messages which can be generated. Usage messages are a short messages which
lists valid options, but does not describe them. Help messages describe
each option on one (or more) lines, resulting in a longer, but more useful,
message. Whenever automatic help messages are used, the <B>descrip</B> and <B>argDescrip</B>
fields <B>struct poptOption</B> members should be filled in for each option. <P>
The
<B>POPT_AUTOHELP</B> macro makes it easy to add <B>--usage</B> and <B>--help</B> messages to your
program, and is described in part 1 of this man page. If more control is
needed over your help messages, the following two functions are available:
<P>
<BR>
<PRE>#include &lt;popt.h&gt;void poptPrintHelp(poptContext con, FILE * f, int flags);void
poptPrintUsage(poptContext con, FILE * f, int flags);</PRE><P>
</B><B>poptPrintHelp()</B> displays
the standard help message to the stdio file descriptor f, while <B>poptPrintUsage()</B>
displays the shorter usage message. Both functions currently ignore the
<B>flags</B> argument; it is there to allow future changes. <P>

<H2><A NAME="sect9" HREF="#toc9">Error Handling</A></H2>
All of
the popt functions that can return errors return integers.  When an error
occurs, a negative error code is returned. The  following table summarizes
the error codes that occur: <P>
<BR>
<PRE>     Error                      DescriptionPOPT_ERROR_NOARG       Argument
missing for an option.POPT_ERROR_BADOPT      Option's argument couldn't be
parsed.POPT_ERROR_OPTSTOODEEP Option aliasing nested too deeply.POPT_ERROR_BADQUOTE
   Quotations do not match.POPT_ERROR_BADNUMBER   Option couldn't be converted
to number.POPT_ERROR_OVERFLOW    A given number was too big or small.</PRE><P>
Here
is a more detailed discussion of each error: <P>

<DL>

<DT><B>POPT_ERROR_NOARG</B> </DT>
<DD>An option
that requires an argument was specified on the command line, but no argument
was given. This can be returned only by <B>poptGetNextOpt()</B>. <P>
</DD>

<DT><B>POPT_ERROR_BADOPT</B>
</DT>
<DD>An option was specified in <I>argv</I> but is not in the option <I></I> table. This error
can be returned only from <B>poptGetNextOpt()</B>. <P>
</DD>

<DT><B>POPT_ERROR_OPTSTOODEEP</B> </DT>
<DD>A set
of option aliases is nested too deeply. Currently, popt  follows options
only 10 levels to prevent infinite recursion. Only  <B>poptGetNextOpt()</B> can
return this error. <P>
</DD>

<DT><B>POPT_ERROR_BADQUOTE</B> </DT>
<DD>A parsed string has a quotation mismatch
(such as a single quotation mark). <B>poptParseArgvString()</B>, <B>poptReadConfigFile()</B>,
or  <B>poptReadDefaultConfig()</B> can return this error. <P>
</DD>

<DT><B>POPT_ERROR_BADNUMBER</B>
</DT>
<DD>A conversion from a string to a number (int or long) failed due to the
string containing nonnumeric characters. This occurs when <B>poptGetNextOpt()</B>
is processing an argument of type <B></B> <B>POPT_ARG_INT</B>, <B>POPT_ARG_LONG</B>,  POPT_ARG_FLOAT<B>,
or </B>POPT_ARG_DOUBLE<B>.</B> <P>
</DD>

<DT><B>POPT_ERROR_OVERFLOW</B> </DT>
<DD>A string-to-number conversion failed
because the number was too large or too small. Like <B>POPT_ERROR_BADNUMBER</B>,
this error  can occur only when <B>poptGetNextOpt()</B> is processing an  argument
of type <B>POPT_ARG_INT</B>, <B>POPT_ARG_LONG</B>,  POPT_ARG_FLOAT<B>, or </B>POPT_ARG_DOUBLE<B>.</B>
<P>
</DD>

<DT><B>POPT_ERROR_ERRNO</B> </DT>
<DD>A system call returned with an error, and <I>errno</I> still
<I></I> contains the error from the system call. Both  <B>poptReadConfigFile()</B> and
<B>poptReadDefaultConfig()</B> can  return this error. <P>
</DD>
</DL>
<P>
Two functions are available
to make it easy for applications to provide good error messages. <BR>
<PRE></PRE>
<DL>

<DT><B>const char *const poptStrerror(const int </B><I>error</I><B>);</B>This function takes a popt
error code and returns a string describing </DT>
<DD>the error, just as with the
standard <B>strerror()</B> function. </DD>
</DL>
<P>
<BR>
<PRE></PRE>
<DL>

<DT><B>const char * poptBadOption(poptContext </B><I>con</I><B>, int </B><I>flags</I><B>);</B>If an error occurred
during <B>poptGetNextOpt()</B>, this function  </DT>
<DD>returns the option that caused
the error. If the <I>flags</I> argument<I></I> is set to <B>POPT_BADOPTION_NOALIAS</B>, the outermost
option is  returned. Otherwise, <I>flags</I> should be 0, and the option that is
<I></I> returned may have been specified through an alias. </DD>
</DL>
<P>
These two functions
make popt error handling trivial for most  applications. When an error is
detected from most of the functions,  an error message is printed along
with the error string from  <B>poptStrerror()</B>. When an error occurs during
argument parsing,  code similiar to the following displays a useful error
message: <P>
<BR>
<PRE>fprintf(stderr, "%s: %s\n",
        poptBadOption(optCon, POPT_BADOPTION_NOALIAS),
        poptStrerror(rc));
</PRE><P>

<H2><A NAME="sect10" HREF="#toc10">Option Aliasing</A></H2>
One of the primary benefits of using popt over <B>getopt()</B>
is the  ability to use option aliasing. This lets the user specify options
that  popt expands into other options when they are specified. If the standard
 grep program made use of popt, users could add a <B>--text</B> option  that expanded
to <B>-i -n -E -2</B> to let them more easily find  information in text files. <P>

<H3><A NAME="sect11" HREF="#toc11">1. Specifying
Aliases</A></H3>
Aliases are normally specified in two places: <I>/etc/popt</I><I></I> and the
<B>.popt</B> file in the user's home directory (found through  the <B>HOME</B> environment
variable). Both files have the same format,  an arbitrary number of lines
formatted like this: <P>
<I>appname</I><B> alias </B><I>newoption</I><B></B><I> expansion</I> <P>
The <I>appname</I> is the
name of the application, which must be the <I></I> same as the <I>name</I> parameter
passed to <I></I> <B>poptGetContext()</B>. This allows each file to specify aliases for
 multiple programs. The <B>alias</B> keyword specifies that an alias is  being
defined; currently popt configuration files support only aliases, but other
abilities may be added in the future. The next option is the option that
should be aliased, and it may be either a short or a long option. The rest
of the line specifies the expansion for the alias. It is parsed  similarly
to a shell command, which allows \, ", and ' to be used for  quoting. If a
backslash is the final character on a line, the next line  in the file
is assumed to be a logical continuation of the line containing  the backslash,
just as in shell. <P>
The following entry would add a <B>--text</B> option to the grep
command,  as suggested at the beginning of this section. <P>
<B>grep alias --text
-i -n -E -2</B> 
<H3><A NAME="sect12" HREF="#toc12">2. Enabling Aliases</A></H3>
An application must enable alias expansion for
a <B>poptContext</B> before calling <B>poptGetNextArg()</B> for the first time. There
are  three functions that define aliases for a context: <BR>
<PRE></PRE>
<DL>

<DT><B>int poptReadDefaultConfig(poptContext </B><I>con</I><B>, int </B><I>flags</I><B>);</B>This function reads
aliases from <I>/etc/popt</I> and the <I></I> </DT>
<DD><B>.popt</B> file in the user's home directory. Currently,
 <I>flags</I> should be  <B>NULL</B>, as it is provided only for future expansion. </DD>
</DL>
<P>
<BR>
<PRE></PRE>
<DL>

<DT><B>int poptReadConfigFile(poptContext </B><I>con</I><B>, char * </B><I>fn</I><B>);</B>The file specified by
<I>fn</I> is opened and parsed as a popt <I></I> </DT>
<DD>configuration file. This allows programs
to use program-specific  configuration files. </DD>
</DL>
<P>
<BR>
<PRE></PRE>
<DL>

<DT><B>int poptAddAlias(poptContext </B><I>con</I><B>, struct poptAlias </B><I>alias</I><B>,</B><B>             
   int </B><I>flags</I><B>);</B>Occasionally, processes want to specify aliases without having
to </DT>
<DD>read them from a configuration file. This function adds a new alias to
a context. The <I>flags</I> argument should be 0, as it is <I></I> currently reserved
for future expansion. The new alias is specified  as a <B>struct poptAlias</B>,
which is defined as: <P>
<BR>
<PRE>struct poptAlias {
     const char * longName; /* may be NULL */
     char shortName; /* may be '\0' */
     int argc;
     const char ** argv; /* must be free()able */
};
</PRE><P>
The first two elements, <I>longName</I> and <I>shortName</I>, specify <I></I> the option that
is aliased. The final two, <I>argc</I> and <I>argv</I>,<I></I> define the expansion to use when
the aliases option is encountered. </DD>
</DL>
<P>

<H2><A NAME="sect13" HREF="#toc13">Parsing Argument Strings</A></H2>
Although popt
is usually used for parsing arguments already divided into an <I>argv</I>-style
array, some programs need to parse strings that <I></I> are formatted identically
to command lines. To facilitate this, popt  provides a function that parses
a string into an array of strings,  using rules similiar to normal shell
parsing. <P>
<BR>
<PRE>#include &lt;popt.h&gt;int poptParseArgvString(char * s, int * argcPtr,        
               char *** argvPtr);int poptDupArgv(int argc, const char **
argv, int * argcPtr,                        const char *** argvPtr);</PRE><P>
</B>The
string s is parsed into an <I>argv</I>-style array. The integer <I></I> pointed to by the
<I>argcPtr</I> parameter contains the number of elements <I></I> parsed, and the final
<I>argvPtr</I> parameter contains the address of the<I></I> newly created array. The routine
<B>poptDupArgv()</B> can be used to make a copy of an existing  argument array.
<P>
The <I>argvPtr</I><I></I> created by <B>poptParseArgvString()</B> or <B>poptDupArgv()</B> is suitable
to pass directly  to <B>poptGetContext()</B>. Both routines return a single dynamically
allocated contiguous block of storage and should be <B>free()</B>ed when the application
is finished with the storage. 
<H2><A NAME="sect14" HREF="#toc14">Handling Extra Arguments</A></H2>
Some applications
implement the equivalent of option aliasing but need to do so through special
logic. The <B>poptStuffArgs()</B> function  allows an application to insert new
arguments into the current  <B>poptContext</B>. <P>
<BR>
<PRE>#include &lt;popt.h&gt;int poptStuffArgs(poptContext con, const char ** argv);</PRE><P>
</B>The
passed <I>argv</I><I></I> must have a <B>NULL</B> pointer as its final element. When  <B>poptGetNextOpt()</B>
is next called, the  "stuffed" arguments are the first to be parsed. popt
returns to the  normal arguments once all the stuffed arguments have been
exhausted. 
<H2><A NAME="sect15" HREF="#toc15">Example</A></H2>
The following example is a simplified version of the program
"robin"  which appears in Chapter 15 of the text cited below.  Robin has
 been stripped of everything but its argument-parsing logic, slightly  reworked,
and renamed "parse." It may prove useful in illustrating  at least some
of the features of the extremely rich popt library. <P>
<BR>
<PRE>#include &lt;popt.h&gt;
#include &lt;stdio.h&gt;
void usage(poptContext optCon, int exitcode, char *error, char *addl) {
    poptPrintUsage(optCon, stderr, 0);
    if (error) fprintf(stderr, "%s: %s0, error, addl);
    exit(exitcode);
}
int main(int argc, char *argv[]) {
   char    c;            /* used for argument parsing */
   int     i = 0;        /* used for tracking options */
   char    *portname;
   int     speed = 0;    /* used in argument parsing to set speed */
   int     raw = 0;      /* raw mode? */ 
   int     j;
   char    buf[BUFSIZ+1];
   poptContext optCon;   /* context for parsing command-line options */
   struct poptOption optionsTable[] = {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { "bps", 'b', POPT_ARG_INT, &amp;speed, 0,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"signaling rate in bits-per-second", "BPS" },
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { "crnl", 'c', 0, 0, 'c',
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"expand cr characters to cr/lf sequences" },
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { "hwflow", 'h', 0, 0, 'h',
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"use hardware (RTS/CTS) flow control" },
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { "noflow", 'n', 0, 0, 'n',
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"use no flow control" },
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { "raw", 'r', 0, &amp;raw, 0,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"don't perform any character conversions" },
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { "swflow", 's', 0, 0, 's',
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"use software (XON/XOF) flow control" } ,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    POPT_AUTOHELP
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { NULL, 0, 0, NULL, 0 }
   };
   optCon = poptGetContext(NULL, argc, argv, optionsTable, 0);
   poptSetOtherOptionHelp(optCon, "[OPTIONS]* &lt;port&gt;");
   if (argc &lt; 2) {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;poptPrintUsage(optCon, stderr, 0);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;exit(1);
   }
   /* Now do options processing, get portname */
   while ((c = poptGetNextOpt(optCon)) &gt;= 0) {
      switch (c) {
         case 'c': 
            buf[i++] = 'c';         
            break;
         case 'h': 
            buf[i++] = 'h';
            break;
         case 's':
            buf[i++] = 's';
            break;
         case 'n':
            buf[i++] = 'n';
            break;
      }
   }
   portname = poptGetArg(optCon);
   if((portname == NULL) || !(poptPeekArg(optCon) == NULL))
      usage(optCon, 1, "Specify a single port", ".e.g., /dev/cua0");
   if (c &lt; -1) {
      /* an error occurred during option processing */
      fprintf(stderr, "%s: %s\n", 
              poptBadOption(optCon, POPT_BADOPTION_NOALIAS),
              poptStrerror(c));
      return 1;
   }
   /* Print out options, portname chosen */
   printf("Options  chosen: ");
   for(j = 0; j &lt; i ; j++)
      printf("-%c ", buf[j]);
   if(raw) printf("-r ");
   if(speed) printf("-b %d ", speed);
   printf("\nPortname chosen: %s\n", portname);
   poptFreeContext(optCon);
   exit(0);
}
</PRE><P>
RPM, a popular Linux package management program, makes heavy use of popt's
features. Many of its command-line arguments are implemented through popt
aliases, which makes RPM an excellent example of how to take advantage
of the popt library. For more information on RPM, see <A HREF="http://www.rpm.org.">http://www.rpm.org.</A>
 The
popt source code distribution includes test program(s) which use all of
the features of the popt libraries in various ways. If a feature isn't working
for you, the popt test code is the first place to look. 
<H2><A NAME="sect16" HREF="#toc16">Bugs</A></H2>
None presently
known. 
<H2><A NAME="sect17" HREF="#toc17">Author</A></H2>
Erik W. Troan &lt;ewt@redhat.com&gt; <P>
This man page is derived in part
from <I>Linux Application Development</I> by Michael K. Johnson and Erik W. Troan,
Copyright (c) 1998 by Addison Wesley Longman, Inc., and included in the
popt documentation with the permission of the Publisher and the appreciation
of the Authors. <P>
Thanks to Robert Lynch for his extensive work on this man
page. 
<H2><A NAME="sect18" HREF="#toc18">See Also</A></H2>
<B><A HREF="getopt.3.html">getopt</B>(3)</A>
 <P>
<I>Linux Application Development</I>, by Michael K. Johnson
and  Erik W. Troan (Addison-Wesley, 1998; ISBN 0-201-30821-5), Chapter 24. <P>
<B>popt.ps</B>
is a Postscript version of the above cited book  chapter. It can be found
in the source archive for popt available at:  ftp://ftp.rpm.org/pub/rpm. <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Basic Popt Usage</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">1. the Option Table</A></LI>
<LI><A NAME="toc5" HREF="#sect5">2. Creating a Context</A></LI>
<LI><A NAME="toc6" HREF="#sect6">3. Parsing the Command Line</A></LI>
<LI><A NAME="toc7" HREF="#sect7">4. Leftover Arguments</A></LI>
<LI><A NAME="toc8" HREF="#sect8">5. Automatic Help Messages</A></LI>
</UL>
<LI><A NAME="toc9" HREF="#sect9">Error Handling</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Option Aliasing</A></LI>
<UL>
<LI><A NAME="toc11" HREF="#sect11">1. Specifying Aliases</A></LI>
<LI><A NAME="toc12" HREF="#sect12">2. Enabling Aliases</A></LI>
</UL>
<LI><A NAME="toc13" HREF="#sect13">Parsing Argument Strings</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Handling Extra Arguments</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Example</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Bugs</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Author</A></LI>
<LI><A NAME="toc18" HREF="#sect18">See Also</A></LI>
</UL>
</BODY></HTML>
