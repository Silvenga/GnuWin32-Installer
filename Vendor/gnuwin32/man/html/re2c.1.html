   <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>RE2C(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
$Log: re2c.1.in,v $ Revision 1.10  2004/07/27 05:19:55  nuffer Replaced
YYCHAR with YYCTYPE. 
<p> Revision 1.9  2004/05/26 13:33:25  nuffer Added description
of -o option. 
<p> Revision 1.8  2004/04/19 22:32:48  helly Update 
<p> Revision 1.7
 2004/04/19 02:13:48  helly Featurerequest #869298 (Add case insensitive
string literals) 
<p> Revision 1.6  2004/04/17 15:49:13  helly Fix example,

<p>cur must be set to make the uncommented printf&rsquo;s working 
<p> Revision 1.5  2004/03/30
01:02:45  helly Update docu 
<p> Revision 1.4  2004/03/14 14:23:40  helly Update

<p> Revision 1.3  2004/03/14 12:54:19  helly Next step of autogen patch 
<p> Revision
1.2  2004/03/13 20:35:12  helly Updated configure stuff 
<p> Revision 1.1  2004/01/31
15:44:39  nuffer Applied patch from Marcus Boerger 
<p> Revision 1.2  1994/04/16
 15:50:32  peter Fix bug in simple example. 
<p> Revision 1.1  1994/04/08  15:39:09
 peter Initial revision 
<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
re2c - convert regular expressions to C/C++

<p> 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
 [<b>-esbvh</b>] [<b>-o output</b>] file 
<p> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
 is a preprocessor that generates
C-based recognizers from regular expressions. The input to  consists of C/C++
source interleaved with comments of the form /*!re2c ... */ which contain
scanner specifications. In the output these comments are replaced with code
that, when executed, will find the next input token and then execute some
user-supplied token-specific code. 
<p> For example, given the following code

<p>  <br>
<pre>#define NULL            ((char*) 0)
char *scan(char *p){
char *q;
#define YYCTYPE         char
#define YYCURSOR        p
#define YYLIMIT         p
#define YYMARKER        q
#define YYFILL(n)
/*!re2c
        [0-9]+          {return YYCURSOR;}
        [\000-\377]     {return NULL;}
*/
}
</pre> 
<p>  will generate 
<p>  <br>
<pre>/* Generated by re2c on Sat Apr 16 11:40:58 1994 */
#line 1 "simple.re"
#define NULL            ((char*) 0)
char *scan(char *p){
char *q;
#define YYCTYPE         char
#define YYCURSOR        p
#define YYLIMIT         p
#define YYMARKER        q
#define YYFILL(n)
{
        YYCTYPE yych;
        unsigned int yyaccept;
        goto yy0;
yy1:    ++YYCURSOR;
yy0:
        if((YYLIMIT - YYCURSOR) &lt; 2) YYFILL(2);
        yych = *YYCURSOR;
        if(yych &lt;= &rsquo;/&rsquo;) goto yy4;
        if(yych &gt;= &rsquo;:&rsquo;) goto yy4;
yy2:    yych = *++YYCURSOR;
        goto yy7;
yy3:
#line 10
        {return YYCURSOR;}
yy4:    yych = *++YYCURSOR;
yy5:
#line 11
        {return NULL;}
yy6:    ++YYCURSOR;
        if(YYLIMIT == YYCURSOR) YYFILL(1);
        yych = *YYCURSOR;
yy7:    if(yych &lt;= &rsquo;/&rsquo;) goto yy3;
        if(yych &lt;= &rsquo;9&rsquo;) goto yy6;
        goto yy3;
}
#line 12
}
</pre> 
<p> 
<h2><a name='sect3' href='#toc3'>Options</a></h2>
 provides the following options: 
<dl>

<dt><b>-e</b> </dt>
<dd>Cross-compile from an ASCII
platform to an EBCDIC one.  </dd>

<dt><b>-s</b> </dt>
<dd>Generate nested ifs for some switches.  Many
compilers need this assist to generate better code. </dd>

<dt><b>-b</b> </dt>
<dd>Implies <b>-s</b>.  Use bit
vectors as well in the attempt to coax better code out of the compiler.
 Most useful for specifications with more than a few keywords (e.g. for most
programming languages). </dd>

<dt><b>-h</b> </dt>
<dd><b>-?</b> Invoke a short help. </dd>

<dt><b>-v</b> </dt>
<dd>Show version information.
</dd>

<dt><b>-o output</b> </dt>
<dd>Specify the output file. 
<p> </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Interface Code</a></h2>
Unlike other scanner generators,
 does not generate complete scanners: the user must supply some interface
code. In particular, the user must define the following macros: 
<dl>

<dt>YYCTYPE
</dt>
<dd>Type used to hold an input symbol. Usually char or unsigned char. </dd>

<dt>YYCURSOR
</dt>
<dd> of type *YYCTYPE that points to the current input symbol. The generated
code advances YYCURSOR as symbols are matched. On entry, YYCURSOR is assumed
to point to the first character of the current token.  On exit, YYCURSOR
will point to the first character of the following token. </dd>

<dt>YLIMIT </dt>
<dd>Expression
of type *YYCTYPE that marks the end of the buffer (YLIMIT[-1] is the last
character in the buffer). The generated code repeatedly compares YYCURSOR
to YLIMIT to determine when the buffer needs (re)filling. </dd>

<dt>YYMARKER </dt>
<dd> of type
*YYCTYPE. The generated code saves backtracking information in YYMARKER.
</dd>

<dt><a href='YYFILL.n.html'><a href='YYFILL.n.html'>YYFILL(<i>n</i>)</a>
</a>
 </dt>
<dd>The generated code "calls" YYFILL when the buffer needs (re)filling:
 at least <i>n</i> additional characters should be provided.  YYFILL should adjust
YYCURSOR, YYLIMIT and YYMARKER as needed.  Note that for typical programming
languages <i>n</i> will be the length of the longest keyword plus one. 
<p> </dd>
</dl>

<h2><a name='sect5' href='#toc5'>Scanner
Specifications</a></h2>
Each scanner specification consists of a set of <i>rules</i> and
name definitions. Rules consist of a regular expression along with a block
of C/C++ code that is to be executed when the associated regular expression
is matched. Name definitions are of the form &lsquo;&lsquo;<i>name</i> = <i>regular expression</i>;&rsquo;&rsquo;.

<p> 
<h2><a name='sect6' href='#toc6'>Summary of Re2c Regular Expressions</a></h2>

<dl>

<dt>"foo" </dt>
<dd>the literal string foo. ANSI-C
escape sequences can be used. </dd>

<dt>&rsquo;foo&rsquo; </dt>
<dd>the literal string foo (characters [a-zA-Z]
treated case-insensitive). ANSI-C escape sequences can be used. </dd>

<dt>[xyz] </dt>
<dd>a "character
class"; in this case, the  matches either an &rsquo;x&rsquo;, a &rsquo;y&rsquo;, or a &rsquo;z&rsquo;. </dd>

<dt>[abj-oZ] </dt>
<dd>a "character
class" with a range in it; matches an &rsquo;a&rsquo;, a &rsquo;b&rsquo;, any letter from &rsquo;j&rsquo; through
&rsquo;o&rsquo;, or a &rsquo;Z&rsquo;. </dd>

<dt><i>r</i>\<i>s</i> </dt>
<dd>match any <i>r</i> which isn&rsquo;t an <i>s</i>. <i>r</i> and <i>s</i> must be regular expressions
which can be expressed as character classes. </dd>

<dt><i>r</i>* </dt>
<dd>zero or more <i>r</i>&rsquo;s, where <i>r</i>
is any regular expression </dd>

<dt><i>r</i>+ </dt>
<dd>one or more <i>r</i>&rsquo;s </dd>

<dt><i>r</i>? </dt>
<dd>zero or one <i>r</i>&rsquo;s (that is,
"an optional <i>r</i>") </dd>

<dt>name </dt>
<dd>the expansion of the "name" definition (see above)
</dd>

<dt>(<i>r</i>) </dt>
<dd>an <i>r</i>; parentheses are used to override precedence (see below) </dd>

<dt><i>rs</i> </dt>
<dd>an
<i>r</i> followed by an <i>s</i> ("concatenation") </dd>

<dt><i>r</i>|<i>s</i> </dt>
<dd>either an <i>r</i> or an <i>s</i> </dd>

<dt><i>r</i>/<i>s</i> </dt>
<dd>an <i>r</i> but
only if it is followed by an <i>s</i>. The s is not part of the matched text. This
type of  is called "trailing context". </dd>

<dt><i>r</i>{<i>n</i>} </dt>
<dd>matches <i>r</i> exactly <i>n</i> times. </dd>

<dt><i>r</i>{<i>n</i>,}
</dt>
<dd>matches <i>r</i> at least <i>n</i> times. </dd>

<dt><i>r</i>{<i>n</i>,<i>m</i>} </dt>
<dd>matches <i>r</i> at least <i>n</i> but not more than
<i>m</i> times. 
<p> </dd>
</dl>
<p>
The regular expressions listed above are grouped according to
precedence, from highest precedence at the top to lowest at the bottom.
Those grouped together have equal precedence. 
<p> 
<h2><a name='sect7' href='#toc7'>a Larger Example</a></h2>
<p>
 <br>
<pre>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#define ADDEQ   257
#define ANDAND  258
#define ANDEQ   259
#define ARRAY   260
#define ASM     261
#define AUTO    262
#define BREAK   263
#define CASE    264
#define CHAR    265
#define CONST   266
#define CONTINUE        267
#define DECR    268
#define DEFAULT 269
#define DEREF   270
#define DIVEQ   271
#define DO      272
#define DOUBLE  273
#define ELLIPSIS        274
#define ELSE    275
#define ENUM    276
#define EQL     277
#define EXTERN  278
#define FCON    279
#define FLOAT   280
#define FOR     281
#define FUNCTION        282
#define GEQ     283
#define GOTO    284
#define ICON    285
#define ID      286
#define IF      287
#define INCR    288
#define INT     289
#define LEQ     290
#define LONG    291
#define LSHIFT  292
#define LSHIFTEQ        293
#define MODEQ   294
#define MULEQ   295
#define NEQ     296
#define OREQ    297
#define OROR    298
#define POINTER 299
#define REGISTER        300
#define RETURN  301
#define RSHIFT  302
#define RSHIFTEQ        303
#define SCON    304
#define SHORT   305
#define SIGNED  306
#define SIZEOF  307
#define STATIC  308
#define STRUCT  309
#define SUBEQ   310
#define SWITCH  311
#define TYPEDEF 312
#define UNION   313
#define UNSIGNED        314
#define VOID    315
#define VOLATILE        316
#define WHILE   317
#define XOREQ   318
#define EOI     319
typedef unsigned int uint;
typedef unsigned char uchar;
#define BSIZE   8192
#define YYCTYPE         uchar
#define YYCURSOR        cursor
#define YYLIMIT         s-&gt;lim
#define YYMARKER        s-&gt;ptr
#define YYFILL(n)       {cursor = fill(s, cursor);}
#define RET(i)  {s-&gt;cur = cursor; return i;}
typedef struct Scanner {
    int                 fd;
    uchar               *bot, *tok, *ptr, *cur, *pos, *lim, *top, *eof;
    uint                line;
} Scanner;
uchar *fill(Scanner *s, uchar *cursor){
    if(!s-&gt;eof){
        uint cnt = s-&gt;tok - s-&gt;bot;
        if(cnt){
            memcpy(s-&gt;bot, s-&gt;tok, s-&gt;lim - s-&gt;tok);
            s-&gt;tok = s-&gt;bot;
            s-&gt;ptr -= cnt;
            cursor -= cnt;
            s-&gt;pos -= cnt;
            s-&gt;lim -= cnt;
        }
        if((s-&gt;top - s-&gt;lim) &lt; BSIZE){
            uchar *buf = (uchar*)
                malloc(((s-&gt;lim - s-&gt;bot) + BSIZE)*sizeof(uchar));
            memcpy(buf, s-&gt;tok, s-&gt;lim - s-&gt;tok);
            s-&gt;tok = buf;
            s-&gt;ptr = &amp;buf[s-&gt;ptr - s-&gt;bot];
            cursor = &amp;buf[cursor - s-&gt;bot];
            s-&gt;pos = &amp;buf[s-&gt;pos - s-&gt;bot];
            s-&gt;lim = &amp;buf[s-&gt;lim - s-&gt;bot];
            s-&gt;top = &amp;s-&gt;lim[BSIZE];
            free(s-&gt;bot);
            s-&gt;bot = buf;
        }
        if((cnt = read(s-&gt;fd, (char*) s-&gt;lim, BSIZE)) != BSIZE){
            s-&gt;eof = &amp;s-&gt;lim[cnt]; *(s-&gt;eof)++ = &rsquo;\n&rsquo;;
        }
        s-&gt;lim += cnt;
    }
    s-&gt;cur = cursor;
    return cursor;
}
int scan(Scanner *s){
        uchar *cursor = s-&gt;cur;
std:
        s-&gt;tok = cursor;
/*!re2c
any     = [\000-\377];
O       = [0-7];
D       = [0-9];
L       = [a-zA-Z_];
H       = [a-fA-F0-9];
E       = [Ee] [+-]? D+;
FS      = [fFlL];
IS      = [uUlL]*;
ESC     = [\\] ([abfnrtv?&rsquo;"\\] | "x" H+ | O+);
*/
/*!re2c
        "/*"                    { goto comment; }
        
        "auto"                  { RET(AUTO); }
        "break"                 { RET(BREAK); }
        "case"                  { RET(CASE); }
        "char"                  { RET(CHAR); }
        "const"                 { RET(CONST); }
        "continue"              { RET(CONTINUE); }
        "default"               { RET(DEFAULT); }
        "do"                    { RET(DO); }
        "double"                { RET(DOUBLE); }
        "else"                  { RET(ELSE); }
        "enum"                  { RET(ENUM); }
        "extern"                { RET(EXTERN); }
        "float"                 { RET(FLOAT); }
        "for"                   { RET(FOR); }
        "goto"                  { RET(GOTO); }
        "if"                    { RET(IF); }
        "int"                   { RET(INT); }
        "long"                  { RET(LONG); }
        "register"              { RET(REGISTER); }
        "return"                { RET(RETURN); }
        "short"                 { RET(SHORT); }
        "signed"                { RET(SIGNED); }
        "sizeof"                { RET(SIZEOF); }
        "static"                { RET(STATIC); }
        "struct"                { RET(STRUCT); }
        "switch"                { RET(SWITCH); }
        "typedef"               { RET(TYPEDEF); }
        "union"                 { RET(UNION); }
        "unsigned"              { RET(UNSIGNED); }
        "void"                  { RET(VOID); }
        "volatile"              { RET(VOLATILE); }
        "while"                 { RET(WHILE); }
        
        L (L|D)*                { RET(ID); }
        
        ("0" [xX] H+ IS?) | ("0" D+ IS?) | (D+ IS?) |
        ([&rsquo;] (ESC|any\[\n\\&rsquo;])* [&rsquo;])
                                { RET(ICON); }
        
        (D+ E FS?) | (D* "." D+ E? FS?) | (D+ "." D* E? FS?)
                                { RET(FCON); }
        
        (["] (ESC|any\[\n\\"])* ["])
                                { RET(SCON); }
        
        "..."                   { RET(ELLIPSIS); }
        "&gt;&gt;="                   { RET(RSHIFTEQ); }
        "&lt;&lt;="                   { RET(LSHIFTEQ); }
        "+="                    { RET(ADDEQ); }
        "-="                    { RET(SUBEQ); }
        "*="                    { RET(MULEQ); }
        "/="                    { RET(DIVEQ); }
        "%="                    { RET(MODEQ); }
        "&amp;="                    { RET(ANDEQ); }
        "^="                    { RET(XOREQ); }
        "|="                    { RET(OREQ); }
        "&gt;&gt;"                    { RET(RSHIFT); }
        "&lt;&lt;"                    { RET(LSHIFT); }
        "++"                    { RET(INCR); }
        "--"                    { RET(DECR); }
        "-&gt;"                    { RET(DEREF); }
        "&amp;&amp;"                    { RET(ANDAND); }
        "||"                    { RET(OROR); }
        "&lt;="                    { RET(LEQ); }
        "&gt;="                    { RET(GEQ); }
        "=="                    { RET(EQL); }
        "!="                    { RET(NEQ); }
        ";"                     { RET(&rsquo;;&rsquo;); }
        "{"                     { RET(&rsquo;{&rsquo;); }
        "}"                     { RET(&rsquo;}&rsquo;); }
        ","                     { RET(&rsquo;,&rsquo;); }
        ":"                     { RET(&rsquo;:&rsquo;); }
        "="                     { RET(&rsquo;=&rsquo;); }
        "("                     { RET(&rsquo;(&rsquo;); }
        ")"                     { RET(&rsquo;)&rsquo;); }
        "["                     { RET(&rsquo;[&rsquo;); }
        "]"                     { RET(&rsquo;]&rsquo;); }
        "."                     { RET(&rsquo;.&rsquo;); }
        "&amp;"                     { RET(&rsquo;&amp;&rsquo;); }
        "!"                     { RET(&rsquo;!&rsquo;); }
        "~"                     { RET(&rsquo;~&rsquo;); }
        "-"                     { RET(&rsquo;-&rsquo;); }
        "+"                     { RET(&rsquo;+&rsquo;); }
        "*"                     { RET(&rsquo;*&rsquo;); }
        "/"                     { RET(&rsquo;/&rsquo;); }
        "%"                     { RET(&rsquo;%&rsquo;); }
        "&lt;"                     { RET(&rsquo;&lt;&rsquo;); }
        "&gt;"                     { RET(&rsquo;&gt;&rsquo;); }
        "^"                     { RET(&rsquo;^&rsquo;); }
        "|"                     { RET(&rsquo;|&rsquo;); }
        "?"                     { RET(&rsquo;?&rsquo;); }
        [ \t\v\f]+           { goto std; }
        "\n"
            {
                if(cursor == s-&gt;eof) RET(EOI);
                s-&gt;pos = cursor; s-&gt;line++;
                goto std;
            }
        any
            {
                printf("unexpected character: %c\n", *s-&gt;tok);
                goto std;
            }
*/
comment:
/*!re2c
        "*/"                    { goto std; }
        "\n"
            {
                if(cursor == s-&gt;eof) RET(EOI);
                s-&gt;tok = s-&gt;pos = cursor; s-&gt;line++;
                goto comment;
            }
        any                     { goto comment; }
*/
}
main(){
    Scanner in;
    int t;
    memset((char*) &amp;in, 0, sizeof(in));
    in.fd = 0;
    while((t = scan(&amp;in)) != EOI){
/*
        printf("%d\t%.*s\n", t, in.cur - in.tok, in.tok);
        printf("%d\n", t);
*/
    }
    close(in.fd);
}
</pre> 
<p> 
<h2><a name='sect8' href='#toc8'>Features</a></h2>
<p>
 does not provide a default action: the generated code assumes
that the input will consist of a sequence of tokens. Typically this can
be dealt with by adding a rule such as the one for unexpected characters
in the example above. <p>
The user must arrange for a sentinel token to appear
at the end of input (and provide a rule for matching it):  does not provide
an &lt;&lt;EOF&gt;&gt; expression. If the source is from a null-byte terminated string, a
rule matching a null character will suffice.  If the source is from a file
then the approach taken in the example can be used: pad the input with
a newline (or some other character that can&rsquo;t appear within another token);
upon recognizing such a character check to see if it is the sentinel and
act accordingly. <p>
 does not provide start conditions:  use a separate scanner
specification for each start condition (as illustrated in the above example).
<p>
No [^x].  Use difference instead. 
<h2><a name='sect9' href='#toc9'>Bugs</a></h2>
<p>
Only fixed length trailing context can
be handled. <p>
The maximum value appearing as a parameter <i>n</i> to YYFILL is not
provided to the generated code (this value is needed for constructing the
interface code). Note that this value is usually relatively small: for typical
programming languages <i>n</i> will be the length of the longest keyword plus
one. <p>
Difference only works for character sets. <p>
The  internal algorithms need
documentation. 
<p> 
<h2><a name='sect10' href='#toc10'>See Also</a></h2>
<p>
<a href='flex.1.html'>flex(1)</a>
, <a href='lex.1.html'>lex(1)</a>
. <p>
More information on <b>re2c</b> can be
found here:  <p>
<a href='http://sourceforge.net/projects/re2c/'><b>http://sourceforge.net/projects/re2c/</b></a>
  
<p> 
<h2><a name='sect11' href='#toc11'>Authors</a></h2>
 <p>
Peter Bumbulis
&lt;peter@csg.uwaterloo.ca&gt; <p>
Brian Young &lt;bayoung@acm.org&gt; <p>
Dan Nuffer &lt;nuffer@users.sourceforge.net&gt;
<p>
Marcus Boerger &lt;helly@users.sourceforge.net&gt; <p>
Hartmut Kaiser &lt;hkaiser@users.sourceforge.net&gt;
<p>
 
<p> 
<h2><a name='sect12' href='#toc12'>Version Information</a></h2>
This manpage describes <b>re2c</b>, version 0.9.4. 
<p> </pre><p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Interface Code</a></li>
<li><a name='toc5' href='#sect5'>Scanner Specifications</a></li>
<li><a name='toc6' href='#sect6'>Summary of Re2c Regular Expressions</a></li>
<li><a name='toc7' href='#sect7'>a Larger Example</a></li>
<li><a name='toc8' href='#sect8'>Features</a></li>
<li><a name='toc9' href='#sect9'>Bugs</a></li>
<li><a name='toc10' href='#sect10'>See Also</a></li>
<li><a name='toc11' href='#sect11'>Authors</a></li>
<li><a name='toc12' href='#sect12'>Version Information</a></li>
</ul>
</body>
</html>
