<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>BARCODE(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
barcode - a stand alone program to run the barcode library 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>barcode</b>
[-b - | string] [-e encoding] [-o - | outfile] [ <i>other-flags</i> ] 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
The information
below is extracted from the texinfo file, which is the preferred source
of information. <p>
The <b>barcode</b> program is a front-end to access some features
of the library from the command line.  It is able to read user supplied
strings from the command line or a data file (standard input by default)
and encode all of them. 
<p> <p>

<h2><a name='sect3' href='#toc3'>Options</a></h2>
<p>

<p> <p>
<b>barcode</b> accepts the following options:

<dl>

<dt>--help or -h </dt>
<dd>Print a usage summary and exit. </dd>

<dt>-i filename </dt>
<dd>Identify a file where
strings to be encoded are read from. If missing (and if -b is not used) it
defaults to standard input. Each data line of the input file will be used
to create one barcode output. </dd>

<dt>-o filename </dt>
<dd>Output file. It defaults to standard
output. </dd>

<dt>-b string </dt>
<dd>Specify a single &lsquo;&lsquo;barcode&rsquo;&rsquo; string to be encoded. The option
can be used multiple times in order to encode multiple strings (this will
result in multi-page postscript output or a table of barcodes if -t is specified).
 The strings must match the encoding chosen; if it doesn&rsquo;t match the program
will print a warning to stderr and generate &lsquo;&lsquo;blank&rsquo;&rsquo; output (although not
zero-length). Please note that a string including spaces or other special
characters must be properly quoted. </dd>

<dt>-e encoding </dt>
<dd><b>encoding</b> is the name of the
chosen encoding format being used. It defaults to the value of the environment
variable BARCODE_ENCODING or to auto detection if the environment is also
unset. </dd>

<dt>-g geometry </dt>
<dd>The geometry argument is of the form &lsquo;&lsquo;[&lt;width&gt; x &lt;height&gt;]
[+ &lt;xmargin&gt; + &lt;ymargin&gt;]&rsquo;&rsquo; (with no intervening spaces). Unspecified margin values
will result in no margin; unspecified size results in default size. The
specified values represent print points by default, and can be inches,
millimeters or other units according to the -u option or the BARCODE_UNIT
environment variable.  The argument is used to place the printout code on
the page. Note that an additional white margin of 10 points is added to
the printout. If the option is unspecified, BARCODE_GEOMETRY is looked up
in the environment, if missing a default size and no margin (but the default
10 points) are used. </dd>

<dt>-t table-geometry </dt>
<dd>Used to print several barcodes to a
single page, this option is meant to be used to print stickers. The argument
is of the form &lsquo;&lsquo;&lt;columns&gt; x &lt;lines&gt; [+ &lt;leftmargin&gt; + &lt;bottommargin&gt; [- &lt;rightmargin&gt;
[- &lt;topmargin&gt;]]]&rsquo;&rsquo; (with no intervening spaces); if missing, the top and right
margin will default to be the same as the bottom and left margin. The margins
are specified in print points or in the chosen unit (see -u below).  If the
option is not specified, BARCODE_TABLE is looked up in the environment,
otherwise no table is printed and each barcode will get its own page.  The
size (but not the position) of a barcode item within a table can also be
selected using -g (see "geometry" above), without struggling with external
and internal margins.  I still think management of geometries in a table
is suboptimal, but I can&rsquo;t make it better without introducing incompatibilities.
</dd>

<dt>-m margin(s) </dt>
<dd>Specifies an internal margin for each sticker in the table.
The argument is of the form &lsquo;&lsquo;&lt;xmargin&gt;,&lt;ymargin&gt;&rsquo;&rsquo; and the margin is applied symmetrically
to the sticker. If unspecified, the environment variable BARCODE_MARGIN
is used or a default internal margin of 10 points is used. </dd>

<dt>-n </dt>
<dd>&lsquo;&lsquo;Numeric&rsquo;&rsquo; output:
don&rsquo;t print the ASCII form of the code, only the bars. </dd>

<dt>-c </dt>
<dd>No checksum character
(for encodings that allow it, like code 39, other codes, like UPC or EAN,
ignore this option). </dd>

<dt>-E </dt>
<dd>Encapsulated postscript (default is normal postscript).
When the output is generated as EPS only one barcode is encoded. </dd>

<dt>-P </dt>
<dd>PCL output.
Please note that the Y direction goes from top to bottom for PCL, and the
origin for an image is the top-left corner instead of the bottom-left </dd>

<dt>-p pagesize
</dt>
<dd>Specify a non-default page size. The page size can be specified in millimeters,
inches or plain numbers (for example: "210x297mm", "8.5x11in", "595x842").
A page specification as numbers will be interpreted according to the current
unit specification (see -u below). If libpaper is available, you can also
specify the page size with its name, like "A3" or "letter" (libpaper is
a standard component of Debian GNU/Linux, but may be missing elsewhere).
The default page size is your system-wide default if libpaper is there,
A4 otherwise. </dd>

<dt>-u unit </dt>
<dd>Choose the unit used in size specifications. Accepted
values are &lsquo;&lsquo;mm&rsquo;&rsquo;, &lsquo;&lsquo;cm&rsquo;&rsquo;, &lsquo;&lsquo;in&rsquo;&rsquo; and &lsquo;&lsquo;pt&rsquo;&rsquo;. By default, the program will check BARCODE_UNIT
in the environment, and assume points otherwise (this behaviour is compatible
with 0.92 and previous versions. If -u appears more than once, each instance
will modified the behaviour for the arguments at its right, as the command
line is processes left to right. The program internally works with points,
and any size is approximated to the nearest multiple of one point. The -u
option affect -g (geometry), -t (table) and -p (page size). 
<p> </dd>
</dl>
<p>

<h2><a name='sect4' href='#toc4'>Encoding Types</a></h2>
<p>

<p>
<p>
The program encodes text strings passed either on the command line (with
-b) or retrieved from standard input. The text representation is interpreted
according to the following rules. When auto-detection of the encoding is
enabled (i.e, no explicit encoding type is specified), the encoding types
are scanned to find one that can digest the text string. The following list
of supported types is sorted in the same order the library uses when auto-detecting
a suitable encoding for a string. 
<dl>

<dt>EAN </dt>
<dd>The EAN frontend is similar to UPC;
it accepts strings of digits, 12 or 7 characters long. Strings of 13 or
8 characters are accepted if the provided checksum digit is correct. I expect
most users to feed input without a  checksum, though. The add-2 and add-5
extension are accepted for both the EAN-13 and the EAN-8 encodings. The following
are example of valid input strings: &lsquo;&lsquo;123456789012&rsquo;&rsquo; (EAN-13), &lsquo;&lsquo;1234567890128&rsquo;&rsquo;
(EAN-13 wih checksum),  &lsquo;&lsquo;1234567&rsquo;&rsquo; (EAN-8), &lsquo;&lsquo;12345670 12345&rsquo;&rsquo; (EAN-8 with checksum
and add-5), &lsquo;&lsquo;123456789012 12&rsquo;&rsquo; (EAN-13 with add-2), &lsquo;&lsquo;123456789012 12345&rsquo;&rsquo; (EAN-13
with add-5). </dd>

<dt>UPC </dt>
<dd>The UPC frontend accepts only strings made up of digits
(and, if a supplemental encoding is used, a blank to separate it). It accepts
strings of 11 or 12 digits (UPC-A) and 6 or 7 or 8 digits (UPC-E). 
<p> </dd>
</dl>
<p>
The 12th
digit of UPC-A is the checksum and is added by the library if not specified
in the input; if it is specified, it must be the right checksum or the
code is rejected as invalid. For UPC-E, 6 digit are considered to be the
middle part of the code, a leading 0 is assumed and the checksum is added;
7 digits are either considered the initial part (leading digit 0 or 1,
checksum missing) or the final part (checksum specified, leading 0 assumed);
8 digits are considered to be the complete code, with leading 0 or 1 and
checksum. For both UPC-A and UPC-E, a trailing string of 2 digits or 5 digits
is accepted as well. Therefore, the following are examples of valid strings
that can be encoded as UPC: &lsquo;&lsquo;01234567890&rsquo;&rsquo; (UPC-A) &lsquo;&lsquo;012345678905&rsquo;&rsquo; (UPC-A with
checksum), &lsquo;&lsquo;012345&rsquo;&rsquo; (UPC-E), &lsquo;&lsquo;01234567890 12&rsquo;&rsquo; (UPC-A, add-2) and &lsquo;&lsquo;01234567890 12345&rsquo;&rsquo;
(UPC-A, add-5), &lsquo;&lsquo;0123456 12&rsquo;&rsquo; (UPC-E, add-2). Please note that when setting BARCODE_ANY
to auto-detect the encoding to be used, 12-digit strings and 7-digit strings
will always be identified as EAN. This because I expect most user to provide
input without a checksum. If you need to specify UPC-with-checksum as input
you must explicitly set BARCODE_UPC as a flag or use -e upc on the command
line. 
<dl>

<dt>ISBN </dt>
<dd>ISBN numbers are encoded as EAN-13 symbols, with an optional add-5
trailer. The ISBN frontend of the library accepts real ISBN numbers and
deals with any hyphen and, if present, the ISBN checksum character before
encoding data. Valid representations for ISBN strings are for example: &lsquo;&lsquo;1-56592-292-1&rsquo;&rsquo;,
&lsquo;&lsquo;3-89721-122-X&rsquo;&rsquo; and &lsquo;&lsquo;3-89721-122-X 06900}&rsquo;&rsquo;. </dd>

<dt>code 128-B </dt>
<dd>This encoding can represent
all of the printing ASCII characters, from the space (32) to DEL (127).
The checksum digit is mandatory in this encoding. </dd>

<dt>code 128-C </dt>
<dd>The &lsquo;&lsquo;C&rsquo;&rsquo; variation
of Code-128 uses Code-128 symbols to represent two digits at a time (Code-128
is made up of 104 symbols whose interpretation is controlled by the start
symbol being used). Code 128-C is thus the most compact way to represent
any even number of digits. The encoder refuses to deal with an odd number
of digits because the caller is expected to provide proper padding to an
even number of digits. (Since Code-128 includes control symbols to switch
charset, it is theoretically possible to represent the odd digit as a Code
128-A or 128-B symbol, but this tool doesn&rsquo;t currently implement this option).
</dd>

<dt>code 128 raw </dt>
<dd>Code-128 output represented symbol-by-symbol in the input string.
 To override part of the problems outlined below in specifying code128
symbols, this pseudo-encoding allows the used to specify a list of code128
symbols separated by spaces. Each symbol is represented by a number in the
range 0-105.  The list should include the leading character.The checksum and
the stop character are automatically added by the library. Most likely this
pseudo-encoding will be used with BARCODE_NO_ASCII and some external program
to supply the printed text. </dd>

<dt>code 39 </dt>
<dd>The code-39 standard can encode uppercase
letters, digits, the blank space, plus, minus, dot, star, dollar, slash,
percent. Any string that is only composed of such characters is accepted
by the code-39 encoder. To avoid loosing information, the encoder refuses
to encode mixed-case strings (a lowercase string is nonetheless accepted
as a shortcut, but is encoded as uppercase). </dd>

<dt>interleaved 2 of 5 </dt>
<dd>This encoding
can only represent an even number of digits (odd digits are represented
by bars, and even digits by the interleaving spaces). The name stresses
the fact that two of the five items (bars or spaces) allocated to each
symbol are wide, while the rest are narrow. The checksum digit is optional
(can be disabled via BARCODE_NO_CHECKSUM). Since the number of digits, including
the checksum, must be even, a leading zero is inserted in the string being
encoded if needed (this is specifically stated in the specs I have access
to). </dd>

<dt>code 128 </dt>
<dd>Automatic selection between alphabet A, B and C of the Code-128
standard. This encoding can represent all ASCII symbols, from 0 (NUL) to
127 (DEL), as well as four special symbols, named F1, F2, F3, F4. The set
of symbols available in this encoding is not easily represented as input
to the barcode library, so the following convention is used.  In the input
string, which is a C-language null-terminated string, the NUL char is represented
by the value 128 (0x80, 0200) and the F1-F4 characters are represented by
the values 193-196 (0xc1-0xc4, 0301-0304). The values have been chosen to ease
their representation as escape sequences. 
<p> </dd>
</dl>
<p>
Since the shell doesn&rsquo;t seem to
interpret escape sequences on the command line, the "-b" option cannot be
easily used to designate the strings to be encoded. As a workaround you
can resort to the command echo, either within back-ticks or used separately
to create a file that is then fed to the standard-input of barcode -- assuming
your echo command processes escape sequences.  The newline character is
especially though to encode (but not impossible unless you use a csh variant.

<p> <p>
These problems only apply to the command-line tool; the use of library
functions doesn&rsquo;t give any problem. In needed, you can use the &lsquo;&lsquo;code 128 raw&rsquo;&rsquo;
pseudo-encoding to represent code128 symbols by their numerical value. This
encoding is used late in the auto-selection mechanism because (almost) any
input string can be represented using code128. 
<dl>

<dt>Codabar </dt>
<dd>Codabar can encode
the ten digits and a few special symbols (minus, plus, dollar, colon, bar,
dot). The characters &lsquo;&lsquo;A&rsquo;&rsquo;, &lsquo;&lsquo;B&rsquo;&rsquo;, &lsquo;&lsquo;C&rsquo;&rsquo; and &lsquo;&lsquo;D&rsquo;&rsquo; are used to represent four different
start/stop characters. The input string to the barcode library can include
the start and stop characters or not include them (in which case &lsquo;&lsquo;A&rsquo;&rsquo; is used
as start and &lsquo;&lsquo;B&rsquo;&rsquo; as stop). Start and stop characters in the input string can
be either all lowercase or all uppercase and are always printed as uppercase.
</dd>

<dt>Plessey </dt>
<dd>Plessey barcodes can encode all the hexadecimal digits. Alphabetic
digits in the input string must either be all lowercase or all uppercase.
The output text is always uppercase. </dd>

<dt>MSI </dt>
<dd>MSI can only encode the decimal
digits. While the standard specifies either one or two check digits, the
current implementation in this library only generates one check digit. </dd>

<dt>code
93 </dt>
<dd>The code-93 standard can natively encode 48 different characters, including
uppercase letters, digits, the blank space, plus, minus, dot, star, dollar,
slash, percent, as well as five special characters:  a start/stop delimiter
and four "shift characters" used for extended encoding.    Using this "extended
encoding" method, any standard 7-bit ASCII character can be encoded, but
it takes up two symbol lengths in barcode if the character is not natively
supported (one of the 48). The encoder here fully implements the code 93
encoding standard. Any characters natively supported (A-Z, 0-9, ".+-/$ encoded
as such - for any other characters (such as lower case letters, brackets,
parentheses, etc.), the encoder will revert to extended encoding. As a note,
the option to exclude the checksum will eliminate the two modulo-47 checksums
(called C and K) from the barcode, but this probably will make it unreadable
by 9 These checksums are specified to be used at the firmware level, and
their absence will be interpreted as an invalid barcode. 
<p> </dd>
</dl>
<p>

<h2><a name='sect5' href='#toc5'>Pcl Output</a></h2>

<p> <p>
While
the default output is Postscript (possibly EPS), and Postscript can be
post-processed to almost anything, it is sometimes desirable to create output
directly usable by the specific printer at hand.  PCL is currently supported
as an output format for this reason. Please note that the Y coordinate for
PCL goes from top to bottom, while for Postscript it goes from bottom to
top. Consistently, while in Postscript you specify the bottom-left corner
as origin, for PCL you specify the top-left corner. 
<p> <p>
Barcode output for PCL
Printers (HP LaserJet and compatibles), was developed using PCL5 Reference
manuals from HP. that really refers to these printers: 
<p>
<dl>

<dt> LaserJet III, III
P, III D, III Si, </dt>
<dd>
<p></dd>

<dt> LaserJet 4 family </dt>
<dd>
<p></dd>

<dt> LaserJet 5 family </dt>
<dd>
<p></dd>

<dt> LaserJet 6 family
</dt>
<dd>
<p></dd>

<dt> Color LaserJet </dt>
<dd>
<p></dd>

<dt> DeskJet 1200 and 1600. </dt>
<dd>
<p> </dd>
</dl>
<p>
However, barcode printing uses
a very small subset of PCL, probably also LaserJet II should print it without
problem, but the resulting text may be horrible. 
<p> <p>
The only real difference
from one printer to another really depends on which font are available
in the printer, used in printing the label associated to the bars (if requested).

<p> <p>
Earlier LaserJet supports only bitmaps fonts, so these are not "scalable".
(Ljet II ?), Also these fonts, when available, have a specified direction,
and not all of them are available in both Portrait and Landscape mode. 
<p>
<p>
From LaserJet 4 series, (except 4L/5L that are entry-level printers), Arial
scalable font should be available, so it&rsquo;s the "default font" used by this
program. 
<p> <p>
LaserJet III series printers (and 4L, 5L), don&rsquo;t feature "Arial"
as a resident font, so you should use BARCODE_OUT_PCL_III instead of BARCODE_OUT_PCL.,
and font the font used will be "Univers" instead of "Arial". 
<p> <p>
Results on
compatible printers, may depend on consistency of PCL5 compatibility, in
doubt, try BARCODE_OUT_PCL_III 
<p> <p>
PJL commands are not used here, as it&rsquo;s
not very compatible. 
<p> <p>
Tested Printers: 
<p>
<dl>

<dt> Hp LaserJet 4050 </dt>
<dd>
<p></dd>

<dt> Hp LaserJet 2100
</dt>
<dd>
<p></dd>

<dt> Epson N-1200 emul PCL </dt>
<dd>
<p></dd>

<dt> Toshiba DP2570 (copier) + PCL option </dt>
<dd>
<p></dd>

<dt> Epson EPL-7100
emul. HP LaserJet II: bars print fine but text is bad. </dt>
<dd>
<p> </dd>
</dl>
<p>

<h2><a name='sect6' href='#toc6'>Bugs</a></h2>

<p> <p>
The current
management of borders/margins is far from optimal. The &lsquo;&lsquo;default&rsquo;&rsquo; margin applied
by the library interferes with the external representation, but I feel
it is mandatory to avoid creating barcode output with no surrounding white
space (the problem is especially relevant for EPS output). 
<p> <p>
EAN-128 is not
(yet) supported. I plan to implement it pretty soon and then bless the package
as version 1.0. 
<p> <p>

<h2><a name='sect7' href='#toc7'>See Also</a></h2>
<a href='barcode.3.html'><b>barcode(3)</b></a>
 
<h2><a name='sect8' href='#toc8'>Authors</a></h2>
Alessandro Rubini &lt;rubini@gnu.org&gt;
(maintainer) <p>
Leonid A. Broukhis &lt;leob@mailcom.com&gt; (several encodings) <p>
Andrea
Scopece &lt;a.scopece@tin.it&gt; (PCL output) <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Encoding Types</a></li>
<li><a name='toc5' href='#sect5'>Pcl Output</a></li>
<li><a name='toc6' href='#sect6'>Bugs</a></li>
<li><a name='toc7' href='#sect7'>See Also</a></li>
<li><a name='toc8' href='#sect8'>Authors</a></li>
</ul>
</body>
</html>
