                             <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>archive_read(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>NAME</a></h2>
                                
<h2><a name='sect1' href='#toc1'>SYNOPSIS</a></h2>

                                                            
<h2><a name='sect2' href='#toc2'>DESCRIPTION</a></h2>
These
functions provide a complete API for reading streaming archives. The general
process is to first create the  object, set options, initialize the reader,
iterate over the archive headers and associated data, then close the archive
and release all resources. The following summary describes the functions
in approximately the order they would be used:   Allocates and initializes
a  object suitable for reading from an archive.  Enables auto-detection code
and decompression support for the specified compression. Note that  is always
enabled by default. For convenience,  enables all available decompression
code.  Data is fed through the specified external program before being dearchived.
Note that this disables automatic detection of the compression format,
so it makes no sense to specify this in conjunction with any other decompression
option.  Enables support---including auto-detection code---for the specified archive
format. For example,  enables support for a variety of standard tar formats,
old-style tar, ustar, pax interchange format, and many common variants. For
convenience,  enables support for all available formats. Only empty archives
are supported by default.  The same as  except that the skip callback is
assumed to be   Freeze the settings, open the archive, and prepare for
reading entries. This is the most generic version of this call, which accepts
four callback functions. Most clients will want to use    or  instead. The
library invokes the client-provided functions to obtain raw bytes from the
archive.  Like  except that it accepts a  pointer. This function should not
be used with tape drives or other devices that require strict I/O blocking.
 Like  except that it accepts a file descriptor and block size rather than
a set of function pointers. Note that the file descriptor will not be automatically
closed at end-of-archive. This function is safe for use with tape drives or
other blocked devices.  This is a deprecated synonym for   Like  except
that it accepts a simple filename and a block size. A NULL filename represents
standard input. This function is safe for use with tape drives or other
blocked devices.  Like  except that it accepts a pointer and size of a block
of memory containing the archive data.  Read the header for the next entry
and return a pointer to a   Read data associated with the header just read.
Internally, this is a convenience function that calls  and fills any gaps
with nulls so that callers see a single continuous stream of data.  Return
the next available block of data for this entry. Unlike  the  function avoids
copying data and allows you to correctly handle sparse files, as supported
by some archive formats. The library guarantees that offsets will increase
and that blocks will not overlap. Note that the blocks returned from this
function can be much larger than the block size read from disk, due to
compression and internal buffer optimizations.  A convenience function that
repeatedly calls  to skip all of the data for this archive entry.   This
function is deprecated and will be removed. Use  instead.   A convenience
function that repeatedly calls  to copy the entire entry to the provided
file descriptor.  A convenience function that wraps the corresponding  interfaces.
The first call to  creates a restore object using  and  then transparently
invokes    and  to create the entry on disk and copy data into it. The 
argument is passed unmodified to   Sets a pointer to a user-defined callback
that can be used for updating progress displays during extraction. The progress
function will be invoked during the extraction of large regular files. The
progress function will be invoked with the pointer provided to this call.
Generally, the data pointed to should include a reference to the archive
object and the archive_entry object so that various statistics can be retrieved
for the progress display.  Complete the archive and invoke the close callback.
 Invokes  if it was not invoked manually, then release all resources. Note:
In libarchive 1.x, this function was declared to return  which made it impossible
to detect certain errors when  was invoked implicitly from this function.
The declaration is corrected beginning with libarchive 2.0.   Note that the
library determines most of the relevant information about the archive by
inspection. In particular, it automatically detects  or  compression and
transparently performs the appropriate decompression. It also automatically
detects the archive format.  A complete description of the  and  objects
can be found in the overview manual page for  
<h2><a name='sect3' href='#toc3'>CLIENT CALLBACKS</a></h2>
The callback
functions must match the following prototypes:                     The
open callback is invoked by  It should return  if the underlying file or
data source is successfully opened. If the open fails, it should call  to
register an error code and message and return   The read callback is invoked
whenever the library requires raw bytes from the archive. The read callback
should read data into a buffer, set the  argument to point to the available
data, and return a count of the number of bytes available. The library will
invoke the read callback again only after it has consumed this data. The
library imposes no constraints on the size of the data blocks returned.
On end-of-file, the read callback should return zero. On error, the read callback
should invoke  to register an error code and message and return -1.  The
skip callback is invoked when the library wants to ignore a block of data.
The return value is the number of bytes actually skipped, which may differ
from the request. If the callback cannot skip data, it should return zero.
If the skip callback is not provided (the function pointer is  the library
will invoke the read function instead and simply discard the result. A skip
callback can provide significant performance gains when reading uncompressed
archives from slow disk drives or other media that can skip quickly.  The
close callback is invoked by archive_close when the archive processing
is complete. The callback should return  on success. On failure, the callback
should invoke  to register an error code and message and return  
<h2><a name='sect4' href='#toc4'>EXAMPLE</a></h2>
The
following illustrates basic usage of the library. In this example, the callback
functions are simply wrappers around the standard   and  system calls. 
void list_archive(const char *name) {   struct mydata *mydata;<br>
   struct archive *a;<br>
   struct archive_entry *entry;<br>
 
<p>   mydata = malloc(sizeof(struct mydata));<br>
   a = archive_read_new();<br>
   mydata-&gt;name = name;<br>
   archive_read_support_compression_all(a);<br>
   archive_read_support_format_all(a);<br>
   archive_read_open(a, mydata, myopen, myread, myclose);<br>
   while (archive_read_next_header(a, &amp;entry) == ARCHIVE_OK) {<br>
     printf("%s\n",archive_entry_pathname(entry));<br>
     archive_read_data_skip(a);<br>
   }<br>
   archive_read_finish(a);<br>
   free(mydata);<br>
 } 
<p> ssize_t myread(struct archive *a, void *client_data, const void **buff)
{   struct mydata *mydata = client_data;<br>
 
<p>   *buff = mydata-&gt;buff;<br>
   return (read(mydata-&gt;fd, mydata-&gt;buff, 10240));<br>
 } 
<p> int myopen(struct archive *a, void *client_data) {   struct mydata
*mydata = client_data;<br>
 
<p>   mydata-&gt;fd = open(mydata-&gt;name, O_RDONLY);<br>
   return (mydata-&gt;fd &gt;= 0 ? ARCHIVE_OK : ARCHIVE_FATAL);<br>
 } 
<p> int myclose(struct archive *a, void *client_data) {   struct mydata
*mydata = client_data;<br>
 
<p>   if (mydata-&gt;fd &gt; 0)<br>
     close(mydata-&gt;fd);<br>
   return (ARCHIVE_OK);<br>
 }  
<h2><a name='sect5' href='#toc5'>RETURN VALUES</a></h2>
Most functions return zero on success, non-zero on error.
The possible return codes include:  (the operation succeeded),  (the operation
succeeded but a non-critical error was encountered),  (end-of-archive was
encountered),  (the operation failed but can be retried), and  (there was
a fatal error; the archive should be closed immediately). Detailed error
codes and textual descriptions are available from the  and  functions. 
 returns a pointer to a freshly allocated  object. It returns  on error.
  returns a count of bytes actually read or zero at the end of the entry.
On error, a value of   or  is returned and an error code and textual description
can be retrieved from the  and  functions.  The library expects the client
callbacks to behave similarly. If there is an error, you can use  to set
an appropriate error code and description, then return one of the non-zero
values above. (Note that the value eventually returned to the client may
not be the same; many errors that are not critical at the level of basic
I/O can prevent the archive from being properly read, thus most I/O errors
eventually cause  to be returned.)  
<h2><a name='sect6' href='#toc6'>SEE ALSO</a></h2>
    
<h2><a name='sect7' href='#toc7'>HISTORY</a></h2>
The  library first
appeared in  
<h2><a name='sect8' href='#toc8'>AUTHORS</a></h2>
 The  library was written by  
<h2><a name='sect9' href='#toc9'>BUGS</a></h2>
Many traditional
archiver programs treat empty files as valid empty archives. For example,
many implementations of  allow you to append entries to an empty file. Of
course, it is impossible to determine the format of an empty file by inspecting
the contents, so this library treats empty files as having a special  format.
<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>NAME</a></li>
<li><a name='toc1' href='#sect1'>SYNOPSIS</a></li>
<li><a name='toc2' href='#sect2'>DESCRIPTION</a></li>
<li><a name='toc3' href='#sect3'>CLIENT CALLBACKS</a></li>
<li><a name='toc4' href='#sect4'>EXAMPLE</a></li>
<li><a name='toc5' href='#sect5'>RETURN VALUES</a></li>
<li><a name='toc6' href='#sect6'>SEE ALSO</a></li>
<li><a name='toc7' href='#sect7'>HISTORY</a></li>
<li><a name='toc8' href='#sect8'>AUTHORS</a></li>
<li><a name='toc9' href='#sect9'>BUGS</a></li>
</ul>
</body>
</html>
