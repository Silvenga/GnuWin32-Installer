<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>FLEX(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
flex - fast lexical analyzer generator 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>flex</b> <b>[-bcdfhilnpstvwBFILTV78+?
-C[aefFmr] -ooutput -Pprefix -Sskeleton]</b> <b>[--help --version]</b> <i>[filename</i> ...] 
<h2><a name='sect2' href='#toc2'>Overview</a></h2>
This
manual describes <i>flex,</i> a tool for generating programs that perform pattern-matching
on text.  The manual includes both tutorial and reference sections: <br>
<pre>    Description
        a brief overview of the tool
    Some Simple Examples
    Format Of The Input File
    Patterns
        the extended regular expressions used by flex
    How The Input Is Matched
        the rules for determining what has been matched
    Actions
        how to specify what to do when a pattern is matched
    The Generated Scanner
        details regarding the scanner that flex produces;
        how to control the input source
    Start Conditions
        introducing context into your scanners, and
        managing "mini-scanners"
    Multiple Input Buffers
        how to manipulate multiple input sources; how to
        scan from strings instead of files
    End-of-file Rules
        special rules for matching the end of the input
    Miscellaneous Macros
        a summary of macros available to the actions
    Values Available To The User
        a summary of values available to the actions
    Interfacing With Yacc
        connecting flex scanners together with yacc parsers
    Options
        flex command-line options, and the "%option"
        directive
    Performance Considerations
        how to make your scanner go as fast as possible
    Generating C++ Scanners
        the (experimental) facility for generating C++
        scanner classes
    Incompatibilities With Lex And POSIX
        how flex differs from AT&amp;T lex and the POSIX lex
        standard
    Diagnostics
        those error messages produced by flex (or scanners
        it generates) whose meanings might not be apparent
    Files
        files used by flex
    Deficiencies / Bugs
        known problems with flex
    See Also
        other documentation, related tools
    Author
        includes contact information
</pre>
<h2><a name='sect3' href='#toc3'>Description</a></h2>
<i>flex</i> is a tool for generating <i>scanners:</i> programs which recognized
lexical patterns in text. <i>flex</i> reads the given input files, or its standard
input if no file names are given, for a description of a scanner to generate.
 The description is in the form of pairs of regular expressions and C code,
called <i>rules.</i>  flex generates as output a C source file, <b>lex.yy.c,</b> which defines
a routine <b>yylex().</b> This file is compiled and linked with the <b>-lfl</b> library
to produce an executable.  When the executable is run, it analyzes its input
for occurrences of the regular expressions.  Whenever it finds one, it executes
the corresponding C code. 
<h2><a name='sect4' href='#toc4'>Some Simple Examples</a></h2>
<p>
First some simple examples
to get the flavor of how one uses <i>flex.</i> The following <i>flex</i> input specifies
a scanner which whenever it encounters the string "username" will replace
it with the user&rsquo;s login name: <br>
<pre>    %%
    username    printf( "%s", getlogin() );
</pre>By default, any text not matched by a <i>flex</i> scanner is copied to the output,
so the net effect of this scanner is to copy its input file to its output
with each occurrence of "username" expanded. In this input, there is just
one rule.  "username" is the <i>pattern</i> and the "printf" is the <i>action.</i> The
"%%" marks the beginning of the rules. <p>
Here&rsquo;s another simple example: <br>
<pre>            int num_lines = 0, num_chars = 0;
    %%
    \n      ++num_lines; ++num_chars;
    .       ++num_chars;
    %%
    main()
            {
            yylex();
            printf( "# of lines = %d, # of chars = %d\n",
                    num_lines, num_chars );
            }
</pre>This scanner counts the number of characters and the number of lines in
its input (it produces no output other than the final report on the counts).
 The first line declares two globals, "num_lines" and "num_chars", which
are accessible both inside <b>yylex()</b> and in the <b>main()</b> routine declared after
the second "%%".  There are two rules, one which matches a newline ("\n")
and increments both the line count and the character count, and one which
matches any character other than a newline (indicated by the "." regular
expression). <p>
A somewhat more complicated example: <br>
<pre>    /* scanner for a toy Pascal-like language */
    %{
    /* need this for the call to atof() below */
    #include &lt;math.h&gt;
    %}
    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*
    %%
    {DIGIT}+    {
                printf( "An integer: %s (%d)\n", yytext,
                        atoi( yytext ) );
                }
    {DIGIT}+"."{DIGIT}*        {
                printf( "A float: %s (%g)\n", yytext,
                        atof( yytext ) );
                }
    if|then|begin|end|procedure|function        {
                printf( "A keyword: %s\n", yytext );
                }
    {ID}        printf( "An identifier: %s\n", yytext );
    "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );
    "{"[^}\n]*"}"     /* eat up one-line comments */
    [ \t\n]+          /* eat up whitespace */
    .           printf( "Unrecognized character: %s\n", yytext );
    %%
    main( argc, argv )
    int argc;
    char **argv;
        {
        ++argv, --argc;  /* skip over program name */
        if ( argc &gt; 0 )
                yyin = fopen( argv[0], "r" );
        else
                yyin = stdin;
        
        yylex();
        }
</pre>This is the beginnings of a simple scanner for a language like Pascal. 
It identifies different types of <i>tokens</i> and reports on what it has seen.
<p>
The details of this example will be explained in the following sections.

<h2><a name='sect5' href='#toc5'>Format of the Input File</a></h2>
The <i>flex</i> input file consists of three sections,
separated by a line with just <b>%%</b> in it: <br>
<pre>    definitions
    %%
    rules
    %%
    user code
</pre>The <i>definitions</i> section contains declarations of simple <i>name</i> definitions
to simplify the scanner specification, and declarations of <i>start</i> conditions,
which are explained in a later section. <p>
Name definitions have the form:
<br>
<pre>    name definition
</pre>The "name" is a word beginning with a letter or an underscore (&rsquo;_&rsquo;) followed
by zero or more letters, digits, &rsquo;_&rsquo;, or &rsquo;-&rsquo; (dash). The definition is taken
to begin at the first non-white-space character following the name and continuing
to the end of the line. The definition can subsequently be referred to using
"{name}", which will expand to "(definition)".  For example, <br>
<pre>    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*
</pre>defines "DIGIT" to be a regular expression which matches a single digit,
and "ID" to be a regular expression which matches a letter followed by
zero-or-more letters-or-digits. A subsequent reference to <br>
<pre>    {DIGIT}+"."{DIGIT}*
</pre>is identical to <br>
<pre>    ([0-9])+"."([0-9])*
</pre>and matches one-or-more digits followed by a &rsquo;.&rsquo; followed by zero-or-more digits.
<p>
The <i>rules</i> section of the <i>flex</i> input contains a series of rules of the form:
<br>
<pre>    pattern   action
</pre>where the pattern must be unindented and the action must begin on the same
line. <p>
See below for a further description of patterns and actions. <p>
Finally,
the user code section is simply copied to <b>lex.yy.c</b> verbatim. It is used for
companion routines which call or are called by the scanner.  The presence
of this section is optional; if it is missing, the second <b>%%</b> in the input
file may be skipped, too. <p>
In the definitions and rules sections, any <i>indented</i>
text or text enclosed in <b>%{</b> and <b>%}</b> is copied verbatim to the output (with
the %{}&rsquo;s removed). The %{}&rsquo;s must appear unindented on lines by themselves.
<p>
In the rules section, any indented or %{} text appearing before the first
rule may be used to declare variables which are local to the scanning routine
and (after the declarations) code which is to be executed whenever the
scanning routine is entered. Other indented or %{} text in the rule section
is still copied to the output, but its meaning is not well-defined and it
may well cause compile-time errors (this feature is present for <i>POSIX</i> compliance;
see below for other such features). <p>
In the definitions section (but not
in the rules section), an unindented comment (i.e., a line beginning with
"/*") is also copied verbatim to the output up to the next "*/". 
<h2><a name='sect6' href='#toc6'>Patterns</a></h2>
The
patterns in the input are written using an extended set of regular expressions.
 These are: <br>
<pre>    x          match the character &rsquo;x&rsquo;
    .          any character (byte) except newline
    [xyz]      a "character class"; in this case, the pattern
                 matches either an &rsquo;x&rsquo;, a &rsquo;y&rsquo;, or a &rsquo;z&rsquo;
    [abj-oZ]   a "character class" with a range in it; matches
                 an &rsquo;a&rsquo;, a &rsquo;b&rsquo;, any letter from &rsquo;j&rsquo; through &rsquo;o&rsquo;,
                 or a &rsquo;Z&rsquo;
    [^A-Z]     a "negated character class", i.e., any character
                 but those in the class.  In this case, any
                 character EXCEPT an uppercase letter.
    [^A-Z\n]   any character EXCEPT an uppercase letter or
                 a newline
    r*         zero or more r&rsquo;s, where r is any regular expression
    r+         one or more r&rsquo;s
    r?         zero or one r&rsquo;s (that is, "an optional r")
    r{2,5}     anywhere from two to five r&rsquo;s
    r{2,}      two or more r&rsquo;s
    r{4}       exactly 4 r&rsquo;s
    {name}     the expansion of the "name" definition
               (see above)
    "[xyz]\"foo"
               the literal string: [xyz]"foo
    \X         if X is an &rsquo;a&rsquo;, &rsquo;b&rsquo;, &rsquo;f&rsquo;, &rsquo;n&rsquo;, &rsquo;r&rsquo;, &rsquo;t&rsquo;, or &rsquo;v&rsquo;,
                 then the ANSI-C interpretation of \x.
                 Otherwise, a literal &rsquo;X&rsquo; (used to escape
                 operators such as &rsquo;*&rsquo;)
    \0         a NUL character (ASCII code 0)
    \123       the character with octal value 123
    \x2a       the character with hexadecimal value 2a
    (r)        match an r; parentheses are used to override
                 precedence (see below)
    rs         the regular expression r followed by the
                 regular expression s; called "concatenation"
    r|s        either an r or an s
    r/s        an r but only if it is followed by an s.  The
                 text matched by s is included when determining
                 whether this rule is the "longest match",
                 but is then returned to the input before
                 the action is executed.  So the action only
                 sees the text matched by r.  This type
                 of pattern is called trailing context".
                 (There are some combinations of r/s that flex
                 cannot match correctly; see notes in the
                 Deficiencies / Bugs section below regarding
                 "dangerous trailing context".)
    ^r         an r, but only at the beginning of a line (i.e.,
                 which just starting to scan, or right after a
                 newline has been scanned).
    r$         an r, but only at the end of a line (i.e., just
                 before a newline).  Equivalent to "r/\n".
               Note that flex&rsquo;s notion of "newline" is exactly
               whatever the C compiler used to compile flex
               interprets &rsquo;\n&rsquo; as; in particular, on some DOS
               systems you must either filter out \r&rsquo;s in the
               input yourself, or explicitly use r/\r\n for "r$".
    &lt;s&gt;r       an r, but only in start condition s (see
                 below for discussion of start conditions)
    &lt;s1,s2,s3&gt;r
               same, but in any of start conditions s1,
                 s2, or s3
    &lt;*&gt;r       an r in any start condition, even an exclusive one.
    &lt;&lt;EOF&gt;&gt;    an end-of-file
    &lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;
               an end-of-file when in start condition s1 or s2
</pre>Note that inside of a character class, all regular expression operators
lose their special meaning except escape (&rsquo;\&rsquo;) and the character class operators,
&rsquo;-&rsquo;, &rsquo;]&rsquo;, and, at the beginning of the class, &rsquo;^&rsquo;. <p>
The regular expressions listed
above are grouped according to precedence, from highest precedence at the
top to lowest at the bottom. Those grouped together have equal precedence.
 For example, <br>
<pre>    foo|bar*
</pre>is the same as <br>
<pre>    (foo)|(ba(r*))
</pre>since the &rsquo;*&rsquo; operator has higher precedence than concatenation, and concatenation
higher than alternation (&rsquo;|&rsquo;).  This pattern therefore matches <i>either</i> the string
"foo" <i>or</i> the string "ba" followed by zero-or-more r&rsquo;s. To match "foo" or zero-or-more
"bar"&rsquo;s, use: <br>
<pre>    foo|(bar)*
</pre>and to match zero-or-more "foo"&rsquo;s-or-"bar"&rsquo;s: <br>
<pre>    (foo|bar)*
</pre><p>
In addition to characters and ranges of characters, character classes can
also contain character class <i>expressions.</i> These are expressions enclosed
inside <b>[:</b> and <b>:]</b> delimiters (which themselves must appear between the &rsquo;[&rsquo;
and &rsquo;]&rsquo; of the character class; other elements may occur inside the character
class, too). The valid expressions are: <br>
<pre>    [:alnum:] [:alpha:] [:blank:]
    [:cntrl:] [:digit:] [:graph:]
    [:lower:] [:print:] [:punct:]
    [:space:] [:upper:] [:xdigit:]
</pre>These expressions all designate a set of characters equivalent to the corresponding
standard C <b>isXXX</b> function.  For example, <b>[:alnum:]</b> designates those characters
for which <b>isalnum()</b> returns true - i.e., any alphabetic or numeric. Some systems
don&rsquo;t provide <b>isblank(),</b> so flex defines <b>[:blank:]</b> as a blank or a tab. <p>
For
example, the following character classes are all equivalent: <br>
<pre>    [[:alnum:]]
    [[:alpha:][:digit:]
    [[:alpha:]0-9]
    [a-zA-Z0-9]
</pre>If your scanner is case-insensitive (the <b>-i</b> flag), then <b>[:upper:]</b> and <b>[:lower:]</b>
are equivalent to <b>[:alpha:].</b> <p>
Some notes on patterns: 
<dl>

<dt>-</dt>
<dd>A negated character
class such as the example "[^A-Z]" above <i>will</i> match a newline unless "\n"
(or an equivalent escape sequence) is one of the characters explicitly
present in the negated character class (e.g., "[^A-Z\n]").  This is unlike how
many other regular expression tools treat negated character classes, but
unfortunately the inconsistency is historically entrenched. Matching newlines
means that a pattern like [^"]* can match the entire input unless there&rsquo;s
another quote in the input. </dd>

<dt>-</dt>
<dd>A rule can have at most one instance of trailing
context (the &rsquo;/&rsquo; operator or the &rsquo;$&rsquo; operator).  The start condition, &rsquo;^&rsquo;, and
"&lt;&lt;EOF&gt;&gt;" patterns can only occur at the beginning of a pattern, and, as well
as with &rsquo;/&rsquo; and &rsquo;$&rsquo;, cannot be grouped inside parentheses.  A &rsquo;^&rsquo; which does not
occur at the beginning of a rule or a &rsquo;$&rsquo; which does not occur at the end
of a rule loses its special properties and is treated as a normal character.
</dd>

<dt>The following are illegal: </dt>
<dd><br>
<pre>    foo/bar$
    &lt;sc1&gt;foo&lt;sc2&gt;bar
</pre>Note that the first of these, can be written "foo/bar\n". </dd>

<dt>The following will
result in &rsquo;$&rsquo; or &rsquo;^&rsquo; being treated as a normal character: </dt>
<dd><br>
<pre>    foo|(bar$)
    foo|^bar
</pre>If what&rsquo;s wanted is a "foo" or a bar-followed-by-a-newline, the following could
be used (the special &rsquo;|&rsquo; action is explained below): <br>
<pre>    foo      |
    bar$     /* action goes here */
</pre>A similar trick will work for matching a foo or a bar-at-the-beginning-of-a-line.
</dd>
</dl>

<h2><a name='sect7' href='#toc7'>How the Input is Matched</a></h2>
When the generated scanner is run, it analyzes
its input looking for strings which match any of its patterns.  If it finds
more than one match, it takes the one matching the most text (for trailing
context rules, this includes the length of the trailing part, even though
it will then be returned to the input).  If it finds two or more matches
of the same length, the rule listed first in the <i>flex</i> input file is chosen.
<p>
Once the match is determined, the text corresponding to the match (called
the <i>token)</i> is made available in the global character pointer <b>yytext,</b> and
its length in the global integer <b>yyleng.</b> The <i>action</i> corresponding to the
matched pattern is then executed (a more detailed description of actions
follows), and then the remaining input is scanned for another match. <p>
If
no match is found, then the <i>default</i> rule is executed: the next character
in the input is considered matched and copied to the standard output.  Thus,
the simplest legal <i>flex</i> input is: <br>
<pre>    %%
</pre>which generates a scanner that simply copies its input (one character at
a time) to its output. <p>
Note that <b>yytext</b> can be defined in two different
ways: either as a character <i>pointer</i> or as a character <i>array.</i> You can control
which definition <i>flex</i> uses by including one of the special directives <b>%pointer</b>
or <b>%array</b> in the first (definitions) section of your flex input.  The default
is <b>%pointer,</b> unless you use the <b>-l</b> lex compatibility option, in which case
<b>yytext</b> will be an array. The advantage of using <b>%pointer</b> is substantially
faster scanning and no buffer overflow when matching very large tokens
(unless you run out of dynamic memory).  The disadvantage is that you are
restricted in how your actions can modify <b>yytext</b> (see the next section),
and calls to the <b>unput()</b> function destroys the present contents of <b>yytext,</b>
which can be a considerable porting headache when moving between different
<i>lex</i> versions. <p>
The advantage of <b>%array</b> is that you can then modify <b>yytext</b>
to your heart&rsquo;s content, and calls to <b>unput()</b> do not destroy <b>yytext</b> (see
below).  Furthermore, existing <i>lex</i> programs sometimes access <b>yytext</b> externally
using declarations of the form: <br>
<pre>    extern char yytext[];
</pre>This definition is erroneous when used with <b>%pointer,</b> but correct for <b>%array.</b>
<p>
<b>%array</b> defines <b>yytext</b> to be an array of <b>YYLMAX</b> characters, which defaults
to a fairly large value.  You can change the size by simply #define&rsquo;ing <b>YYLMAX</b>
to a different value in the first section of your <i>flex</i> input.  As mentioned
above, with <b>%pointer</b> yytext grows dynamically to accommodate large tokens.
 While this means your <b>%pointer</b> scanner can accommodate very large tokens
(such as matching entire blocks of comments), bear in mind that each time
the scanner must resize <b>yytext</b> it also must rescan the entire token from
the beginning, so matching such tokens can prove slow. <b>yytext</b> presently
does <i>not</i> dynamically grow if a call to <b>unput()</b> results in too much text
being pushed back; instead, a run-time error results. <p>
Also note that you
cannot use <b>%array</b> with C++ scanner classes (the <b>c++</b> option; see below).

<h2><a name='sect8' href='#toc8'>Actions</a></h2>
Each pattern in a rule has a corresponding action, which can be
any arbitrary C statement.  The pattern ends at the first non-escaped whitespace
character; the remainder of the line is its action.  If the action is empty,
then when the pattern is matched the input token is simply discarded.  For
example, here is the specification for a program which deletes all occurrences
of "zap me" from its input: <br>
<pre>    %%
    "zap me"
</pre>(It will copy all other characters in the input to the output since they
will be matched by the default rule.) <p>
Here is a program which compresses
multiple blanks and tabs down to a single blank, and throws away whitespace
found at the end of a line: <br>
<pre>    %%
    [ \t]+        putchar( &rsquo; &rsquo; );
    [ \t]+$       /* ignore this token */
</pre><p>
If the action contains a &rsquo;{&rsquo;, then the action spans till the balancing &rsquo;}&rsquo;
is found, and the action may cross multiple lines. <i>flex</i>  knows about C strings
and comments and won&rsquo;t be fooled by braces found within them, but also allows
actions to begin with <b>%{</b> and will consider the action to be all the text
up to the next <b>%}</b> (regardless of ordinary braces inside the action). <p>
An
action consisting solely of a vertical bar (&rsquo;|&rsquo;) means "same as the action
for the next rule."  See below for an illustration. <p>
Actions can include arbitrary
C code, including <b>return</b> statements to return a value to whatever routine
called <b>yylex().</b> Each time <b>yylex()</b> is called it continues processing tokens
from where it last left off until it either reaches the end of the file
or executes a return. <p>
Actions are free to modify <b>yytext</b> except for lengthening
it (adding characters to its end--these will overwrite later characters in
the input stream).  This however does not apply when using <b>%array</b> (see above);
in that case, <b>yytext</b> may be freely modified in any way. <p>
Actions are free
to modify <b>yyleng</b> except they should not do so if the action also includes
use of <b>yymore()</b> (see below). <p>
There are a number of special directives which
can be included within an action: 
<dl>

<dt>-</dt>
<dd><b>ECHO</b> copies yytext to the scanner&rsquo;s output.
</dd>

<dt>-</dt>
<dd><b>BEGIN</b> followed by the name of a start condition places the scanner in the
corresponding start condition (see below). </dd>

<dt>-</dt>
<dd><b>REJECT</b> directs the scanner to
proceed on to the "second best" rule which matched the input (or a prefix
of the input).  The rule is chosen as described above in "How the Input
is Matched", and <b>yytext</b> and <b>yyleng</b> set up appropriately. It may either be
one which matched as much text as the originally chosen rule but came later
in the <i>flex</i> input file, or one which matched less text. For example, the
following will both count the words in the input and call the routine special()
whenever "frob" is seen: <br>
<pre>            int word_count = 0;
    %%
    frob        special(); REJECT;
    [^ \t\n]+   ++word_count;
</pre>Without the <b>REJECT,</b> any "frob"&rsquo;s in the input would not be counted as words,
since the scanner normally executes only one action per token. Multiple
<b>REJECT&rsquo;s</b> are allowed, each one finding the next best choice to the currently
active rule.  For example, when the following scanner scans the token "abcd",
it will write "abcdabcaba" to the output: <br>
<pre>    %%
    a        |
    ab       |
    abc      |
    abcd     ECHO; REJECT;
    .|\n     /* eat up any unmatched character */
</pre>(The first three rules share the fourth&rsquo;s action since they use the special
&rsquo;|&rsquo; action.) <b>REJECT</b> is a particularly expensive feature in terms of scanner
performance; if it is used in <i>any</i> of the scanner&rsquo;s actions it will slow
down <i>all</i> of the scanner&rsquo;s matching.  Furthermore, <b>REJECT</b> cannot be used with
the <i>-Cf</i> or <i>-CF</i> options (see below). </dd>

<dt>Note also that unlike the other special
actions, </dt>
<dd><b>REJECT</b> is a <i>branch;</i> code immediately following it in the action
will <i>not</i> be executed. </dd>

<dt>-</dt>
<dd><b>yymore()</b> tells the scanner that the next time it matches
a rule, the corresponding token should be <i>appended</i> onto the current value
of <b>yytext</b> rather than replacing it.  For example, given the input "mega-kludge"
the following will write "mega-mega-kludge" to the output: <br>
<pre>    %%
    mega-    ECHO; yymore();
    kludge   ECHO;
</pre>First "mega-" is matched and echoed to the output.  Then "kludge" is matched,
but the previous "mega-" is still hanging around at the beginning of <b>yytext</b>
so the <b>ECHO</b> for the "kludge" rule will actually write "mega-kludge". </dd>
</dl>
<p>
Two
notes regarding use of <b>yymore().</b> First, <b>yymore()</b> depends on the value of
<i>yyleng</i> correctly reflecting the size of the current token, so you must
not modify <i>yyleng</i> if you are using <b>yymore().</b> Second, the presence of <b>yymore()</b>
in the scanner&rsquo;s action entails a minor performance penalty in the scanner&rsquo;s
matching speed. 
<dl>

<dt>-</dt>
<dd><a href='yyless.n.html'><b>yyless(n)</b></a>
 returns all but the first <i>n</i> characters of the
current token back to the input stream, where they will be rescanned when
the scanner looks for the next match. <b>yytext</b> and <b>yyleng</b> are adjusted appropriately
(e.g., <b>yyleng</b> will now be equal to <i>n</i> ).  For example, on the input "foobar"
the following will write out "foobarbar": <br>
<pre>    %%
    foobar    ECHO; yyless(3);
    [a-z]+    ECHO;
</pre>An argument of 0 to <b>yyless</b> will cause the entire current input string to
be scanned again.  Unless you&rsquo;ve changed how the scanner will subsequently
process its input (using <b>BEGIN,</b> for example), this will result in an endless
loop. </dd>
</dl>
<p>
Note that <b>yyless</b> is a macro and can only be used in the flex input
file, not from other source files. 
<dl>

<dt>-</dt>
<dd><b>unput(c)</b> puts the character <i>c</i> back onto
the input stream.  It will be the next character scanned. The following action
will take the current token and cause it to be rescanned enclosed in parentheses.
<br>
<pre>    {
    int i;
    /* Copy yytext because unput() trashes yytext */
    char *yycopy = strdup( yytext );
    unput( &rsquo;)&rsquo; );
    for ( i = yyleng - 1; i &gt;= 0; --i )
        unput( yycopy[i] );
    unput( &rsquo;(&rsquo; );
    free( yycopy );
    }
</pre>Note that since each <b>unput()</b> puts the given character back at the <i>beginning</i>
of the input stream, pushing back strings must be done back-to-front. </dd>
</dl>
<p>
An important
potential problem when using <b>unput()</b> is that if you are using <b>%pointer</b>
(the default), a call to <b>unput()</b> <i>destroys</i> the contents of <i>yytext,</i> starting
with its rightmost character and devouring one character to the left with
each call.  If you need the value of yytext preserved after a call to <b>unput()</b>
(as in the above example), you must either first copy it elsewhere, or
build your scanner using <b>%array</b> instead (see How The Input Is Matched).
<p>
Finally, note that you cannot put back <b>EOF</b> to attempt to mark the input
stream with an end-of-file. 
<dl>

<dt>-</dt>
<dd><b>input()</b> reads the next character from the input
stream.  For example, the following is one way to eat up C comments: <br>
<pre>    %%
    "/*"        {
                register int c;
                for ( ; ; )
                    {
                    while ( (c = input()) != &rsquo;*&rsquo; &amp;&amp;
                            c != EOF )
                        ;    /* eat up text of comment */
                    if ( c == &rsquo;*&rsquo; )
                        {
                        while ( (c = input()) == &rsquo;*&rsquo; )
                            ;
                        if ( c == &rsquo;/&rsquo; )
                            break;    /* found the end */
                        }
                    if ( c == EOF )
                        {
                        error( "EOF in comment" );
                        break;
                        }
                    }
                }
</pre>(Note that if the scanner is compiled using <b>C++,</b> then <b>input()</b> is instead
referred to as <b>yyinput(),</b> in order to avoid a name clash with the <b>C++</b> stream
by the name of <i>input.)</i> </dd>

<dt>-</dt>
<dd><b>YY_FLUSH_BUFFER</b> flushes the scanner&rsquo;s internal buffer
so that the next time the scanner attempts to match a token, it will first
refill the buffer using <b>YY_INPUT</b> (see The Generated Scanner, below).  This
action is a special case of the more general <b>yy_flush_buffer()</b> function,
described below in the section Multiple Input Buffers. </dd>

<dt>-</dt>
<dd><b>yyterminate()</b> can
be used in lieu of a return statement in an action.  It terminates the scanner
and returns a 0 to the scanner&rsquo;s caller, indicating "all done". By default,
<b>yyterminate()</b> is also called when an end-of-file is encountered.  It is a
macro and may be redefined. </dd>
</dl>

<h2><a name='sect9' href='#toc9'>the Generated Scanner</a></h2>
The output of <i>flex</i> is the
file <b>lex.yy.c,</b> which contains the scanning routine <b>yylex(),</b> a number of tables
used by it for matching tokens, and a number of auxiliary routines and
macros.  By default, <b>yylex()</b> is declared as follows: <br>
<pre>    int yylex()
        {
        ... various definitions and the actions in here ...
        }
</pre>(If your environment supports function prototypes, then it will be "int
yylex( void )".)  This definition may be changed by defining the "YY_DECL"
macro.  For example, you could use: <br>
<pre>    #define YY_DECL float lexscan( a, b ) float a, b;
</pre>to give the scanning routine the name <i>lexscan,</i> returning a float, and taking
two floats as arguments.  Note that if you give arguments to the scanning
routine using a K&amp;R-style/non-prototyped function declaration, you must terminate
the definition with a semi-colon (;). <p>
Whenever <b>yylex()</b> is called, it scans
tokens from the global input file <i>yyin</i> (which defaults to stdin).  It continues
until it either reaches an end-of-file (at which point it returns the value
0) or one of its actions executes a <i>return</i> statement. <p>
If the scanner reaches
an end-of-file, subsequent calls are undefined unless either <i>yyin</i> is pointed
at a new input file (in which case scanning continues from that file),
or <b>yyrestart()</b> is called. <b>yyrestart()</b> takes one argument, a <b>FILE *</b> pointer
(which can be nil, if you&rsquo;ve set up <b>YY_INPUT</b> to scan from a source other
than <i>yyin),</i> and initializes <i>yyin</i> for scanning from that file.  Essentially
there is no difference between just assigning <i>yyin</i> to a new input file
or using <b>yyrestart()</b> to do so; the latter is available for compatibility
with previous versions of <i>flex,</i> and because it can be used to switch input
files in the middle of scanning. It can also be used to throw away the current
input buffer, by calling it with an argument of <i>yyin;</i> but better is to
use <b>YY_FLUSH_BUFFER</b> (see above). Note that <b>yyrestart()</b> does <i>not</i> reset the
start condition to <b>INITIAL</b> (see Start Conditions, below). <p>
If <b>yylex()</b> stops
scanning due to executing a <i>return</i> statement in one of the actions, the
scanner may then be called again and it will resume scanning where it left
off. <p>
By default (and for purposes of efficiency), the scanner uses block-reads
rather than simple <i>getc()</i> calls to read characters from <i>yyin.</i> The nature
of how it gets its input can be controlled by defining the <b>YY_INPUT</b> macro.
YY_INPUT&rsquo;s calling sequence is "YY_INPUT(buf,result,max_size)".  Its action
is to place up to <i>max_size</i> characters in the character array <i>buf</i> and return
in the integer variable <i>result</i> either the number of characters read or
the constant YY_NULL (0 on Unix systems) to indicate EOF.  The default YY_INPUT
reads from the global file-pointer "yyin". <p>
A sample definition of YY_INPUT
(in the definitions section of the input file): <br>
<pre>    %{
    #define YY_INPUT(buf,result,max_size) \
        { \
        int c = getchar(); \
        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
        }
    %}
</pre>This definition will change the input processing to occur one character
at a time. <p>
When the scanner receives an end-of-file indication from YY_INPUT,
it then checks the <b>yywrap()</b> function.  If <b>yywrap()</b> returns false (zero),
then it is assumed that the function has gone ahead and set up <i>yyin</i> to
point to another input file, and scanning continues.  If it returns true
(non-zero), then the scanner terminates, returning 0 to its caller.  Note
that in either case, the start condition remains unchanged; it does <i>not</i>
revert to <b>INITIAL.</b> <p>
If you do not supply your own version of <b>yywrap(),</b> then
you must either use <b>%option noyywrap</b> (in which case the scanner behaves
as though <b>yywrap()</b> returned 1), or you must link with <b>-lfl</b> to obtain the
default version of the routine, which always returns 1. <p>
Three routines are
available for scanning from in-memory buffers rather than files: <b>yy_scan_string(),
yy_scan_bytes(),</b> and <b>yy_scan_buffer().</b> See the discussion of them below
in the section Multiple Input Buffers. <p>
The scanner writes its <b>ECHO</b> output
to the <i>yyout</i> global (default, stdout), which may be redefined by the user
simply by assigning it to some other <b>FILE</b> pointer. 
<h2><a name='sect10' href='#toc10'>Start Conditions</a></h2>
<i>flex</i>
provides a mechanism for conditionally activating rules.  Any rule whose
pattern is prefixed with "&lt;sc&gt;" will only be active when the scanner is in
the start condition named "sc".  For example, <br>
<pre>    &lt;STRING&gt;[^"]*        { /* eat up the string body ... */
                ...
                }
</pre>will be active only when the scanner is in the "STRING" start condition,
and <br>
<pre>    &lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
                ...
                }
</pre>will be active only when the current start condition is either "INITIAL",
"STRING", or "QUOTE". <p>
Start conditions are declared in the definitions (first)
section of the input using unindented lines beginning with either <b>%s</b> or
<b>%x</b> followed by a list of names. The former declares <i>inclusive</i> start conditions,
the latter <i>exclusive</i> start conditions.  A start condition is activated using
the <b>BEGIN</b> action.  Until the next <b>BEGIN</b> action is executed, rules with the
given start condition will be active and rules with other start conditions
will be inactive. If the start condition is <i>inclusive,</i> then rules with no
start conditions at all will also be active. If it is <i>exclusive,</i> then <i>only</i>
rules qualified with the start condition will be active. A set of rules
contingent on the same exclusive start condition describe a scanner which
is independent of any of the other rules in the <i>flex</i> input.  Because of
this, exclusive start conditions make it easy to specify "mini-scanners"
which scan portions of the input that are syntactically different from
the rest (e.g., comments). <p>
If the distinction between inclusive and exclusive
start conditions is still a little vague, here&rsquo;s a simple example illustrating
the connection between the two.  The set of rules: <br>
<pre>    %s example
    %%
    &lt;example&gt;foo   do_something();
    bar            something_else();
</pre>is equivalent to <br>
<pre>    %x example
    %%
    &lt;example&gt;foo   do_something();
    &lt;INITIAL,example&gt;bar    something_else();
</pre>Without the <b>&lt;INITIAL,example&gt;</b> qualifier, the <i>bar</i> pattern in the second example
wouldn&rsquo;t be active (i.e., couldn&rsquo;t match) when in start condition <b>example.</b> If
we just used <b>&lt;example&gt;</b> to qualify <i>bar,</i> though, then it would only be active
in <b>example</b> and not in <b>INITIAL,</b> while in the first example it&rsquo;s active in
both, because in the first example the <b>example</b> startion condition is an
<i>inclusive</i> <b>(%s)</b> start condition. <p>
Also note that the special start-condition
specifier <b>&lt;*&gt;</b> matches every start condition.  Thus, the above example could
also have been written; <br>
<pre>    %x example
    %%
    &lt;example&gt;foo   do_something();
    &lt;*&gt;bar    something_else();
</pre><p>
The default rule (to <b>ECHO</b> any unmatched character) remains active in start
conditions.  It is equivalent to: <br>
<pre>    &lt;*&gt;.|\n     ECHO;
</pre><p>
<b>BEGIN(0)</b> returns to the original state where only the rules with no start
conditions are active.  This state can also be referred to as the start-condition
"INITIAL", so <b>BEGIN(INITIAL)</b> is equivalent to <b>BEGIN(0).</b> (The parentheses
around the start condition name are not required but are considered good
style.) <p>
<b>BEGIN</b> actions can also be given as indented code at the beginning
of the rules section.  For example, the following will cause the scanner
to enter the "SPECIAL" start condition whenever <b>yylex()</b> is called and the
global variable <i>enter_special</i> is true: <br>
<pre>            int enter_special;
    %x SPECIAL
    %%
            if ( enter_special )
                BEGIN(SPECIAL);
    &lt;SPECIAL&gt;blahblahblah
    ...more rules follow...
</pre><p>
To illustrate the uses of start conditions, here is a scanner which provides
two different interpretations of a string like "123.456".  By default it
will treat it as three tokens, the integer "123", a dot (&rsquo;.&rsquo;), and the integer
"456". But if the string is preceded earlier in the line by the string "expect-floats"
it will treat it as a single token, the floating-point number 123.456: <br>
<pre>    %{
    #include &lt;math.h&gt;
    %}
    %s expect
    %%
    expect-floats        BEGIN(expect);
    &lt;expect&gt;[0-9]+"."[0-9]+      {
                printf( "found a float, = %f\n",
                        atof( yytext ) );
                }
    &lt;expect&gt;\n           {
                /* that&rsquo;s the end of the line, so
                 * we need another "expect-number"
                 * before we&rsquo;ll recognize any more
                 * numbers
                 */
                BEGIN(INITIAL);
                }
    [0-9]+      {
                printf( "found an integer, = %d\n",
                        atoi( yytext ) );
                }
    "."         printf( "found a dot\n" );
</pre>Here is a scanner which recognizes (and discards) C comments while maintaining
a count of the current input line. <br>
<pre>    %x comment
    %%
            int line_num = 1;
    "/*"         BEGIN(comment);
    &lt;comment&gt;[^*\n]*        /* eat anything that&rsquo;s not a &rsquo;*&rsquo; */
    &lt;comment&gt;"*"+[^*/\n]*   /* eat up &rsquo;*&rsquo;s not followed by &rsquo;/&rsquo;s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</pre>This scanner goes to a bit of trouble to match as much text as possible
with each rule.  In general, when attempting to write a high-speed scanner
try to match as much possible in each rule, as it&rsquo;s a big win. <p>
Note that
start-conditions names are really integer values and can be stored as such.
 Thus, the above could be extended in the following fashion: <br>
<pre>    %x comment foo
    %%
            int line_num = 1;
            int comment_caller;
    "/*"         {
                 comment_caller = INITIAL;
                 BEGIN(comment);
                 }
    ...
    &lt;foo&gt;"/*"    {
                 comment_caller = foo;
                 BEGIN(comment);
                 }
    &lt;comment&gt;[^*\n]*        /* eat anything that&rsquo;s not a &rsquo;*&rsquo; */
    &lt;comment&gt;"*"+[^*/\n]*   /* eat up &rsquo;*&rsquo;s not followed by &rsquo;/&rsquo;s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;"*"+"/"        BEGIN(comment_caller);
</pre>Furthermore, you can access the current start condition using the integer-valued
<b>YY_START</b> macro.  For example, the above assignments to <i>comment_caller</i> could
instead be written <br>
<pre>    comment_caller = YY_START;
</pre>Flex provides <b>YYSTATE</b> as an alias for <b>YY_START</b> (since that is what&rsquo;s used
by AT&amp;T <i>lex).</i> <p>
Note that start conditions do not have their own name-space;
%s&rsquo;s and %x&rsquo;s declare names in the same fashion as #define&rsquo;s. <p>
Finally, here&rsquo;s
an example of how to match C-style quoted strings using exclusive start
conditions, including expanded escape sequences (but not including checking
for a string that&rsquo;s too long): <br>
<pre>    %x str
    %%
            char string_buf[MAX_STR_CONST];
            char *string_buf_ptr;
    \"      string_buf_ptr = string_buf; BEGIN(str);
    &lt;str&gt;\"        { /* saw closing quote - all done */
            BEGIN(INITIAL);
            *string_buf_ptr = &rsquo;\0&rsquo;;
            /* return string constant token type and
             * value to parser
             */
            }
    &lt;str&gt;\n        {
            /* error - unterminated string constant */
            /* generate error message */
            }
    &lt;str&gt;\\[0-7]{1,3} {
            /* octal escape sequence */
            int result;
            (void) sscanf( yytext + 1, "%o", &amp;result );
            if ( result &gt; 0xff )
                    /* error, constant is out-of-bounds */
            *string_buf_ptr++ = result;
            }
    &lt;str&gt;\\[0-9]+ {
            /* generate error - bad escape sequence; something
             * like &rsquo;\48&rsquo; or &rsquo;\0777777&rsquo;
             */
            }
    &lt;str&gt;\\n  *string_buf_ptr++ = &rsquo;\n&rsquo;;
    &lt;str&gt;\\t  *string_buf_ptr++ = &rsquo;\t&rsquo;;
    &lt;str&gt;\\r  *string_buf_ptr++ = &rsquo;\r&rsquo;;
    &lt;str&gt;\\b  *string_buf_ptr++ = &rsquo;\b&rsquo;;
    &lt;str&gt;\\f  *string_buf_ptr++ = &rsquo;\f&rsquo;;
    &lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1];
    &lt;str&gt;[^\\\n\"]+        {
            char *yptr = yytext;
            while ( *yptr )
                    *string_buf_ptr++ = *yptr++;
            }
</pre><p>
Often, such as in some of the examples above, you wind up writing a whole
bunch of rules all preceded by the same start condition(s).  Flex makes
this a little easier and cleaner by introducing a notion of start condition
<i>scope.</i> A start condition scope is begun with: <br>
<pre>    &lt;SCs&gt;{
</pre>where <i>SCs</i> is a list of one or more start conditions.  Inside the start condition
scope, every rule automatically has the prefix <i>&lt;SCs&gt;</i> applied to it, until
a <i>&rsquo;}&rsquo;</i> which matches the initial <i>&rsquo;{&rsquo;.</i> So, for example, <br>
<pre>    &lt;ESC&gt;{
        "\\n"   return &rsquo;\n&rsquo;;
        "\\r"   return &rsquo;\r&rsquo;;
        "\\f"   return &rsquo;\f&rsquo;;
        "\\0"   return &rsquo;\0&rsquo;;
    }
</pre>is equivalent to: <br>
<pre>    &lt;ESC&gt;"\\n"  return &rsquo;\n&rsquo;;
    &lt;ESC&gt;"\\r"  return &rsquo;\r&rsquo;;
    &lt;ESC&gt;"\\f"  return &rsquo;\f&rsquo;;
    &lt;ESC&gt;"\\0"  return &rsquo;\0&rsquo;;
</pre>Start condition scopes may be nested. <p>
Three routines are available for manipulating
stacks of start conditions: 
<dl>

<dt><b>void yy_push_state(int new_state)</b> </dt>
<dd>pushes the
current start condition onto the top of the start condition stack and switches
to <i>new_state</i> as though you had used <b>BEGIN new_state</b> (recall that start
condition names are also integers). </dd>

<dt><b>void yy_pop_state()</b> </dt>
<dd>pops the top of
the stack and switches to it via <b>BEGIN.</b> </dd>

<dt><b>int yy_top_state()</b> </dt>
<dd>returns the top
of the stack without altering the stack&rsquo;s contents. </dd>
</dl>
<p>
The start condition stack
grows dynamically and so has no built-in size limitation.  If memory is exhausted,
program execution aborts. <p>
To use start condition stacks, your scanner must
include a <b>%option stack</b> directive (see Options below). 
<h2><a name='sect11' href='#toc11'>Multiple Input Buffers</a></h2>
Some
scanners (such as those which support "include" files) require reading
from several input streams.  As <i>flex</i> scanners do a large amount of buffering,
one cannot control where the next input will be read from by simply writing
a <b>YY_INPUT</b> which is sensitive to the scanning context. <b>YY_INPUT</b> is only
called when the scanner reaches the end of its buffer, which may be a long
time after scanning a statement such as an "include" which requires switching
the input source. <p>
To negotiate these sorts of problems, <i>flex</i> provides a
mechanism for creating and switching between multiple input buffers.  An
input buffer is created by using: <br>
<pre>    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
</pre>which takes a <i>FILE</i> pointer and a size and creates a buffer associated with
the given file and large enough to hold <i>size</i> characters (when in doubt,
use <b>YY_BUF_SIZE</b> for the size).  It returns a <b>YY_BUFFER_STATE</b> handle, which
may then be passed to other routines (see below).  The <b>YY_BUFFER_STATE</b> type
is a pointer to an opaque <b>struct yy_buffer_state</b> structure, so you may
safely initialize YY_BUFFER_STATE variables to <b>((YY_BUFFER_STATE) 0)</b> if
you wish, and also refer to the opaque structure in order to correctly
declare input buffers in source files other than that of your scanner. 
Note that the <i>FILE</i> pointer in the call to <b>yy_create_buffer</b> is only used
as the value of <i>yyin</i> seen by <b>YY_INPUT;</b> if you redefine <b>YY_INPUT</b> so it no
longer uses <i>yyin,</i> then you can safely pass a nil <i>FILE</i> pointer to <b>yy_create_buffer.</b>
You select a particular buffer to scan from using: <br>
<pre>    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
</pre>switches the scanner&rsquo;s input buffer so subsequent tokens will come from
<i>new_buffer.</i> Note that <b>yy_switch_to_buffer()</b> may be used by yywrap() to set
things up for continued scanning, instead of opening a new file and pointing
<i>yyin</i> at it.  Note also that switching input sources via either <b>yy_switch_to_buffer()</b>
or <b>yywrap()</b> does <i>not</i> change the start condition. <br>
<pre>    void yy_delete_buffer( YY_BUFFER_STATE buffer )
</pre>is used to reclaim the storage associated with a buffer.  ( <b>buffer</b> can be
nil, in which case the routine does nothing.) You can also clear the current
contents of a buffer using: <br>
<pre>    void yy_flush_buffer( YY_BUFFER_STATE buffer )
</pre>This function discards the buffer&rsquo;s contents, so the next time the scanner
attempts to match a token from the buffer, it will first fill the buffer
anew using <b>YY_INPUT.</b> <p>
<b>yy_new_buffer()</b> is an alias for <b>yy_create_buffer(),</b>
provided for compatibility with the C++ use of <i>new</i> and <i>delete</i> for creating
and destroying dynamic objects. <p>
Finally, the <b>YY_CURRENT_BUFFER</b> macro returns
a <b>YY_BUFFER_STATE</b> handle to the current buffer. <p>
Here is an example of using
these features for writing a scanner which expands include files (the <b>&lt;&lt;EOF&gt;&gt;</b>
feature is discussed below): <br>
<pre>    /* the "incl" state is used for picking up the name
     * of an include file
     */
    %x incl
    %{
    #define MAX_INCLUDE_DEPTH 10
    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
    int include_stack_ptr = 0;
    %}
    %%
    include             BEGIN(incl);
    [a-z]+              ECHO;
    [^a-z\n]*\n?        ECHO;
    &lt;incl&gt;[ \t]*      /* eat the whitespace */
    &lt;incl&gt;[^ \t\n]+   { /* got the include file name */
            if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH )
                {
                fprintf( stderr, "Includes nested too deeply" );
                exit( 1 );
                }
            include_stack[include_stack_ptr++] =
                YY_CURRENT_BUFFER;
            yyin = fopen( yytext, "r" );
            if ( ! yyin )
                error( ... );
            yy_switch_to_buffer(
                yy_create_buffer( yyin, YY_BUF_SIZE ) );
            BEGIN(INITIAL);
            }
    &lt;&lt;EOF&gt;&gt; {
            if ( --include_stack_ptr &lt; 0 )
                {
                yyterminate();
                }
            else
                {
                yy_delete_buffer( YY_CURRENT_BUFFER );
                yy_switch_to_buffer(
                     include_stack[include_stack_ptr] );
                }
            }
</pre>Three routines are available for setting up input buffers for scanning
in-memory strings instead of files.  All of them create a new input buffer
for scanning the string, and return a corresponding <b>YY_BUFFER_STATE</b> handle
(which you should delete with <b>yy_delete_buffer()</b> when done with it).  They
also switch to the new buffer using <b>yy_switch_to_buffer(),</b> so the next
call to <b>yylex()</b> will start scanning the string. 
<dl>

<dt><b>yy_scan_string(const char
*str)</b> </dt>
<dd>scans a NUL-terminated string. </dd>

<dt><b>yy_scan_bytes(const char *bytes, int
len)</b> </dt>
<dd>scans <i>len</i> bytes (including possibly NUL&rsquo;s) starting at location <i>bytes.</i>
</dd>
</dl>
<p>
Note that both of these functions create and scan a <i>copy</i> of the string
or bytes.  (This may be desirable, since <b>yylex()</b> modifies the contents of
the buffer it is scanning.)  You can avoid the copy by using: 
<dl>

<dt><b>yy_scan_buffer(char
*base, yy_size_t size)</b> </dt>
<dd>which scans in place the buffer starting at <i>base,</i>
consisting of <i>size</i> bytes, the last two bytes of which <i>must</i> be <b>YY_END_OF_BUFFER_CHAR</b>
(ASCII NUL). These last two bytes are not scanned; thus, scanning consists
of <b>base[0]</b> through <b>base[size-2],</b> inclusive. </dd>

<dt>If you fail to set up </dt>
<dd><i>base</i> in
this manner (i.e., forget the final two <b>YY_END_OF_BUFFER_CHAR</b> bytes), then
<b>yy_scan_buffer()</b> returns a nil pointer instead of creating a new input
buffer. </dd>

<dt>The type </dt>
<dd><b>yy_size_t</b> is an integral type to which you can cast an
integer expression reflecting the size of the buffer. </dd>
</dl>

<h2><a name='sect12' href='#toc12'>End-of-file Rules</a></h2>
The
special rule "&lt;&lt;EOF&gt;&gt;" indicates actions which are to be taken when an end-of-file
is encountered and yywrap() returns non-zero (i.e., indicates no further files
to process).  The action must finish by doing one of four things: 
<dl>

<dt>-</dt>
<dd>assigning
<i>yyin</i> to a new input file (in previous versions of flex, after doing the
assignment you had to call the special action <b>YY_NEW_FILE;</b> this is no longer
necessary); </dd>

<dt>-</dt>
<dd>executing a <i>return</i> statement; </dd>

<dt>-</dt>
<dd>executing the special <b>yyterminate()</b>
action; </dd>

<dt>-</dt>
<dd>or, switching to a new buffer using <b>yy_switch_to_buffer()</b> as shown
in the example above. </dd>
</dl>
<p>
&lt;&lt;EOF&gt;&gt; rules may not be used with other patterns; they
may only be qualified with a list of start conditions.  If an unqualified
&lt;&lt;EOF&gt;&gt; rule is given, it applies to <i>all</i> start conditions which do not already
have &lt;&lt;EOF&gt;&gt; actions.  To specify an &lt;&lt;EOF&gt;&gt; rule for only the initial start condition,
use <br>
<pre>    &lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;
</pre><p>
These rules are useful for catching things like unclosed comments. An example:
<br>
<pre>    %x quote
    %%
    ...other rules for dealing with quotes...
    &lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
             error( "unterminated quote" );
             yyterminate();
             }
    &lt;&lt;EOF&gt;&gt;  {
             if ( *++filelist )
                 yyin = fopen( *filelist, "r" );
             else
                yyterminate();
             }
</pre>
<h2><a name='sect13' href='#toc13'>Miscellaneous Macros</a></h2>
The macro <b>YY_USER_ACTION</b> can be defined to provide
an action which is always executed prior to the matched rule&rsquo;s action.  For
example, it could be #define&rsquo;d to call a routine to convert yytext to lower-case.
When <b>YY_USER_ACTION</b> is invoked, the variable <i>yy_act</i> gives the number of
the matched rule (rules are numbered starting with 1). Suppose you want
to profile how often each of your rules is matched.  The following would
do the trick: <br>
<pre>    #define YY_USER_ACTION ++ctr[yy_act]
</pre>where <i>ctr</i> is an array to hold the counts for the different rules.  Note
that the macro <b>YY_NUM_RULES</b> gives the total number of rules (including
the default rule, even if you use <b>-s),</b> so a correct declaration for <i>ctr</i>
is: <br>
<pre>    int ctr[YY_NUM_RULES];
</pre><p>
The macro <b>YY_USER_INIT</b> may be defined to provide an action which is always
executed before the first scan (and before the scanner&rsquo;s internal initializations
are done). For example, it could be used to call a routine to read in a
data table or open a logging file. <p>
The macro <b>yy_set_interactive(is_interactive)</b>
can be used to control whether the current buffer is considered <i>interactive.</i>
An interactive buffer is processed more slowly, but must be used when the
scanner&rsquo;s input source is indeed interactive to avoid problems due to waiting
to fill buffers (see the discussion of the <b>-I</b> flag below).  A non-zero value
in the macro invocation marks the buffer as interactive, a zero   value
as non-interactive.  Note that use of this macro overrides <b>%option always-interactive</b>
or <b>%option never-interactive</b> (see Options below). <b>yy_set_interactive()</b> must
be invoked prior to beginning to scan the buffer that is (or is not) to
be considered interactive. <p>
The macro <b>yy_set_bol(at_bol)</b> can be used to control
whether the current buffer&rsquo;s scanning context for the next token match is
done as though at the beginning of a line.  A non-zero macro argument makes
rules anchored with  <p>
The macro <b>YY_AT_BOL()</b> returns true if the next token
scanned from the current buffer will have &rsquo;^&rsquo; rules active, false otherwise.
<p>
In the generated scanner, the actions are all gathered in one large switch
statement and separated using <b>YY_BREAK,</b> which may be redefined.  By default,
it is simply a "break", to separate each rule&rsquo;s action from the following
rule&rsquo;s. Redefining <b>YY_BREAK</b> allows, for example, C++ users to #define YY_BREAK
to do nothing (while being very careful that every rule ends with a "break"
or a "return"!) to avoid suffering from unreachable statement warnings
where because a rule&rsquo;s action ends with "return", the <b>YY_BREAK</b> is inaccessible.

<h2><a name='sect14' href='#toc14'>Values Available to the User</a></h2>
This section summarizes the various values
available to the user in the rule actions. 
<dl>

<dt>-</dt>
<dd><b>char *yytext</b> holds the text of
the current token.  It may be modified but not lengthened (you cannot append
characters to the end). </dd>

<dt>If the special directive </dt>
<dd><b>%array</b> appears in the first
section of the scanner description, then <b>yytext</b> is instead declared <b>char
yytext[YYLMAX],</b> where <b>YYLMAX</b> is a macro definition that you can redefine
in the first section if you don&rsquo;t like the default value (generally 8KB).
 Using <b>%array</b> results in somewhat slower scanners, but the value of <b>yytext</b>
becomes immune to calls to <i>input()</i> and <i>unput(),</i> which potentially destroy
its value when <b>yytext</b> is a character pointer.  The opposite of <b>%array</b> is
<b>%pointer,</b> which is the default. </dd>

<dt>You cannot use </dt>
<dd><b>%array</b> when generating C++
scanner classes (the <b>-+</b> flag). </dd>

<dt>-</dt>
<dd><b>int yyleng</b> holds the length of the current
token. </dd>

<dt>-</dt>
<dd><b>FILE *yyin</b> is the file which by default <i>flex</i> reads from.  It may be
redefined but doing so only makes sense before scanning begins or after
an EOF has been encountered.  Changing it in the midst of scanning will
have unexpected results since <i>flex</i> buffers its input; use <b>yyrestart()</b> instead.
Once scanning terminates because an end-of-file has been seen, you can assign
<i>yyin</i> at the new input file and then call the scanner again to continue
scanning. </dd>

<dt>-</dt>
<dd><b>void yyrestart( FILE *new_file )</b> may be called to point <i>yyin</i> at
the new input file.  The switch-over to the new file is immediate (any previously
buffered-up input is lost).  Note that calling <b>yyrestart()</b> with <i>yyin</i> as an
argument thus throws away the current input buffer and continues scanning
the same input file. </dd>

<dt>-</dt>
<dd><b>FILE *yyout</b> is the file to which <b>ECHO</b> actions are done.
 It can be reassigned by the user. </dd>

<dt>-</dt>
<dd><b>YY_CURRENT_BUFFER</b> returns a <b>YY_BUFFER_STATE</b>
handle to the current buffer. </dd>

<dt>-</dt>
<dd><b>YY_START</b> returns an integer value corresponding
to the current start condition.  You can subsequently use this value with
<b>BEGIN</b> to return to that start condition. </dd>
</dl>

<h2><a name='sect15' href='#toc15'>Interfacing with Yacc</a></h2>
One of the
main uses of <i>flex</i> is as a companion to the <i>yacc</i> parser-generator. <i>yacc</i> parsers
expect to call a routine named <b>yylex()</b> to find the next input token.  The
routine is supposed to return the type of the next token as well as putting
any associated value in the global <b>yylval.</b> To use <i>flex</i> with <i>yacc,</i> one specifies
the <b>-d</b> option to <i>yacc</i> to instruct it to generate the file <b>y.tab.h</b> containing
definitions of all the <b>%tokens</b> appearing in the <i>yacc</i> input.  This file is
then included in the <i>flex</i> scanner.  For example, if one of the tokens is
"TOK_NUMBER", part of the scanner might look like: <br>
<pre>    %{
    #include "y.tab.h"
    %}
    %%
    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;
</pre>
<h2><a name='sect16' href='#toc16'>Options</a></h2>
<i>flex</i> has the following options: 
<dl>

<dt><b>-b</b> </dt>
<dd>Generate backing-up information
to <i>lex.backup.</i> This is a list of scanner states which require backing up
and the input characters on which they do so.  By adding rules one can remove
backing-up states.  If <i>all</i> backing-up states are eliminated and <b>-Cf</b> or <b>-CF</b> is
used, the generated scanner will run faster (see the <b>-p</b> flag).  Only users
who wish to squeeze every last cycle out of their scanners need worry about
this option.  (See the section on Performance Considerations below.) </dd>

<dt><b>-c</b> </dt>
<dd>is
a do-nothing, deprecated option included for POSIX compliance. </dd>

<dt><b>-d</b> </dt>
<dd>makes the
generated scanner run in <i>debug</i> mode.  Whenever a pattern is recognized and
the global <b>yy_flex_debug</b> is non-zero (which is the default), the scanner
will write to <i>stderr</i> a line of the form: <br>
<pre>    --accepting rule at line 53 ("the matched text")
</pre>The line number refers to the location of the rule in the file defining
the scanner (i.e., the file that was fed to flex).  Messages are also generated
when the scanner backs up, accepts the default rule, reaches the end of
its input buffer (or encounters a NUL; at this point, the two look the
same as far as the scanner&rsquo;s concerned), or reaches an end-of-file. </dd>

<dt><b>-f</b> </dt>
<dd>specifies
<i>fast</i> scanner. No table compression is done and stdio is bypassed. The result
is large but fast.  This option is equivalent to <b>-Cfr</b> (see below). </dd>

<dt><b>-h</b> </dt>
<dd>generates
a "help" summary of <i>flex&rsquo;s</i> options to <i>stdout</i>  and then exits. <b>-?</b> and <b>--help</b>
are synonyms for <b>-h.</b> </dd>

<dt><b>-i</b> </dt>
<dd>instructs <i>flex</i> to generate a <i>case-insensitive</i> scanner.
 The case of letters given in the <i>flex</i> input patterns will be ignored,
and tokens in the input will be matched regardless of case.  The matched
text given in <i>yytext</i> will have the preserved case (i.e., it will not be folded).
</dd>

<dt><b>-l</b> </dt>
<dd>turns on maximum compatibility with the original AT&amp;T <i>lex</i> implementation.
 Note that this does not mean <i>full</i> compatibility.  Use of this option costs
a considerable amount of performance, and it cannot be used with the <b>-+,
-f, -F, -Cf,</b> or <b>-CF</b> options.  For details on the compatibilities it provides,
see the section "Incompatibilities With Lex And POSIX" below.  This option
also results in the name <b>YY_FLEX_LEX_COMPAT</b> being #define&rsquo;d in the generated
scanner. </dd>

<dt><b>-n</b> </dt>
<dd>is another do-nothing, deprecated option included only for POSIX
compliance. </dd>

<dt><b>-p</b> </dt>
<dd>generates a performance report to stderr.  The report consists
of comments regarding features of the <i>flex</i> input file which will cause
a serious loss of performance in the resulting scanner.  If you give the
flag twice, you will also get comments regarding features that lead to
minor performance losses. </dd>

<dt>Note that the use of </dt>
<dd><b>REJECT,</b> <b>%option yylineno,</b>
and variable trailing context (see the Deficiencies / Bugs section below)
entails a substantial performance penalty; use of <i>yymore(),</i> the <b>^</b> operator,
and the <b>-I</b> flag entail minor performance penalties. </dd>

<dt><b>-s</b> </dt>
<dd>causes the <i>default</i>
rule (that unmatched scanner input is echoed to <i>stdout)</i> to be suppressed.
 If the scanner encounters input that does not match any of its rules,
it aborts with an error.  This option is useful for finding holes in a scanner&rsquo;s
rule set. </dd>

<dt><b>-t</b> </dt>
<dd>instructs <i>flex</i> to write the scanner it generates to standard
output instead of <b>lex.yy.c.</b> </dd>

<dt><b>-v</b> </dt>
<dd>specifies that <i>flex</i> should write to <i>stderr</i> a
summary of statistics regarding the scanner it generates. Most of the statistics
are meaningless to the casual <i>flex</i> user, but the first line identifies
the version of <i>flex</i> (same as reported by <b>-V),</b> and the next line the flags
used when generating the scanner, including those that are on by default.
</dd>

<dt><b>-w</b> </dt>
<dd>suppresses warning messages. </dd>

<dt><b>-B</b> </dt>
<dd>instructs <i>flex</i> to generate a <i>batch</i> scanner,
the opposite of <i>interactive</i> scanners generated by <b>-I</b> (see below).  In general,
you use <b>-B</b> when you are <i>certain</i> that your scanner will never be used interactively,
and you want to squeeze a <i>little</i> more performance out of it.  If your goal
is instead to squeeze out a <i>lot</i> more performance, you should  be using
the <b>-Cf</b> or <b>-CF</b> options (discussed below), which turn on <b>-B</b> automatically anyway.
</dd>

<dt><b>-F</b> </dt>
<dd>specifies that the  fast scanner table representation should be used
(and stdio bypassed).  This representation is about as fast as the full
table representation <b>(-f),</b> and for some sets of patterns will be considerably
smaller (and for others, larger).  In general, if the pattern set contains
both "keywords" and a catch-all, "identifier" rule, such as in the set:
<br>
<pre>    "case"    return TOK_CASE;
    "switch"  return TOK_SWITCH;
    ...
    "default" return TOK_DEFAULT;
    [a-z]+    return TOK_ID;
</pre>then you&rsquo;re better off using the full table representation.  If only the
"identifier" rule is present and you then use a hash table or some such
to detect the keywords, you&rsquo;re better off using <b>-F.</b> </dd>

<dt>This option is equivalent
to </dt>
<dd><b>-CFr</b> (see below).  It cannot be used with <b>-+.</b> </dd>

<dt><b>-I</b> </dt>
<dd>instructs <i>flex</i> to generate
an <i>interactive</i> scanner.  An interactive scanner is one that only looks ahead
to decide what token has been matched if it absolutely must.  It turns out
that always looking one extra character ahead, even if the scanner has
already seen enough text to disambiguate the current token, is a bit faster
than only looking ahead when necessary.  But scanners that always look ahead
give dreadful interactive performance; for example, when a user types a
newline, it is not recognized as a newline token until they enter <i>another</i>
token, which often means typing in another whole line. </dd>

<dt><i>Flex</i> </dt>
<dd>scanners default
to <i>interactive</i> unless you use the <b>-Cf</b> or <b>-CF</b> table-compression options (see
below).  That&rsquo;s because if you&rsquo;re looking for high-performance you should be
using one of these options, so if you didn&rsquo;t, <i>flex</i> assumes you&rsquo;d rather trade
off a bit of run-time performance for intuitive interactive behavior.  Note
also that you <i>cannot</i> use <b>-I</b> in conjunction with <b>-Cf</b> or <b>-CF.</b> Thus, this option
is not really needed; it is on by default for all those cases in which
it is allowed. </dd>

<dt>You can force a scanner to </dt>
<dd><i>not</i> be interactive by using <b>-B</b>
(see above). </dd>

<dt><b>-L</b> </dt>
<dd>instructs <i>flex</i> not to generate <b>#line</b> directives.  Without
this option, <i>flex</i> peppers the generated scanner with #line directives so
error messages in the actions will be correctly located with respect to
either the original <i>flex</i> input file (if the errors are due to code in the
input file), or <b>lex.yy.c</b> (if the errors are <i>flex&rsquo;s</i> fault -- you should report
these sorts of errors to the email address given below). </dd>

<dt><b>-T</b> </dt>
<dd>makes <i>flex</i> run
in <i>trace</i> mode.  It will generate a lot of messages to <i>stderr</i> concerning
the form of the input and the resultant non-deterministic and deterministic
finite automata.  This option is mostly for use in maintaining <i>flex.</i> </dd>

<dt><b>-V</b> </dt>
<dd>prints
the version number to <i>stdout</i> and exits. <b>--version</b> is a synonym for <b>-V.</b> </dd>

<dt><b>-7</b> </dt>
<dd>instructs
<i>flex</i> to generate a 7-bit scanner, i.e., one which can only recognized 7-bit
characters in its input.  The advantage of using <b>-7</b> is that the scanner&rsquo;s
tables can be up to half the size of those generated using the <b>-8</b> option
(see below).  The disadvantage is that such scanners often hang or crash
if their input contains an 8-bit character. </dd>

<dt>Note, however, that unless you
generate your scanner using the </dt>
<dd><b>-Cf</b> or <b>-CF</b> table compression options, use
of <b>-7</b> will save only a small amount of table space, and make your scanner
considerably less portable. <i>Flex&rsquo;s</i> default behavior is to generate an 8-bit
scanner unless you use the <b>-Cf</b> or <b>-CF,</b> in which case <i>flex</i> defaults to generating
7-bit scanners unless your site was always configured to generate 8-bit scanners
(as will often be the case with non-USA sites).  You can tell whether flex
generated a 7-bit or an 8-bit scanner by inspecting the flag summary in the
<b>-v</b> output as described above. </dd>

<dt>Note that if you use </dt>
<dd><b>-Cfe</b> or <b>-CFe</b> (those table
compression options, but also using equivalence classes as discussed see
below), flex still defaults to generating an 8-bit scanner, since usually
with these compression options full 8-bit tables are not much more expensive
than 7-bit tables. </dd>

<dt><b>-8</b> </dt>
<dd>instructs <i>flex</i> to generate an 8-bit scanner, i.e., one
which can recognize 8-bit characters.  This flag is only needed for scanners
generated using <b>-Cf</b> or <b>-CF,</b> as otherwise flex defaults to generating an 8-bit
scanner anyway. </dd>

<dt>See the discussion of </dt>
<dd><b>-7</b> above for flex&rsquo;s default behavior
and the tradeoffs between 7-bit and 8-bit scanners. </dd>

<dt><b>-+</b> </dt>
<dd>specifies that you want
flex to generate a C++ scanner class.  See the section on Generating C++
Scanners below for details. </dd>

<dt><b>-C[aefFmr]</b> </dt>
<dd>controls the degree of table compression
and, more generally, trade-offs between small scanners and fast scanners.
</dd>

<dt><b>-Ca</b> </dt>
<dd>("align") instructs flex to trade off larger tables in the generated
scanner for faster performance because the elements of the tables are better
aligned for memory access and computation.  On some RISC architectures,
fetching and manipulating longwords is more efficient than with smaller-sized
units such as shortwords.  This option can double the size of the tables
used by your scanner. </dd>

<dt><b>-Ce</b> </dt>
<dd>directs <i>flex</i> to construct <i>equivalence</i> classes,
i.e., sets of characters which have identical lexical properties (for example,
if the only appearance of digits in the <i>flex</i> input is in the character
class "[0-9]" then the digits &rsquo;0&rsquo;, &rsquo;1&rsquo;, ..., &rsquo;9&rsquo; will all be put in the same equivalence
class).  Equivalence classes usually give dramatic reductions in the final
table/object file sizes (typically a factor of 2-5) and are pretty cheap
performance-wise (one array look-up per character scanned). </dd>

<dt><b>-Cf</b> </dt>
<dd>specifies that
the <i>full</i> scanner tables should be generated - <i>flex</i> should not compress the
tables by taking advantages of similar transition functions for different
states. </dd>

<dt><b>-CF</b> </dt>
<dd>specifies that the alternate fast scanner representation (described
above under the <b>-F</b> flag) should be used.  This option cannot be used with
<b>-+.</b> </dd>

<dt><b>-Cm</b> </dt>
<dd>directs <i>flex</i> to construct <i>meta-equivalence</i> classes, which are sets
of equivalence classes (or characters, if equivalence classes are not being
used) that are commonly used together.  Meta-equivalence classes are often
a big win when using compressed tables, but they have a moderate performance
impact (one or two "if" tests and one array look-up per character scanned).
</dd>

<dt><b>-Cr</b> </dt>
<dd>causes the generated scanner to <i>bypass</i> use of the standard I/O library
(stdio) for input.  Instead of calling <b>fread()</b> or <b>getc(),</b> the scanner will
use the <b>read()</b> system call, resulting in a performance gain which varies
from system to system, but in general is probably negligible unless you
are also using <b>-Cf</b> or <b>-CF.</b> Using <b>-Cr</b> can cause strange behavior if, for example,
you read from <i>yyin</i> using stdio prior to calling the scanner (because the
scanner will miss whatever text your previous reads left in the stdio input
buffer). </dd>

<dt><b>-Cr</b> </dt>
<dd>has no effect if you define <b>YY_INPUT</b> (see The Generated Scanner
above). </dd>

<dt>A lone </dt>
<dd><b>-C</b> specifies that the scanner tables should be compressed
but neither equivalence classes nor meta-equivalence classes should be used.
</dd>

<dt>The options </dt>
<dd><b>-Cf</b> or <b>-CF</b> and <b>-Cm</b> do not make sense together - there is no opportunity
for meta-equivalence classes if the table is not being compressed.  Otherwise
the options may be freely mixed, and are cumulative. </dd>

<dt>The default setting
is </dt>
<dd><b>-Cem,</b> which specifies that <i>flex</i> should generate equivalence classes and
meta-equivalence classes.  This setting provides the highest degree of table
compression.  You can trade off faster-executing scanners at the cost of
larger tables with the following generally being true: <br>
<pre>    slowest &amp; smallest
          -Cem
          -Cm
          -Ce
          -C
          -C{f,F}e
          -C{f,F}
          -C{f,F}a
    fastest &amp; largest
</pre>Note that scanners with the smallest tables are usually generated and compiled
the quickest, so during development you will usually want to use the default,
maximal compression. </dd>

<dt><b>-Cfe</b> </dt>
<dd>is often a good compromise between speed and size
for production scanners. </dd>

<dt><b>-ooutput</b> </dt>
<dd>directs flex to write the scanner to the
file <b>output</b> instead of <b>lex.yy.c.</b> If you combine <b>-o</b> with the <b>-t</b> option, then
the scanner is written to <i>stdout</i> but its <b>#line</b> directives (see the <b>\-L</b> option
above) refer to the file <b>output.</b> </dd>

<dt><b>-Pprefix</b> </dt>
<dd>changes the default <i>yy</i> prefix used
by <i>flex</i> for all globally-visible variable and function names to instead
be <i>prefix.</i> For example, <b>-Pfoo</b> changes the name of <b>yytext</b> to <b>footext.</b> It also
changes the name of the default output file from <b>lex.yy.c</b> to <b>lex.foo.c.</b> Here
are all of the names affected: <br>
<pre>    yy_create_buffer
    yy_delete_buffer
    yy_flex_debug
    yy_init_buffer
    yy_flush_buffer
    yy_load_buffer_state
    yy_switch_to_buffer
    yyin
    yyleng
    yylex
    yylineno
    yyout
    yyrestart
    yytext
    yywrap
</pre>(If you are using a C++ scanner, then only <b>yywrap</b> and <b>yyFlexLexer</b> are affected.)
Within your scanner itself, you can still refer to the global variables
and functions using either version of their name; but externally, they
have the modified name. </dd>

<dt>This option lets you easily link together multiple
</dt>
<dd><i>flex</i> programs into the same executable.  Note, though, that using this option
also renames <b>yywrap(),</b> so you now <i>must</i> either provide your own (appropriately-named)
version of the routine for your scanner, or use <b>%option noyywrap,</b> as linking
with <b>-lfl</b> no longer provides one for you by default. </dd>

<dt><b>-Sskeleton_file</b> </dt>
<dd>overrides
the default skeleton file from which <i>flex</i> constructs its scanners.  You&rsquo;ll
never need this option unless you are doing <i>flex</i> maintenance or development.
</dd>
</dl>
<p>
<i>flex</i> also provides a mechanism for controlling options within the scanner
specification itself, rather than from the flex command-line. This is done
by including <b>%option</b> directives in the first section of the scanner specification.
You can specify multiple options with a single <b>%option</b> directive, and multiple
directives in the first section of your flex input file. <p>
Most options are
given simply as names, optionally preceded by the word "no" (with no intervening
whitespace) to negate their meaning. A number are equivalent to flex flags
or their negation: <br>
<pre>    7bit            -7 option
    8bit            -8 option
    align           -Ca option
    backup          -b option
    batch           -B option
    c++             -+ option
    caseful or
    case-sensitive  opposite of -i (default)
    case-insensitive or
    caseless        -i option
    debug           -d option
    default         opposite of -s option
    ecs             -Ce option
    fast            -F option
    full            -f option
    interactive     -I option
    lex-compat      -l option
    meta-ecs        -Cm option
    perf-report     -p option
    read            -Cr option
    stdout          -t option
    verbose         -v option
    warn            opposite of -w option
                    (use "%option nowarn" for -w)
    array           equivalent to "%array"
    pointer         equivalent to "%pointer" (default)
</pre>Some <b>%option&rsquo;s</b> provide features otherwise not available: 
<dl>

<dt><b>always-interactive</b>
</dt>
<dd>instructs flex to generate a scanner which always considers its input "interactive".
 Normally, on each new input file the scanner calls <b>isatty()</b> in an attempt
to determine whether the scanner&rsquo;s input source is interactive and thus
should be read a character at a time.  When this option is used, however,
then no such call is made. </dd>

<dt><b>main</b> </dt>
<dd>directs flex to provide a default <b>main()</b>
program for the scanner, which simply calls <b>yylex().</b> This option implies
<b>noyywrap</b> (see below). </dd>

<dt><b>never-interactive</b> </dt>
<dd>instructs flex to generate a scanner
which never considers its input "interactive" (again, no call made to <b>isatty()).</b>
This is the opposite of <b>always-interactive.</b> </dd>

<dt><b>stack</b> </dt>
<dd>enables the use of start
condition stacks (see Start Conditions above). </dd>

<dt><b>stdinit</b> </dt>
<dd>if set (i.e., <b>%option
stdinit)</b> initializes <i>yyin</i> and <i>yyout</i> to <i>stdin</i> and <i>stdout,</i> instead of the
default of <i>nil.</i> Some existing <i>lex</i> programs depend on this behavior, even
though it is not compliant with ANSI C, which does not require <i>stdin</i> and
<i>stdout</i> to be compile-time constant. </dd>

<dt><b>yylineno</b> </dt>
<dd>directs <i>flex</i> to generate a scanner
that maintains the number of the current line read from its input in the
global variable <b>yylineno.</b> This option is implied by <b>%option lex-compat.</b> </dd>

<dt><b>yywrap</b>
</dt>
<dd>if unset (i.e., <b>%option noyywrap),</b> makes the scanner not call <b>yywrap()</b> upon
an end-of-file, but simply assume that there are no more files to scan (until
the user points <i>yyin</i> at a new file and calls <b>yylex()</b> again). </dd>
</dl>
<p>
<i>flex</i> scans
your rule actions to determine whether you use the <b>REJECT</b> or <b>yymore()</b> features.
 The <b>reject</b> and <b>yymore</b> options are available to override its decision as
to whether you use the options, either by setting them (e.g., <b>%option reject)</b>
to indicate the feature is indeed used, or unsetting them to indicate it
actually is not used (e.g., <b>%option noyymore).</b> <p>
Three options take string-delimited
values, offset with &rsquo;=&rsquo;: <br>
<pre>    %option outfile="ABC"
</pre>is equivalent to <b>-oABC,</b> and <br>
<pre>    %option prefix="XYZ"
</pre>is equivalent to <b>-PXYZ.</b> Finally, <br>
<pre>    %option yyclass="foo"
</pre>only applies when generating a C++ scanner ( <b>-+</b> option).  It informs <i>flex</i>
that you have derived <b>foo</b> as a subclass of <b>yyFlexLexer,</b> so <i>flex</i> will place
your actions in the member function <b>foo::yylex()</b> instead of <b>yyFlexLexer::yylex().</b>
It also generates a <b>yyFlexLexer::yylex()</b> member function that emits a run-time
error (by invoking <b>yyFlexLexer::LexerError())</b> if called. See Generating
C++ Scanners, below, for additional information. <p>
A number of options are
available for lint purists who want to suppress the appearance of unneeded
routines in the generated scanner.  Each of the following, if unset (e.g.,
<b>%option nounput</b> ), results in the corresponding routine not appearing in
the generated scanner: <br>
<pre>    input, unput
    yy_push_state, yy_pop_state, yy_top_state
    yy_scan_buffer, yy_scan_bytes, yy_scan_string
</pre>(though <b>yy_push_state()</b> and friends won&rsquo;t appear anyway unless you use <b>%option
stack).</b> 
<h2><a name='sect17' href='#toc17'>Performance Considerations</a></h2>
The main design goal of <i>flex</i> is that it
generate high-performance scanners.  It has been optimized for dealing well
with large sets of rules.  Aside from the effects on scanner speed of the
table compression <b>-C</b> options outlined above, there are a number of options/actions
which degrade performance.  These are, from most expensive to least: <br>
<pre>    REJECT
    %option yylineno
    arbitrary trailing context
    pattern sets that require backing up
    %array
    %option interactive
    %option always-interactive
    &rsquo;^&rsquo; beginning-of-line operator
    yymore()
</pre>with the first three all being quite expensive and the last two being quite
cheap.  Note also that <b>unput()</b> is implemented as a routine call that potentially
does quite a bit of work, while <b>yyless()</b> is a quite-cheap macro; so if just
putting back some excess text you scanned, use <b>yyless().</b> <p>
<b>REJECT</b> should be
avoided at all costs when performance is important. It is a particularly
expensive option. <p>
Getting rid of backing up is messy and often may be an
enormous amount of work for a complicated scanner.  In principal, one begins
by using the <b>-b </b> flag to generate a <i>lex.backup</i> file.  For example, on the
input <br>
<pre>    %%
    foo        return TOK_KEYWORD;
    foobar     return TOK_KEYWORD;
</pre>the file looks like: <br>
<pre>    State #6 is non-accepting -
     associated rule line numbers:
           2       3
     out-transitions: [ o ]
     jam-transitions: EOF [ \001-n  p-\177 ]
    State #8 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ a ]
     jam-transitions: EOF [ \001-&lsquo;  b-\177 ]
    State #9 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ r ]
     jam-transitions: EOF [ \001-q  s-\177 ]
    Compressed tables always back up.
</pre>The first few lines tell us that there&rsquo;s a scanner state in which it can
make a transition on an &rsquo;o&rsquo; but not on any other character, and that in that
state the currently scanned text does not match any rule.  The state occurs
when trying to match the rules found at lines 2 and 3 in the input file.
If the scanner is in that state and then reads something other than an
&rsquo;o&rsquo;, it will have to back up to find a rule which is matched.  With a bit
of headscratching one can see that this must be the state it&rsquo;s in when it
has seen "fo".  When this has happened, if anything other than another &rsquo;o&rsquo;
is seen, the scanner will have to back up to simply match the &rsquo;f&rsquo; (by the
default rule). <p>
The comment regarding State #8 indicates there&rsquo;s a problem
when "foob" has been scanned.  Indeed, on any character other than an &rsquo;a&rsquo;,
the scanner will have to back up to accept "foo". Similarly, the comment
for State #9 concerns when "fooba" has been scanned and an &rsquo;r&rsquo; does not follow.
<p>
The final comment reminds us that there&rsquo;s no point going to all the trouble
of removing backing up from the rules unless we&rsquo;re using <b>-Cf</b> or <b>-CF,</b> since
there&rsquo;s no performance gain doing so with compressed scanners. <p>
The way to
remove the backing up is to add "error" rules: <br>
<pre>    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;
    fooba       |
    foob        |
    fo          {
                /* false alarm, not really a keyword */
                return TOK_ID;
                }
</pre><p>
Eliminating backing up among a list of keywords can also be done using
a "catch-all" rule: <br>
<pre>    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;
    [a-z]+      return TOK_ID;
</pre>This is usually the best solution when appropriate. <p>
Backing up messages
tend to cascade. With a complicated set of rules it&rsquo;s not uncommon to get
hundreds of messages.  If one can decipher them, though, it often only takes
a dozen or so rules to eliminate the backing up (though it&rsquo;s easy to make
a mistake and have an error rule accidentally match a valid token.  A possible
future <i>flex</i> feature will be to automatically add rules to eliminate backing
up). <p>
It&rsquo;s important to keep in mind that you gain the benefits of eliminating
backing up only if you eliminate <i>every</i> instance of backing up.  Leaving
just one means you gain nothing. <p>
<i>Variable</i> trailing context (where both the
leading and trailing parts do not have a fixed length) entails almost the
same performance loss as <b>REJECT</b> (i.e., substantial).  So when possible a rule
like: <br>
<pre>    %%
    mouse|rat/(cat|dog)   run();
</pre>is better written: <br>
<pre>    %%
    mouse/cat|dog         run();
    rat/cat|dog           run();
</pre>or as <br>
<pre>    %%
    mouse|rat/cat         run();
    mouse|rat/dog         run();
</pre>Note that here the special &rsquo;|&rsquo; action does <i>not</i> provide any savings, and can
even make things worse (see Deficiencies / Bugs below). <p>
Another area where
the user can increase a scanner&rsquo;s performance (and one that&rsquo;s easier to implement)
arises from the fact that the longer the tokens matched, the faster the
scanner will run. This is because with long tokens the processing of most
input characters takes place in the (short) inner scanning loop, and does
not often have to go through the additional work of setting up the scanning
environment (e.g., <b>yytext)</b> for the action.  Recall the scanner for C comments:
<br>
<pre>    %x comment
    %%
            int line_num = 1;
    "/*"         BEGIN(comment);
    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;"*"+[^*/\n]*
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</pre>This could be sped up by writing it as: <br>
<pre>    %x comment
    %%
            int line_num = 1;
    "/*"         BEGIN(comment);
    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;[^*\n]*\n      ++line_num;
    &lt;comment&gt;"*"+[^*/\n]*
    &lt;comment&gt;"*"+[^*/\n]*\n ++line_num;
    &lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</pre>Now instead of each newline requiring the processing of another action,
recognizing the newlines is "distributed" over the other rules to keep
the matched text as long as possible.  Note that <i>adding</i> rules does <i>not</i> slow
down the scanner!  The speed of the scanner is independent of the number
of rules or (modulo the considerations given at the beginning of this section)
how complicated the rules are with regard to operators such as &rsquo;*&rsquo; and &rsquo;|&rsquo;. <p>
A
final example in speeding up a scanner: suppose you want to scan through
a file containing identifiers and keywords, one per line and with no other
extraneous characters, and recognize all the keywords.  A natural first
approach is: <br>
<pre>    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it&rsquo;s a keyword */
    .|\n     /* it&rsquo;s not a keyword */
</pre>To eliminate the back-tracking, introduce a catch-all rule: <br>
<pre>    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it&rsquo;s a keyword */
    [a-z]+   |
    .|\n     /* it&rsquo;s not a keyword */
</pre>Now, if it&rsquo;s guaranteed that there&rsquo;s exactly one word per line, then we can
reduce the total number of matches by a half by merging in the recognition
of newlines with that of the other tokens: <br>
<pre>    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it&rsquo;s a keyword */
    [a-z]+\n |
    .|\n     /* it&rsquo;s not a keyword */
</pre>One has to be careful here, as we have now reintroduced backing up into
the scanner.  In particular, while <i>we</i> know that there will never be any
characters in the input stream other than letters or newlines, <i>flex</i> can&rsquo;t
figure this out, and it will plan for possibly needing to back up when
it has scanned a token like "auto" and then the next character is something
other than a newline or a letter.  Previously it would then just match the
"auto" rule and be done, but now it has no "auto" rule, only a "auto\n"
rule.  To eliminate the possibility of backing up, we could either duplicate
all rules but without final newlines, or, since we never expect to encounter
such an input and therefore don&rsquo;t how it&rsquo;s classified, we can introduce one
more catch-all rule, this one which doesn&rsquo;t include a newline: <br>
<pre>    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it&rsquo;s a keyword */
    [a-z]+\n |
    [a-z]+   |
    .|\n     /* it&rsquo;s not a keyword */
</pre>Compiled with <b>-Cf,</b> this is about as fast as one can get a <i>flex</i>  scanner
to go for this particular problem. <p>
A final note: <i>flex</i> is slow when matching
NUL&rsquo;s, particularly when a token contains multiple NUL&rsquo;s. It&rsquo;s best to write
rules which match <i>short</i> amounts of text if it&rsquo;s anticipated that the text
will often include NUL&rsquo;s. <p>
Another final note regarding performance: as mentioned
above in the section How the Input is Matched, dynamically resizing <b>yytext</b>
to accommodate huge tokens is a slow process because it presently requires
that the (huge) token be rescanned from the beginning.  Thus if performance
is vital, you should attempt to match "large" quantities of text but not
"huge" quantities, where the cutoff between the two is at about 8K characters/token.

<h2><a name='sect18' href='#toc18'>Generating C++ Scanners</a></h2>
<i>flex</i> provides two different ways to generate scanners
for use with C++.  The first way is to simply compile a scanner generated
by <i>flex</i> using a C++ compiler instead of a C compiler.  You should not encounter
any compilations errors (please report any you find to the email address
given in the Author section below).  You can then use C++ code in your rule
actions instead of C code.  Note that the default input source for your
scanner remains <i>yyin,</i> and default echoing is still done to <i>yyout.</i> Both of
these remain <i>FILE</i> * variables and not C++ <i>streams.</i> <p>
You can also use <i>flex</i>
to generate a C++ scanner class, using the <b>-+</b> option (or, equivalently,
<b>%option c++),</b> which is automatically specified if the name of the flex
executable ends in a &rsquo;+&rsquo;, such as <i>flex++.</i> When using this option, flex defaults
to generating the scanner to the file <b>lex.yy.cc</b> instead of <b>lex.yy.c.</b> The generated
scanner includes the header file <i>FlexLexer.h,</i> which defines the interface
to two C++ classes. <p>
The first class, <b>FlexLexer,</b> provides an abstract base
class defining the general scanner class interface.  It provides the following
member functions: 
<dl>

<dt><b>const char* YYText()</b> </dt>
<dd>returns the text of the most recently
matched token, the equivalent of <b>yytext.</b> </dd>

<dt><b>int YYLeng()</b> </dt>
<dd>returns the length
of the most recently matched token, the equivalent of <b>yyleng.</b> </dd>

<dt><b>int lineno()
const</b> </dt>
<dd>returns the current input line number (see <b>%option yylineno),</b> or
<b>1</b> if <b>%option yylineno</b> was not used. </dd>

<dt><b>void set_debug( int flag )</b> </dt>
<dd>sets the
debugging flag for the scanner, equivalent to assigning to <b>yy_flex_debug</b>
(see the Options section above).  Note that you must build the scanner using
<b>%option debug</b> to include debugging information in it. </dd>

<dt><b>int debug() const</b>
</dt>
<dd>returns the current setting of the debugging flag. </dd>
</dl>
<p>
Also provided are member
functions equivalent to <b>yy_switch_to_buffer(),</b> <b>yy_create_buffer()</b> (though
the first argument is an <b>istream*</b> object pointer and not a <b>FILE*),</b> <b>yy_flush_buffer(),</b>
<b>yy_delete_buffer(),</b> and <b>yyrestart()</b> (again, the first argument is a <b>istream*</b>
object pointer). <p>
The second class defined in <i>FlexLexer.h</i> is <b>yyFlexLexer,</b>
which is derived from <b>FlexLexer.</b> It defines the following additional member
functions: 
<dl>

<dt><b></b> yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0
) </dt>
<dd>constructs a <b>yyFlexLexer</b> object using the given streams for input and
output.  If not specified, the streams default to <b>cin</b> and <b>cout,</b> respectively.
</dd>

<dt><b>virtual int yylex()</b> </dt>
<dd>performs the same role is <b>yylex()</b> does for ordinary
flex scanners: it scans the input stream, consuming tokens, until a rule&rsquo;s
action returns a value.  If you derive a subclass <b>S</b> from <b>yyFlexLexer</b> and
want to access the member functions and variables of <b>S</b> inside <b>yylex(),</b>
then you need to use <b>%option yyclass="S"</b> to inform <i>flex</i> that you will be
using that subclass instead of <b>yyFlexLexer.</b> In this case, rather than generating
<b>yyFlexLexer::yylex(),</b> <i>flex</i> generates <b>S::yylex()</b> (and also generates a dummy
<b>yyFlexLexer::yylex()</b> that calls <b>yyFlexLexer::LexerError()</b> if called). </dd>

<dt><b></b> virtual
void switch_streams(istream* new_in = 0, </dt>
<dd><b></b> ostream* new_out = 0) reassigns
<b>yyin</b> to <b>new_in</b> (if non-nil) and <b>yyout</b> to <b>new_out</b> (ditto), deleting the previous
input buffer if <b>yyin</b> is reassigned. </dd>

<dt><b></b> int yylex( istream* new_in, ostream*
new_out = 0 ) </dt>
<dd>first switches the input streams via <b>switch_streams( new_in,
new_out )</b> and then returns the value of <b>yylex().</b> </dd>
</dl>
<p>
In addition, <b>yyFlexLexer</b>
defines the following protected virtual functions which you can redefine
in derived classes to tailor the scanner: 
<dl>

<dt><b></b> virtual int LexerInput( char*
buf, int max_size ) </dt>
<dd>reads up to <b>max_size</b> characters into <b>buf</b> and returns
the number of characters read.  To indicate end-of-input, return 0 characters.
 Note that "interactive" scanners (see the <b>-B</b> and <b>-I</b> flags) define the macro
<b>YY_INTERACTIVE.</b> If you redefine <b>LexerInput()</b> and need to take different
actions depending on whether or not the scanner might be scanning an interactive
input source, you can test for the presence of this name via <b>#ifdef.</b> </dd>

<dt><b></b> virtual
void LexerOutput( const char* buf, int size ) </dt>
<dd>writes out <b>size</b> characters
from the buffer <b>buf,</b> which, while NUL-terminated, may also contain "internal"
NUL&rsquo;s if the scanner&rsquo;s rules can match text with NUL&rsquo;s in them. </dd>

<dt><b></b> virtual void
LexerError( const char* msg ) </dt>
<dd>reports a fatal error message.  The default
version of this function writes the message to the stream <b>cerr</b> and exits.
</dd>
</dl>
<p>
Note that a <b>yyFlexLexer</b> object contains its <i>entire</i> scanning state.  Thus
you can use such objects to create reentrant scanners.  You can instantiate
multiple instances of the same <b>yyFlexLexer</b> class, and you can also combine
multiple C++ scanner classes together in the same program using the <b>-P</b> option
discussed above. <p>
Finally, note that the <b>%array</b> feature is not available
to C++ scanner classes; you must use <b>%pointer</b> (the default). <p>
Here is an
example of a simple C++ scanner: <br>
<pre>        // An example of using the flex C++ scanner class.
    %{
    int mylineno = 0;
    %}
    string  \"[^\n"]+\"
    ws      [ \t]+
    alpha   [A-Za-z]
    dig     [0-9]
    name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
    num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
    num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
    number  {num1}|{num2}
    %%
    {ws}    /* skip blanks and tabs */
    "/*"    {
            int c;
            while((c = yyinput()) != 0)
                {
                if(c == &rsquo;\n&rsquo;)
                    ++mylineno;
                else if(c == &rsquo;*&rsquo;)
                    {
                    if((c = yyinput()) == &rsquo;/&rsquo;)
                        break;
                    else
                        unput(c);
                    }
                }
            }
    {number}  cout &lt;&lt; "number " &lt;&lt; YYText() &lt;&lt; &rsquo;\n&rsquo;;
    \n        mylineno++;
    {name}    cout &lt;&lt; "name " &lt;&lt; YYText() &lt;&lt; &rsquo;\n&rsquo;;
    {string}  cout &lt;&lt; "string " &lt;&lt; YYText() &lt;&lt; &rsquo;\n&rsquo;;
    %%
    int main( int /* argc */, char** /* argv */ )
        {
        FlexLexer* lexer = new yyFlexLexer;
        while(lexer-&gt;yylex() != 0)
            ;
        return 0;
        }
</pre>If you want to create multiple (different) lexer classes, you use the <b>-P</b>
flag (or the <b>prefix=</b> option) to rename each <b>yyFlexLexer</b> to some other <b>xxFlexLexer.</b>
You then can include <b>&lt;FlexLexer.h&gt;</b> in your other sources once per lexer class,
first renaming <b>yyFlexLexer</b> as follows: <br>
<pre>    #undef yyFlexLexer
    #define yyFlexLexer xxFlexLexer
    #include &lt;FlexLexer.h&gt;
    #undef yyFlexLexer
    #define yyFlexLexer zzFlexLexer
    #include &lt;FlexLexer.h&gt;
</pre>if, for example, you used <b>%option prefix="xx"</b> for one of your scanners
and <b>%option prefix="zz"</b> for the other. <p>
IMPORTANT: the present form of the
scanning class is <i>experimental</i> and may change considerably between major
releases.  
<h2><a name='sect19' href='#toc19'>Incompatibilities with Lex and Posix</a></h2>
<i>flex</i> is a rewrite of the
AT&amp;T Unix <i>lex</i> tool (the two implementations do not share any code, though),
with some extensions and incompatibilities, both of which are of concern
to those who wish to write scanners acceptable to either implementation.
 Flex is fully compliant with the POSIX <i>lex</i> specification, except that
when using <b>%pointer</b> (the default), a call to <b>unput()</b> destroys the contents
of <b>yytext,</b> which is counter to the POSIX specification. <p>
In this section
we discuss all of the known areas of incompatibility between flex, AT&amp;T
lex, and the POSIX specification. <p>
<i>flex&rsquo;s</i> <b>-l</b> option turns on maximum compatibility
with the original AT&amp;T <i>lex</i> implementation, at the cost of a major loss in
the generated scanner&rsquo;s performance.  We note below which incompatibilities
can be overcome using the <b>-l</b> option. <p>
<i>flex</i> is fully compatible with <i>lex</i> with
the following exceptions: 
<dl>

<dt>-</dt>
<dd>The undocumented <i>lex</i> scanner internal variable
<b>yylineno</b> is not supported unless <b>-l</b> or <b>%option yylineno</b> is used. </dd>

<dt><b>yylineno</b>
</dt>
<dd>should be maintained on a per-buffer basis, rather than a per-scanner (single
global variable) basis. </dd>

<dt><b>yylineno</b> </dt>
<dd>is not part of the POSIX specification.
</dd>

<dt>-</dt>
<dd>The <b>input()</b> routine is not redefinable, though it may be called to read
characters following whatever has been matched by a rule.  If <b>input()</b> encounters
an end-of-file the normal <b>yywrap()</b> processing is done.  A &lsquo;&lsquo;real&rsquo;&rsquo; end-of-file is
returned by <b>input()</b> as <i>EOF.</i> </dd>

<dt>Input is instead controlled by defining the
</dt>
<dd><b>YY_INPUT</b> macro. </dd>

<dt>The </dt>
<dd><i>flex</i> restriction that <b>input()</b> cannot be redefined is
in accordance with the POSIX specification, which simply does not specify
any way of controlling the scanner&rsquo;s input other than by making an initial
assignment to <i>yyin.</i> </dd>

<dt>-</dt>
<dd>The <b>unput()</b> routine is not redefinable.  This restriction
is in accordance with POSIX. </dd>

<dt>-</dt>
<dd><i>flex</i> scanners are not as reentrant as <i>lex</i> scanners.
 In particular, if you have an interactive scanner and an interrupt handler
which long-jumps out of the scanner, and the scanner is subsequently called
again, you may get the following message: <br>
<pre>    fatal flex scanner internal error--end of buffer missed
</pre>To reenter the scanner, first use <br>
<pre>    yyrestart( yyin );
</pre>Note that this call will throw away any buffered input; usually this isn&rsquo;t
a problem with an interactive scanner. </dd>

<dt>Also note that flex C++ scanner classes
</dt>
<dd><i>are</i> reentrant, so if using C++ is an option for you, you should use them
instead.  See "Generating C++ Scanners" above for details. </dd>

<dt>-</dt>
<dd><b>output()</b> is not
supported. Output from the <b>ECHO</b> macro is done to the file-pointer <i>yyout</i> (default
<i>stdout).</i> </dd>

<dt><b>output()</b> </dt>
<dd>is not part of the POSIX specification. </dd>

<dt>-</dt>
<dd><i>lex</i> does not support
exclusive start conditions (%x), though they are in the POSIX specification.
</dd>

<dt>-</dt>
<dd>When definitions are expanded, <i>flex</i> encloses them in parentheses. With lex,
the following: <br>
<pre>    NAME    [A-Z][A-Z0-9]*
    %%
    foo{NAME}?      printf( "Found it\n" );
    %%
</pre>will not match the string "foo" because when the macro is expanded the
rule is equivalent to "foo[A-Z][A-Z0-9]*?" and the precedence is such that
the &rsquo;?&rsquo; is associated with "[A-Z0-9]*".  With <i>flex,</i> the rule will be expanded
to "foo([A-Z][A-Z0-9]*)?" and so the string "foo" will match. </dd>

<dt>Note that if
the definition begins with </dt>
<dd><b>^</b> or ends with <b>$</b> then it is <i>not</i> expanded with
parentheses, to allow these operators to appear in definitions without
losing their special meanings.  But the <b>&lt;s&gt;, /,</b> and <b>&lt;&lt;EOF&gt;&gt;</b> operators cannot be
used in a <i>flex</i> definition. </dd>

<dt>Using </dt>
<dd><b>-l</b> results in the <i>lex</i> behavior of no parentheses
around the definition. </dd>

<dt>The POSIX specification is that the definition be
enclosed in parentheses. </dt>
<dd></dd>

<dt>-</dt>
<dd>Some implementations of <i>lex</i> allow a rule&rsquo;s action
to begin on a separate line, if the rule&rsquo;s pattern has trailing whitespace:
<br>
<pre>    %%
    foo|bar&lt;space here&gt;
      { foobar_action(); }
</pre><i>flex</i> does not support this feature. </dd>

<dt>-</dt>
<dd>The <i>lex</i> <b>%r</b> (generate a Ratfor scanner)
option is not supported.  It is not part of the POSIX specification. </dd>

<dt>-</dt>
<dd>After
a call to <b>unput(),</b> <i>yytext</i> is undefined until the next token is matched,
unless the scanner was built using <b>%array.</b> This is not the case with <i>lex</i>
or the POSIX specification.  The <b>-l</b> option does away with this incompatibility.
</dd>

<dt>-</dt>
<dd>The precedence of the <b>{}</b> (numeric range) operator is different. <i>lex</i> interprets
"abc{1,3}" as "match one, two, or three occurrences of &rsquo;abc&rsquo;", whereas <i>flex</i>
interprets it as "match &rsquo;ab&rsquo; followed by one, two, or three occurrences of
&rsquo;c&rsquo;".  The latter is in agreement with the POSIX specification. </dd>

<dt>-</dt>
<dd>The precedence
of the <b>^</b> operator is different. <i>lex</i> interprets "^foo|bar" as "match either
&rsquo;foo&rsquo; at the beginning of a line, or &rsquo;bar&rsquo; anywhere", whereas <i>flex</i> interprets
it as "match either &rsquo;foo&rsquo; or &rsquo;bar&rsquo; if they come at the beginning of a line".
 The latter is in agreement with the POSIX specification. </dd>

<dt>-</dt>
<dd>The special table-size
declarations such as <b>%a</b> supported by <i>lex</i> are not required by <i>flex</i> scanners;
<i>flex</i> ignores them. </dd>

<dt>-</dt>
<dd>The name  FLEX_SCANNER is #define&rsquo;d so scanners may be
written for use with either <i>flex</i> or <i>lex.</i> Scanners also include <b>YY_FLEX_MAJOR_VERSION</b>
and <b>YY_FLEX_MINOR_VERSION</b> indicating which version of <i>flex</i> generated the
scanner (for example, for the 2.5 release, these defines would be 2 and
5 respectively). </dd>
</dl>
<p>
The following <i>flex</i> features are not included in <i>lex</i> or
the POSIX specification: <br>
<pre>    C++ scanners
    %option
    start condition scopes
    start condition stacks
    interactive/non-interactive scanners
    yy_scan_string() and friends
    yyterminate()
    yy_set_interactive()
    yy_set_bol()
    YY_AT_BOL()
    &lt;&lt;EOF&gt;&gt;
    &lt;*&gt;
    YY_DECL
    YY_START
    YY_USER_ACTION
    YY_USER_INIT
    #line directives
    %{}&rsquo;s around actions
    multiple actions on a line
</pre>plus almost all of the flex flags. The last feature in the list refers to
the fact that with <i>flex</i> you can put multiple actions on the same line,
separated with semi-colons, while with <i>lex,</i> the following <br>
<pre>    foo    handle_foo(); ++num_foos_seen;
</pre>is (rather surprisingly) truncated to <br>
<pre>    foo    handle_foo();
</pre><i>flex</i> does not truncate the action.  Actions that are not enclosed in braces
are simply terminated at the end of the line. 
<h2><a name='sect20' href='#toc20'>Diagnostics</a></h2>
<p>
<i>warning,</i> rule cannot
be matched indicates that the given rule cannot be matched because it follows
other rules that will always match the same text as it.  For example, in
the following "foo" cannot be matched because it comes after an identifier
"catch-all" rule: <br>
<pre>    [a-z]+    got_identifier();
    foo       got_foo();
</pre>Using <b>REJECT</b> in a scanner suppresses this warning. <p>
<i>warning,</i> <b>-s</b> <i></i> option given
but default rule can be matched means that it is possible (perhaps only
in a particular start condition) that the default rule (match any single
character) is the only one that will match a particular input.  Since <b>-s</b>
was given, presumably this is not intended. <p>
<i>reject_used_but_not_detected</i>
undefined or <i>yymore_used_but_not_detected</i> undefined - These errors can occur
at compile time.  They indicate that the scanner uses <b>REJECT</b> or <b>yymore()</b>
but that <i>flex</i> failed to notice the fact, meaning that <i>flex</i> scanned the
first two sections looking for occurrences of these actions and failed
to find any, but somehow you snuck some in (via a #include file, for example).
 Use <b>%option reject</b> or <b>%option yymore</b> to indicate to flex that you really
do use these features. <p>
<i>flex</i> scanner jammed - a scanner compiled with <b>-s</b> has
encountered an input string which wasn&rsquo;t matched by any of its rules.  This
error can also occur due to internal problems. <p>
<i>token</i> too large, exceeds
YYLMAX - your scanner uses <b>%array</b> and one of its rules matched a string
longer than the <b>YYLMAX</b> constant (8K bytes by default).  You can increase
the value by #define&rsquo;ing <b>YYLMAX</b> in the definitions section of your <i>flex</i>
input. <p>
<i>scanner</i> requires -8 flag to <i>use</i> the character &rsquo;x&rsquo; - Your scanner specification
includes recognizing the 8-bit character <i>&rsquo;x&rsquo;</i> and you did not specify the -8
flag, and your scanner defaulted to 7-bit because you used the <b>-Cf</b> or <b>-CF</b>
table compression options.  See the discussion of the <b>-7</b> flag for details.
<p>
<i>flex</i> scanner push-back overflow - you used <b>unput()</b> to push back so much text
that the scanner&rsquo;s buffer could not hold both the pushed-back text and the
current token in <b>yytext.</b> Ideally the scanner should dynamically resize the
buffer in this case, but at present it does not. <p>
<i></i> input buffer overflow,
can&rsquo;t enlarge buffer because scanner uses REJECT - the scanner was working
on matching an extremely large token and needed to expand the input buffer.
 This doesn&rsquo;t work with scanners that use <b></b> REJECT. <p>
<i></i> fatal flex scanner internal
error--end of buffer missed - This can occur in an scanner which is reentered
after a long-jump has jumped out (or over) the scanner&rsquo;s activation frame.
 Before reentering the scanner, use: <br>
<pre>    yyrestart( yyin );
</pre>or, as noted above, switch to using the C++ scanner class. <p>
<i>too</i> many start
conditions in &lt;&gt; construct! - you listed more start conditions in a &lt;&gt; construct
than exist (so you must have listed at least one of them twice). 
<h2><a name='sect21' href='#toc21'>Files</a></h2>

<dl>

<dt><b>-lfl</b>
</dt>
<dd>library with which scanners must be linked. </dd>

<dt><i>lex.yy.c</i> </dt>
<dd>generated scanner (called
<i>lexyy.c</i> on some systems). </dd>

<dt><i>lex.yy.cc</i> </dt>
<dd>generated C++ scanner class, when using
<b>-+.</b> </dd>

<dt><i>&lt;FlexLexer.h&gt;</i> </dt>
<dd>header file defining the C++ scanner base class, <b>FlexLexer,</b>
and its derived class, <b>yyFlexLexer.</b> </dd>

<dt><i>flex.skl</i> </dt>
<dd>skeleton scanner.  This file
is only used when building flex, not when flex executes. </dd>

<dt><i>lex.backup</i> </dt>
<dd>backing-up
information for <b>-b</b> flag (called <i>lex.bck</i> on some systems). </dd>
</dl>

<h2><a name='sect22' href='#toc22'>Deficiencies / Bugs</a></h2>
<p>
Some
trailing context patterns cannot be properly matched and generate warning
messages ("dangerous trailing context").  These are patterns where the ending
of the first part of the rule matches the beginning of the second part,
such as "zx*/xy*", where the &rsquo;x*&rsquo; matches the &rsquo;x&rsquo; at the beginning of the trailing
context.  (Note that the POSIX draft states that the text matched by such
patterns is undefined.) <p>
For some trailing context rules, parts which are
actually fixed-length are not recognized as such, leading to the abovementioned
performance loss. In particular, parts using &rsquo;|&rsquo; or {n} (such as "foo{3}")
are always considered variable-length. <p>
Combining trailing context with the
special &rsquo;|&rsquo; action can result in <i>fixed</i> trailing context being turned into
the more expensive <i>variable</i> trailing context.  For example, in the following:
<br>
<pre>    %%
    abc      |
    xyz/def
</pre><p>
Use of <b>unput()</b> invalidates yytext and yyleng, unless the <b>%array</b> directive
or the <b>-l</b> option has been used. <p>
Pattern-matching of NUL&rsquo;s is substantially
slower than matching other characters. <p>
Dynamic resizing of the input buffer
is slow, as it entails rescanning all the text matched so far by the current
(generally huge) token. <p>
Due to both buffering of input and read-ahead, you
cannot intermix calls to &lt;stdio.h&gt; routines, such as, for example, <b>getchar(),</b>
with <i>flex</i> rules and expect it to work.  Call <b>input()</b> instead. <p>
The total table
entries listed by the <b>-v</b> flag excludes the number of table entries needed
to determine what rule has been matched.  The number of entries is equal
to the number of DFA states if the scanner does not use <b>REJECT,</b> and somewhat
greater than the number of states if it does. <p>
<b>REJECT</b> cannot be used with
the <b>-f</b> or <b>-F</b> options. <p>
The <i>flex</i> internal algorithms need documentation. 
<h2><a name='sect23' href='#toc23'>See
Also</a></h2>
<p>
<a href='lex.1.html'>lex(1)</a>
, <a href='yacc.1.html'>yacc(1)</a>
, <a href='sed.1.html'>sed(1)</a>
, <a href='awk.1.html'>awk(1)</a>
. <p>
John Levine, Tony Mason, and Doug Brown,
<i>Lex</i> &amp; Yacc, O&rsquo;Reilly and Associates.  Be sure to get the 2nd edition. <p>
M. E. Lesk
and E. Schmidt, <i>LEX</i> - Lexical Analyzer Generator <p>
Alfred Aho, Ravi Sethi and
Jeffrey Ullman, <i>Compilers:</i> Principles, Techniques and Tools, Addison-Wesley
(1986).  Describes the pattern-matching techniques used by <i>flex</i> (deterministic
finite automata). 
<h2><a name='sect24' href='#toc24'>Author</a></h2>
Vern Paxson, with the help of many ideas and much
inspiration from Van Jacobson.  Original version by Jef Poskanzer.  The fast
table representation is a partial implementation of a design done by Van
Jacobson.  The implementation was done by Kevin Gong and Vern Paxson. <p>
Thanks
to the many <i>flex</i> beta-testers, feedbackers, and contributors, especially
Francois Pinard, Casey Leedom, Robert Abramovitz, Stan Adermann, Terry
Allen, David Barker-Plummer, John Basrai, Neal Becker, Nelson H.F. Beebe,
benson@odi.com, Karl Berry, Peter A. Bigot, Simon Blanchard, Keith Bostic,
Frederic Brehm, Ian Brockbank, Kin Cho, Nick Christopher, Brian Clapper,
J.T. Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave Curtis, Scott
David Daniels, Chris G. Demetriou, Theo Deraadt, Mike Donahue, Chuck Doucette,
Tom Epperly, Leo Eskin, Chris Faylor, Chris Flatters, Jon Forrest, Jeffrey
Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang Glunz, Eric Goldman, Christopher
M. Gould, Ulrich Grepel, Peer Griebel, Jan Hajic, Charles Hemphill, NORO
Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, Dana Hudes, Eric Hughes,
John Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari Jalovaara, Jeffrey
R. Jones, Henry Juengst, Klaus Kaempf, Jonathan I. Kamens, Terrence O Kane,
Amir Katz, ken@ken.hilco.com, Kevin B. Kenny, Steve Kirsch, Winfried Koenig,
Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard, Craig Leres, John
Levine, Steve Liddle, David Loffredo, Mike Long, Mohamed el Lozy, Brian
Madsen, Malte, Joe Marshall, Bengt Martensson, Chris Metcalf, Luke Mewburn,
Jim Meyering, R. Alexander Milowski, Erik Naggum, G.T. Nicol, Landon Noll,
James Nordby, Marc Nozell, Richard Ohnemus, Karsten Pahnke, Sven Panne,
Roland Pesch, Walter Pelissero, Gaumond Pierre, Esmond Pitt, Jef Poskanzer,
Joe Rahmeh, Jarmo Raiha, Frederic Raimbault, Pat Rankin, Rick Richardson,
Kevin Rodgers, Kai Uwe Rommel, Jim Roskind, Alberto Santini, Andreas Scherer,
Darrell Schiebel, Raf Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas
Schwab, Larry Schwimmer, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist,
Mike Stump, Paul Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt,
Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard
Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn,
and those whose names have slipped my marginal mail-archiving skills but
whose contributions are appreciated all the same. <p>
Thanks to Keith Bostic,
Jon Forrest, Noah Friedman, John Gilmore, Craig Leres, John Levine, Bob
Mulcahy, G.T. Nicol, Francois Pinard, Rich Salz, and Richard Stallman for
help with various distribution headaches. <p>
Thanks to Esmond Pitt and Earle
Horton for 8-bit character support; to Benson Margulies and Fred Burke for
C++ support; to Kent Williams and Tom Epperly for C++ class support; to
Ove Ewerlid for support of NUL&rsquo;s; and to Eric Hughes for support of multiple
buffers. <p>
This work was primarily done when I was with the Real Time Systems
Group at the Lawrence Berkeley Laboratory in Berkeley, CA.  Many thanks
to all there for the support I received. <p>
Send comments to vern@ee.lbl.gov.
<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Overview</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Some Simple Examples</a></li>
<li><a name='toc5' href='#sect5'>Format of the Input File</a></li>
<li><a name='toc6' href='#sect6'>Patterns</a></li>
<li><a name='toc7' href='#sect7'>How the Input is Matched</a></li>
<li><a name='toc8' href='#sect8'>Actions</a></li>
<li><a name='toc9' href='#sect9'>the Generated Scanner</a></li>
<li><a name='toc10' href='#sect10'>Start Conditions</a></li>
<li><a name='toc11' href='#sect11'>Multiple Input Buffers</a></li>
<li><a name='toc12' href='#sect12'>End-of-file Rules</a></li>
<li><a name='toc13' href='#sect13'>Miscellaneous Macros</a></li>
<li><a name='toc14' href='#sect14'>Values Available to the User</a></li>
<li><a name='toc15' href='#sect15'>Interfacing with Yacc</a></li>
<li><a name='toc16' href='#sect16'>Options</a></li>
<li><a name='toc17' href='#sect17'>Performance Considerations</a></li>
<li><a name='toc18' href='#sect18'>Generating C++ Scanners</a></li>
<li><a name='toc19' href='#sect19'>Incompatibilities with Lex and Posix</a></li>
<li><a name='toc20' href='#sect20'>Diagnostics</a></li>
<li><a name='toc21' href='#sect21'>Files</a></li>
<li><a name='toc22' href='#sect22'>Deficiencies / Bugs</a></li>
<li><a name='toc23' href='#sect23'>See Also</a></li>
<li><a name='toc24' href='#sect24'>Author</a></li>
</ul>
</body>
</html>
