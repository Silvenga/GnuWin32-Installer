 <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>"YACC"(1P) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
 
<h2><a name='sect0' href='#toc0'>Prolog</a></h2>
This manual page is part of the POSIX Programmer&rsquo;s Manual. The Linux
implementation of this interface may differ (consult the corresponding
Linux manual page for details of Linux behavior), or the interface may
not be implemented on Linux. 
<h2><a name='sect1' href='#toc1'>Name</a></h2>
yacc - yet another compiler compiler (<b>DEVELOPMENT</b>)

<h2><a name='sect2' href='#toc2'>Synopsis</a></h2>
<p>
<b>yacc</b> <b>[</b><b>-dltv</b><b>][</b><b>-b</b> <i>file_prefix</i><b>][</b><b>-p</b> <i>sym_prefix</i><b>]</b> <i>grammar</i><b></b> 
<h2><a name='sect3' href='#toc3'>Description</a></h2>
<p>
The
<i>yacc</i> utility shall read a description of a context-free grammar in <i>grammar</i>
and write C source code, conforming to the ISO&nbsp;C standard, to a code file,
and optionally header information into a header file, in the current directory.
The C code shall define a function and related routines and macros for
an automaton that executes a parsing algorithm meeting the requirements
in Algorithms . <p>
The form and meaning of the grammar are described in the
EXTENDED DESCRIPTION section. <p>
The C source code and header file shall be
produced in a form suitable as input for the C compiler (see <i>c99</i> ). 
<h2><a name='sect4' href='#toc4'>Options</a></h2>
<p>
The
<i>yacc</i> utility shall conform to the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001,
Section 12.2, Utility Syntax Guidelines. <p>
The following options shall be supported:

<dl>

<dt><b>-b&nbsp;</b> <i>file_prefix</i> </dt>
<dd>Use <i>file_prefix</i> instead of <b>y</b> as the prefix for all output
filenames. The code file <b>y.tab.c</b>, the header file <b>y.tab.h</b> (created when <b>-d</b> is
specified), and the description file <b>y.output</b> (created when <b>-v</b> is specified),
shall be changed to <i>file_prefix</i> <b>.tab.c</b>, <i>file_prefix</i> <b>.tab.h</b>, and <i>file_prefix</i>
<b>.output</b>, respectively. </dd>

<dt><b>-d</b> </dt>
<dd>Write the header file; by default only the code
file is written. The <b>#define</b> statements associate the token codes assigned
by <i>yacc</i> with the user-declared token names. This allows source files other
than <b>y.tab.c</b> to access the token codes. </dd>

<dt><b>-l</b> </dt>
<dd>Produce a code file that does not
contain any <b>#line</b> constructs. If this option is not present, it is unspecified
whether the code file or header file contains <b>#line</b> directives. This should
only be used after the grammar and the associated actions are fully debugged.
</dd>

<dt><b>-p&nbsp;</b> <i>sym_prefix</i> </dt>
<dd><p>
Use <i>sym_prefix</i> instead of <b>yy</b> as the prefix for all external
names produced by <i>yacc</i>. The names affected shall include the functions <i>yyparse</i>(),
<i>yylex</i>(), and <i>yyerror</i>(), and the variables <i>yylval</i>, <i>yychar</i>, and <i>yydebug</i>. (In
the remainder of this section, the six symbols cited are referenced using
their default names only as a notational convenience.) Local names may also
be affected by the <b>-p</b> option; however, the <b>-p</b> option shall not affect <b>#define</b>
symbols generated by <i>yacc</i>. </dd>

<dt><b>-t</b> </dt>
<dd>Modify conditional compilation directives to
permit compilation of debugging code in the code file. Runtime debugging
statements shall always be contained in the code file, but by default conditional
compilation directives prevent their compilation. </dd>

<dt><b>-v</b> </dt>
<dd>Write a file containing
a description of the parser and a report of conflicts generated by ambiguities
in the grammar. <p>
</dd>
</dl>

<h2><a name='sect5' href='#toc5'>Operands</a></h2>
<p>
The following operand is required: 
<dl>

<dt><i>grammar</i> </dt>
<dd>A pathname
of a file containing instructions, hereafter called <i>grammar</i>, for which
a parser is to be created. The format for the grammar is described in the
EXTENDED DESCRIPTION section. <p>
</dd>
</dl>

<h2><a name='sect6' href='#toc6'>Stdin</a></h2>
<p>
Not used. 
<h2><a name='sect7' href='#toc7'>Input Files</a></h2>
<p>
The file <i>grammar</i>
shall be a text file formatted as specified in the EXTENDED DESCRIPTION
section. 
<h2><a name='sect8' href='#toc8'>Environment Variables</a></h2>
<p>
The following environment variables shall
affect the execution of <i>yacc</i>: 
<dl>

<dt><i>LANG</i> </dt>
<dd>Provide a default value for the internationalization
variables that are unset or null. (See the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001,
Section 8.2, Internationalization Variables for the precedence of internationalization
variables used to determine the values of locale categories.) </dd>

<dt><i>LC_ALL</i> </dt>
<dd>If
set to a non-empty string value, override the values of all the other internationalization
variables. </dd>

<dt><i>LC_CTYPE</i> </dt>
<dd>Determine the locale for the interpretation of sequences
of bytes of text data as characters (for example, single-byte as opposed
to multi-byte characters in arguments and input files). </dd>

<dt><i>LC_MESSAGES</i> </dt>
<dd>Determine
the locale that should be used to affect the format and contents of diagnostic
messages written to standard error. </dd>

<dt><i>NLSPATH</i> </dt>
<dd>Determine the location of message
catalogs for the processing of <i>LC_MESSAGES .</i>  <p>
</dd>
</dl>
<p>
The <i>LANG</i> and <i>LC_*</i> variables
affect the execution of the <i>yacc</i> utility as stated. The <i>main</i>() function
defined in Yacc Library shall call: <p>
<blockquote><br>
<pre>setlocale(LC_ALL, "")

</pre></blockquote>
<p>
and thus the program generated by <i>yacc</i> shall also be affected by the contents
of these variables at runtime. 
<h2><a name='sect9' href='#toc9'>Asynchronous Events</a></h2>
<p>
Default. 
<h2><a name='sect10' href='#toc10'>Stdout</a></h2>
<p>
Not used.

<h2><a name='sect11' href='#toc11'>Stderr</a></h2>
<p>
If shift/reduce or reduce/reduce conflicts are detected in <i>grammar</i>,
<i>yacc</i> shall write a report of those conflicts to the standard error in an
unspecified format. <p>
Standard error shall also be used for diagnostic messages.

<h2><a name='sect12' href='#toc12'>Output Files</a></h2>
<p>
The code file, the header file, and the description file shall
be text files. All are described in the following sections. 
<h3><a name='sect13' href='#toc13'>Code File</a></h3>
<p>
This
file shall contain the C source code for the <i>yyparse</i>() function. It shall
contain code for the various semantic actions with macro substitution performed
on them as described in the EXTENDED DESCRIPTION section. It also shall
contain a copy of the <b>#define</b> statements in the header file. If a <b>%union</b>
declaration is used, the declaration for YYSTYPE shall also be included
in this file. 
<h3><a name='sect14' href='#toc14'>Header File</a></h3>
<p>
The header file shall contain <b>#define</b> statements
that associate the token numbers with the token names. This allows source
files other than the code file to access the token codes. If a <b>%union</b> declaration
is used, the declaration for YYSTYPE and an <i>extern YYSTYPE yylval</i> declaration
shall also be included in this file. 
<h3><a name='sect15' href='#toc15'>Description File</a></h3>
<p>
The description file
shall be a text file containing a description of the state machine corresponding
to the parser, using an unspecified format. Limits for internal tables (see
Limits ) shall also be reported, in an implementation-defined manner. (Some
implementations may use dynamic allocation techniques and have no specific
limit values to report.) 
<h2><a name='sect16' href='#toc16'>Extended Description</a></h2>
<p>
The <i>yacc</i> command accepts a
language that is used to define a grammar for a target language to be parsed
by the tables and code generated by <i>yacc</i>. The language accepted by <i>yacc</i>
as a grammar for the target language is described below using the <i>yacc</i>
input language itself. <p>
The input <i>grammar</i> includes rules describing the input
structure of the target language and code to be invoked when these rules
are recognized to provide the associated semantic action. The code to be
executed shall appear as bodies of text that are intended to be C-language
code. The C-language inclusions are presumed to form a correct function when
processed by <i>yacc</i> into its output files. The code included in this way shall
be executed during the recognition of the target language. <p>
Given a grammar,
the <i>yacc</i> utility generates the files described in the OUTPUT FILES section.
The code file can be compiled and linked using <i>c99</i>. If the declaration and
programs sections of the grammar file did not include definitions of <i>main</i>(),
<i>yylex</i>(), and <i>yyerror</i>(), the compiled output requires linking with externally
supplied versions of those functions. Default versions of <i>main</i>() and <i>yyerror</i>()
are supplied in the <i>yacc</i> library and can be linked in by using the <b>-l&nbsp;y</b> operand
to <i>c99</i>. The <i>yacc</i> library interfaces need not support interfaces with other
than the default <b>yy</b> symbol prefix. The application provides the lexical
analyzer function, <i>yylex</i>(); the <i>lex</i> utility is specifically designed to
generate such a routine. 
<h3><a name='sect17' href='#toc17'>Input Language</a></h3>
<p>
The application shall ensure that
every specification file consists of three sections in order: <i>declarations</i>,
<i>grammar rules</i>, and <i>programs</i>, separated by double percent signs ( <b>"%%"</b> ).
The declarations and programs sections can be empty. If the latter is empty,
the preceding <b>"%%"</b> mark separating it from the rules section can be omitted.
<p>
The input is free form text following the structure of the grammar defined
below. 
<h3><a name='sect18' href='#toc18'>Lexical Structure of the Grammar</a></h3>
<p>
The &lt;blank&gt;s, &lt;newline&gt;s, and &lt;form-feed&gt;s
shall be ignored, except that the application shall ensure that they do
not appear in names or multi-character reserved symbols. Comments shall be
enclosed in <b>"/*&nbsp;...&nbsp;*/"</b>, and can appear wherever a name is valid. <p>
Names are of
arbitrary length, made up of letters, periods ( <b>&rsquo;.&rsquo;</b> ), underscores ( <b>&rsquo;_&rsquo;</b> ),
and non-initial digits. Uppercase and lowercase letters are distinct. Conforming
applications shall not use names beginning in <b>yy</b> or <b>YY</b> since the <i>yacc</i> parser
uses such names. Many of the names appear in the final output of <i>yacc</i>, and
thus they should be chosen to conform with any additional rules created
by the C compiler to be used. In particular they appear in <b>#define</b> statements.
<p>
A literal shall consist of a single character enclosed in single-quotes
( <b>&rsquo;"</b> ). All of the escape sequences supported for character constants by
the ISO&nbsp;C standard shall be supported by <i>yacc</i>. <p>
The relationship with the
lexical analyzer is discussed in detail below. <p>
The application shall ensure
that the NUL character is not used in grammar rules or literals. 
<h3><a name='sect19' href='#toc19'>Declarations
Section</a></h3>
<p>
The declarations section is used to define the symbols used to define
the target language and their relationship with each other. In particular,
much of the additional information required to resolve ambiguities in the
context-free grammar for the target language is provided here. <p>
Usually <i>yacc</i>
assigns the relationship between the symbolic names it generates and their
underlying numeric value. The declarations section makes it possible to
control the assignment of these values. <p>
It is also possible to keep semantic
information associated with the tokens currently on the parse stack in
a user-defined C-language <b>union</b>, if the members of the union are associated
with the various names in the grammar. The declarations section provides
for this as well. <p>
The first group of declarators below all take a list of
names as arguments. That list can optionally be preceded by the name of
a C union member (called a <i>tag</i> below) appearing within <b>&rsquo;&lt;&rsquo;</b> and <b>&rsquo;&gt;&rsquo;</b> . (As an exception
to the typographical conventions of the rest of this volume of IEEE&nbsp;Std&nbsp;1003.1-2001,
in this case &lt;<i>tag</i>&gt; does not represent a metavariable, but the literal angle
bracket characters surrounding a symbol.) The use of <i>tag</i> specifies that
the tokens named on this line shall be of the same C type as the union
member referenced by <i>tag</i>. This is discussed in more detail below. <p>
For lists
used to define tokens, the first appearance of a given token can be followed
by a positive integer (as a string of decimal digits). If this is done,
the underlying value assigned to it for lexical purposes shall be taken
to be that number. <p>
The following declares <i>name</i> to be a token: <p>
<blockquote><br>
<pre>%token [&lt;tag&gt;] name [number][name [number]]...

</pre></blockquote>
<p>
If <i>tag</i> is present, the C type for all tokens on this line shall be declared
to be the type referenced by <i>tag</i>. If a positive integer, <i>number</i>, follows
a <i>name</i>, that value shall be assigned to the token. <p>
The following declares
<i>name</i> to be a token, and assigns precedence to it: <p>
<blockquote><br>
<pre>%left [&lt;tag&gt;] name [number][name [number]]...
%right [&lt;tag&gt;] name [number][name [number]]...

</pre></blockquote>
<p>
One or more lines, each beginning with one of these symbols, can appear
in this section. All tokens on the same line have the same precedence level
and associativity; the lines are in order of increasing precedence or binding
strength. <b>%left</b> denotes that the operators on that line are left associative,
and <b>%right</b> similarly denotes right associative operators. If <i>tag</i> is present,
it shall declare a C type for <i>name</i>s as described for <b>%token</b>. <p>
The following
declares <i>name</i> to be a token, and indicates that this cannot be used associatively:
<p>
<blockquote><br>
<pre>%nonassoc [&lt;tag&gt;] name [number][name [number]]...

</pre></blockquote>
<p>
If the parser encounters associative use of this token it reports an error.
If <i>tag</i> is present, it shall declare a C type for <i>name</i>s as described for
<b>%token</b>. <p>
The following declares that union member <i>name</i>s are non-terminals,
and thus it is required to have a <i>tag</i> field at its beginning: <p>
<blockquote><br>
<pre>%type &lt;tag&gt; name...

</pre></blockquote>
<p>
Because it deals with non-terminals only, assigning a token number or using
a literal is also prohibited. If this construct is present, <i>yacc</i> shall perform
type checking; if this construct is not present, the parse stack shall
hold only the <b>int</b> type. <p>
Every name used in <i>grammar</i> not defined by a <b>%token</b>,
<b>%left</b>, <b>%right</b>, or <b>%nonassoc</b> declaration is assumed to represent a non-terminal
symbol. The <i>yacc</i> utility shall report an error for any non-terminal symbol
that does not appear on the left side of at least one grammar rule. <p>
Once
the type, precedence, or token number of a name is specified, it shall
not be changed. If the first declaration of a token does not assign a token
number, <i>yacc</i> shall assign a token number. Once this assignment is made,
the token number shall not be changed by explicit assignment. <p>
The following
declarators do not follow the previous pattern. <p>
The following declares the
non-terminal <i>name</i> to be the <i>start symbol</i>, which represents the largest,
most general structure described by the grammar rules: <p>
<blockquote><br>
<pre>%start name
</pre></blockquote>
<p>
By default, it is the left-hand side of the first grammar rule; this default
can be overridden with this declaration. <p>
The following declares the <i>yacc</i>
value stack to be a union of the various types of values desired: <p>
<blockquote><br>
<pre>%union { body of union (in C) }

</pre></blockquote>
<p>
By default, the values returned by actions (see below) and the lexical
analyzer shall be of type <b>int</b>. The <i>yacc</i> utility keeps track of types, and
it shall insert corresponding union member names in order to perform strict
type checking of the resulting parser. <p>
Alternatively, given that at least
one &lt;<i>tag</i>&gt; construct is used, the union can be declared in a header file (which
shall be included in the declarations section by using a <b>#include</b> construct
within <b>%{</b> and <b>%}</b>), and a <b>typedef</b> used to define the symbol YYSTYPE to represent
this union. The effect of <b>%union</b> is to provide the declaration of YYSTYPE
directly from the <i>yacc</i> input. <p>
C-language declarations and definitions can
appear in the declarations section, enclosed by the following marks: <p>
<blockquote><br>
<pre>%{ ... %}

</pre></blockquote>
<p>
These statements shall be copied into the code file, and have global scope
within it so that they can be used in the rules and program sections. <p>
The
application shall ensure that the declarations section is terminated by
the token <b>%%</b>. 
<h3><a name='sect20' href='#toc20'>Grammar Rules in yacc</a></h3>
<p>
The rules section defines the context-free
grammar to be accepted by the function <i>yacc</i> generates, and associates with
those rules C-language actions and additional precedence information. The
grammar is described below, and a formal definition follows. <p>
The rules section
is comprised of one or more grammar rules. A grammar rule has the form:
<p>
<blockquote><br>
<pre>A : BODY ;

</pre></blockquote>
<p>
The symbol <b>A</b> represents a non-terminal name, and <b>BODY</b> represents a sequence
of zero or more <i>name</i>s, <i>literal</i>s, and <i>semantic action</i>s that can then be
followed by optional <i>precedence rule</i>s. Only the names and literals participate
in the formation of the grammar; the semantic actions and precedence rules
are used in other ways. The colon and the semicolon are <i>yacc</i> punctuation.
If there are several successive grammar rules with the same left-hand side,
the vertical bar <b>&rsquo;|&rsquo;</b> can be used to avoid rewriting the left-hand side; in
this case the semicolon appears only after the last rule. The BODY part
can be empty (or empty of names and literals) to indicate that the non-terminal
symbol matches the empty string. <p>
The <i>yacc</i> utility assigns a unique number
to each rule. Rules using the vertical bar notation are distinct rules. The
number assigned to the rule appears in the description file. <p>
The elements
comprising a BODY are: 
<dl>

<dt><i>name</i>,&nbsp;<i>literal</i> </dt>
<dd>These form the rules of the grammar:
<i>name</i> is either a <i>token</i> or a <i>non-terminal</i>; <i>literal</i> stands for itself (less
the lexically required quotation marks). </dd>

<dt><i>semantic action</i> </dt>
<dd><p>
With each grammar
rule, the user can associate actions to be performed each time the rule
is recognized in the input process. (Note that the word "action" can also
refer to the actions of the parser-shift, reduce, and so on.)  </dd>
</dl>
<p>
These actions
can return values and can obtain the values returned by previous actions.
These values are kept in objects of type YYSTYPE (see <b>%union</b>). The result
value of the action shall be kept on the parse stack with the left-hand
side of the rule, to be accessed by other reductions as part of their right-hand
side. By using the &lt;<i>tag</i>&gt; information provided in the declarations section,
the code generated by <i>yacc</i> can be strictly type checked and contain arbitrary
information. In addition, the lexical analyzer can provide the same kinds
of values for tokens, if desired. <p>
An action is an arbitrary C statement
and as such can do input or output, call subprograms, and alter external
variables. An action is one or more C statements enclosed in curly braces
<b>&rsquo;{&rsquo;</b> and <b>&rsquo;}&rsquo;</b> . <p>
Certain pseudo-variables can be used in the action. These are macros
for access to data structures known internally to <i>yacc</i>. 
<dl>

<dt>$$ </dt>
<dd><blockquote>The value of
the action can be set by assigning it to $$. If type checking is enabled
and the type of the value to be assigned cannot be determined, a diagnostic
message may be generated. </dd>
</dl>
</blockquote>

<dl>

<dt>$<i>number</i> </dt>
<dd><blockquote>This refers to the value returned by the
component specified by the token <i>number</i> in the right side of a rule, reading
from left to right; <i>number</i> can be zero or negative. If <i>number</i> is zero or
negative, it refers to the data associated with the name on the parser&rsquo;s
stack preceding the leftmost symbol of the current rule. (That is, <b>"$0"</b>
refers to the name immediately preceding the leftmost name in the current
rule to be found on the parser&rsquo;s stack and <b>"$-1"</b> refers to the symbol to
<i>its</i> left.) If <i>number</i> refers to an element past the current point in the
rule, or beyond the bottom of the stack, the result is undefined. If type
checking is enabled and the type of the value to be assigned cannot be
determined, a diagnostic message may be generated. </dd>
</dl>
</blockquote>

<dl>

<dt>$&lt;<i>tag</i>&gt;<i>number</i> </dt>
<dd><blockquote><p>
These correspond
exactly to the corresponding symbols without the <i>tag</i> inclusion, but allow
for strict type checking (and preclude unwanted type conversions). The effect
is that the macro is expanded to use <i>tag</i> to select an element from the
YYSTYPE union (using <i>dataname.tag</i>). This is particularly useful if <i>number</i>
is not positive. </dd>
</dl>
</blockquote>

<dl>

<dt>$&lt;<i>tag</i>&gt;$ </dt>
<dd><blockquote>This imposes on the reference the type of the union
member referenced by <i>tag</i>. This construction is applicable when a reference
to a left context value occurs in the grammar, and provides <i>yacc</i> with a
means for selecting a type. </dd>
</dl>
</blockquote>
<p>
<p>
Actions can occur anywhere in a rule (not just
at the end); an action can access values returned by actions to its left,
and in turn the value it returns can be accessed by actions to its right.
An action appearing in the middle of a rule shall be equivalent to replacing
the action with a new non-terminal symbol and adding an empty rule with
that non-terminal symbol on the left-hand side. The semantic action associated
with the new rule shall be equivalent to the original action. The use of
actions within rules might introduce conflicts that would not otherwise
exist. <p>
By default, the value of a rule shall be the value of the first element
in it. If the first element does not have a type (particularly in the case
of a literal) and type checking is turned on by <b>%type</b>, an error message
shall result. 
<dl>

<dt><i>precedence</i> </dt>
<dd>The keyword <b>%prec</b> can be used to change the precedence
level associated with a particular grammar rule. Examples of this are in
cases where a unary and binary operator have the same symbolic representation,
but need to be given different precedences, or where the handling of an
ambiguous if-else construction is necessary. The reserved symbol <b>%prec</b> can
appear immediately after the body of the grammar rule and can be followed
by a token name or a literal. It shall cause the precedence of the grammar
rule to become that of the following token name or literal. The action for
the rule as a whole can follow <b>%prec</b>. <p>
</dd>
</dl>
<p>
If a program section follows, the
application shall ensure that the grammar rules are terminated by <b>%%</b>. 
<h3><a name='sect21' href='#toc21'>Programs
Section</a></h3>
<p>
The <i>programs</i> section can include the definition of the lexical analyzer
<i>yylex</i>(), and any other functions; for example, those used in the actions
specified in the grammar rules. It is unspecified whether the programs section
precedes or follows the semantic actions in the output file; therefore,
if the application contains any macro definitions and declarations intended
to apply to the code in the semantic actions, it shall place them within
<b>"%{&nbsp;...&nbsp;%}"</b> in the declarations section. 
<h3><a name='sect22' href='#toc22'>Input Grammar</a></h3>
<p>
The following input to
<i>yacc</i> yields a parser for the input to <i>yacc</i>. This formal syntax takes precedence
over the preceding text syntax description. <p>
The lexical structure is defined
less precisely; Lexical Structure of the Grammar defines most terms. The
correspondence between the previous terms and the tokens below is as follows.

<dl>

<dt><b>IDENTIFIER</b> </dt>
<dd>This corresponds to the concept of <i>name</i>, given previously. It
also includes literals as defined previously. </dd>

<dt><b>C_IDENTIFIER</b> </dt>
<dd>This is a name,
and additionally it is known to be followed by a colon. A literal cannot
yield this token. </dd>

<dt><b>NUMBER</b> </dt>
<dd>A string of digits (a non-negative decimal integer).
</dd>

<dt><b>TYPE</b>,&nbsp;<b>LEFT</b>,&nbsp;<b>MARK</b>,&nbsp;<b>LCURL</b>,&nbsp;<b>RCURL</b> </dt>
<dd><p>
These correspond directly to <b>%type</b>, <b>%left</b>, <b>%%</b>,
<b>%{</b>, and <b>%}</b>. </dd>

<dt><b>{&nbsp;...&nbsp;}</b> </dt>
<dd>This indicates C-language source code, with the possible inclusion
of <b>&rsquo;$&rsquo;</b> macros as discussed previously. <p>
<p>
<blockquote><br>
<pre>/* Grammar for the input to yacc. */
/* Basic entries. */
/* The following are recognized by the lexical analyzer. */

%token    IDENTIFIER      /* Includes identifiers and literals */
%token    C_IDENTIFIER    /* identifier (but not literal)
                             followed by a :. */
%token    NUMBER          /* [0-9][0-9]* */

/* Reserved words : %type=&gt;TYPE %left=&gt;LEFT, and so on */

%token    LEFT RIGHT NONASSOC TOKEN PREC TYPE START UNION

%token    MARK            /* The %% mark. */
%token    LCURL           /* The %{ mark. */
%token    RCURL           /* The %} mark. */

/* 8-bit character literals stand for themselves; */
/* tokens have to be defined for multi-byte characters. */

%start    spec

%%

spec  : defs MARK rules tail
      ;
tail  : MARK
      {
        /* In this action, set up the rest of the file. */
      }
      | /* Empty; the second MARK is optional. */
      ;
defs  : /* Empty. */
      |    defs def
      ;
def   : START IDENTIFIER
      |    UNION
      {
        /* Copy union definition to output. */
      }
      |    LCURL
      {
        /* Copy C code to output file. */
      }
        RCURL
      |    rword tag nlist
      ;
rword : TOKEN
      | LEFT
      | RIGHT
      | NONASSOC
      | TYPE
      ;
tag   : /* Empty: union tag ID optional. */
      | &rsquo;&lt;&rsquo; IDENTIFIER &rsquo;&gt;&rsquo;
      ;
nlist : nmno
      | nlist nmno
      ;
nmno  : IDENTIFIER         /* Note: literal invalid with % type. */
      | IDENTIFIER NUMBER  /* Note: invalid with % type. */
      ;

/* Rule section */

rules : C_IDENTIFIER rbody prec
      | rules  rule
      ;
rule  : C_IDENTIFIER rbody prec
      | &rsquo;|&rsquo; rbody prec
      ;
rbody : /* empty */
      | rbody IDENTIFIER
      | rbody act
      ;
act   : &rsquo;{&rsquo;
        {
          /* Copy action, translate $$, and so on. */
        }
        &rsquo;}&rsquo;
      ;
prec  : /* Empty */
      | PREC IDENTIFIER
      | PREC IDENTIFIER act
      | prec &rsquo;;&rsquo;
      ;

</pre></dd>
</dl>
</blockquote>

<h3><a name='sect23' href='#toc23'>Conflicts</a></h3>
<p>
The parser produced for an input grammar may contain states in
which conflicts occur. The conflicts occur because the grammar is not <a href='LALR.1.html'>LALR(1)</a>
.
An ambiguous grammar always contains at least one <a href='LALR.1.html'>LALR(1)</a>
 conflict. The
<i>yacc</i> utility shall resolve all conflicts, using either default rules or
user-specified precedence rules. <p>
Conflicts are either shift/reduce conflicts
or reduce/reduce conflicts. A shift/reduce conflict is where, for a given
state and lookahead symbol, both a shift action and a reduce action are
possible. A reduce/reduce conflict is where, for a given state and lookahead
symbol, reductions by two different rules are possible. <p>
The rules below
describe how to specify what actions to take when a conflict occurs. Not
all shift/reduce conflicts can be successfully resolved this way because
the conflict may be due to something other than ambiguity, so incautious
use of these facilities can cause the language accepted by the parser to
be much different from that which was intended. The description file shall
contain sufficient information to understand the cause of the conflict.
Where ambiguity is the reason either the default or explicit rules should
be adequate to produce a working parser. <p>
The declared precedences and associativities
(see Declarations Section ) are used to resolve parsing conflicts as follows:

<dl>

<dt> 1.</dt>
<dd>A precedence and associativity is associated with each grammar rule;
it is the precedence and associativity of the last token or literal in
the body of the rule. If the <b>%prec</b> keyword is used, it overrides this default.
Some grammar rules might not have both precedence and associativity. </dd>
</dl>
<p>

<dl>

<dt> 2.</dt>
<dd>If
there is a shift/reduce conflict, and both the grammar rule and the input
symbol have precedence and associativity associated with them, then the
conflict is resolved in favor of the action (shift or reduce) associated
with the higher precedence. If the precedences are the same, then the associativity
is used; left associative implies reduce, right associative implies shift,
and non-associative implies an error in the string being parsed. </dd>
</dl>
<p>

<dl>

<dt> 3.</dt>
<dd>When there
is a shift/reduce conflict that cannot be resolved by rule 2, the shift
is done. Conflicts resolved this way are counted in the diagnostic output
described in Error Handling . </dd>
</dl>
<p>

<dl>

<dt> 4.</dt>
<dd>When there is a reduce/reduce conflict,
a reduction is done by the grammar rule that occurs earlier in the input
sequence. Conflicts resolved this way are counted in the diagnostic output
described in Error Handling . </dd>
</dl>
<p>
<p>
Conflicts resolved by precedence or associativity
shall not be counted in the shift/reduce and reduce/reduce conflicts reported
by <i>yacc</i> on either standard error or in the description file. 
<h3><a name='sect24' href='#toc24'>Error Handling</a></h3>
<p>
The
token <b>error</b> shall be reserved for error handling. The name <b>error</b> can be
used in grammar rules. It indicates places where the parser can recover
from a syntax error. The default value of <b>error</b> shall be 256. Its value can
be changed using a <b>%token</b> declaration. The lexical analyzer should not return
the value of <b>error</b>. <p>
The parser shall detect a syntax error when it is in
a state where the action associated with the lookahead symbol is <b>error</b>.
A semantic action can cause the parser to initiate error handling by executing
the macro YYERROR. When YYERROR is executed, the semantic action passes
control back to the parser. YYERROR cannot be used outside of semantic actions.
<p>
When the parser detects a syntax error, it normally calls <i>yyerror</i>() with
the character string <b>"syntax&nbsp;error"</b> as its argument. The call shall not be
made if the parser is still recovering from a previous error when the error
is detected. The parser is considered to be recovering from a previous error
until the parser has shifted over at least three normal input symbols since
the last error was detected or a semantic action has executed the macro
<i>yyerrok</i>. The parser shall not call <i>yyerror</i>() when YYERROR is executed. <p>
The
macro function YYRECOVERING shall return 1 if a syntax error has been detected
and the parser has not yet fully recovered from it. Otherwise, zero shall
be returned. <p>
When a syntax error is detected by the parser, the parser shall
check if a previous syntax error has been detected. If a previous error
was detected, and if no normal input symbols have been shifted since the
preceding error was detected, the parser checks if the lookahead symbol
is an endmarker (see Interface to the Lexical Analyzer ). If it is, the
parser shall return with a non-zero value. Otherwise, the lookahead symbol
shall be discarded and normal parsing shall resume. <p>
When YYERROR is executed
or when the parser detects a syntax error and no previous error has been
detected, or at least one normal input symbol has been shifted since the
previous error was detected, the parser shall pop back one state at a time
until the parse stack is empty or the current state allows a shift over
<b>error</b>. If the parser empties the parse stack, it shall return with a non-zero
value. Otherwise, it shall shift over <b>error</b> and then resume normal parsing.
If the parser reads a lookahead symbol before the error was detected, that
symbol shall still be the lookahead symbol when parsing is resumed. <p>
The
macro <i>yyerrok</i> in a semantic action shall cause the parser to act as if
it has fully recovered from any previous errors. The macro <i>yyclearin</i> shall
cause the parser to discard the current lookahead token. If the current
lookahead token has not yet been read, <i>yyclearin</i> shall have no effect. <p>
The
macro YYACCEPT shall cause the parser to return with the value zero. The
macro YYABORT shall cause the parser to return with a non-zero value. 
<h3><a name='sect25' href='#toc25'>Interface
to the Lexical Analyzer</a></h3>
<p>
The <i>yylex</i>() function is an integer-valued function
that returns a <i>token number</i> representing the kind of token read. If there
is a value associated with the token returned by <i>yylex</i>() (see the discussion
of <i>tag</i> above), it shall be assigned to the external variable <i>yylval</i>. <p>
If
the parser and <i>yylex</i>() do not agree on these token numbers, reliable communication
between them cannot occur. For (single-byte character) literals, the token
is simply the numeric value of the character in the current character set.
The numbers for other tokens can either be chosen by <i>yacc</i>, or chosen by
the user. In either case, the <b>#define</b> construct of C is used to allow <i>yylex</i>()
to return these numbers symbolically. The <b>#define</b> statements are put into
the code file, and the header file if that file is requested. The set of
characters permitted by <i>yacc</i> in an identifier is larger than that permitted
by C. Token names found to contain such characters shall not be included
in the <b>#define</b> declarations. <p>
If the token numbers are chosen by <i>yacc</i>, the
tokens other than literals shall be assigned numbers greater than 256,
although no order is implied. A token can be explicitly assigned a number
by following its first appearance in the declarations section with a number.
Names and literals not defined this way retain their default definition.
All token numbers assigned by <i>yacc</i> shall be unique and distinct from the
token numbers used for literals and user-assigned tokens. If duplicate token
numbers cause conflicts in parser generation, <i>yacc</i> shall report an error;
otherwise, it is unspecified whether the token assignment is accepted or
an error is reported. <p>
The end of the input is marked by a special token
called the <i>endmarker</i>, which has a token number that is zero or negative.
(These values are invalid for any other token.) All lexical analyzers shall
return zero or negative as a token number upon reaching the end of their
input. If the tokens up to, but excluding, the endmarker form a structure
that matches the start symbol, the parser shall accept the input. If the
endmarker is seen in any other context, it shall be considered an error.

<h3><a name='sect26' href='#toc26'>Completing the Program</a></h3>
<p>
In addition to <i>yyparse</i>() and <i>yylex</i>(), the functions
<i>yyerror</i>() and <i>main</i>() are required to make a complete program. The application
can supply <i>main</i>() and <i>yyerror</i>(), or those routines can be obtained from
the <i>yacc</i> library. 
<h3><a name='sect27' href='#toc27'>Yacc Library</a></h3>
<p>
The following functions shall appear only
in the <i>yacc</i> library accessible through the <b>-l&nbsp;y</b> operand to <i>c99</i>; they can
therefore be redefined by a conforming application: 
<dl>

<dt><b>int&nbsp;</b> <i>main</i>(<b>void</b>) </dt>
<dd><p>
This
function shall call <i>yyparse</i>() and exit with an unspecified value. Other
actions within this function are unspecified. </dd>

<dt><b>int&nbsp;</b> <i>yyerror</i>(<b>const&nbsp;char</b>&nbsp;*<i>s</i>) </dt>
<dd><p>
This
function shall write the NUL-terminated argument to standard error, followed
by a &lt;newline&gt;. <p>
</dd>
</dl>
<p>
The order of the <b>-l&nbsp;y</b> and <b>-l&nbsp;l</b> operands given to <i>c99</i> is significant;
the application shall either provide its own <i>main</i>() function or ensure
that <b>-l&nbsp;y</b> precedes <b>-l&nbsp;l</b>. 
<h3><a name='sect28' href='#toc28'>Debugging the Parser</a></h3>
<p>
The parser generated by <i>yacc</i> shall
have diagnostic facilities in it that can be optionally enabled at either
compile time or at runtime (if enabled at compile time). The compilation
of the runtime debugging code is under the control of YYDEBUG, a preprocessor
symbol. If YYDEBUG has a non-zero value, the debugging code shall be included.
If its value is zero, the code shall not be included. <p>
In parsers where the
debugging code has been included, the external <b>int</b> <i>yydebug</i> can be used
to turn debugging on (with a non-zero value) and off (zero value) at runtime.
The initial value of <i>yydebug</i> shall be zero. <p>
When <b>-t</b> is specified, the code
file shall be built such that, if YYDEBUG is not already defined at compilation
time (using the <i>c99</i> <b>-D</b> YYDEBUG option, for example), YYDEBUG shall be set
explicitly to 1. When <b>-t</b> is not specified, the code file shall be built such
that, if YYDEBUG is not already defined, it shall be set explicitly to
zero. <p>
The format of the debugging output is unspecified but includes at
least enough information to determine the shift and reduce actions, and
the input symbols. It also provides information about error recovery. 
<h3><a name='sect29' href='#toc29'>Algorithms</a></h3>
<p>
The
parser constructed by <i>yacc</i> implements an <a href='LALR.1.html'>LALR(1)</a>
 parsing algorithm as documented
in the literature. It is unspecified whether the parser is table-driven or
direct-coded. <p>
A parser generated by <i>yacc</i> shall never request an input symbol
from <i>yylex</i>() while in a state where the only actions other than the error
action are reductions by a single rule. <p>
The literature of parsing theory
defines these concepts. 
<h3><a name='sect30' href='#toc30'>Limits</a></h3>
<p>
The <i>yacc</i> utility may have several internal
tables. The minimum maximums for these tables are shown in the following
table. The exact meaning of these values is implementation-defined. The implementation
shall define the relationship between these values and between them and
any error messages that the implementation may generate should it run out
of space for any internal structure. An implementation may combine groups
of these resources into a single pool as long as the total available to
the user does not fall below the sum of the sizes specified by this section.
<br>
<p>
<center><b>Table: Internal Limits in <i>yacc</i></b></center> <center><table border='0'>
<tr><td align='left'></td></tr>
<b>&nbsp;</b> <tr></tr>
<tr></tr>
 <tr></tr>
 <tr></tr>
<tr></tr>
 <tr></tr>
 <tr></tr>
<tr></tr>
 <tr></tr>
 <tr></tr>
<tr></tr>
 <tr></tr>
 <tr></tr>
<tr></tr>
 <tr></tr>
 <tr></tr>
<tr></tr>
 <tr></tr>
 <tr></tr>
<tr></tr>
 <tr></tr>
 <tr></tr>
</table>
</center> 
<h2><a name='sect31' href='#toc31'>Exit Status</a></h2>
<p>
The following
exit values shall be returned: 
<ol>
&nbsp;<li>Successful completion. </dd>

<dt>&gt;0 </dt>
<dd>An error occurred.
<p>
</dd>
</dl>

<h2><a name='sect32' href='#toc32'>Consequences of Errors</a></h2>
<p>
If any errors are encountered, the run is aborted
and <i>yacc</i> exits with a non-zero status. Partial code files and header files
may be produced. The summary information in the description file shall always
be produced if the <b>-v</b> flag is present. <p>
<i>The following sections are informative.</i>

<h2><a name='sect33' href='#toc33'>Application Usage</a></h2>
<p>
Historical implementations experience name conflicts on
the names <b>yacc.tmp</b>, <b>yacc.acts</b>, <b>yacc.debug</b>, <b>y.tab.c</b>, <b>y.tab.h</b>, and <b>y.output</b> if more
than one copy of <i>yacc</i> is running in a single directory at one time. The
<b>-b</b> option was added to overcome this problem. The related problem of allowing
multiple <i>yacc</i> parsers to be placed in the same file was addressed by adding
a <b>-p</b> option to override the previously hard-coded <b>yy</b> variable prefix. <p>
The
description of the <b>-p</b> option specifies the minimal set of function and variable
names that cause conflict when multiple parsers are linked together. YYSTYPE
does not need to be changed. Instead, the programmer can use <b>-b</b> to give the
header files for different parsers different names, and then the file with
the <i>yylex</i>() for a given parser can include the header for that parser. Names
such as <i>yyclearerr</i> do not need to be changed because they are used only
in the actions; they do not have linkage. It is possible that an implementation
has other names, either internal ones for implementing things such as <i>yyclearerr</i>,
or providing non-standard features that it wants to change with <b>-p</b>. <p>
Unary
operators that are the same token as a binary operator in general need
their precedence adjusted. This is handled by the <b>%prec</b> advisory symbol
associated with the particular grammar rule defining that unary operator.
(See Grammar Rules in yacc .) Applications are not required to use this
operator for unary operators, but the grammars that do not require it are
rare. 
<h2><a name='sect34' href='#toc34'>Examples</a></h2>
<p>
Access to the <i>yacc</i> library is obtained with library search
operands to <i>c99</i>. To use the <i>yacc</i> library <i>main</i>(): <p>
<blockquote><br>
<pre>c99 y.tab.c -l y

</pre></blockquote>
<p>
Both the <i>lex</i> library and the <i>yacc</i> library contain <i>main</i>(). To access the
<i>yacc</i> <i>main</i>(): <p>
<blockquote><br>
<pre>c99 y.tab.c lex.yy.c -l y -l l

</pre></blockquote>
<p>
This ensures that the <i>yacc</i> library is searched first, so that its <i>main</i>()
is used. <p>
The historical <i>yacc</i> libraries have contained two simple functions
that are normally coded by the application programmer. These functions are
similar to the following code: <p>
<blockquote><br>
<pre>#include &lt;locale.h&gt;
int main(void)
{
    extern int yyparse();

    setlocale(LC_ALL, "");

    /* If the following parser is one created by lex, the
       application must be careful to ensure that LC_CTYPE
       and LC_COLLATE are set to the POSIX locale. */
    (void) yyparse();
    return (0);
}

#include &lt;stdio.h&gt;

int yyerror(const char *msg)
{
    (void) fprintf(stderr, "%s\n", msg);
    return (0);
}

</pre></blockquote>

<h2><a name='sect35' href='#toc35'>Rationale</a></h2>
<p>
The references in may be helpful in constructing the parser generator.
The referenced DeRemer and Pennello article (along with the works it references)
describes a technique to generate parsers that conform to this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001. Work in this area continues to be done, so implementors
should consult current literature before doing any new implementations.
The original Knuth article is the theoretical basis for this kind of parser,
but the tables it generates are impractically large for reasonable grammars
and should not be used. The "equivalent to" wording is intentional to assure
that the best tables that are <a href='LALR.1.html'>LALR(1)</a>
 can be generated. <p>
There has been confusion
between the class of grammars, the algorithms needed to generate parsers,
and the algorithms needed to parse the languages. They are all reasonably
orthogonal. In particular, a parser generator that accepts the full range
of <a href='LR.1.html'>LR(1)</a>
 grammars need not generate a table any more complex than one that
accepts <a href='SLR.1.html'>SLR(1)</a>
 (a relatively weak class of LR grammars) for a grammar that
happens to be <a href='SLR.1.html'>SLR(1)</a>
. Such an implementation need not recognize the case,
either; table compression can yield the <a href='SLR.1.html'>SLR(1)</a>
 table (or one even smaller
than that) without recognizing that the grammar is <a href='SLR.1.html'>SLR(1)</a>
. The speed of
an <a href='LR.1.html'>LR(1)</a>
 parser for any class is dependent more upon the table representation
and compression (or the code generation if a direct parser is generated)
than upon the class of grammar that the table generator handles. <p>
The speed
of the parser generator is somewhat dependent upon the class of grammar
it handles. However, the original Knuth article algorithms for constructing
LR parsers were judged by its author to be impractically slow at that time.
Although full LR is more complex than <a href='LALR.1.html'>LALR(1)</a>
, as computer speeds and algorithms
improve, the difference (in terms of acceptable wall-clock execution time)
is becoming less significant. <p>
Potential authors are cautioned that the referenced
DeRemer and Pennello article previously cited identifies a bug (an over-simplification
of the computation of <a href='LALR.1.html'>LALR(1)</a>
 lookahead sets) in some of the <a href='LALR.1.html'>LALR(1)</a>
 algorithm
statements that preceded it to publication. They should take the time to
seek out that paper, as well as current relevant work, particularly Aho&rsquo;s.
<p>
The <b>-b</b> option was added to provide a portable method for permitting <i>yacc</i>
to work on multiple separate parsers in the same directory. If a directory
contains more than one <i>yacc</i> grammar, and both grammars are constructed
at the same time (by, for example, a parallel <i>make</i> program), conflict results.
While the solution is not historical practice, it corrects a known deficiency
in historical implementations. Corresponding changes were made to all sections
that referenced the filenames <b>y.tab.c</b> (now "the code file"), <b>y.tab.h</b> (now "the
header file"), and <b>y.output</b> (now "the description file"). <p>
The grammar for
<i>yacc</i> input is based on System V documentation. The textual description shows
there that the <b>&rsquo;;&rsquo;</b> is required at the end of the rule. The grammar and the
implementation do not require this. (The use of <b>C_IDENTIFIER</b> causes a reduce
to occur in the right place.) <p>
Also, in that implementation, the constructs
such as <b>%token</b> can be terminated by a semicolon, but this is not permitted
by the grammar. The keywords such as <b>%token</b> can also appear in uppercase,
which is again not discussed. In most places where <b>&rsquo;%&rsquo;</b> is used, <b>&rsquo;\&rsquo;</b> can be substituted,
and there are alternate spellings for some of the symbols (for example,
<b>%LEFT</b> can be <b>"%&lt;"</b> or even <b>"\&lt;"</b> ). <p>
Historically, &lt;<i>tag</i>&gt; can contain any characters
except <b>&rsquo;&gt;&rsquo;</b>, including white space, in the implementation. However, since the
<i>tag</i> must reference an ISO&nbsp;C standard union member, in practice conforming
implementations need to support only the set of characters for ISO&nbsp;C standard
identifiers in this context. <p>
Some historical implementations are known to
accept actions that are terminated by a period. Historical implementations
often allow <b>&rsquo;$&rsquo;</b> in names. A conforming implementation does not need to support
either of these behaviors. <p>
Deciding when to use <b>%prec</b> illustrates the difficulty
in specifying the behavior of <i>yacc</i>. There may be situations in which the
<i>grammar</i> is not, strictly speaking, in error, and yet <i>yacc</i> cannot interpret
it unambiguously. The resolution of ambiguities in the grammar can in many
instances be resolved by providing additional information, such as using
<b>%type</b> or <b>%union</b> declarations. It is often easier and it usually yields a
smaller parser to take this alternative when it is appropriate. <p>
The size
and execution time of a program produced without the runtime debugging
code is usually smaller and slightly faster in historical implementations.
<p>
Statistics messages from several historical implementations include the
following types of information: <p>
<blockquote><br>
<pre>n/512 terminals, n/300 non-terminals
n/600 grammar rules, n/1500 states
n shift/reduce, n reduce/reduce conflicts reported
n/350 working sets used
Memory: states, etc. n/15000, parser n/15000
n/600 distinct lookahead sets
n extra closures
n shift entries, n exceptions
n goto entries
n entries saved by goto default
Optimizer space used: input n/15000, output n/15000
n table entries, n zero
Maximum spread: n, Maximum offset: n
</pre></blockquote>
<p>
The report of internal tables in the description file is left implementation-defined
because all aspects of these limits are also implementation-defined. Some
implementations may use dynamic allocation techniques and have no specific
limit values to report. <p>
The format of the <b>y.output</b> file is not given because
specification of the format was not seen to enhance applications portability.
The listing is primarily intended to help human users understand and debug
the parser; use of <b>y.output</b> by a conforming application script would be
unusual. Furthermore, implementations have not produced consistent output
and no popular format was apparent. The format selected by the implementation
should be human-readable, in addition to the requirement that it be a text
file. <p>
Standard error reports are not specifically described because they
are seldom of use to conforming applications and there was no reason to
restrict implementations. <p>
Some implementations recognize <b>"={"</b> as equivalent
to <b>&rsquo;{&rsquo;</b> because it appears in historical documentation. This construction was
recognized and documented as obsolete as long ago as 1978, in the referenced
<i>Yacc: Yet Another Compiler-Compiler</i>. This volume of IEEE&nbsp;Std&nbsp;1003.1-2001 chose
to leave it as obsolete and omit it. <p>
Multi-byte characters should be recognized
by the lexical analyzer and returned as tokens. They should not be returned
as multi-byte character literals. The token <b>error</b> that is used for error
recovery is normally assigned the value 256 in the historical implementation.
Thus, the token value 256, which is used in many multi-byte character sets,
is not available for use as the value of a user-defined token. 
<h2><a name='sect36' href='#toc36'>Future Directions</a></h2>
<p>
None.

<h2><a name='sect37' href='#toc37'>See Also</a></h2>
<p>
<i>c99</i>, <i>lex</i> 
<h2><a name='sect38' href='#toc38'>Copyright</a></h2>
Portions of this text are reprinted and reproduced
in electronic form from IEEE Std 1003.1, 2003 Edition, Standard for Information
Technology -- Portable Operating System Interface (POSIX), The Open Group
Base Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of
Electrical and Electronics Engineers, Inc and The Open Group. In the event
of any discrepancy between this version and the original IEEE and The Open
Group Standard, the original IEEE and The Open Group Standard is the referee
document. The original Standard can be obtained online at <a href='http://www.opengroup.org/unix/online.html'>http://www.opengroup.org/unix/online.html</a>

. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Prolog</a></li>
<li><a name='toc1' href='#sect1'>Name</a></li>
<li><a name='toc2' href='#sect2'>Synopsis</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<li><a name='toc4' href='#sect4'>Options</a></li>
<li><a name='toc5' href='#sect5'>Operands</a></li>
<li><a name='toc6' href='#sect6'>Stdin</a></li>
<li><a name='toc7' href='#sect7'>Input Files</a></li>
<li><a name='toc8' href='#sect8'>Environment Variables</a></li>
<li><a name='toc9' href='#sect9'>Asynchronous Events</a></li>
<li><a name='toc10' href='#sect10'>Stdout</a></li>
<li><a name='toc11' href='#sect11'>Stderr</a></li>
<li><a name='toc12' href='#sect12'>Output Files</a></li>
<ul>
<li><a name='toc13' href='#sect13'>Code File</a></li>
<li><a name='toc14' href='#sect14'>Header File</a></li>
<li><a name='toc15' href='#sect15'>Description File</a></li>
</ul>
<li><a name='toc16' href='#sect16'>Extended Description</a></li>
<ul>
<li><a name='toc17' href='#sect17'>Input Language</a></li>
<li><a name='toc18' href='#sect18'>Lexical Structure of the Grammar</a></li>
<li><a name='toc19' href='#sect19'>Declarations Section</a></li>
<li><a name='toc20' href='#sect20'>Grammar Rules in yacc</a></li>
<li><a name='toc21' href='#sect21'>Programs Section</a></li>
<li><a name='toc22' href='#sect22'>Input Grammar</a></li>
<li><a name='toc23' href='#sect23'>Conflicts</a></li>
<li><a name='toc24' href='#sect24'>Error Handling</a></li>
<li><a name='toc25' href='#sect25'>Interface to the Lexical Analyzer</a></li>
<li><a name='toc26' href='#sect26'>Completing the Program</a></li>
<li><a name='toc27' href='#sect27'>Yacc Library</a></li>
<li><a name='toc28' href='#sect28'>Debugging the Parser</a></li>
<li><a name='toc29' href='#sect29'>Algorithms</a></li>
<li><a name='toc30' href='#sect30'>Limits</a></li>
</ul>
<li><a name='toc31' href='#sect31'>Exit Status</a></li>
<li><a name='toc32' href='#sect32'>Consequences of Errors</a></li>
<li><a name='toc33' href='#sect33'>Application Usage</a></li>
<li><a name='toc34' href='#sect34'>Examples</a></li>
<li><a name='toc35' href='#sect35'>Rationale</a></li>
<li><a name='toc36' href='#sect36'>Future Directions</a></li>
<li><a name='toc37' href='#sect37'>See Also</a></li>
<li><a name='toc38' href='#sect38'>Copyright</a></li>
</ul>
</body>
</html>
