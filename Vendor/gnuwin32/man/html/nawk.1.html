<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>NAWK(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
nawk - pattern-directed scanning and processing language 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>nawk</b>
[ <b>-F</b> <i>fs</i> ] [ <b>-v</b> <i>var=value</i> ] [ <i>&rsquo;prog&rsquo;</i> | <b>-f</b> <i>progfile</i> ] [ <i>file</i> ... ] 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<i>Nawk</i>
scans each input <i>file</i> for lines that match any of a set of patterns specified
literally in <i>prog</i> or in one or more files specified as <b>-f</b> <i>progfile</i>. With
each pattern there can be an associated action that will be performed when
a line of a <i>file</i> matches the pattern. Each line is matched against the pattern
portion of every pattern-action statement; the associated action is performed
for each matched pattern. The file name  <b>-</b> means the standard input. Any <i>file</i>
of the form <i>var=value</i> is treated as an assignment, not a filename, and
is executed at the time it would have been opened if it were a filename.
The option <b>-v</b> followed by <i>var=value</i> is an assignment to be done before <i>prog</i>
is executed; any number of <b>-v</b> options may be present. The <b>-F</b> <i>fs</i> option defines
the input field separator to be the regular expression <i>fs.</i> <p>
An input line
is normally made up of fields separated by white space, or by regular expression
<b>FS</b>. The fields are denoted <b>$1</b>, <b>$2</b>, ..., while <b>$0</b> refers to the entire line.
If <b>FS</b> is null, the input line is split into one field per character. <p>
A pattern-action
statement has the form 
<dl>

<dt><i>pattern</i><b> { </b><i>action</i><b> }</b> </dt>
<dd></dd>
</dl>
<p>
A missing  <b>{</b><i> action </i><b>}</b> means print
the line; a missing pattern always matches. Pattern-action statements are
separated by newlines or semicolons. <p>
An action is a sequence of statements.
A statement can be one of the following: <p>
<br>
<pre>
if( expression ) statement [ else statement ]
while( expression ) statement
for( expression ; expression ; expression ) statement
for( var in array ) statement
do statement while( expression )
break
continue
{ [ statement ... ] }
expression<tt> </tt>&nbsp;<tt> </tt>&nbsp;# commonly var = expression
print [ expression-list ] [ &gt; expression ]
printf format [ , expression-list ] [ &gt; expression ]
return [ expression ]
next<tt> </tt>&nbsp;<tt> </tt>&nbsp;# skip remaining patterns on this input line
nextfile<tt> </tt>&nbsp;<tt> </tt>&nbsp;# skip rest of this file, open next, start at top
delete array[ expression ]<tt> </tt>&nbsp;<tt> </tt>&nbsp;# delete an array element
delete array<tt> </tt>&nbsp;<tt> </tt>&nbsp;# delete all elements of array
exit [ expression ]<tt> </tt>&nbsp;<tt> </tt>&nbsp;# exit immediately; status is expression
</pre></blockquote>
<br>
</pre>  <p>
Statements are terminated by semicolons, newlines or right braces. An
empty <i>expression-list</i> stands for <b>$0</b>. String constants are quoted CW"&nbsp;", with
the usual C escapes recognized within. Expressions take on string or numeric
values as appropriate, and are built using the operators <b>+ - * / % ^</b> (exponentiation),
and concatenation (indicated by white space). The operators <b></b> ! ++ -- += -=
*= /= %= ^= &gt; &gt;= &lt; &lt;= == != ?: are also available in expressions. Variables may
be scalars, array elements (denoted <i>x</i><b>[</b><i>i</i><b>]</b><i>)</i> or fields. Variables are initialized
to the null string. Array subscripts may be any string, not necessarily
numeric; this allows for a form of associative memory. Multiple subscripts
such as <b>[i,j,k]</b> are permitted; the constituents are concatenated, separated
by the value of <b>SUBSEP</b>. <p>
The <b>print</b> statement prints its arguments on the
standard output (or on a file if <b>&gt;</b><i>file</i> or <b>&gt;&gt;</b><i>file</i> is present or on a pipe if
<b>|</b><i>cmd</i> is present), separated by the current output field separator, and terminated
by the output record separator. <i>file</i> and <i>cmd</i> may be literal names or parenthesized
expressions; identical string values in different statements denote the
same open file. The <b>printf</b> statement formats its expression list according
to the format (see <a href='printf.3.html'><i>printf</i>(3)</a>
)<i>.</i> The built-in function <b>close(</b><i>expr</i><b>)</b> closes the
file or pipe <i>expr</i>. The built-in function <b>fflush(</b><i>expr</i><b>)</b> flushes any buffered
output for the file or pipe <i>expr</i>. <p>
The mathematical functions <b>exp</b>, <b>log</b>, <b>sqrt</b>,
<b>sin</b>, <b>cos</b>, and <b>atan2</b> are built in. Other built-in functions:  
<dl>

<dt><b>length</b> </dt>
<dd>the length
of its argument taken as a string, or of <b>$0</b> if no argument. </dd>

<dt><b>rand</b> </dt>
<dd>random
number on (0,1) </dd>

<dt><b>srand</b> </dt>
<dd>sets seed for <b>rand</b> and returns the previous seed.
</dd>

<dt><b>int</b> </dt>
<dd>truncates to an integer value </dd>

<dt><b>substr(</b><i>s</i><b>,</b><i> m</i><b>,</b><i> n<b>)</i> </b></dt>
<dd>the <i>n</i>-character substring
of <i>s</i> that begins at position <i>m</i> counted from 1. </dd>

<dt><b>index(</b><i>s</i><b>,</b><i> t</i><b>)</b> </dt>
<dd>the position
in <i>s</i> where the string <i>t</i> occurs, or 0 if it does not. </dd>

<dt><b>match(</b><i>s</i><b>,</b><i> r</i><b>)</b> </dt>
<dd>the position
in <i>s</i> where the regular expression <i>r</i> occurs, or 0 if it does not. The variables
<b>RSTART</b> and <b>RLENGTH</b> are set to the position and length of the matched string.
</dd>

<dt><b>split(</b><i>s</i><b>,</b><i> a</i><b>,</b><i> fs<b>)</i> </b></dt>
<dd>splits the string <i>s</i> into array elements <i>a</i><b>[1]</b><i>,</i> <i>a</i><b>[2]</b><i>,</i> ..., <i>a</i><b>[</b><i>n</i><b>]</b><i>,</i>
and returns <i>n</i>. The separation is done with the regular expression <i>fs</i> or
with the field separator <b>FS</b> if <i>fs</i> is not given. An empty string as field
separator splits the string into one array element per character. </dd>

<dt><b>sub(</b><i>r</i><b>,</b><i>
t</i><b>,</b><i> s<b>)</i> </b></dt>
<dd>substitutes <i>t</i> for the first occurrence of the regular expression
<i>r</i> in the string <i>s</i>. If <i>s</i> is not given, <b>$0</b> is used. </dd>

<dt><b>gsub</b> </dt>
<dd>same as <b>sub</b> except
that all occurrences of the regular expression are replaced; <b>sub</b> and <b>gsub</b>
return the number of replacements. </dd>

<dt><b>sprintf(</b><i>fmt</i><b>,</b><i> expr</i><b>,</b><i> ...<b> )</i> </b></dt>
<dd>the string resulting
from formatting <i>expr</i> ... according to the <a href='printf.3.html'><i>printf</i>(3)</a>
 format <i>fmt</i> </dd>

<dt><b>system(</b><i>cmd</i><b>)</b>
</dt>
<dd>executes <i>cmd</i> and returns its exit status </dd>

<dt><b>tolower(</b><i>str</i><b>)</b> </dt>
<dd>returns a copy of
<i>str</i> with all upper-case characters translated to their corresponding lower-case
equivalents. </dd>

<dt><b>toupper(</b><i>str</i><b>)</b> </dt>
<dd>returns a copy of <i>str</i> with all lower-case characters
translated to their corresponding upper-case equivalents.  </dd>
</dl>
<p>
The &lsquo;&lsquo;function&rsquo;&rsquo; <b>getline</b>
sets <b>$0</b> to the next input record from the current input file; <b>getline</b> <b>&lt;</b><i>file</i>
sets <b>$0</b> to the next record from <i>file</i>. <b>getline</b> <i>x</i> sets variable <i>x</i> instead.
Finally, <i>cmd</i><b> | getline</b> pipes the output of <i>cmd</i> into <b>getline</b>; each call of
<b>getline</b> returns the next line of output from <i>cmd</i>. In all cases, <b>getline</b>
returns 1 for a successful input, 0 for end of file, and -1 for an error.
<p>
Patterns are arbitrary Boolean combinations (with <b>! || &amp;&amp;</b>) of regular expressions
and relational expressions. Regular expressions are as in <i>egrep</i>;<i></i> see <a href='grep.1.html'><i>grep</i>(1)</a>
.
Isolated regular expressions in a pattern apply to the entire line. Regular
expressions may also occur in relational expressions, using the operators
<b>~</b> and <b>!~</b>. <b>/</b><i>re</i><b>/</b> is a constant regular expression; any string (constant or
variable) may be used as a regular expression, except in the position of
an isolated regular expression in a pattern. <p>
A pattern may consist of two
patterns separated by a comma; in this case, the action is performed for
all lines from an occurrence of the first pattern though an occurrence
of the second. <p>
A relational expression is one of the following: 
<dl>

<dt><i>expression</i>
matchop regular-expression </dt>
<dd><br>
<i>expression</i> relop expression <br>
<i>expression</i><b> in </b><i>array-name</i> <br>
<b>(</b><i>expr</i><b>,</b><i>expr,...</i><b>) in </b><i>array-name</i> </dd>
</dl>
<p>
where a relop is any of the six relational operators
in C, and a matchop is either <b>~</b> (matches) or <b>!~</b> (does not match). A conditional
is an arithmetic expression, a relational expression, or a Boolean combination
of these. <p>
The special patterns <b>BEGIN</b> and <b>END</b> may be used to capture control
before the first input line is read and after the last. <b>BEGIN</b> and <b>END</b> do
not combine with other patterns. <p>
Variable names with special meanings: 

<dl>

<dt><b>CONVFMT</b> </dt>
<dd>conversion format used when converting numbers (default <b>%.6g</b>) </dd>

<dt><b>FS</b>
</dt>
<dd>regular expression used to separate fields; also settable by option <b>-F</b><i>fs.</i>
</dd>

<dt><b>NF</b> </dt>
<dd>number of fields in the current record </dd>

<dt><b>NR</b> </dt>
<dd>ordinal number of the current
record </dd>

<dt><b>FNR</b> </dt>
<dd>ordinal number of the current record in the current file </dd>

<dt><b>FILENAME</b>
</dt>
<dd>the name of the current input file </dd>

<dt><b>RS</b> </dt>
<dd>input record separator (default newline)
</dd>

<dt><b>OFS</b> </dt>
<dd>output field separator (default blank) </dd>

<dt><b>ORS</b> </dt>
<dd>output record separator
(default newline) </dd>

<dt><b>OFMT</b> </dt>
<dd>output format for numbers (default <b>%.6g</b>) </dd>

<dt><b>SUBSEP</b> </dt>
<dd>separates
multiple subscripts (default 034) </dd>

<dt><b>ARGC</b> </dt>
<dd>argument count, assignable </dd>

<dt><b>ARGV</b>
</dt>
<dd>argument array, assignable; non-null members are taken as filenames </dd>

<dt><b>ENVIRON</b>
</dt>
<dd>array of environment variables; subscripts are names.  </dd>
</dl>
<p>
Functions may be
defined (at the position of a pattern-action statement) thus: 
<dl>

<dt><b></b> function
foo(a, b, c) { ...; return x } </dt>
<dd></dd>
</dl>
<p>
Parameters are passed by value if scalar and
by reference if array name; functions may be called recursively. Parameters
are local to the function; all other variables are global. Thus local variables
may be created by providing excess parameters in the function definition.

<h2><a name='sect3' href='#toc3'>Examples</a></h2>
<br>
<pre>

</pre>
<dl>

<dt>length($0) &gt; 72 </dt>
<dd>Print lines longer than 72 characters. <br>
<pre>

</pre></dd>

<dt>{ print $2, $1 } </dt>
<dd>Print first two fields in opposite order. </dd>
</dl>
<p>
<br>
<pre>BEGIN { FS = ",[ \t]*|[ \t]+" }
      { print $2, $1 }

</pre>  
<dl>

<dt>Same, with input fields separated by comma and/or blanks and tabs. </dt>
<dd></dd>
</dl>
<p>
<br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{ s += $1 }
END<tt> </tt>&nbsp;<tt> </tt>&nbsp;{ print "sum is", s, " average is", s/NR }
</pre><br>
</pre>  
<dl>

<dt>Add up first column, print sum and average. </dt>
<dd><br>
<pre>

</pre></dd>

<dt>/start/, /stop/ </dt>
<dd>Print all lines between start/stop pairs. </dd>
</dl>
<p>
<br>
<pre>
BEGIN<tt> </tt>&nbsp;<tt> </tt>&nbsp;{<tt> </tt>&nbsp;<tt> </tt>&nbsp;# Simulate echo(1)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;for (i = 1; i &lt; ARGC; i++) printf "%s ", ARGV[i]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;printf "\n"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;exit }
</pre><br>
</pre> 
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='lex.1.html'><i>lex</i>(1)</a>
,<i></i> <a href='sed.1.html'><i>sed</i>(1)</a>
 <br>
A. V. Aho, B. W. Kernighan, P. J. Weinberger, <i></i> The AWK Programming Language,
Addison-Wesley, 1988.  ISBN 0-201-07981-X 
<h2><a name='sect5' href='#toc5'>Bugs</a></h2>
There are no explicit conversions
between numbers and strings. To force an expression to be treated as a number
add 0 to it; to force it to be treated as a string concatenate CW"" to
it. <br>
The scope rules for variables in functions are a botch; the syntax is worse.
<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Examples</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
<li><a name='toc5' href='#sect5'>Bugs</a></li>
</ul>
</body>
</html>
