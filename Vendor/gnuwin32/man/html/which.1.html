<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>WHICH(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
   
<h2><a name='sect0' href='#toc0'>Name</a></h2>
which - shows the full path of (shell) commands. 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>which</b> [options]
[--] programname [...] 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<b>Which</b> takes one or more arguments. For each
of its arguments it prints to stdout the full path of the executables that
would have been executed when this argument had been entered at the shell
prompt. It does this by searching for an executable or script in the directories
listed in the environment variable <b>PATH</b> using the same algorithm as <a href='bash.1.html'><b>bash(1)</b></a>
.

<p> This man page is generated from the file <i>which.texinfo</i>. 
<h2><a name='sect3' href='#toc3'>Options</a></h2>

<p> 
<dl>

<dt><b>--all, <b>-a</b></b> </dt>
<dd>Print
all matching executables in <b>PATH</b>, not just the first. </dd>

<dt><b>--read-alias, <b>-i</b></b> </dt>
<dd>Read
aliases from stdin, reporting matching ones on stdout. This is useful in
combination with using an alias for which itself. For example <br>
<b></b> alias which=&rsquo;alias | which -i&rsquo;. </dd>

<dt><b>--skip-alias</b> </dt>
<dd>Ignore option &lsquo;--read-alias&rsquo;, if any. This
is useful to explicity search for normal binaries, while using the &lsquo;--read-alias&rsquo;
option in an alias or function for which. </dd>

<dt><b>--read-functions</b> </dt>
<dd>Read shell function
definitions from stdin, reporting matching ones on stdout. This is useful
in combination with using a shell function for which itself.  For example:
<br>
<b></b> which() { declare -f | which --read-functions $@ } <br>
export -f which </dd>

<dt><b>--skip-functions</b> </dt>
<dd>Ignore option &lsquo;--read-functions&rsquo;, if any. This is
useful to explicity search for normal binaries, while using the &lsquo;--read-functions&rsquo;
option in an alias or function for which. </dd>

<dt><b>--skip-dot</b> </dt>
<dd>Skip directories in <b>PATH</b>
that start with a dot. </dd>

<dt><b>--skip-tilde</b> </dt>
<dd>Skip directories in <b>PATH</b> that start with
a tilde and executables which reside in the <b>HOME</b> directory. </dd>

<dt><b>--show-dot</b> </dt>
<dd>If a
directory in <b>PATH</b> starts with a dot and a matching executable was found
for that path, then print "./programname" rather than the full path. </dd>

<dt><b>--show-tilde</b>
</dt>
<dd>Output a tilde when a directory matches the <b>HOME</b> directory. This option
is ignored when which is invoked as root. </dd>

<dt><b>--tty-only</b> </dt>
<dd>Stop processing options
on the right if not on tty. </dd>

<dt><b>--version,-v,-V</b> </dt>
<dd>Print version information on standard
output then exit successfully. </dd>

<dt><b>--help</b> </dt>
<dd>Print usage information on standard
output then exit successfully. </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Return Value</a></h2>
<b>Which</b> returns the number of failed
arguments, or -1 when no &lsquo;programname&rsquo; was given. 
<h2><a name='sect5' href='#toc5'>Example</a></h2>
The recommended way
to use this utility is by adding an alias (C shell) or shell function (Bourne
shell) for <b>which</b> like the following: 
<p> [ba]sh: 
<p>  <br>
<pre>which ()
{
  (alias; declare -f) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde
--show-dot $@
}
export -f which
</pre>
<p> [t]csh: 
<p>  <br>
<pre>alias which &rsquo;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&rsquo;
</pre>
<p> This will print the readable ~/ and ./ when starting which from your prompt,
while still printing the full path when used from a script: 
<p>  <br>
<pre>&gt; which q2
~/bin/q2
&gt; echo &lsquo;which q2&lsquo;
/home/carlo/bin/q2
</pre>
<p> 
<h2><a name='sect6' href='#toc6'>Bugs</a></h2>
The <b>HOME</b> directory is determined by looking for the <b>HOME</b> environment
variable, which aborts when this variable doesn&rsquo;t exist.  <b>Which</b> will consider
two equivalent directories to be different when one of them contains a
path with a symbolic link. 
<h2><a name='sect7' href='#toc7'>Author</a></h2>
<br>
Carlo Wood &lt;carlo@gnu.org&gt; 
<h2><a name='sect8' href='#toc8'>See Also</a></h2>
<a href='bash.1.html'><b>bash(1)</b></a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Return Value</a></li>
<li><a name='toc5' href='#sect5'>Example</a></li>
<li><a name='toc6' href='#sect6'>Bugs</a></li>
<li><a name='toc7' href='#sect7'>Author</a></li>
<li><a name='toc8' href='#sect8'>See Also</a></li>
</ul>
</body>
</html>
