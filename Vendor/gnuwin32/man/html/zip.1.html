               <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>ZIP(1L) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
zip - package and compress (archive) files 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>zip</b>
[-<b>aABcdDeEfFghjklLmoqrRSTuvVwXyz!@$</b>] [--longoption ...] [-<b>b</b> path] [-<b>n</b> suffixes]
[-<b>t</b> date] [-<b>tt</b> date] [<i>zipfile</i> [<i>file</i> ...]] [<b>-xi</b> list] <p>
<b>zipcloak</b> (see separate man
page) <p>
<b>zipnote</b> (see separate man page) <p>
<b>zipsplit</b> (see separate man page)
<p>
Note:  Command line processing in <i>zip</i> has been changed to support long
options and handle all options and arguments more consistently.  Some old
command lines that depend on command line inconsistencies may no longer
work. 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<i>zip</i> is a compression and file packaging utility for Unix,
VMS, MSDOS, OS/2, Windows 9x/NT/XP, Minix, Atari, Macintosh, Amiga, and
Acorn RISC OS.  It is analogous to a combination of the Unix commands <a href='tar.1.html'><i>tar</i>(1)</a>

and <a href='compress.1.html'><i>compress</i>(1)</a>
 and is compatible with PKZIP (Phil Katz&rsquo;s ZIP for MSDOS
systems). <p>
A companion program (<a href='unzip.1L.html'><i>unzip</i>(1L)</a>
)<i></i> unpacks <i>zip</i> archives. The <i>zip</i> and
<a href='unzip.1L.html'><i>unzip</i>(1L)</a>
 programs can work with archives produced by PKZIP (supporting
most PKZIP features up to PKZIP version 4.6), and PKZIP and PKUNZIP can
work with archives produced by <i>zip</i> (with some exceptions, notably streamed
archives, but recent changes in the zip file standard may facilitate better
compatibility). <i>zip</i> version 3.0 is compatible with PKZIP 2.04 and also supports
the Zip64 extensions of PKZIP 4.5 which allow archives as well as files
to exceed the previous 2 GB limit (4 GB in some cases).  <i>zip</i> also now supports
<b>bzip2</b> compression if the <b>bzip2</b> library is included when <i>zip</i> is compiled.
Note that PKUNZIP 1.10 cannot extract files produced by PKZIP 2.04 or <i>zip&nbsp;3.0</i>.
You must use PKUNZIP 2.04g or <i>unzip&nbsp;5.0p1</i> (or later versions) to extract them.
<p>
See the <b>EXAMPLES</b> section at the bottom of this page for examples of some
typical uses of <i>zip</i>. <p>
<b>Large&nbsp;Archives&nbsp;and&nbsp;Zip64.</b> <i>zip</i> automatically uses the Zip64
extensions when files larger than 4 GB are added to an archive, an archive
containing Zip64 entries is updated (if the resulting archive still needs
Zip64), the size of the archive will exceed 4 GB, or when the number of
entries in the archive will exceed about 64K. Zip64 is also used for archives
streamed from standard input as the size of such archives are not known
in advance, but the option <b>-fz-</b> can be used to force <i>zip</i> to create PKZIP
2 compatible archives (as long as Zip64 extensions are not needed).  You
must use a PKZIP 4.5 compatible unzip, such as <i>unzip&nbsp;6.0</i> or later, to extract
files using the Zip64 extensions. <p>
In addition, streamed archives, entries
encrypted with standard encryption, or split archives created with the
pause option may not be compatible with PKZIP as data descriptors are used
and PKZIP at the time of this writing does not support data descriptors
(but recent changes in the PKWare published zip standard now include some
support for the data descriptor format <i>zip</i> uses). 
<p> <p>
<b>Mac OS X.</b>  Though previous
Mac versions had their own <i>zip</i> port, <i>zip</i> supports Mac OS X as part of the
Unix port and most Unix features apply.  References to "MacOS" below generally
refer to MacOS versions older than OS X.  Support for some Mac OS features
in the Unix Mac OS X port, such as resource forks, is expected in the next
<i>zip</i> release. 
<p> <p>
For a brief help on <i>zip</i> and <i>unzip</i>, run each without specifying
any parameters on the command line. 
<p> 
<h2><a name='sect3' href='#toc3'>Use</a></h2>
<p>
The program is useful for packaging
a set of files for distribution; for archiving files; and for saving disk
space by temporarily compressing unused files or directories. <p>
The <i>zip</i> program
puts one or more compressed files into a single <i>zip</i> archive, along with
information about the files (name, path, date, time of last modification,
protection, and check information to verify file integrity). An entire directory
structure can be packed into a <i>zip</i> archive with a single command. Compression
ratios of 2:1 to 3:1 are common for text files. <i>zip</i> has one compression
method (deflation) and can also store files without compression.  (If <b>bzip2</b>
support is added, <i>zip</i> can also compress using <b>bzip2</b> compression, but such
entries require a reasonably modern unzip to decompress.  When <b>bzip2</b> compression
is selected, it replaces deflation as the default method.) <i>zip</i> automatically
chooses the better of the two (deflation or store or, if <b>bzip2</b> is selected,
<b>bzip2</b> or store) for each file to be compressed. <p>
<b>Command&nbsp;format.</b>  The basic
command format is 
<dl>

<dt><b>zip</b> options archive inpath inpath ... </dt>
<dd></dd>
</dl>
<p>
where <b>archive</b> is a
new or existing <i>zip</i> archive and <b>inpath</b> is a directory or file path optionally
including wildcards. When given the name of an existing <i>zip</i> archive, <i>zip</i>
will replace identically named entries in the <i>zip</i> archive (matching the
relative names as stored in the archive) or add entries for new names. For
example, if <i>foo.zip</i> exists and contains <i>foo/file1</i> and <i>foo/file2</i>, and the
directory <i>foo</i> contains the files <i>foo/file1</i> and <i>foo/file3</i>, then: 
<dl>

<dt>zip -r foo.zip
foo </dt>
<dd></dd>
</dl>
<p>
or more concisely 
<dl>

<dt>zip -r foo foo </dt>
<dd></dd>
</dl>
<p>
will replace <i>foo/file1</i> in <i>foo.zip</i> and
add <i>foo/file3</i> to <i>foo.zip</i>. After this, <i>foo.zip</i> contains <i>foo/file1</i>, <i>foo/file2</i>,
and <i>foo/file3</i>, with <i>foo/file2</i> unchanged from before. <p>
So if before the zip
command is executed <i>foo.zip</i> has: 
<dl>

<dt> foo/file1 foo/file2 </dt>
<dd></dd>
</dl>
<p>
and directory foo
has: 
<dl>

<dt> file1 file3 </dt>
<dd></dd>
</dl>
<p>
then <i>foo.zip</i> will have: 
<dl>

<dt> foo/file1 foo/file2 foo/file3
</dt>
<dd></dd>
</dl>
<p>
where <i>foo/file1</i> is replaced and <i>foo/file3</i> is new. <p>
<b>-@&nbsp;file&nbsp;lists.</b>  If a file
list is specified as <b>-@</b> [Not on MacOS], <i>zip</i> takes the list of input files
from standard input instead of from the command line.  For example, 
<dl>

<dt>zip
-@ foo </dt>
<dd></dd>
</dl>
<p>
will store the files listed one per line on stdin in <i>foo.zip</i>. <p>
Under
Unix, this option can be used to powerful effect in conjunction with the
<a href='find.1.html'><i>find</i>&nbsp;(1)</a>
 command. For example, to archive all the C source files in the current
directory and its subdirectories: 
<dl>

<dt>find . -name "*.[ch]" -print | zip source
-@ </dt>
<dd></dd>
</dl>
<p>
(note that the pattern must be quoted to keep the shell from expanding
it). <p>
<b>Streaming&nbsp;input&nbsp;and&nbsp;output.</b> <i>zip</i> will also accept a single dash ("-") as
the zip file name, in which case it will write the zip file to standard
output, allowing the output to be piped to another program. For example:

<dl>

<dt>zip -r - . | dd of=/dev/nrst0 obs=16k </dt>
<dd></dd>
</dl>
<p>
would write the zip output directly to
a tape with the specified block size for the purpose of backing up the
current directory. <p>
<i>zip</i> also accepts a single dash ("-") as the name of a
file to be compressed, in which case it will read the file from standard
input, allowing zip to take input from another program. For example: 
<dl>

<dt>tar
cf - . | zip backup - </dt>
<dd></dd>
</dl>
<p>
would compress the output of the tar command for the
purpose of backing up the current directory. This generally produces better
compression than the previous example using the -r option because <i>zip</i> can
take advantage of redundancy between files. The backup can be restored using
the command 
<dl>

<dt>unzip -p backup | tar xf - </dt>
<dd></dd>
</dl>
<p>
When no zip file name is given and
stdout is not a terminal, <i>zip</i> acts as a filter, compressing standard input
to standard output. For example, 
<dl>

<dt>tar cf - . | zip | dd of=/dev/nrst0 obs=16k
</dt>
<dd></dd>
</dl>
<p>
is equivalent to 
<dl>

<dt>tar cf - . | zip - - | dd of=/dev/nrst0 obs=16k </dt>
<dd></dd>
</dl>
<p>
<i>zip</i> archives
created in this manner can be extracted with the program <i>funzip</i> which is
provided in the <i>unzip</i> package, or by <i>gunzip</i> which is provided in the <i>gzip</i>
package (but some <i>gunzip</i> may not support this if <i>zip</i> used the Zip64 extensions).
For example: 
<dl>

<dt>dd if=/dev/nrst0  ibs=16k | funzip | tar xvf - </dt>
<dd></dd>
</dl>
<p>
The stream can
also be saved to a file and <i>unzip</i> used. <p>
If Zip64 support for large files
and archives is enabled and <i>zip</i> is used as a filter, <i>zip</i> creates a Zip64
archive that requires a PKZIP 4.5 or later compatible unzip to read it. 
This is to avoid amgibuities in the zip file structure as defined in the
current zip standard (PKWARE AppNote) where the decision to use Zip64 needs
to be made before data is written for the entry, but for a stream the size
of the data is not known at that point.  If the data is known to be smaller
than 4 GB, the option <b>-fz-</b> can be used to prevent use of Zip64, but <i>zip</i> will
exit with an error if Zip64 was in fact needed. <i>zip&nbsp;3</i> and <i>unzip&nbsp;6</i> and later
can read archives with Zip64 entries.  Also, <i>zip</i> removes the Zip64 extensions
if not needed when archive entries are copied (see the <b>-U</b> (<b>--copy</b>) option).
<p>
When directing the output to another file, note that all options should
be before the redirection including <b>-x</b>.  For example: 
<dl>

<dt>zip archive "*.h" "*.c"
-x donotinclude.h orthis.h &gt; tofile </dt>
<dd></dd>
</dl>
<p>
<b>Zip&nbsp;files.</b>  When changing an existing <i>zip</i>
archive, <i>zip</i> will write a temporary file with the new contents, and only
replace the old one when the process of creating the new version has been
completed without error. <p>
If the name of the <i>zip</i> archive does not contain
an extension, the extension <b>.zip</b> is added. If the name already contains an
extension other than <b>.zip</b>, the existing extension is kept unchanged.  However,
split archives (archives split over multiple files) require the <b>.zip</b> extension
on the last split. <p>
<b>Scanning&nbsp;and&nbsp;reading&nbsp;files.</b> When <i>zip</i> starts, it scans for
files to process (if needed).  If this scan takes longer than about 5 seconds,
<i>zip</i> will display a "Scanning files" message and start displaying progress
dots every 2 seconds or every so many entries processed, whichever takes
longer.  If there is more than 2 seconds between dots it could indicate
that finding each file is taking time and could mean a slow network connection
for example. (Actually the initial file scan is a two-step process where
the directory scan is followed by a sort and these two steps are separated
with a space in the dots.  If updating an existing archive, a space also
appears between the existing file scan and the new file scan.)  The scanning
files dots are not controlled by the <b>-ds</b> dot size option, but the dots are
turned off by the <b>-q</b> quiet option.  The <b>-sf</b> show files option can be used
to scan for files and get the list of files scanned without actually processing
them. <p>
If <i>zip</i> is not able to read a file, it issues a warning but continues.
 See the <b>-MM</b> option below for more on how <i>zip</i> handles patterns that are
not matched and files that are not readable. If some files were skipped,
a warning is issued at the end of the zip operation noting how many files
were read and how many skipped. <p>
<b>Command&nbsp;modes.</b>  <i>zip</i> now supports two distinct
types of command modes, <b>external</b> and <b>internal</b>.  The <b>external</b> modes (add,
update, and freshen) read files from the file system (as well as from an
existing archive) while the <b>internal</b> modes (delete and copy) operate exclusively
on entries in an existing archive. <p>

<dl>

<dt><b>add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b> </dt>
<dd>Update existing entries and add new
files.  If the archive does not exist create it.  This is the default mode.
</dd>

<dt><b>update&nbsp;(<b>-u</b>)</b> </dt>
<dd>Update existing entries if newer on the file system and add new
files.  If the archive does not exist issue warning then create a new archive.
</dd>

<dt><b>freshen&nbsp;(<b>-f</b>)</b> </dt>
<dd>Update existing entries of an archive if newer on the file system.
Does not add new files to the archive. </dd>

<dt><b>delete&nbsp;(<b>-d</b>)</b> </dt>
<dd>Select entries in an existing
archive and delete them. </dd>

<dt><b>copy&nbsp;(<b>-U</b>)</b> </dt>
<dd>Select entries in an existing archive and
copy them to a new archive. This new mode is similar to <b>update</b> but command
line patterns select entries in the existing archive rather than files
from the file system and it uses the <b>--out</b> option to write the resulting
archive to a new file rather than update the existing archive, leaving
the original archive unchanged. </dd>
</dl>
<p>
The new File Sync option (<b>-FS</b>) is also considered
a new mode, though it is similar to <b>update</b>.  This mode synchronizes the
archive with the files on the OS, only replacing files in the archive if
the file time or size of the OS file is different, adding new files, and
deleting entries from the archive where there is no matching file.  As this
mode can delete entries from the archive, consider making a backup copy
of the archive. 
<p> Also see <b>-DF</b> for creating difference archives. 
<p> See each
option description below for details and the <b>EXAMPLES</b> section below for
examples. <p>
<b>Split&nbsp;archives.</b>  <i>zip</i> version 3.0 and later can create split archives.
 A <b>split archive</b> is a standard zip archive split over multiple files.  (Note
that split archives are not just archives split in to pieces, as the offsets
of entries are now based on the start of each split.  Concatenating the
pieces together will invalidate these offsets, but <i>unzip</i> can usually deal
with it.  <i>zip</i> will usually refuse to process such a spliced archive unless
the <b>-FF</b> fix option is used to fix the offsets.) <p>
One use of split archives
is storing a large archive on multiple removable media. For a split archive
with 20 split files the files are typically named (replace ARCHIVE with
the name of your archive) ARCHIVE.z01, ARCHIVE.z02, ..., ARCHIVE.z19, ARCHIVE.zip.
 Note that the last file is the <b>.zip</b> file.  In contrast, <b>spanned archives</b>
are the original multi-disk archive generally requiring floppy disks and
using volume labels to store disk numbers.  <i>zip</i> supports split archives
but not spanned archives, though a procedure exists for converting split
archives of the right size to spanned archives.  The reverse is also true,
where each file of a spanned archive can be copied in order to files with
the above names to create a split archive. <p>
Use <b>-s</b> to set the split size and
create a split archive.  The size is given as a number followed optionally
by one of k (kB), m (MB), g (GB), or t (TB) (the default is m).  The <b>-sp</b>
option can be used to pause <i>zip</i> between splits to allow changing removable
media, for example, but read the descriptions and warnings for both <b>-s</b> and
<b>-sp</b> below. <p>
Though <i>zip</i> does not update split archives, <i>zip</i> provides the new
option <b>-O</b> (<b>--output-file</b> or <b>--out</b>) to allow split archives to be updated and
saved in a new archive.  For example, 
<dl>

<dt>zip inarchive.zip foo.c bar.c --out outarchive.zip
</dt>
<dd></dd>
</dl>
<p>
reads archive <b>inarchive.zip</b>, even if split, adds the files <b>foo.c</b> and <b>bar.c</b>,
and writes the resulting archive to <b>outarchive.zip</b>.  If <b>inarchive.zip</b> is split
then <b>outarchive.zip</b> defaults to the same split size.  Be aware that if <b>outarchive.zip</b>
and any split files that are created with it already exist, these are always
overwritten as needed without warning.  This may be changed in the future.
<p>
<b>Unicode.</b>  Though the zip standard requires storing paths in an archive using
a specific character set, in practice zips have stored paths in archives
in whatever the local character set is.  This creates problems when an archive
is created or updated on a system using one character set and then extracted
on another system using a different character set.  When compiled with Unicode
support enabled on platforms that support wide characters, <i>zip</i> now stores,
in addition to the standard local path for backward compatibility, the
UTF-8 translation of the path. This provides a common universal character
set for storing paths that allows these paths to be fully extracted on
other systems that support Unicode and to match as close as possible on
systems that don&rsquo;t. 
<p> On Win32 systems where paths are internally stored as
Unicode but represented in the local character set, it&rsquo;s possible that some
paths will be skipped during a local character set directory scan.  <i>zip</i>
with Unicode support now can read and store these paths.  Note that Win
9x systems and FAT file systems don&rsquo;t fully support Unicode. 
<p> Be aware that
console windows on Win32 and Unix, for example, sometimes don&rsquo;t accurately
show all characters due to how each operating system switches in character
sets for display.  However, directory navigation tools should show the correct
paths if the needed fonts are loaded. <p>
<b>Command line format.</b>  This version
of <i>zip</i> has updated command line processing and support for long options.
<p>
Short options take the form 
<dl>

<dt>-s[-][s[-]...][value][=value][&nbsp;value] </dt>
<dd></dd>
</dl>
<p>
where s is a
one or two character short option.  A short option that takes a value is
last in an argument and anything after it is taken as the value.  If the
option can be negated and "-" immediately follows the option, the option
is negated. Short options can also be given as separate arguments 
<dl>

<dt>-s[-][value][=value][&nbsp;value]&nbsp;-s[-][value][=value][&nbsp;value]&nbsp;...
</dt>
<dd></dd>
</dl>
<p>
Short options in general take values either as part of the same argument
or as the following argument.  An optional = is also supported. So 
<dl>

<dt>-ttmmddyyyy
</dt>
<dd></dd>
</dl>
<p>
and 
<dl>

<dt>-tt=mmddyyyy </dt>
<dd></dd>
</dl>
<p>
and 
<dl>

<dt>-tt mmddyyyy </dt>
<dd></dd>
</dl>
<p>
all work.  The <b>-x</b> and <b>-i</b> options accept lists
of values and use a slightly different format described below.  See the
<b>-x</b> and <b>-i</b> options. <p>
Long options take the form 
<dl>

<dt>--longoption[-][=value][ value]
</dt>
<dd></dd>
</dl>
<p>
where the option starts with --, has a multicharacter name, can include a
trailing dash to negate the option (if the option supports it), and can
have a value (option argument) specified by preceeding it with = (no spaces).
 Values can also follow the argument.  So 
<dl>

<dt>--before-date=mmddyyyy </dt>
<dd></dd>
</dl>
<p>
and 
<dl>

<dt>--before-date
mmddyyyy </dt>
<dd></dd>
</dl>
<p>
both work. 
<p> Long option names can be shortened to the shortest
unique abbreviation.  See the option descriptions below for which support
long options.  To avoid confusion, avoid abbreviating a negatable option
with an embedded dash ("-") at the dash if you plan to negate it (the parser
would consider a trailing dash, such as for the option <b>--some-option</b> using
<b>--some-</b> as the option, as part of the name rather than a negating dash).  This
may be changed to force the last dash in <b>--some-</b> to be negating in the future.

<h2><a name='sect4' href='#toc4'>Options</a></h2>

<dl>

<dt> <b>-a</b> </dt>
<dd></dd>

<dt> <b>--ascii</b> </dt>
<dd>[Systems using EBCDIC] Translate file to ASCII format.

<p> </dd>

<dt> <b>-A</b> </dt>
<dd></dd>

<dt> <b>--adjust-sfx</b> </dt>
<dd>Adjust self-extracting executable archive. A self-extracting
executable archive is created by prepending the SFX stub to an existing
archive. The <b>-A</b> option tells <i>zip</i> to adjust the entry offsets stored in the
archive to take into account this "preamble" data. </dd>
</dl>
<p>
Note: self-extracting
archives for the Amiga are a special case. At present, only the Amiga port
of <i>zip</i> is capable of adjusting or updating these without corrupting them.
-J can be used to remove the SFX stub if other updates need to be made. 
<p>

<dl>

<dt> <b>-AC</b> </dt>
<dd></dd>

<dt> <b>--archive-clear</b> </dt>
<dd>[WIN32]  Once archive is created (and tested if <b>-T</b> is
used, which is recommended), clear the archive bits of files processed.
 WARNING: Once the bits are cleared they are cleared.  You may want to use
the <b>-sf</b> show files option to store the list of files processed in case the
archive operation must be repeated.  Also consider using the <b>-MM</b> must match
option.  Be sure to check out <b>-DF</b> as a possibly better way to do incremental
backups. 
<p> </dd>

<dt> <b>-AS</b> </dt>
<dd></dd>

<dt> <b>--archive-set</b> </dt>
<dd>[WIN32]  Only include files that have the archive
bit set.  Directories are not stored when <b>-AS</b> is used, though by default
the paths of entries, including directories, are stored as usual and can
be used by most unzips to recreate directories. 
<p> The archive bit is set
by the operating system when a file is modified and, if used with <b>-AC</b>, <b>-AS</b>
can provide an incremental backup capability.  However, other applications
can modify the archive bit and it may not be a reliable indicator of which
files have changed since the last archive operation.  Alternative ways to
create incremental backups are using <b>-t</b> to use file dates, though this won&rsquo;t
catch old files copied to directories being archived, and <b>-DF</b> to create
a differential archive. 
<p> </dd>

<dt> <b>-B</b> </dt>
<dd></dd>

<dt> <b>--binary</b> </dt>
<dd>[VM/CMS and MVS] force file to be read
binary (default is text). 
<p> </dd>

<dt><b>-Bn</b> </dt>
<dd>[TANDEM] set Edit/Enscribe formatting options
with n defined as <blockquote>bit  0: Don&rsquo;t add delimiter (Edit/Enscribe) </dd>
</dl>
</blockquote>
<blockquote>bit  1: Use
LF rather than CR/LF as delimiter (Edit/Enscribe) </blockquote>
<blockquote>bit  2: Space fill record
to maximum record length (Enscribe) </blockquote>
<blockquote>bit  3: Trim trailing space (Enscribe)
</blockquote>
<blockquote>bit  8: Force 30K (Expand) large read for unstructured files </blockquote>

<p> 
<dl>

<dt> <b>-b&nbsp;path</b> </dt>
<dd></dd>

<dt> <b>--temp-path&nbsp;path</b>
</dt>
<dd>Use the specified <i>path</i> for the temporary <i>zip</i> archive. For example: <blockquote></dd>

<dt>zip -b
/tmp stuff * </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will put the temporary </dt>
<dd><i>zip</i> archive in the directory <i>/tmp</i>,
copying over <i>stuff.zip</i> to the current directory when done. This option is
useful when updating an existing archive and the file system containing
this old archive does not have enough space to hold both old and new archives
at the same time.  It may also be useful when streaming in some cases to
avoid the need for data descriptors.  Note that using this option may require
<i>zip</i> take additional time to copy the archive file when done to the destination
file system. 
<p> </dd>

<dt> <b>-c</b> </dt>
<dd></dd>

<dt> <b>--entry-comments</b> </dt>
<dd>Add one-line comments for each file. File
operations (adding, updating) are done first, and the user is then prompted
for a one-line comment for each file. Enter the comment followed by return,
or just return for no comment. 
<p> </dd>

<dt> <b>-C</b> </dt>
<dd></dd>

<dt> <b>--preserve-case</b> </dt>
<dd>[VMS]  Preserve case all
on VMS.  Negating this option (<b>-C-</b>) downcases. 
<p> </dd>

<dt> <b>-C2</b> </dt>
<dd></dd>

<dt> <b>--preserve-case-2</b> </dt>
<dd>[VMS]  Preserve
case ODS2 on VMS.  Negating this option (<b>-C2-</b>) downcases. 
<p> </dd>

<dt> <b>-C5</b> </dt>
<dd></dd>

<dt> <b>--preserve-case-5</b>
</dt>
<dd>[VMS]  Preserve case ODS5 on VMS.  Negating this option (<b>-C5-</b>) downcases. 
<p>
</dd>

<dt> <b>-d</b> </dt>
<dd></dd>

<dt> <b>--delete</b> </dt>
<dd>Remove (delete) entries from a <i>zip</i> archive. For example: <blockquote></dd>

<dt>zip
-d foo foo/tom/junk foo/harry/\* \*.o </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will remove the entry </dt>
<dd><i>foo/tom/junk</i>, all
of the files that start with <i>foo/harry/</i>, and all of the files that end
with <b>.o</b> (in any path). Note that shell pathname expansion has been inhibited
with backslashes, so that <i>zip</i> can see the asterisks, enabling <i>zip</i> to match
on the contents of the <i>zip</i> archive instead of the contents of the current
directory. (The backslashes are not used on MSDOS-based platforms.) Can also
use quotes to escape the asterisks as in <blockquote></dd>

<dt>zip -d foo foo/tom/junk "foo/harry/*"
"*.o" </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>Not escaping the asterisks on a system where the shell expands </dt>
<dd>wildcards
could result in the asterisks being converted to a list of files in the
current directory and that list used to delete entries from the archive.
</dd>

<dt>Under MSDOS, </dt>
<dd><b>-d</b> is case sensitive when it matches names in the <i>zip</i> archive.
This requires that file names be entered in upper case if they were zipped
by PKZIP on an MSDOS system.  (We considered making this case insensitive
on systems where paths were case insensitive, but it is possible the archive
came from a system where case does matter and the archive could include
both <b>Bar</b> and <b>bar</b> as separate files in the archive.)  But see the new option
<b>-ic</b> to ignore case in the archive. 
<p> </dd>

<dt> <b>-db</b> </dt>
<dd></dd>

<dt> <b>--display-bytes</b> </dt>
<dd>Display running byte
counts showing the bytes zipped and the bytes to go. 
<p> </dd>

<dt> <b>-dc</b> </dt>
<dd></dd>

<dt> <b>--display-counts</b>
</dt>
<dd>Display running count of entries zipped and entries to go. 
<p> </dd>

<dt> <b>-dd</b> </dt>
<dd></dd>

<dt> <b>--display-dots</b>
</dt>
<dd>Display dots while each entry is zipped (except on ports that have their
own progress indicator).  See <b>-ds</b> below for setting dot size.  The default
is a dot every 10 MB of input file processed.  The <b>-v</b> option also displays
dots (previously at a much higher rate than this but now <b>-v</b> also defaults
to 10 MB) and this rate is also controlled by <b>-ds</b>. 
<p> </dd>

<dt> <b>-df</b> </dt>
<dd></dd>

<dt> <b>--datafork</b> </dt>
<dd>[MacOS]
Include only data-fork of files zipped into the archive. Good for exporting
files to foreign operating-systems. Resource-forks will be ignored at all.

<p> </dd>

<dt> <b>-dg</b> </dt>
<dd></dd>

<dt> <b>--display-globaldots</b> </dt>
<dd>Display progress dots for the archive instead of
for each file.  The command <blockquote><br>
</dd>

<dt>    zip -qdgds 10m </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will turn off most output except dots every 10 MB. </dt>
<dd>
<p> </dd>

<dt> <b>-ds&nbsp;size</b>
</dt>
<dd></dd>

<dt> <b>--dot-size&nbsp;size</b> </dt>
<dd>Set amount of input file processed for each dot displayed.
 See <b>-dd</b> to enable displaying dots.  Setting this option implies <b>-dd</b>.  Size
is in the format nm where n is a number and m is a multiplier.  Currently
m can be k (KB), m (MB), g (GB), or t (TB), so if n is 100 and m is k,
size would be 100k which is 100 KB.  The default is 10 MB. </dd>

<dt>The <b>-v</b> option also
displays dots and now defaults to </dt>
<dd>10 MB also.  This rate is also controlled
by this option.  A size of 0 turns dots off. </dd>

<dt>This option does not control
the dots from the "Scanning files" message as </dt>
<dd><i>zip</i> scans for input files.
 The dot size for that is fixed at 2 seconds or a fixed number of entries,
whichever is longer. 
<p> </dd>

<dt> <b>-du</b> </dt>
<dd></dd>

<dt> <b>--display-usize</b> </dt>
<dd>Display the uncompressed size of
each entry. 
<p> </dd>

<dt> <b>-dv</b> </dt>
<dd></dd>

<dt> <b>--display-volume</b> </dt>
<dd>Display the volume (disk) number each entry
is being read from, if reading an existing archive, and being written to.

<p> </dd>

<dt> <b>-D</b> </dt>
<dd></dd>

<dt> <b>--no-dir-entries</b> </dt>
<dd>Do not create entries in the <i>zip</i> archive for directories.
 Directory entries are created by default so that their attributes can
be saved in the zip archive. The environment variable ZIPOPT can be used
to change the default options. For example under Unix with sh: <blockquote></dd>

<dt>ZIPOPT="-D";
export ZIPOPT </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>(The variable ZIPOPT can be used for any option, including
<b>-i</b> and <b>-x</b> </dt>
<dd>using a new option format detailed below, and can include several
options.) The option <b>-D</b> is a shorthand for <b>-x</b> "*/" but the latter previously
could not be set as default in the ZIPOPT environment variable as the contents
of ZIPOPT gets inserted near the beginning of the command line and the
file list had to end at the end of the line. </dd>

<dt>This version of </dt>
<dd><i>zip</i> does allow
<b>-x</b> and <b>-i</b> options in ZIPOPT if the form </dd>

<dt> <b>-x</b>&nbsp;file&nbsp;file&nbsp;...<b>&nbsp;@</b> </dt>
<dd></dd>

<dt>is used, where the @
(an argument that is just @) terminates </dt>
<dd>the list. 
<p> </dd>

<dt> <b>-DF</b> </dt>
<dd></dd>

<dt> <b>--difference-archive</b>
</dt>
<dd>Create an archive that contains all new and changed files since the original
archive was created.  For this to work, the input file list and current
directory must be the same as during the original <i>zip</i> operation. </dd>

<dt>For example,
if the existing archive was created using </dt>
<dd><blockquote></dd>

<dt>zip -r foofull . </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>from the <i>bar</i> directory,
then the command </dt>
<dd><blockquote></dd>

<dt>zip -r foofull . -DF --out foonew </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>also from the <i>bar</i> directory
creates the archive <i>foonew</i> </dt>
<dd>with just the files not in <i>foofull</i> and the files
where the size or file time of the files do not match those in <i>foofull</i>.

<p> Note that the timezone environment variable TZ should be set according
to the local timezone in order for this option to work correctly.  A change
in timezone since the original archive was created could result in no times
matching and all files being included. 
<p> A possible approach to backing up
a directory might be to create a normal archive of the contents of the
directory as a full backup, then use this option to create incremental
backups. 
<p> </dd>

<dt> <b>-e</b> </dt>
<dd></dd>

<dt> <b>--encrypt</b> </dt>
<dd>Encrypt the contents of the <i>zip</i> archive using a password
which is entered on the terminal in response to a prompt (this will not
be echoed; if standard error is not a tty, <i>zip</i> will exit with an error).
The password prompt is repeated to save the user from typing errors. 
<p> </dd>

<dt> <b>-E</b>
</dt>
<dd></dd>

<dt> <b>--longnames</b> </dt>
<dd>[OS/2] Use the .LONGNAME Extended Attribute (if found) as filename.

<p> </dd>

<dt> <b>-f</b> </dt>
<dd></dd>

<dt> <b>--freshen</b> </dt>
<dd>Replace (freshen) an existing entry in the <i>zip</i> archive only
if it has been modified more recently than the version already in the <i>zip</i>
archive; unlike the update option (<b>-u</b>) this will not add files that are
not already in the <i>zip</i> archive. For example: <blockquote></dd>

<dt>zip -f foo </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>This command should
be run from the same directory from which the original </dt>
<dd><i>zip</i> command was
run, since paths stored in <i>zip</i> archives are always relative. </dd>

<dt>Note that the
timezone environment variable TZ should be set according to </dt>
<dd>the local timezone
in order for the <b>-f</b>, <b>-u</b> and <b>-o</b> options to work correctly. </dd>

<dt>The reasons behind
this are somewhat subtle but have to do with the differences </dt>
<dd>between the
Unix-format file times (always in GMT) and most of the other operating systems
(always local time) and the necessity to compare the two. A typical TZ value
is &lsquo;&lsquo;MET-1MEST&rsquo;&rsquo; (Middle European time with automatic adjustment for &lsquo;&lsquo;summertime&rsquo;&rsquo;
or Daylight Savings Time). </dd>

<dt>The format is TTThhDDD, where TTT is the time
zone such as MET, hh is the </dt>
<dd>difference between GMT and local time such
as -1 above, and DDD is the time zone when daylight savings time is in effect.
 Leave off the DDD if there is no daylight savings time.  For the US Eastern
time zone EST5EDT. 
<p> </dd>

<dt> <b>-F</b> </dt>
<dd></dd>

<dt><b>--fix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b> </dt>
<dd></dd>

<dt><b>-FF</b> </dt>
<dd></dd>

<dt> <b>--fixfix&nbsp;&nbsp;</b> </dt>
<dd>Fix the <i>zip</i> archive. The <b>-F</b> option can
be used if some portions of the archive are missing, but requires a reasonably
intact central directory. The input archive is scanned as usual, but <i>zip</i>
will ignore some problems.  The resulting archive should be valid, but any
inconsistent entries will be left out. </dd>

<dt>When doubled as in </dt>
<dd><b>-FF</b>, the archive
is scanned from the beginning and <i>zip</i> scans for special signatures to identify
the limits between the archive members. The single <b>-F</b> is more reliable if
the archive is not too much damaged, so try this option first. </dd>

<dt>If the archive
is too damaged or the end has been truncated, you </dt>
<dd>must use <b>-FF</b>.  This is
a change from <i>zip&nbsp;2.32</i>, where the <b>-F</b> option is able to read a truncated archive.
 The <b>-F</b> option now more reliably fixes archives with minor damage and the
<b>-FF</b> option is needed to fix archives where <b>-F</b> might have been sufficient
before. </dd>

<dt>Neither option will recover archives that have been incorrectly
</dt>
<dd>transferred in ascii mode instead of binary. After the repair, the <b>-t</b> option
of <i>unzip</i> may show that some files have a bad CRC. Such files cannot be recovered;
you can remove them from the archive using the <b>-d</b> option of <i>zip</i>. </dd>

<dt>Note that
<b>-FF</b> may have trouble fixing archives that include an </dt>
<dd>embedded zip archive
that was stored (without compression) in the archive and, depending on
the damage, it may find the entries in the embedded archive rather than
the archive itself.  Try <b>-F</b> first as it does not have this problem. </dd>

<dt>The format
of the fix commands have changed.  For example, to fix </dt>
<dd>the damaged archive
<i>foo.zip</i>, <blockquote></dd>

<dt>zip -F foo --out foofix </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>tries to read the entries normally, copying
good entries to the </dt>
<dd>new archive <i>foofix.zip</i>.  If this doesn&rsquo;t work, as when
the archive is truncated, or if some entries you know are in the archive
are missed, then try <blockquote></dd>

<dt>zip -FF foo --out foofixfix </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>and compare the resulting
archive to the archive created by <b>-F</b>.  The </dt>
<dd><b>-FF</b> option may create an inconsistent
archive.  Depending on what is damaged, you can then use the <b>-F</b> option to
fix that archive. </dd>

<dt>A split archive with missing split files can be fixed
using </dt>
<dd><b>-F</b> if you have the last split of the archive (the <b>.zip</b> file). If this
file is missing, you must use <b>-FF</b> to fix the archive, which will prompt
you for the splits you have. </dd>

<dt>Currently the fix options can&rsquo;t recover entries
that have a bad checksum </dt>
<dd>or are otherwise damaged. 
<p> </dd>

<dt> <b>-FI</b> </dt>
<dd></dd>

<dt> <b>--fifo</b> </dt>
<dd>[Unix]  Normally
<i>zip</i> skips reading any FIFOs (named pipes) encountered, as <i>zip</i> can hang
if the FIFO is not being fed.  This option tells <i>zip</i> to read the contents
of any FIFO it finds. 
<p> </dd>

<dt> <b>-FS</b> </dt>
<dd></dd>

<dt> <b>--filesync</b> </dt>
<dd>Synchronize the contents of an archive
with the files on the OS. Normally when an archive is updated, new files
are added and changed files are updated but files that no longer exist
on the OS are not deleted from the archive.  This option enables a new mode
that checks entries in the archive against the file system.  If the file
time and file size of the entry matches that of the OS file, the entry
is copied from the old archive instead of being read from the file system
and compressed.  If the OS file has changed, the entry is read and compressed
as usual.  If the entry in the archive does not match a file on the OS,
the entry is deleted.  Enabling this option should create archives that
are the same as new archives, but since existing entries are copied instead
of compressed, updating an existing archive with <b>-FS</b> can be much faster
than creating a new archive.  Also consider using <b>-u</b> for updating an archive.
</dd>

<dt>For this option to work, the archive should be updated from the same </dt>
<dd>directory
it was created in so the relative paths match.  If few files are being copied
from the old archive, it may be faster to create a new archive instead.
</dd>

<dt>Note that the timezone environment variable TZ should be set according
to </dt>
<dd>the local timezone in order for this option to work correctly.  A change
in timezone since the original archive was created could result in no times
matching and recompression of all files. </dd>

<dt>This option deletes files from
the archive.  If you need to preserve </dt>
<dd>the original archive, make a copy
of the archive first or use the <b>--out</b> option to output the updated archive
to a new file. Even though it may be slower, creating a new archive with
a new archive name is safer, avoids mismatches between archive and OS paths,
and is preferred. 
<p> </dd>

<dt> <b>-g</b> </dt>
<dd></dd>

<dt> <b>--grow &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b> </dt>
<dd>Grow (append to) the specified <i>zip</i> archive,
instead of creating a new one. If this operation fails, <i>zip</i> attempts to
restore the archive to its original state. If the restoration fails, the
archive might become corrupted. This option is ignored when there&rsquo;s no existing
archive or when at least one archive member must be updated or deleted.

<p> </dd>

<dt> <b>-h</b> </dt>
<dd></dd>

<dt> <b>-?</b> </dt>
<dd></dd>

<dt> <b>--help &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b> </dt>
<dd>Display the <i>zip</i> help information (this also appears if <i>zip</i>
is run with no arguments). 
<p> </dd>

<dt> <b>-h2</b> </dt>
<dd></dd>

<dt> <b>--more-help</b> </dt>
<dd>Display extended help including
more on command line format, pattern matching, and more obscure options.

<p> </dd>

<dt> <b>-i&nbsp;files</b> </dt>
<dd></dd>

<dt> <b>--include&nbsp;files</b> </dt>
<dd>Include only the specified files, as in: <blockquote></dd>

<dt>zip -r foo
. -i \*.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>which will include only the files that end in </dt>
<dd><i></i>.c in the current directory
and its subdirectories. (Note for PKZIP users: the equivalent command is
<blockquote></dd>

<dt>pkzip -rP foo *.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>PKZIP does not allow recursion in directories other than
the current one.) </dt>
<dd>The backslash avoids the shell filename substitution,
so that the name matching is performed by <i>zip</i> at all directory levels. [This
is for Unix and other systems where \  escapes the next character.  For other
systems where the shell does not process * do not use \ and the above is
<blockquote></dd>

<dt>zip -r foo . -i *.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>Examples are for Unix unless otherwise specified.]  So to
include dir, </dt>
<dd>a directory directly under the current directory, use <blockquote></dd>

<dt>zip
-r foo . -i dir/\* </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>or </dt>
<dd><blockquote></dd>

<dt>zip -r foo . -i "dir/*" </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>to match paths such as dir/a and
dir/b/file.c [on </dt>
<dd>ports without wildcard expansion in the shell such as MSDOS
and Windows <blockquote></dd>

<dt>zip -r foo . -i dir/* </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>is used.]  Note that currently the trailing
/ is needed </dt>
<dd>for directories (as in <blockquote></dd>

<dt>zip -r foo . -i dir/ </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>to include directory
dir). </dt>
<dd></dd>

<dt>The long option form of the first example is </dt>
<dd><blockquote></dd>

<dt>zip -r foo . --include \*.c
</dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>and does the same thing as the short option form. </dt>
<dd></dd>

<dt>Though the command syntax
used to require <b>-i</b> at </dt>
<dd>the end of the command line, this version actually
allows <b>-i</b> (or <b>--include</b>) anywhere.  The list of files terminates at the next
argument starting with <b>-</b>, the end of the command line, or the list terminator
<b>@</b> (an argument that is just @).  So the above can be given as <blockquote></dd>

<dt>zip -i \*.c @
-r foo . </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>for example.  There must be a space between </dt>
<dd>the option and the first
file of a list.  For just one file you can use the single value form <blockquote></dd>

<dt>zip
-i\*.c -r foo . </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>(no space between option and value) or </dt>
<dd><blockquote></dd>

<dt>zip --include=\*.c -r foo
. </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>as additional examples.  The single value forms are </dt>
<dd>not recommended because
they can be confusing and, in particular, the <b>-ifile</b> format can cause problems
if the first letter of <b>file</b> combines with <b>i</b> to form a two-letter option
starting with <b>i</b>.  Use <b>-sc</b> to see how your command line will be parsed. </dd>

<dt>Also
possible: </dt>
<dd><blockquote></dd>

<dt>zip -r foo  . -i@include.lst </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>which will only include the files in
the current directory and its </dt>
<dd>subdirectories that match the patterns in
the file include.lst. </dd>

<dt>Files to <b>-i</b> and <b>-x</b> are patterns matching internal archive
paths.  See </dt>
<dd><b>-R</b> for more on patterns. 
<p> </dd>

<dt> <b>-I</b> </dt>
<dd></dd>

<dt> <b>--no-image</b> </dt>
<dd>[Acorn RISC OS] Don&rsquo;t scan
through Image files.  When used, <i>zip</i> will not consider Image files (eg. DOS
partitions or Spark archives when SparkFS is loaded) as directories but
will store them as single files. 
<p> For example, if you have SparkFS loaded,
zipping a Spark archive will result in a zipfile containing a directory
(and its content) while using the &rsquo;I&rsquo; option will result in a zipfile containing
a Spark archive. Obviously this second case will also be obtained (without
the &rsquo;I&rsquo; option) if SparkFS isn&rsquo;t loaded. 
<p> </dd>

<dt> <b>-ic</b> </dt>
<dd></dd>

<dt> <b>--ignore-case</b> </dt>
<dd>[VMS, WIN32] Ignore
case when matching archive entries.  This option is only available on systems
where the case of files is ignored.  On systems with case-insensitive file
systems, case is normally ignored when matching files on the file system
but is not ignored for -f (freshen), -d (delete), -U (copy), and similar modes
when matching against archive entries (currently -f ignores case on VMS)
because archive entries can be from systems where case does matter and
names that are the same except for case can exist in an archive.  The <b>-ic</b>
option makes all matching case insensitive. This can result in multiple
archive entries matching a command line pattern. 
<p> </dd>

<dt> <b>-j</b> </dt>
<dd></dd>

<dt> <b>--junk-paths</b> </dt>
<dd>Store just
the name of a saved file (junk the path), and do not store directory names.
By default, <i>zip</i> will store the full path (relative to the current directory).

<p> </dd>

<dt> <b>-jj</b> </dt>
<dd></dd>

<dt> <b>--absolute-path</b> </dt>
<dd>[MacOS] record Fullpath (+ Volname). The complete path
including volume will be stored. By default the relative path will be stored.

<p> </dd>

<dt> <b>-J</b> </dt>
<dd></dd>

<dt> <b>--junk-sfx</b> </dt>
<dd>Strip any prepended data (e.g. a SFX stub) from the archive.
</dd>

<dt> <b>-k</b> </dt>
<dd></dd>

<dt> <b>--DOS-names</b> </dt>
<dd>Attempt to convert the names and paths to conform to MSDOS,
store only the MSDOS attribute (just the user write attribute from Unix),
and mark the entry as made under MSDOS (even though it was not); for compatibility
with PKUNZIP under MSDOS which cannot handle certain names such as those
with two dots. </dd>

<dt> <b>-l</b> </dt>
<dd></dd>

<dt> <b>--to-crlf</b> </dt>
<dd>Translate the Unix end-of-line character LF into
the MSDOS convention CR LF. This option should not be used on binary files.
This option can be used on Unix if the zip file is intended for PKUNZIP
under MSDOS. If the input files already contain CR LF, this option adds
an extra CR. This is to ensure that <b>unzip -a</b> on Unix will get back an exact
copy of the original file, to undo the effect of <b>zip -l</b>.  See <b>-ll</b> for how
binary files are handled. </dd>

<dt> <b>-la</b> </dt>
<dd></dd>

<dt> <b>--log-append</b> </dt>
<dd>Append to existing logfile.  Default
is to overwrite. </dd>

<dt> <b>-lf&nbsp;logfilepath</b> </dt>
<dd></dd>

<dt> <b>--logfile-path&nbsp;logfilepath</b> </dt>
<dd>Open a logfile at
the given path.  By default any existing file at that location is overwritten,
but the <b>-la</b> option will result in an existing file being opened and the
new log information appended to any existing information. Only warnings
and errors are written to the log unless the <b>-li</b> option is also given, then
all information messages are also written to the log. </dd>

<dt> <b>-li</b> </dt>
<dd></dd>

<dt> <b>--log-info</b> </dt>
<dd>Include
information messages, such as file names being zipped, in the log. The default
is to only include the command line, any warnings and errors, and the final
status. </dd>

<dt> <b>-ll</b> </dt>
<dd></dd>

<dt> <b>--from-crlf</b> </dt>
<dd>Translate the MSDOS end-of-line CR LF into Unix LF. This
option should not be used on binary files. This option can be used on MSDOS
if the zip file is intended for unzip under Unix.  If the file is converted
and the file is later determined to be binary a warning is issued and the
file is probably corrupted.  In this release if <b>-ll</b> detects binary in the
first buffer read from a file, <i>zip</i> now issues a warning and skips line
end conversion on the file.  This check seems to catch all binary files
tested, but the original check remains and if a converted file is later
determined to be binary that warning is still issued.  A new algorithm is
now being used for binary detection that should allow line end conversion
of text files in <b>UTF-8</b> and similar encodings. </dd>

<dt> <b>-L</b> </dt>
<dd></dd>

<dt> <b>--license</b> </dt>
<dd>Display the <i>zip</i>
license. </dd>

<dt> <b>-m</b> </dt>
<dd></dd>

<dt> <b>--move &nbsp;&nbsp;&nbsp;</b> </dt>
<dd>Move the specified files into the <i>zip</i> archive; actually,
this deletes the target directories/files after making the specified <i>zip</i>
archive. If a directory becomes empty after removal of the files, the directory
is also removed. No deletions are done until <i>zip</i> has created the archive
without error. This is useful for conserving disk space, but is potentially
dangerous so it is recommended to use it in combination with <b>-T</b> to test
the archive before removing all input files. </dd>

<dt> <b>-MM</b> </dt>
<dd></dd>

<dt> <b>--must-match</b> </dt>
<dd>All input patterns
must match at least one file and all input files found must be readable.
 Normally when an input pattern does not match a file the "name not matched"
warning is issued and when an input file has been found but later is missing
or not readable a missing or not readable warning is issued.  In either
case <i>zip</i> continues creating the archive, with missing or unreadable new
files being skipped and files already in the archive remaining unchanged.
After the archive is created, if any files were not readable <i>zip</i> returns
the OPEN error code (18 on most systems) instead of the normal success
return (0 on most systems).  With <b>-MM</b> set, <i>zip</i> exits as soon as an input
pattern is not matched (whenever the "name not matched" warning would be
issued) or when an input file is not readable.  In either case <i>zip</i> exits
with an OPEN error and no archive is created. </dd>

<dt>This option is useful when
a known list of files is to be zipped so </dt>
<dd>any missing or unreadable files
will result in an error.  It is less useful when used with wildcards, but
<i>zip</i> will still exit with an error if any input pattern doesn&rsquo;t match at
least one file and if any matched files are unreadable.  If you want to
create the archive anyway and only need to know if files were skipped,
don&rsquo;t use <b>-MM</b> and just check the return code.  Also <b>-lf</b> could be useful. </dd>

<dt> <b>-n&nbsp;suffixes</b>
</dt>
<dd></dd>

<dt> <b>--suffixes&nbsp;suffixes</b> </dt>
<dd>Do not attempt to compress files named with the given
<b>suffixes</b>. Such files are simply stored (0% compression) in the output zip
file, so that <i>zip</i> doesn&rsquo;t waste its time trying to compress them. The suffixes
are separated by either colons or semicolons.  For example: <blockquote></dd>

<dt>zip -rn .Z:.zip:.tiff:.gif:.snd
 foo foo </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will copy everything from </dt>
<dd><i>foo</i> into <i>foo.zip</i>, but will store any
files that end in <i>.Z</i>, <i>.zip</i>, <i>.tiff</i>, <i>.gif</i>, or <i>.snd</i> without trying to compress
them (image and sound files often have their own specialized compression
methods). By default, <i>zip</i> does not compress files with extensions in the
list <i>.Z:.zip:.zoo:.arc:.lzh:.arj.</i> Such files are stored directly in the output
archive. The environment variable ZIPOPT can be used to change the default
options. For example under Unix with csh: <blockquote></dd>

<dt>setenv ZIPOPT "-n .gif:.zip" </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>To attempt
compression on all files, use: </dt>
<dd><blockquote></dd>

<dt>zip -n : foo </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>The maximum compression option
</dt>
<dd><b>-9</b> also attempts compression on all files regardless of extension. </dd>

<dt>On Acorn
RISC OS systems the suffixes are actually filetypes (3 hex digit </dt>
<dd>format).
By default, <i>zip</i> does not compress files with filetypes in the list DDC:D96:68E
(i.e. Archives, CFS files and PackDir files). </dd>

<dt> <b>-nw</b> </dt>
<dd></dd>

<dt> <b>--no-wild</b> </dt>
<dd>Do not perform internal
wildcard processing (shell processing of wildcards is still done by the
shell unless the arguments are escaped).  Useful if a list of paths is being
read and no wildcard substitution is desired. </dd>

<dt> <b>-N</b> </dt>
<dd></dd>

<dt> <b>--notes</b> </dt>
<dd>[Amiga, MacOS] Save
Amiga or MacOS filenotes as zipfile comments. They can be restored by using
the -N option of <i>unzip</i>. If -c is used also, you are prompted for comments
only for those files that do not have filenotes. </dd>

<dt> <b>-o</b> </dt>
<dd></dd>

<dt> <b>--latest-time</b> </dt>
<dd>Set the
"last modified" time of the <i>zip</i> archive to the latest (oldest) "last modified"
time found among the entries in the <i>zip</i> archive. This can be used without
any other operations, if desired. For example: </dd>

<dt>zip -o foo </dt>
<dd></dd>

<dt>will change the
last modified time of </dt>
<dd><b>foo.zip</b> to the latest time of the entries in <b>foo.zip</b>.
</dd>

<dt> <b>-O output-file</b> </dt>
<dd></dd>

<dt> <b>--output-file output-file</b> </dt>
<dd>Process the archive changes as usual,
but instead of updating the existing archive, output the new archive to
output-file.  Useful for updating an archive without changing the existing
archive and the input archive must be a different file than the output
archive. 
<p> This option can be used to create updated split archives. It can
also be used with <b>-U</b> to copy entries from an existing archive to a new archive.
 See the <b>EXAMPLES</b> section below. 
<p> Another use is converting <i>zip</i> files from
one split size to another.  For instance, to convert an archive with 700
MB CD splits to one with 2 GB DVD splits, can use: <blockquote></dd>

<dt>zip -s 2g cd-split.zip
--out dvd-split.zip </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>which uses copy mode.  See <b>-U</b> below.  Also: </dt>
<dd><blockquote></dd>

<dt>zip -s 0 split.zip
--out unsplit.zip </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will convert a split archive to a single-file archive. </dt>
<dd>
<p> Copy
mode will convert stream entries (using data descriptors and which should
be compatible with most unzips) to normal entries (which should be compatible
with all unzips), except if standard encryption was used.  For archives
with encrypted entries, <i>zipcloak</i> will decrypt the entries and convert them
to normal entries. </dd>

<dt> <b>-p</b> </dt>
<dd></dd>

<dt> <b>--paths</b> </dt>
<dd>Include relative file paths as part of the
names of files stored in the archive. This is the default.  The <b>-j</b> option
junks the paths and just stores the names of the files. </dd>

<dt> <b>-P&nbsp;password</b> </dt>
<dd></dd>

<dt> <b>--password&nbsp;password</b>
</dt>
<dd>Use <i>password</i> to encrypt zipfile entries (if any).  <b>THIS IS INSECURE!</b>  Many
multi-user operating systems provide ways for any user to see the current
command line of any other user; even on stand-alone systems there is always
the threat of over-the-shoulder peeking.  Storing the plaintext password as
part of a command line in an automated script is even worse. Whenever possible,
use the non-echoing, interactive prompt to enter passwords. (And where security
is truly important, use strong encryption such as Pretty Good Privacy instead
of the relatively weak standard encryption provided by zipfile utilities.)
</dd>

<dt> <b>-q</b> </dt>
<dd></dd>

<dt> <b>--quiet</b> </dt>
<dd>Quiet mode; eliminate informational messages and comment prompts.
(Useful, for example, in shell scripts and background tasks). </dd>

<dt> <b>-Qn</b> </dt>
<dd></dd>

<dt> <b>--Q-flag&nbsp;n</b>
</dt>
<dd>[QDOS] store information about the file in the file header with n defined
as <blockquote>bit  0: </dd>
</dl>
Don&rsquo;t add headers for any file </blockquote>
<blockquote>bit  1: Add headers for all files
</blockquote>
<blockquote>bit  2: Don&rsquo;t wait for interactive key press on exit </blockquote>

<dl>

<dt> <b>-r</b> </dt>
<dd></dd>

<dt> <b>--recurse-paths</b> </dt>
<dd>Travel
the directory structure recursively; for example: <blockquote></dd>

<dt>zip -r foo.zip foo </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>or more
concisely </dt>
<dd><blockquote></dd>

<dt>zip -r foo foo </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>In this case, all the files and directories in
</dt>
<dd><b>foo</b> are saved in a <i>zip</i> archive named <b>foo.zip</b>, including files with names
starting with <b>"."</b>, since the recursion does not use the shell&rsquo;s file-name
substitution mechanism. If you wish to include only a specific subset of
the files in directory <b>foo</b> and its subdirectories, use the <b>-i</b> option to
specify the pattern of files to be included. You should not use <b>-r</b> with the
name <b>".*"</b>, since that matches <b>".."</b> which will attempt to zip up the parent
directory (probably not what was intended). </dd>

<dt>Multiple source directories
are allowed as in </dt>
<dd><blockquote></dd>

<dt>zip -r foo foo1 foo2 </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>which first zips up <b>foo1</b> and then
<b>foo2</b>, going down each directory. </dt>
<dd></dd>

<dt>Note that while wildcards to <b>-r</b> are typically
resolved while recursing down </dt>
<dd>directories in the file system, any <b>-R, <b>-x</b></b>,
and <b>-i</b> wildcards are applied to internal archive pathnames once the directories
are scanned. To have wildcards apply to files in subdirectories when recursing
on Unix and similar systems where the shell does wildcard substitution,
either escape all wildcards or put all arguments with wildcards in quotes.
 This lets <i>zip</i> see the wildcards and match files in subdirectories using
them as it recurses. </dd>

<dt> <b>-R</b> </dt>
<dd></dd>

<dt> <b>--recurse-patterns</b> </dt>
<dd>Travel the directory structure
recursively starting at the current directory; for example: <blockquote></dd>

<dt>zip -R foo "*.c"
</dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>In this case, all the files matching <b>*.c</b> in the tree starting at the </dt>
<dd>current
directory are stored into a <i>zip</i> archive named <b>foo.zip</b>. Note that <b>*.c</b> will
match <b>file.c</b>, <b>a/file.c</b> and <b>a/b/.c</b>.  More than one pattern can be listed as
separate arguments. Note for PKZIP users: the equivalent command is <blockquote></dd>

<dt>pkzip
-rP foo *.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>Patterns are relative file paths as they appear in the archive,
or will after </dt>
<dd>zipping, and can have optional wildcards in them.  For example,
given the current directory is <b>foo</b> and under it are directories <b>foo1</b> and
<b>foo2</b> and in <b>foo1</b> is the file <b>bar.c</b>, <blockquote></dd>

<dt>zip -R foo/* </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will zip up <b>foo</b>, <b>foo/foo1</b>,
<b>foo/foo1/bar.c</b>, and <b>foo/foo2</b>. </dt>
<dd><blockquote></dd>

<dt>zip -R */bar.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will zip up <b>foo/foo1/bar.c</b>.  See
the note for <b>-r</b> on escaping wildcards. </dt>
<dd>
<p> </dd>

<dt> <b>-RE</b> </dt>
<dd></dd>

<dt> <b>--regex</b> </dt>
<dd>[WIN32]  Before <i>zip</i> <i>3.0</i>,
regular expression list matching was enabled by default on Windows platforms.
 Because of confusion resulting from the need to escape "[" and "]" in
names, it is now off by default for Windows so "[" and "]" are just normal
characters in names.  This option enables [] matching again. 
<p> </dd>

<dt> <b>-s&nbsp;splitsize</b>
</dt>
<dd></dd>

<dt> <b>--split-size&nbsp;splitsize</b> </dt>
<dd>Enable creating a split archive and set the split size.
 A split archive is an archive that could be split over many files.  As
the archive is created, if the size of the archive reaches the specified
split size, that split is closed and the next split opened.  In general
all splits but the last will be the split size and the last will be whatever
is left.  If the entire archive is smaller than the split size a single-file
archive is created. 
<p> Split archives are stored in numbered files.  For example,
if the output archive is named <b>archive</b> and three splits are required, the
resulting archive will be in the three files <b>archive.z01</b>, <b>archive.z02</b>, and
<b>archive.zip</b>.  Do not change the numbering of these files or the archive will
not be readable as these are used to determine the order the splits are
read. 
<p> Split size is a number optionally followed by a multiplier.  Currently
the number must be an integer.  The multiplier can currently be one of <b>k</b>
(kilobytes), <b>m</b> (megabytes), <b>g</b> (gigabytes), or <b>t</b> (terabytes).  As 64k is
the minimum split size, numbers without multipliers default to megabytes.
 For example, to create a split archive called <b>foo</b> with the contents of
the <b>bar</b> directory with splits of 670 MB that might be useful for burning
on CDs, the command: <blockquote></dd>

<dt>zip -s 670m -r foo bar </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>could be used. </dt>
<dd>
<p> Currently the
old splits of a split archive are not excluded from a new archive, but
they can be specifically excluded.  If possible, keep the input and output
archives out of the path being zipped when creating split archives. 
<p> Using
<b>-s</b> without <b>-sp</b> as above creates all the splits where <b>foo</b> is being written,
in this case the current directory.  This split mode updates the splits
as the archive is being created, requiring all splits to remain writable,
but creates split archives that are readable by any unzip that supports
split archives.  See <b>-sp</b> below for enabling split pause mode which allows
splits to be written directly to removable media. 
<p> The option <b>-sv</b> can be
used to enable verbose splitting and provide details of how the splitting
is being done.  The <b>-sb</b> option can be used to ring the bell when <i>zip</i> pauses
for the next split destination. 
<p> Split archives cannot be updated, but see
the <b>-O</b> (<b>--out</b>) option for how a split archive can be updated as it is copied
to a new archive. A split archive can also be converted into a single-file
archive using a split size of 0 or negating the <b>-s</b> option: <blockquote></dd>

<dt>zip -s 0 split.zip
--out single.zip </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>Also see <b>-U</b> (<b>--copy</b>) for more on using copy mode. </dt>
<dd></dd>

<dt> <b>-sb</b> </dt>
<dd></dd>

<dt> <b>--split-bell</b>
</dt>
<dd>If splitting and using split pause mode, ring the bell when <i>zip</i> pauses
for each split destination. </dd>

<dt> <b>-sc</b> </dt>
<dd></dd>

<dt> <b>--show-command</b> </dt>
<dd>Show the command line starting
<i>zip</i> as processed and exit.  The new command parser permutes the arguments,
putting all options and any values associated with them before any non-option
arguments.  This allows an option to appear anywhere in the command line
as long as any values that go with the option go with it.  This option displays
the command line as <i>zip</i> sees it, including any arguments from the environment
such as from the <b>ZIPOPT</b> variable.  Where allowed, options later in the command
line can override options earlier in the command line. </dd>

<dt> <b>-sf</b> </dt>
<dd></dd>

<dt> <b>--show-files</b> </dt>
<dd>Show
the files that would be operated on, then exit.  For instance, if creating
a new archive, this will list the files that would be added.  If the option
is negated, <b>-sf-</b>, output only to an open log file.  Screen display is not
recommended for large lists. </dd>

<dt> <b>-so</b> </dt>
<dd></dd>

<dt> <b>--show-options</b> </dt>
<dd>Show all available options
supported by <i>zip</i> as compiled on the current system. As this command reads
the option table, it should include all options.  Each line includes the
short option (if defined), the long option (if defined), the format of
any value that goes with the option, if the option can be negated, and
a small description.  The value format can be no value, required value,
optional value, single character value, number value, or a list of values.
 The output of this option is not intended to show how to use any option
but only show what options are available. </dd>

<dt> <b>-sp</b> </dt>
<dd></dd>

<dt> <b>--split-pause</b> </dt>
<dd>If splitting is
enabled with <b>-s</b>, enable split pause mode.  This creates split archives as
<b>-s</b> does, but stream writing is used so each split can be closed as soon
as it is written and <i>zip</i> will pause between each split to allow changing
split destination or media. 
<p> Though this split mode allows writing splits
directly to removable media, it uses stream archive format that may not
be readable by some unzips.  Before relying on splits created with <b>-sp</b>, test
a split archive with the unzip you will be using. 
<p> To convert a stream split
archive (created with <b>-sp</b>) to a standard archive see the <b>--out</b> option. </dd>

<dt> <b>-su</b>
</dt>
<dd></dd>

<dt> <b>--show-unicode</b> </dt>
<dd>As <b>-sf</b>, but also show Unicode version of the path if exists.
</dd>

<dt> <b>-sU</b> </dt>
<dd></dd>

<dt> <b>--show-just-unicode</b> </dt>
<dd>As <b>-sf</b>, but only show Unicode version of the path if
exists, otherwise show the standard version of the path. </dd>

<dt> <b>-sv</b> </dt>
<dd></dd>

<dt> <b>--split-verbose</b>
</dt>
<dd>Enable various verbose messages while splitting, showing how the splitting
is being done. </dd>

<dt> <b>-S</b> </dt>
<dd></dd>

<dt> <b>--system-hidden</b> </dt>
<dd>[MSDOS, OS/2, WIN32 and ATARI] Include system
and hidden files. <blockquote>[MacOS] Includes finder invisible files, which are ignored
otherwise. </dd>
</dl>
</blockquote>

<dl>

<dt> <b>-t&nbsp;mmddyyyy</b> </dt>
<dd></dd>

<dt> <b>--from-date&nbsp;mmddyyyy</b> </dt>
<dd>Do not operate on files modified
prior to the specified date, where <b>mm</b> is the month (00-12), <b>dd</b> is the day
of the month (01-31), and <b>yyyy</b> is the year. The <i>ISO&nbsp;8601</i> date format <b>yyyy-mm-dd</b>
is also accepted. For example: <blockquote></dd>

<dt>zip -rt 12071991 infamy foo </dt>
<dd>
<p> </dd>
</dl>
zip -rt 1991-12-07
infamy foo </blockquote>

<dl>

<dt>will add all the files in </dt>
<dd><b>foo</b> and its subdirectories that were
last modified on or after 7 December 1991, to the <i>zip</i> archive <b>infamy.zip</b>.
</dd>

<dt> <b>-tt&nbsp;mmddyyyy</b> </dt>
<dd></dd>

<dt> <b>--before-date&nbsp;mmddyyyy</b> </dt>
<dd>Do not operate on files modified after
or at the specified date, where <b>mm</b> is the month (00-12), <b>dd</b> is the day of
the month (01-31), and <b>yyyy</b> is the year. The <i>ISO&nbsp;8601</i> date format <b>yyyy-mm-dd</b>
is also accepted. For example: <blockquote></dd>

<dt>zip -rtt 11301995 infamy foo </dt>
<dd>
<p> </dd>
</dl>
zip -rtt 1995-11-30
infamy foo </blockquote>

<dl>

<dt>will add all the files in </dt>
<dd><b>foo</b> and its subdirectories that were
last modified before 30 November 1995, to the <i>zip</i> archive <b>infamy.zip</b>. </dd>

<dt> <b>-T</b>
</dt>
<dd></dd>

<dt> <b>--test&nbsp;&nbsp;&nbsp;&nbsp;</b> </dt>
<dd>Test the integrity of the new zip file. If the check fails, the old
zip file is unchanged and (with the <b>-m</b> option) no input files are removed.
</dd>

<dt> <b>-TT&nbsp;cmd</b> </dt>
<dd></dd>

<dt> <b>--unzip-command&nbsp;cmd</b> </dt>
<dd>Use command cmd instead of &rsquo;unzip -tqq&rsquo; to test an
archive when the <b>-T</b> option is used.  On Unix, to use a copy of unzip in the
current directory instead of the standard system unzip, could use: </dd>

<dt> zip
archive file1 file2 -T -TT "./unzip -tqq" </dt>
<dd></dd>

<dt>In cmd, {} is replaced by the name
of the temporary archive, otherwise the name </dt>
<dd>of the archive is appended
to the end of the command. The return code is checked for success (0 on
Unix). </dd>

<dt> <b>-u</b> </dt>
<dd></dd>

<dt> <b>--update</b> </dt>
<dd>Replace (update) an existing entry in the <i>zip</i> archive
only if it has been modified more recently than the version already in
the <i>zip</i> archive. For example: <blockquote></dd>

<dt>zip -u stuff * </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>will add any new files in the
current directory, </dt>
<dd>and update any files which have been modified since
the <i>zip</i> archive <i>stuff.zip</i> was last created/modified (note that <i>zip</i> will
not try to pack <i>stuff.zip</i> into itself when you do this). </dd>

<dt>Note that the </dt>
<dd><b>-u</b>
option with no input file arguments acts like the <b>-f</b> (freshen) option. </dd>

<dt> <b>-U</b>
</dt>
<dd></dd>

<dt> <b>--copy-entries</b> </dt>
<dd>Copy entries from one archive to another.  Requires the <b>--out</b>
option to specify a different output file than the input archive.  Copy
mode is the reverse of <b>-d</b> delete.  When delete is being used with <b>--out</b>, the
selected entries are deleted from the archive and all other entries are
copied to the new archive, while copy mode selects the files to include
in the new archive.  Unlike <b>-u</b> update, input patterns on the command line
are matched against archive entries only and not the file system files.
 For instance, <blockquote></dd>

<dt>zip inarchive "*.c" --copy --out outarchive </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>copies entries with
names ending in <b>.c</b> from <b>inarchive</b> </dt>
<dd>to <b>outarchive</b>.  The wildcard must be escaped
on some systems to prevent the shell from substituting names of files from
the file system which may have no relevance to the entries in the archive.

<p> If no input files appear on the command line and <b>--out</b> is used, copy mode
is assumed: <blockquote></dd>

<dt>zip inarchive --out outarchive </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>This is useful for changing split
size for instance.  Encrypting </dt>
<dd>and decrypting entries is not yet supported
using copy mode.  Use <i>zipcloak</i> for that. </dd>

<dt> <b>-UN&nbsp;v</b> </dt>
<dd></dd>

<dt> <b>--unicode&nbsp;v</b> </dt>
<dd>Determine what <i>zip</i>
should do with Unicode file names. <i>zip&nbsp;3.0</i>, in addition to the standard file
path, now includes the UTF-8 translation of the path if the entry path is
not entirely 7-bit ASCII.  When an entry is missing the Unicode path, <i>zip</i>
reverts back to the standard file path.  The problem with using the standard
path is this path is in the local character set of the zip that created
the entry, which may contain characters that are not valid in the character
set being used by the unzip.  When <i>zip</i> is reading an archive, if an entry
also has a Unicode path, <i>zip</i> now defaults to using the Unicode path to
recreate the standard path using the current local character set. 
<p> This
option can be used to determine what <i>zip</i> should do with this path if there
is a mismatch between the stored standard path and the stored UTF-8 path
(which can happen if the standard path was updated).  In all cases, if there
is a mismatch it is assumed that the standard path is more current and
<i>zip</i> uses that.  Values for <b>v</b> are <blockquote></dd>

<dt>q - quit if paths do not match </dt>
<dd></dd>

<dt>w - warn,
continue with standard path </dt>
<dd></dd>

<dt>i - ignore, continue with standard path </dt>
<dd></dd>

<dt>n - no
Unicode, do not use Unicode paths </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>The default is to warn and continue. </dt>
<dd>
<p>
Characters that are not valid in the current character set are escaped
as <b>#Uxxxx</b> and <b>#Lxxxxxx</b>, where x is an ASCII character for a hex digit. 
The first is used if a 16-bit character number is sufficient to represent
the Unicode character and the second if the character needs more than 16
bits to represent it&rsquo;s Unicode character code.  Setting <b>-UN</b> to <blockquote></dd>

<dt>e - escape </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>as
in </dt>
<dd><blockquote></dd>

<dt>zip archive -sU -UN=e </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>forces <i>zip</i> to escape all characters that are not
printable 7-bit </dt>
<dd>ASCII. 
<p> Normally <i>zip</i> stores UTF-8 directly in the standard
path field on systems where UTF-8 is the current character set and stores
the UTF-8 in the new extra fields otherwise.  The option <blockquote></dd>

<dt>u - UTF-8 </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>as in </dt>
<dd><blockquote></dd>

<dt>zip
archive dir -r -UN=UTF8 </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>forces <i>zip</i> to store UTF-8 as native in the archive.
 Note that </dt>
<dd>storing UTF-8 directly is the default on Unix systems that support
it. This option could be useful on Windows systems where the escaped path
is too large to be a valid path and the UTF-8 version of the path is smaller,
but native UTF-8 is not backward compatible on Windows systems. 
<p> </dd>

<dt> <b>-v</b> </dt>
<dd></dd>

<dt> <b>--verbose</b>
</dt>
<dd>Verbose mode or print diagnostic version info. </dd>

<dt>Normally, when applied to
real operations, this option enables the display of a </dt>
<dd>progress indicator
during compression (see <b>-dd</b> for more on dots) and requests verbose diagnostic
info about zipfile structure oddities. </dd>

<dt>However, when </dt>
<dd><b>-v</b> is the only command
line argument a diagnostic screen is printed instead.  This should now work
even if stdout is redirected to a file, allowing easy saving of the information
for sending with bug reports to Info-ZIP.  The version screen provides the
help screen header with program name, version, and release date, some pointers
to the Info-ZIP home and distribution sites, and shows information about
the target environment (compiler type and version, OS version, compilation
date and the enabled optional features used to create the <i>zip</i> executable).
</dd>

<dt> <b>-V</b> </dt>
<dd></dd>

<dt> <b>--VMS-portable</b> </dt>
<dd>[VMS] Save VMS file attributes. (Files are  truncated at
EOF.)   When a -V archive is unpacked on a non-VMS system,  some file types
(notably Stream_LF text files  and  pure binary files  like fixed-512) should
be extracted intact.  Indexed files and file types with embedded record
sizes (notably variable-length record types) will probably be seen as corrupt
elsewhere. </dd>

<dt> <b>-VV</b> </dt>
<dd></dd>

<dt> <b>--VMS-specific</b> </dt>
<dd>[VMS] Save VMS file attributes, and  all allocated
blocks in a file,  including  any  data beyond EOF. Useful for moving ill-formed
files  among  VMS systems.   When a -VV archive is unpacked on a non-VMS system,
almost all files will appear corrupt. </dd>

<dt> <b>-w</b> </dt>
<dd></dd>

<dt> <b>--VMS-versions</b> </dt>
<dd>[VMS] Append the version
number of the files to the name, including multiple versions of files. 
Default is to use only the most recent version of a specified file. </dd>

<dt> <b>-ww</b>
</dt>
<dd></dd>

<dt> <b>--VMS-dot-versions</b> </dt>
<dd>[VMS] Append the version number of the files to the name,
including multiple versions of files, using the .nnn format. Default is to
use only the most recent version of a specified file. </dd>

<dt> <b>-ws</b> </dt>
<dd></dd>

<dt> <b>--wild-stop-dirs</b>
</dt>
<dd>Wildcards match only at a directory level.  Normally <i>zip</i> handles paths as
strings and given the paths <blockquote></dd>

<dt>/foo/bar/dir/file1.c </dt>
<dd></dd>

<dt>/foo/bar/file2.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>an input
pattern such as </dt>
<dd><blockquote></dd>

<dt>/foo/bar/* </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>normally would match both paths, the * matching
<b>dir/file1.c</b> </dt>
<dd>and <b>file2.c</b>.  Note that in the first case a directory boundary
(/) was crossed in the match.  With <b>-ws</b> no directory bounds will be included
in the match, making wildcards local to a specific directory level.  So,
with <b>-ws</b> enabled, only the second path would be matched. 
<p> When using <b>-ws</b>,
use ** to match across directory boundaries as * does normally. </dd>

<dt> <b>-x&nbsp;files</b>
</dt>
<dd></dd>

<dt> <b>--exclude&nbsp;files</b> </dt>
<dd>Explicitly exclude the specified files, as in: <blockquote></dd>

<dt>zip -r foo
foo -x \*.o </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>which will include the contents of </dt>
<dd><b>foo</b> in <b>foo.zip</b> while excluding
all the files that end in <b>.o</b>. The backslash avoids the shell filename substitution,
so that the name matching is performed by <i>zip</i> at all directory levels. </dd>

<dt>Also
possible: </dt>
<dd><blockquote></dd>

<dt>zip -r foo foo -x@exclude.lst </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>which will include the contents of
</dt>
<dd><b>foo</b> in <b>foo.zip</b> while excluding all the files that match the patterns in
the file <b>exclude.lst</b>. </dd>

<dt>The long option forms of the above are </dt>
<dd><blockquote></dd>

<dt>zip -r foo foo
--exclude \*.o </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>and </dt>
<dd><blockquote></dd>

<dt>zip -r foo foo --exclude @exclude.lst </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>Multiple patterns can
be specified, as in: </dt>
<dd><blockquote></dd>

<dt>zip -r foo foo -x \*.o \*.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>If there is no space between
<b>-x</b> and </dt>
<dd>the pattern, just one value is assumed (no list): <blockquote></dd>

<dt>zip -r foo foo -x\*.o
</dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>See <b>-i</b> for more on include and exclude. </dt>
<dd></dd>

<dt> <b>-X</b> </dt>
<dd></dd>

<dt> <b>--no-extra</b> </dt>
<dd>Do not save extra file
attributes (Extended Attributes on OS/2, uid/gid and file times on Unix).
 The zip format uses extra fields to include additional information for
each entry.  Some extra fields are specific to particular systems while
others are applicable to all systems. Normally when <i>zip</i> reads entries from
an existing archive, it reads the extra fields it knows, strips the rest,
and adds the extra fields applicable to that system.  With <b>-X</b>, <i>zip</i> strips
all old fields and only includes the Unicode and Zip64 extra fields (currently
these two extra fields cannot be disabled). 
<p> Negating this option, <b>-X-</b>, includes
all the default extra fields, but also copies over any unrecognized extra
fields. </dd>

<dt> <b>-y</b> </dt>
<dd></dd>

<dt> <b>--symlinks</b> </dt>
<dd>For UNIX and VMS (V8.3 and later), store symbolic links
as such in the <i>zip</i> archive, instead of compressing and storing the file
referred to by the link.  This can avoid multiple copies of files being
included in the archive as <i>zip</i> recurses the directory trees and accesses
files directly and by links. </dd>

<dt> <b>-z</b> </dt>
<dd></dd>

<dt> <b>--archive-comment</b> </dt>
<dd>Prompt for a multi-line comment
for the entire <i>zip</i> archive. The comment is ended by a line containing just
a period, or an end of file condition (^D on Unix, ^Z on MSDOS, OS/2, and
VMS). The comment can be taken from a file: <blockquote></dd>

<dt>zip -z foo &lt; foowhat </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt> <b>-Z&nbsp;cm</b> </dt>
<dd></dd>

<dt> <b>--compression-method&nbsp;cm</b>
</dt>
<dd>Set the default compression method.  Currently the main methods supported
by <i>zip</i> are <b>store</b> and <b>deflate</b>.  Compression method can be set to: 
<p> <b>store</b>
- Setting the compression method to <b>store</b> forces <i>zip</i> to store entries with
no compression.  This is generally faster than compressing entries, but
results in no space savings. This is the same as using <b>-0</b> (compression level
zero). 
<p> <b>deflate</b> - This is the default method for <i>zip</i>.  If <i>zip</i> determines that
storing is better than deflation, the entry will be stored instead. 
<p> <b>bzip2</b>
- If <b>bzip2</b> support is compiled in, this compression method also becomes
available.  Only some modern unzips currently support the <b>bzip2</b> compression
method, so test the unzip you will be using before relying on archives
using this method (compression method 12). 
<p> For example, to add <b>bar.c</b> to
archive <b>foo</b> using <b>bzip2</b> compression: <blockquote></dd>

<dt>zip -Z bzip2 foo bar.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>The compression
method can be abbreviated: </dt>
<dd><blockquote></dd>

<dt>zip -Zb foo bar.c </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt> <b>-#</b> </dt>
<dd></dd>

<dt> <b>(-0, -1, -2, -3, -4, -5, -6, -7,
-8, -9)</b> </dt>
<dd>Regulate the speed of compression using the specified digit <b>#</b>, where
<b>-0</b> indicates no compression (store all files), <b>-1</b> indicates the fastest compression
speed (less compression) and <b>-9</b> indicates the slowest compression speed
(optimal compression, ignores the suffix list). The default compression
level is <b>-6.</b> 
<p> Though still being worked, the intention is this setting will
control compression speed for all compression methods.  Currently only deflation
is controlled. </dd>

<dt> <b>-!</b> </dt>
<dd></dd>

<dt> <b>--use-privileges</b> </dt>
<dd>[WIN32] Use priviliges (if granted) to
obtain all aspects of WinNT security. </dd>

<dt> <b>-@</b> </dt>
<dd></dd>

<dt> <b>--names-stdin</b> </dt>
<dd>Take the list of input
files from standard input. Only one filename per line. </dd>

<dt> <b>-$</b> </dt>
<dd></dd>

<dt> <b>--volume-label</b> </dt>
<dd>[MSDOS,
OS/2, WIN32] Include the volume label for the drive holding the first file
to be compressed.  If you want to include only the volume label or to force
a specific drive, use the drive name as first file name, as in: <blockquote></dd>

<dt>zip -$ foo
a: c:bar </dt>
<dd></dd>
</dl>
</blockquote>

<h2><a name='sect5' href='#toc5'>Examples</a></h2>
The simplest example: 
<dl>

<dt>zip stuff * </dt>
<dd></dd>
</dl>
<p>
creates the archive
<i>stuff.zip</i> (assuming it does not exist) and puts all the files in the current
directory in it, in compressed form (the <b>.zip</b> suffix is added automatically,
unless the archive name contains a dot already; this allows the explicit
specification of other suffixes). <p>
Because of the way the shell on Unix does
filename substitution, files starting with "." are not included; to include
these as well: 
<dl>

<dt>zip stuff .* * </dt>
<dd></dd>
</dl>
<p>
Even this will not include any subdirectories
from the current directory. <p>
To zip up an entire directory, the command:

<dl>

<dt>zip -r foo foo </dt>
<dd></dd>
</dl>
<p>
creates the archive <i>foo.zip</i>, containing all the files and
directories in the directory <i>foo</i> that is contained within the current directory.
<p>
You may want to make a <i>zip</i> archive that contains the files in <i>foo</i>, without
recording the directory name, <i>foo</i>. You can use the <b>-j</b> option to leave off
the paths, as in: 
<dl>

<dt>zip -j foo foo/* </dt>
<dd></dd>
</dl>
<p>
If you are short on disk space, you might
not have enough room to hold both the original directory and the corresponding
compressed <i>zip</i> archive. In this case, you can create the archive in steps
using the <b>-m</b> option. If <i>foo</i> contains the subdirectories <i>tom</i>, <i>dick</i>, and <i>harry</i>,
you can: 
<dl>

<dt>zip -rm foo foo/tom </dt>
<dd><br>
zip -rm foo foo/dick <br>
zip -rm foo foo/harry </dd>
</dl>
<p>
where the first command creates <i>foo.zip</i>, and the next
two add to it. At the completion of each <i>zip</i> command, the last created archive
is deleted, making room for the next <i>zip</i> command to function. 
<p> 
<p> 
<p> <p>
Use <b>-s</b> to
set the split size and create a split archive.  The size is given as a number
followed optionally by one of k (kB), m (MB), g (GB), or t (TB). The command

<dl>

<dt>zip -s 2g -r split.zip foo </dt>
<dd></dd>
</dl>
<p>
creates a split archive of the directory foo with
splits no bigger than 2&nbsp;GB each.  If foo contained 5&nbsp;GB of contents and the
contents were stored in the split archive without compression (to make
this example simple), this would create three splits, split.z01 at 2&nbsp;GB,
split.z02 at 2&nbsp;GB, and split.zip at a little over 1&nbsp;GB. <p>
The <b>-sp</b> option can be
used to pause <i>zip</i> between splits to allow changing removable media, for
example, but read the descriptions and warnings for both <b>-s</b> and <b>-sp</b> below.
<p>
Though <i>zip</i> does not update split archives, <i>zip</i> provides the new option
<b>-O</b> (<b>--output-file</b>) to allow split archives to be updated and saved in a new
archive.  For example, 
<dl>

<dt>zip inarchive.zip foo.c bar.c --out outarchive.zip </dt>
<dd></dd>
</dl>
<p>
reads
archive <b>inarchive.zip</b>, even if split, adds the files <b>foo.c</b> and <b>bar.c</b>, and
writes the resulting archive to <b>outarchive.zip</b>.  If <b>inarchive.zip</b> is split
then <b>outarchive.zip</b> defaults to the same split size.  Be aware that <b>outarchive.zip</b>
and any split files that are created with it are always overwritten without
warning.  This may be changed in the future. 
<p> 
<p> 
<p> 
<p> 
<h2><a name='sect6' href='#toc6'>Pattern Matching</a></h2>
This section
applies only to Unix. Watch this space for details on MSDOS and VMS operation.
However, the special wildcard characters <b>*</b> and <b>[]</b> below apply to at least
MSDOS also. <p>
The Unix shells (<i>sh</i>, <i>csh</i>, <i>bash</i>, and others) normally do filename
substitution (also called "globbing") on command arguments. Generally the
special characters are: 
<dl>

<dt><b>?</b> </dt>
<dd>match any single character </dd>

<dt><b>*</b> </dt>
<dd>match any number
of characters (including none) </dd>

<dt><b>[]</b> </dt>
<dd>match any character in the range indicated
within the brackets (example: [a-f], [0-9]).  This form of wildcard matching
allows a user to specify a list of characters between square brackets and
if any of the characters match the expression matches.  For example: <blockquote></dd>

<dt>zip
archive "*.[hc]" </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>would archive all files in the current directory that end
in </dt>
<dd><b>.h</b> or <b>.c</b>. 
<p> Ranges of characters are supported: <blockquote></dd>

<dt>zip archive "[a-f]*" </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>would
add to the archive all files starting with "a" through "f". </dt>
<dd>
<p> Negation is
also supported, where any character in that position not in the list matches.
 Negation is supported by adding <b>!</b> or <b>^</b> to the beginning of the list: <blockquote></dd>

<dt>zip
archive "*.[!o]" </dt>
<dd></dd>
</dl>
</blockquote>

<dl>

<dt>matches files that don&rsquo;t end in ".o". </dt>
<dd>
<p> On WIN32, [] matching
needs to be turned on with the -RE option to avoid the confusion that names
with [ or ] have caused. 
<p> </dd>
</dl>
<p>
When these characters are encountered (without
being escaped with a backslash or quotes), the shell will look for files
relative to the current path that match the pattern, and replace the argument
with a list of the names that matched. <p>
The <i>zip</i> program can do the same matching
on names that are in the <i>zip</i> archive being modified or, in the case of
the <b>-x</b> (exclude) or <b>-i</b> (include) options, on the list of files to be operated
on, by using backslashes or quotes to tell the shell not to do the name
expansion. In general, when <i>zip</i> encounters a name in the list of files to
do, it first looks for the name in the file system.  If it finds it, it
then adds it to the list of files to do. If it does not find it, it looks
for the name in the <i>zip</i> archive being modified (if it exists), using the
pattern matching characters described above, if present.  For each match,
it will add that name to the list of files to be processed, unless this
name matches one given with the <b>-x</b> option, or does not match any name given
with the <b>-i</b> option. <p>
The pattern matching includes the path, and so patterns
like \*.o match names that end in ".o", no matter what the path prefix is.
Note that the backslash must precede every special character (i.e. ?*[]),
or the entire argument must be enclosed in double quotes (""). <p>
In general,
use backslashes or double quotes for paths that have wildcards to make
<i>zip</i> do the pattern matching for file paths, and always for paths and strings
that have spaces or wildcards for <b>-i</b>, <b>-x</b>, <b>-R</b>, <b>-d</b>, and <b>-U</b> and anywhere <i>zip</i> needs
to process the wildcards. 
<h2><a name='sect7' href='#toc7'>Environment</a></h2>
<p>
The following environment variables
are read and used by <i>zip</i> as described. 
<dl>

<dt><b>ZIPOPT&nbsp;&nbsp;</b> </dt>
<dd>contains default options that
will be used when running <i>zip</i>.  The contents of this environment variable
will get added to the command line just after the <b>zip</b> command. </dd>

<dt><b>ZIP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b> </dt>
<dd>[Not
on RISC OS and VMS] see ZIPOPT </dd>

<dt><b>Zip$Options</b> </dt>
<dd>[RISC OS] see ZIPOPT </dd>

<dt><b>Zip$Exts</b>
</dt>
<dd>[RISC OS] contains extensions separated by a : that will cause native filenames
with one of the specified extensions to be added to the zip file with basename
and extension swapped. </dd>

<dt><b>ZIP_OPTS</b> </dt>
<dd>[VMS] see ZIPOPT </dd>
</dl>

<h2><a name='sect8' href='#toc8'>See Also</a></h2>
<a href='compress.1.html'>compress(1)</a>
, <a href='shar.1L.html'>shar(1L)</a>
,
<a href='tar.1.html'>tar(1)</a>
, <a href='unzip.1L.html'>unzip(1L)</a>
, <a href='gzip.1L.html'>gzip(1L)</a>
 
<h2><a name='sect9' href='#toc9'>Diagnostics</a></h2>
The exit status (or error level)
approximates the exit codes defined by PKWARE and takes on the following
values, except under VMS: <blockquote>
<dl>

<dt>0</dt>
<dd>normal; no errors or warnings detected. </dd>

<dt>2</dt>
<dd>unexpected
end of zip file. </dd>

<dt>3</dt>
<dd>a generic error in the zipfile format was detected.  Processing
may have completed successfully anyway; some broken zipfiles created by
other archivers have simple work-arounds. </dd>

<dt>4</dt>
<dd><i>zip</i> was unable to allocate memory
for one or more buffers during program initialization. </dd>

<dt>5</dt>
<dd>a severe error in
the zipfile format was detected.  Processing probably failed immediately.
</dd>

<dt>6</dt>
<dd>entry too large to be processed (such as input files larger than 2 GB
when not using Zip64 or trying to read an existing archive that is too
large) or entry too large to be split with <i>zipsplit</i> </dd>

<dt>7</dt>
<dd>invalid comment format
</dd>

<dt>8</dt>
<dd><i>zip</i> -T failed or out of memory </dd>

<dt>9</dt>
<dd>the user aborted <i>zip</i> prematurely with control-C
(or similar) </dd>

<dt>10</dt>
<dd><i>zip</i> encountered an error while using a temp file </dd>

<dt>11</dt>
<dd>read
or seek error </dd>

<dt>12</dt>
<dd><i>zip</i> has nothing to do </dd>

<dt>13</dt>
<dd>missing or empty zip file </dd>

<dt>14</dt>
<dd>error
writing to a file </dd>

<dt>15</dt>
<dd><i>zip</i> was unable to create a file to write to </dd>

<dt>16</dt>
<dd>bad command
line parameters </dd>

<dt>18</dt>
<dd><i>zip</i> could not open a specified file to read </dd>

<dt>19</dt>
<dd></dd>
</dl>
<i>zip</i> was
compiled with options not supported on this system </blockquote>
<p>
VMS interprets standard
Unix (or PC) return values as other, scarier-looking things, so <i>zip</i> instead
maps them into VMS-style status codes.  In general, <i>zip</i> sets VMS Facility
= 1955 (0x07A3), Code = 2* Unix_status, and an appropriate Severity (as
specified in ziperr.h).  More details are included in the VMS-specific documentation.
 See [.vms]NOTES.TXT and [.vms]vms_msg_gen.c.  
<h2><a name='sect10' href='#toc10'>Bugs</a></h2>
<i>zip</i> 3.0 is not compatible
with PKUNZIP 1.10. Use <i>zip</i> 1.1 to produce <i>zip</i> files which can be extracted
by PKUNZIP 1.10. <p>
<i>zip</i> files produced by <i>zip</i> 3.0 must not be <i>updated</i> by <i>zip</i>
1.1 or PKZIP 1.10, if they contain encrypted members or if they have been
produced in a pipe or on a non-seekable device. The old versions of <i>zip</i> or
PKZIP would create an archive with an incorrect format. The old versions
can list the contents of the zip file but cannot extract it anyway (because
of the new compression algorithm). If you do not use encryption and use
regular disk files, you do not have to care about this problem. <p>
Under VMS,
not all of the odd file formats are treated properly. Only stream-LF format
<i>zip</i> files are expected to work with <i>zip</i>. Others can be converted using Rahul
Dhesi&rsquo;s BILF program. This version of <i>zip</i> handles some of the conversion
internally. When using Kermit to transfer zip files from VMS to MSDOS, type
"set file type block" on VMS.  When transfering from MSDOS to VMS, type
"set file type fixed" on VMS.  In both cases, type "set file type binary"
on MSDOS. <p>
Under some older VMS versions, <i>zip</i> may hang for file specifications
that use DECnet syntax <i>foo::*.*.</i> <p>
On OS/2, zip cannot match some names, such
as those including an exclamation mark or a hash sign.  This is a bug in
OS/2 itself: the 32-bit DosFindFirst/Next don&rsquo;t find such names.  Other programs
such as GNU tar are also affected by this bug. <p>
Under OS/2, the amount of
Extended Attributes displayed by DIR is (for compatibility) the amount
returned by the 16-bit version of DosQueryPathInfo(). Otherwise OS/2 1.3 and
2.0 would report different EA sizes when DIRing a file. However, the structure
layout returned by the 32-bit DosQueryPathInfo() is a bit different, it
uses extra padding bytes and link pointers (it&rsquo;s a linked list) to have
all fields on 4-byte boundaries for portability to future RISC OS/2 versions.
Therefore the value reported by <i>zip</i> (which uses this 32-bit-mode size) differs
from that reported by DIR. <i>zip</i> stores the 32-bit format for portability,
even the 16-bit MS-C-compiled version running on OS/2 1.3, so even this one
shows the 32-bit-mode size. 
<h2><a name='sect11' href='#toc11'>Authors</a></h2>
Copyright (C) 1997-2008 Info-ZIP. <p>
Currently
distributed under the Info-ZIP license. <p>
Copyright (C) 1990-1997 Mark Adler,
Richard B. Wales, Jean-loup Gailly, Onno van der Linden, Kai Uwe Rommel,
Igor Mandrichenko, John Bush and Paul Kienitz. <p>
Original copyright: <p>
Permission
is granted to any individual or institution to use, copy, or redistribute
this software so long as all of the original files are included, that it
is not sold for profit, and that this copyright notice is retained. <p>
LIKE
ANYTHING ELSE THAT&rsquo;S FREE, ZIP AND ITS ASSOCIATED UTILITIES ARE PROVIDED
AS IS AND COME WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED.
IN NO EVENT WILL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DAMAGES RESULTING
FROM THE USE OF THIS SOFTWARE. <p>
Please send bug reports and comments using
the web page at: <i>www.info-zip.org</i>. For bug reports, please include the version
of <i>zip</i> (see <i>zip&nbsp;-h</i>), the make options used to compile it (see <i>zip&nbsp;-v</i>), the
machine and operating system in use, and as much additional information
as possible. 
<h2><a name='sect12' href='#toc12'>Acknowledgements</a></h2>
Thanks to R. P. Byrne for his <i>Shrink.Pas</i> program,
which inspired this project, and from which the shrink algorithm was stolen;
to Phil Katz for placing in the public domain the <i>zip</i> file format, compression
format, and .ZIP filename extension, and for accepting minor changes to
the file format; to Steve Burg for clarifications on the deflate format;
to Haruhiko Okumura and Leonid Broukhis for providing some useful ideas
for the compression algorithm; to Keith Petersen, Rich Wales, Hunter Goatley
and Mark Adler for providing a mailing list and <i>ftp</i> site for the Info-ZIP
group to use; and most importantly, to the Info-ZIP group itself (listed
in the file <i>infozip.who</i>) without whose tireless testing and bug-fixing efforts
a portable <i>zip</i> would not have been possible. Finally we should thank (blame)
the first Info-ZIP moderator, David Kirschbaum, for getting us into this
mess in the first place. The manual page was rewritten for Unix by R. P. C.
Rodgers and updated by E. Gordon for <i>zip</i> 3.0.  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Use</a></li>
<li><a name='toc4' href='#sect4'>Options</a></li>
<li><a name='toc5' href='#sect5'>Examples</a></li>
<li><a name='toc6' href='#sect6'>Pattern Matching</a></li>
<li><a name='toc7' href='#sect7'>Environment</a></li>
<li><a name='toc8' href='#sect8'>See Also</a></li>
<li><a name='toc9' href='#sect9'>Diagnostics</a></li>
<li><a name='toc10' href='#sect10'>Bugs</a></li>
<li><a name='toc11' href='#sect11'>Authors</a></li>
<li><a name='toc12' href='#sect12'>Acknowledgements</a></li>
</ul>
</body>
</html>
