<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>AWKA-ELM(5) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
     
<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
<p>
awka-elm - Awka Extended Library Methods 
<p> 
<h2><a name='sect1' href='#toc1'>Description</a></h2>
<b>Awka</b> is a
translator of AWK programs to ANSI-C code, and a library (<i>libawka.a</i>) against
which the code is linked to create executables. Awka is described in the
<i>awka</i> manpage. <p>
The Extended Library Methods (ELM) provide a way of adding
new functions to the AWK language, so that they appear in your AWK code
as if they were builtin functions such as substr() or index(). <p>
ELM code
interfaces with the internal Awka variable structures and functions, and
is suitable for anyone with some experience and proficiency in C programming.
<p>
This document is a step-by-step introduction to how the ELM works, so by
the end of it you can write your own libraries to extend the AWK programming
language using Awka.  For example, you could write an interface to allow
AWK  programs to communicate with ODBC databases, or solve the travelling
salesman problem given input of town locations - whatever you require AWK
to do should now be possible. 
<p> 
<h2><a name='sect2' href='#toc2'>an Overview of How it Works</a></h2>
<p>
The C code produced
by <b>awka</b> from AWK programs is heavily populated with calls to functions
in the awka library (<i>libawka</i>).  Hence after it is compiled, this code must
be linked to the library to produce a working executable. <p>
When parsing an
AWK program, <b>awka</b> checks to see if each function call in the program is
(a) a core builtin function, (b) a call to a user-defined AWK  function
in the program, or (c) a call to one of the extended builtin functions.
The above order of priority is applied, so a user-defined function (b) overrides
(c), and (a) overrides (b) to avoid conflicts. <p>
If none of these prove to
be true, the function call is written in the code in the format of a user-defined
function, even though that function doesn&rsquo;t exist to its knowledge.  <b>Awka</b>
is assuming that by link time you will provide another object file or library
that contains the missing function and resolve the call. <p>
So if I pass <b>awka</b>
the following code: <p>
<blockquote><br>
<pre>
</pre></blockquote>

<dl>

<dt><p>
BEGIN { print mymath(3,4) } </dt>
<dd></dd>
</dl>
<p>
The call it generates will look like this... <p>
<blockquote><br>
<pre>
</pre></blockquote>

<dl>

<dt><p>
mymath_fn(awka_arg2(a_TEMP, _litd0_awka, _litd1_awka)) </dt>
<dd></dd>
</dl>
<p>
So all we need to
do is write the mymath_fn() function, and link it with the awka-generated
code, and bingo!  AWK has been extended by you, to do what you want.  And
the only restrictions on what a function like mymath_fn() might do are
those imposed by the C language! <p>
So, you write the function, compile it
into a library, use it in your AWK program, translate it, link it in, and
you&rsquo;re away - its that simple (fingers crossed). 
<p> 
<h2><a name='sect3' href='#toc3'>Functions and Data Structures</a></h2>
<p>
Ok,
the first thing to notice is that the function name in the AWK code,  <i>mymath</i>,
has been appended with <i>_fn</i> in the C code.  This happens with all unresolved
AWK function calls (also with user-defined function names, but that doesn&rsquo;t
matter here).  It&rsquo;s done to avoid unintentional conflicts  with functions
in other libraries. <p>
The definition of any function is this:- <blockquote><br>
<pre>

</pre></blockquote>
<p>

<dl>

<dt>funcname_fn( a_VARARG * ) </dt>
<dd>Ugh!  What&rsquo;s this a_VARARG thingy?  Yes, learned
reader, the time has come to get acquainted with the dreaded Awka data
structures.  Well they&rsquo;re pretty simple actually.  The two you need to know
about are a_VAR and a_VARARG, and as the latter contains arrays of the
former, I&rsquo;ll deal with a_VAR first. <blockquote><br>
<pre>

</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>The a_VAR Structure</b> </dt>
<dd><blockquote><br>
<pre>








</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
typedef struct {  double dval;          /* the variable&rsquo;s numeric value
*/  char * ptr;           /* pointer to string, array or RE structure */
 unsigned int slen;    /* length of string ptr as per strlen */  unsigned
int allc;    /* space mallocated for string ptr */  char type;        
   /* records current cast of variable */  char type2;           /* special
flag for dual-type variables */  char temp;            /* TRUE if a temporary
variable */} a_VAR; </dt>
<dd></dd>
</dl>
<p>
These are used prolifically throughout the AWK library,
and are at the heart of how it manipulates data.  Remember, AWK variables
are essentially typeless, as they can be cast to number, string or regular
expression at your whim throughout a program.  The only thing you can&rsquo;t cast
to &amp; from is arrays, as a variable is only either an array or a scalar (the
other types). <p>
Recall our mymath example earlier.  In the AWK code, we had
"mymath(3,4)", but the C code was "mymath_fn(awka_arg2(a_TEMP, _litd0_awka,
_litd1_awka))". <p>
The numeric value of 3 has been changed to _litd0_awka,
and 4 to _litd1_awka. If you run awka with this example program &amp; examine
the output, you&rsquo;ll see that both _litd0_awka and _litd1_awka are pointers
to a_VAR structures, and each has been set to the appropriate numeric values.
 Hence, all data passed to our functions will be embodied inside a_VAR&rsquo;s.
  <p>
Confused?  Yes?  No?  Take heart, it doesn&rsquo;t get much worse, and with
a few more examples I hope things should be clearer.  Looking at the call
to mymath_fn above, you&rsquo;ll notice a call to awka_arg2().  Remember that mymath_fn
only takes a pointer to an a_VARARG, so awka_arg2() obviously returns one
of these. <p>
What an a_VARARG contains is an array of a_VARs, and an integer
showing how many there are in the array - thats all!  Don&rsquo;t believe me? 
Then here&rsquo;s the structure in all its glory: <blockquote><br>
<pre>

</pre></blockquote>
<p>

<dl>

<dt><b>The a_VARARG Structure</b> </dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
typedef struct {  a_VAR *var[256];  int used;} a_VARARG; </dt>
<dd></dd>
</dl>
<p>
The a_VARARG structure
gives us an easy means of passing around flexible numbers of a_VARS to
functions, much as you&rsquo;d use vararg in a C program.  If you don&rsquo;t know what
vararg does and have some time, check the <i>stdarg</i> manpage. <p>
So, to conclude,
awka_arg2() takes two a_VARs and packages them nicely into an a_VARARG
to make life easy for our function.  Another thing to note - the a_VARARG
function allows up to 256 arguments.  No parameters, only arguments, and
they always win them!  Sorry, on with the serious stuff... 
<p> 
<h2><a name='sect4' href='#toc4'>the Mymath Function
Implemented</a></h2>
<p>
So when we come to write mymath_fn, what type of thing should
it contain?  Ok, lets assume we want mymath to add the two numbers it receives
as arguments,  then add on the two numbers multiplied, and return the result,
ie. (n1+n2)+n1*n2. <p>
Well, here goes... <p>
<blockquote><br>
<pre>











</pre></blockquote>

<dl>

<dt><p>
#include &lt;libawka.h&gt; a_VAR * mymath_fn( a_VARARG *va ){   a_VAR *ret = NULL;
 if (va-&gt;used &lt; 2)    awka_error("function mymath expecting 2 arguments, only
got %d.\n",va-&gt;used);  ret = awka_getdoublevar(FALSE);  ret-&gt;dval = (awka_getd(va-&gt;var[0])
+ awka_getd(va-&gt;var[1])) +                   va-&gt;var[0]-&gt;dval * va-&gt;var[1]-&gt;dval;
 return ret;} </dt>
<dd></dd>
</dl>
<p>
Ok, there&rsquo;s not a lot to it, so lets start at the top.  You
need to include libawka.h, as it defines the data structures plus the whole
Awka API that you&rsquo;ll be calling. <p>
The definition of mymath_fn is as described
earlier.  It will need to return a numeric value, but as we&rsquo;re in AWK (conceptually),
this will need to be enclosed in an a_VAR, hence the existence of <i>ret</i>. <p>
The
incoming a_VARARG can contain any number of a_VAR&rsquo;s - we only care about
the first two, so we check to see whether these exist, and if not spit
an error through the awka_error function (or you could use your own error
handler).  When writing your own functions, you&rsquo;ll need to remember that
any number of arguments could be passed in, and they could be of any type,
so you&rsquo;ll need to check them. <p>
So far, <i>ret</i> is NULL, so we need to create a
structure to point it to. Better than that, we call awka_getdoublevar(),
which gets us a temporary variable, already initialised to contain a numeric
value.  You guessed it, there&rsquo;s an awka_getstringvar() that we could use
if our function was to return a string. The value of FALSE passed to awka_getdoublevar()
means that we don&rsquo;t want to be responsible for freeing this structure, but
prefer to leave it to libawka&rsquo;s  internal garbage collection.  I can&rsquo;t see
any reason why you&rsquo;d choose TRUE, but its there just in case. <p>
The next 2
lines do the core stuff.  Ok, ret-&gt;dval is set, that makes sense.  The expression
refers to the contents of the a_VARARG-&gt;a_VAR array, again this is  expected.
 At first, though, it calls awka_getd() for each of the arguments, but
on the next line it references the dval value directly.  Why the calls to
awka_getd? <p>
Because it can&rsquo;t be sure that the incoming variables are already
cast to numbers, so these functions (actually macros) do the casting for
us, and return the value of dval after the cast is done.  Subsequently,
we can look at dval directly as we know its been set to the current numerical
value of the variable. <p>
Lastly, we return ret. 
<p> 
<h2><a name='sect5' href='#toc5'>Compiling and Linking</a></h2>
<p>
Alright,
let&rsquo;s get this working.  Follow these steps: <blockquote><br>
<pre>











</pre></blockquote>
<p>

<dl>

<dt>  1. Create mymath.c with mymath_fn(), exactly as its written above. 2. Create
mymath.h containing:  a_VAR * mymath_fn( a_VARARG *va );3. gcc -c mymath.c
   (or use whatever C compiler you have).4. awka -i mymath.h &rsquo;BEGIN { print
mymath(3,4) }&rsquo; &gt;test.c5. gcc -I. test.c mymath.o -lawka -lm -o mytest6. mytest </dt>
<dd>The
output from running mytest should be 19.  Magic! </dd>
</dl>
<p>
A more comprehensive example
is the awkatk library available from the awka website.  Hopefully you&rsquo;ll
find it helpful, and who knows, you may even use it to write GUI interfaces
from AWK! 
<p> 
<h2><a name='sect6' href='#toc6'>How &amp; When Would You Use It?</a></h2>
<p>
Obviously, this is intended to extend
the limits of the AWK universe, as you  could introduce any functionality
written in C as a new builtin function within AWK. <p>
There may be complex
functions you&rsquo;ve written in AWK and use all the time that are just plain
inefficient, even using Awka.  They&rsquo;re stable, you have the skill to implement
them in C, so now you can, and your AWK programs become shorter in the
process.  It&rsquo;s no longer a choice of C <b>or</b> AWK, now you can migrate sections
to C as &amp; when you like. <p>
There are many functions in standard C libraries
that AWK doesn&rsquo;t have.  Things like strcasecmp(), fread(), cbrt(), and so
on.  Now you can implement them. <p>
Lastly, I&rsquo;d love to see Awka have functions
to read &amp; write proprietary formats like MS Excel, to communicate with ODBC
databases, to perform complex mathematical or scientific operations, to
implement true multi-dimensional arrays, to provide Fast Fourier Transform
functions - I know its possible.  If you do develop something  neat like
this, it&rsquo;d be very cool if you were to make it available for everyone  to
share.  Just send an email to andrewsumner@yahoo.com, and I&rsquo;d be happy to
 host it on, or link it from the Awka website. 
<p> 
<h2><a name='sect7' href='#toc7'>Note: Keep Your API "flat"</a></h2>
<p>
So
you&rsquo;ve created quite a few Awka-ELM functions that you&rsquo;ve put together into
a library.  Let&rsquo;s say they calculate the time needed to build the Sydney
 Harbour Bridge given a volume of manpower and the number of supervisors.
 Internally, there&rsquo;s quite a few algorithms that take into account strikes
by unions, material shortages, and casualties as workers fall off the bridge.
<p>
Because of this complexity, within your library functions will need to
call other functions.  This is fine.  What you need to do is not have an
API function call another API function, but instead keep any functions
they call hidden within the library, and also ensure these internal functions
do not use the awka_getdoublevar(), awka_getstringvar() or awka_tmpvar()
calls. <p>
Apart from keeping your library structure nice and hierarchical and
your API simple, it avoids overloading awka&rsquo;s internal pool of temporary
variables.  If this pool is overloaded, random chaos will ensue, so please
avoid it. 
<p> 
<h2><a name='sect8' href='#toc8'>Note: Referencing Global Variables</a></h2>
<p>
All global variables in your
AWK program are accessible by your library functions. Herein lies the potential
for great danger, so be careful! <p>
Global variables are, of course, pointers
to a_VAR structures, and their name is the same as in the AWK script, with
_awk appended.  So the variable &rsquo;myvar&rsquo; in the script would be myvar_awk in
the translated C code.  If you know what the variable name is, you can put
an extern declaration of it in your library code then work with it directly,
but this may be very restrictive, as it would mean that every script that
uses your library would need that variable name reserved.  There are other
methods. <p>
One of the easiest is with arrays.  You can pass them in as arguments
to your functions,  as their address is passed over rather than a copy
of their contents.  Scalars are not as easy.  Just say our function will
work with a global variable, however it expects a string argument to contain
the variable name in order to identify which variable to work with - this
would make it pretty flexible. <p>
You have available to you the <i>gvar_struct</i>
variable <b>_gvar</b> (both described in <a href='awka-elmref.5.html'><b>awka-elmref</b>(5)</a>
).  This contains the name
of every global variable in the script, and its a simple matter to search
down the list to find a pointer to the a_VAR structure of the variable
you want to use. <p>

<h2><a name='sect9' href='#toc9'>Note: Custom Data Structures</a></h2>
<p>
Looking again at the a_VAR
structure, you may note that it contains a char * pointer that can reference
strings, arrays and regular expressions.  There is no reason why you couldn&rsquo;t
introduce your own custom data structure and attach it to a global variable
within one of your functions, as long as you adhere to the following rules:
<p>
1. Don&rsquo;t set the variable to anything in AWK after you set it to your   
customised value, as libawka will try (and fail) to free the value up,<br>
    causing all sorts of flow-on problems.<br>
 <p>
2. Don&rsquo;t use the AWK language to copy or compare this variable to others,
    even with two variables of the same custom type (ie. custvar1 = custvar2),<br>
    as libawka will have no idea how the copy should be done, and it will
stuff<br>
    it up.  Instead, provide your own copy and comparison functions.<br>
 <p>
3. If your structures are memory intensive, you may consider providing
a method    of freeing the structures when they are no longer needed.<br>
 <p>
4. Document what your data structures and methods do, and how they should
be used    in the AWK script.  Please, please do this, as it could save
you a lot of grief<br>
    later.  If your library becomes publicly available this is especially
necessary.<br>
 <p>
This has been a very brief introduction indeed, but hopefully enough to
get you started.  I recommend you refer to the <a href='awka-elmref.5.html'><i>awka-elmref</i>(5)</a>
 manpage for
a listing  of key libawka API functions and data definitions that are available
for you to  use (but hopefully not abuse).  If you have any questions at
all, don&rsquo;t be afraid  to contact me (andrewsumner@yahoo.com).  Put the word
"awka" at the front of  your message title so I know its not spam. 
<p> 
<h2><a name='sect10' href='#toc10'>See
Also</a></h2>
<a href='awka.1.html'><b>awka</b>(1)</a>
, <a href='awka-elmref.5.html'><b>awka-elmref</b>(5)</a>
, <a href='gcc.1.html'><b>gcc</b>(1)</a>
 
<p> 
<h2><a name='sect11' href='#toc11'>Bugs</a></h2>
Bound to be plenty.  Let me know
if you find a bug with the libawka interface, or get stuck with a problem.
 I am not, though, in any way responsible for bugs  that are introduced
by your code, nor am I liable for any damages or expenses incurred as a
result.  Nor am I liable for anything you do using Awka.   <p>
I&rsquo;ll help where
I can, and I&rsquo;ll usually help debug someone&rsquo;s library if I have  a personal
interest in it.  If you&rsquo;re not sure, try me anyway, the worst I can  do is
say no, and I might be able to help.  I really like folk who send fixes
 along with bug reports, though.  And I love the folk who send cash inducements
 (at last count, um, zero folk).  Oh well, enough rambling, time to finish.

<p> 
<h2><a name='sect12' href='#toc12'>Author</a></h2>
Andrew Sumner, August 2000 (andrewsumner@yahoo.com). <p>
<p>
<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Description</a></li>
<li><a name='toc2' href='#sect2'>an Overview of How it Works</a></li>
<li><a name='toc3' href='#sect3'>Functions and Data Structures</a></li>
<li><a name='toc4' href='#sect4'>the Mymath Function Implemented</a></li>
<li><a name='toc5' href='#sect5'>Compiling and Linking</a></li>
<li><a name='toc6' href='#sect6'>How & When Would You Use It?</a></li>
<li><a name='toc7' href='#sect7'>Note: Keep Your API "flat"</a></li>
<li><a name='toc8' href='#sect8'>Note: Referencing Global Variables</a></li>
<li><a name='toc9' href='#sect9'>Note: Custom Data Structures</a></li>
<li><a name='toc10' href='#sect10'>See Also</a></li>
<li><a name='toc11' href='#sect11'>Bugs</a></li>
<li><a name='toc12' href='#sect12'>Author</a></li>
</ul>
</body>
</html>
