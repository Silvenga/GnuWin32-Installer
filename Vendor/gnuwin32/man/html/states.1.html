                      <!-- manual page source format generated by PolyglotMan v3.0.9, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>STATES(1) manual page</TITLE>
</HEAD>
<BODY bgcolor=white>
<A HREF="#toc">Table of Contents</A><P>
<P>
 
<H2><A NAME="sect0" HREF="#toc0">Name</A></H2>
states - awk alike text processing tool <P>
 
<H2><A NAME="sect1" HREF="#toc1">Synopsis</A></H2>
<B>states</B>
[<B>-hvV</B>] [<B>-D <I>var<B>=<I>val</I></B></I></B>] [<B>-f <I>file</I></B>] [<B>-o <I>outputfile</I></B>] [<B>-p <I>path</I></B>] [<B>-s <I>startstate</I></B>] [<B>-W <I>level</I></B>]
[<I>filename</I> ...] <P>
 
<H2><A NAME="sect2" HREF="#toc2">Description</A></H2>
<P>
 <B>States</B> is an awk-alike text processing tool with
some state machine extensions.  It is designed for program source code highlighting
and to similar tasks where state information helps input processing. <P>
 At
a single point of time, <B>States</B> is in one state, each quite similar to awk's
work environment, they have regular expressions which are matched from
the input and actions which are executed when a match is found.  From the
action blocks, <B>states</B> can perform state transitions; it can move to another
state from which the processing is continued.  State transitions are recorded
so <B>states</B> can return to the calling state once the current state has finished.
<P>
 The biggest difference between <B>states</B> and awk, besides state machine extensions,
is that <B>states</B> is not line-oriented.  It matches regular expression tokens
from the input and once a match is processed, it continues processing from
the current position, not from the beginning of the next input line. <P>
 
<H2><A NAME="sect3" HREF="#toc3">Options</A></H2>

<DL>

<DT><B>-D
<I>var<B>=<I>val<B>, --define=<I>var<B>=<I>val<B></B> </B></I></B></I></B></I></B></I></DT>
<DD>Define variable <I>var</I> to have string value <I>val</I>.  Command
line definitions overwrite variable definitions found from the config file.
</DD>

<DT><B>-f <I>file<B>, --file=<I>file<B></B> </B></I></B></I></DT>
<DD>Read state definitions from file <I>file</I>.  As a default,
<B>states</B> tries to read state definitions from file <B>states.st</B> in the current
working directory. </DD>

<DT><B>-h, --help</B> </DT>
<DD>Print short help message and exit. </DD>

<DT><B>-o <I>file<B>, --output=<I>file<B></B>
</B></I></B></I></DT>
<DD>Save output to file <I>file</I> instead of printing it to <B>stdout</B>. </DD>

<DT><B>-p <I>path<B>, --path=<I>path<B></B>
</B></I></B></I></DT>
<DD>Set the load path to <I>path</I>.  The load path defaults to the directory, from
which the state definitions file is loaded. </DD>

<DT><B>-s <I>state<B>, --state=<I>state<B></B> </B></I></B></I></DT>
<DD>Start execution
from state <B>state</B>.  This definition overwrites start state resolved from
the <B>start</B> block. </DD>

<DT><B>-v, --verbose</B> </DT>
<DD>Increase the program verbosity. </DD>

<DT><B>-V, --version</B> </DT>
<DD>Print
<B>states</B> version and exit. </DD>

<DT><B>-W <I>level<B>, --warning=<I>level<B></B> </B></I></B></I></DT>
<DD>Set the warning level to
<I>level</I>.  Possible values for <I>level</I> are: <blockquote></DD>

<DT><B>light</B> </DT>
<DD>light warnings (default) </DD>

<DT><B>all</B>
</DT>
<DD></DD>
</DL>
all warnings </blockquote>
<P>
 
<H2><A NAME="sect4" HREF="#toc4">States Program Files</A></H2>
<P>
 <B>States</B> program files can contain on
<I>start</I> block, <I>startrules</I> and <I>namerules</I> blocks to specify the initial state,
<I>state</I> definitions and <I>expressions</I>. <P>
 The <I>start</I> block is the main() of the
<B>states</B> program, it is executed on script startup for each input file and
it can perform any initialization the script needs.  It normally also calls
the <B>check_startrules()</B> and <B>check_namerules()</B> primitives which resolve the
initial state from the input file name or the data found from the begining
of the input file.  Here is a sample start block which initializes two variables
and does the standard start state resolving: <P>
<blockquote><BR>
<PRE>start
{
  a = 1;
  msg = "Hello, world!";
  check_startrules ();
  check_namerules ();
}
</PRE></blockquote>
<P>
Once the start block is processed, the input processing is continued from
the initial state. <P>
 The initial state is resolved by the information found
from the <I>startrules</I> and <I>namerules</I> blocks.  Both blocks contain regular expression
- symbol pairs, when the regular expression is matched from the name of
from the beginning of the input file, the initial state is named by the
corresponding symbol.  For example, the following start and name rules can
distinguish C and Fortran files: <P>
<blockquote><BR>
<PRE>namerules
{
  /.(c|h)$/    c;
  /.[fF]$/     fortran;
}
startrules
{
  /- [cC] -/      c;
  /- fortran -/   fortran;
}
</PRE></blockquote>
<P>
If these rules are used with the previously shown start block, <B>states</B> first
check the beginning of input file.  If it has string <B>-*- c -*-</B>, the file is
assumed to contain C code and the processing is started from state called
<B>c</B>.  If the beginning of the input file has string <B>-*- fortran -*-</B>, the initial
state is <B>fortran</B>.  If none of the start rules matched, the name of the input
file is matched with the namerules.  If the name ends to suffix <B>c</B> or <B>C</B>,
we go to state <B>c</B>.  If the suffix is <B>f</B> or <B>F</B>, the initial state is fortran.
<P>
 If both start and name rules failed to resolve the start state, <B>states</B>
just copies its input to output unmodified. <P>
 The start state can also be
specified from the command line with option <B>-s</B>, <B>--state</B>. <P>
 State definitions
have the following syntax: <P>
 <B>state { <I>expr</I> {<I>statements</I>} ... }</B> <P>
 where <I>expr</I> is:
a regular expression, special expression or symbol and <I>statements</I> is a
list of statements.  When the expression <I>expr</I> is matched from the input,
the statement block is executed.  The statement block can call <B>states</B>' primitives,
user-defined subroutines, call other states, etc.  Once the block is executed,
the input processing is continued from the current intput position (which
might have been changed if the statement block called other states). <P>
 Special
expressions <B>BEGIN</B> and <B>END</B> can be used in the place of <I>expr</I>.  Expression
<B>BEGIN</B> matches the beginning of the state, its block is called when the
state is entered.  Expression <B>END</B> matches the end of the state, its block
is executed when <B>states</B> leaves the state. <P>
 If <I>expr</I> is a symbol, its value
is looked up from the global environment and if it is a regular expression,
it is matched to the input, otherwise that rule is ignored. <P>
 The <B>states</B>
program file can also have top-level expressions, they are evaluated after
the program file is parsed but before any input files are processed or
the <I>start</I> block is evaluated. <P>
 
<H2><A NAME="sect5" HREF="#toc5">Primitive Functions</A></H2>
<P>
 
<DL>

<DT><B>call (<I>symbol<B>)</B> </B></I></DT>
<DD>Move to
state <I>symbol</I> and continue input file processing from that state.  Function
returns whatever the <B>symbol</B> state's terminating <B>return</B> statement returned.
</DD>

<DT><B>calln (<I>name<B>)</B> </B></I></DT>
<DD>Like <B>call</B> but the argument <I>name</I> is evaluated and its value
must be string.  For example, this function can be used to call a state
which name is stored to a variable. </DD>

<DT><B>check_namerules ()</B> </DT>
<DD>Try to resolve start
state from <B>namerules</B> rules.  Function returns <B>1</B> if start state was resolved
or <B>0</B> otherwise. </DD>

<DT><B>check_startrules ()</B> </DT>
<DD>Try to resolve start state from <B>startrules</B>
rules.  Function returns <B>1</B> if start state was resolved or <B>0</B> otherwise. </DD>

<DT><B>concat
(<I>str<B>, ...)</B> </B></I></DT>
<DD>Concanate argument strings and return result as a new string. </DD>

<DT><B>float
(<I>any<B>)</B> </B></I></DT>
<DD>Convert argument to a floating point number. </DD>

<DT><B>getenv (<I>str<B>)</B> </B></I></DT>
<DD>Get value
of environment variable <I>str</I>.  Returns an empty string if variable <I>var</I> is
undefined. </DD>

<DT><B>int (<I>any<B>)</B> </B></I></DT>
<DD>Convert argument to an integer number. </DD>

<DT><B>length (<I>item<B>,
...)</B> </B></I></DT>
<DD>Count the length of argument strings or lists. </DD>

<DT><B>list (<I>any<B>, ...)</B> </B></I></DT>
<DD>Create a new
list which contains items <I>any</I>, ... </DD>

<DT><B>panic (<I>any<B>, ...)</B> </B></I></DT>
<DD>Report a non-recoverable error
and exit with status <B>1</B>.  Function never returns. </DD>

<DT><B>print (<I>any<B>, ...)</B> </B></I></DT>
<DD>Convert arguments
to strings and print them to the output. </DD>

<DT><B>range (<I>source<B>, <I>start<B>, <I>end<B>)</B> </B></I></B></I></B></I></DT>
<DD>Return
a sub-range of <I>source</I> starting from position <I>start</I> (inclusively) to <I>end</I>
(exclusively).  Argument <I>source</I> can be string or list. </DD>

<DT><B>regexp (<I>string<B>)</B> </B></I></DT>
<DD>Convert
string <I>string</I> to a new regular expression. </DD>

<DT><B>regexp_syntax (<I>char<B>, <I>syntax<B>)</B>
</B></I></B></I></DT>
<DD>Modify regular expression character syntaxes by assigning new syntax <I>syntax</I>
for character <I>char</I>.  Possible values for <I>syntax</I> are: <blockquote></DD>

<DT><B>'w'</B> </DT>
<DD>character is a word
constituent </DD>

<DT><B>' '</B> </DT>
<DD></DD>
</DL>
character isn't a word constituent </blockquote>

<DL>

<DT><B>regmatch (<I>string<B>, <I>regexp<B>)</B>
</B></I></B></I></DT>
<DD>Check if string <I>string</I> matches regular expression <I>regexp</I>. Functions returns
a boolean success status and sets sub-expression registers <B>$<I>n</I></B>. </DD>

<DT><B>regsub (<I>string</I>,
<I>regexp<B>, <I>subst<B>)</B> </B></I></B></I></DT>
<DD>Search regular expression <I>regexp</I> from string <I>string</I> and
replace the matching substring with string <I>subst</I>.  Returns the resulting
string.  The substitution string <I>subst</I> can contain <B>$<I>n</I></B> references to the
<I>n</I>:th parenthesized sup-expression. </DD>

<DT><B>regsuball (<I>string</I>, <I>regexp<B>, <I>subst<B>)</B> </B></I></B></I></DT>
<DD>Like
<B>regsub</B> but replace all matches of regular expression <I>regexp</I> from string
<I>string</I> with string <I>subst</I>. </DD>

<DT><B>require_state (<I>symbol<B>)</B> </B></I></DT>
<DD>Check that the state <I>symbol</I>
is defined.  If the required state is undefined, the function tries to autoload
it.  If the loading fails, the program will terminate with an error message.
</DD>

<DT><B>split (<I>regexp<B>, <I>string<B>)</B> </B></I></B></I></DT>
<DD>Split string <I>string</I> to list considering matches
of regular rexpression <I>regexp</I> as item separator. </DD>

<DT><B>sprintf (<I>fmt</I>, ...)</B> </DT>
<DD>Format
arguments according to <I>fmt</I> and return result as a string. </DD>

<DT><B>strcmp (<I>str1<B>,
<I>str2<B>)</B> </B></I></B></I></DT>
<DD>Perform a case-sensitive comparision for strings <I>str1</I> and <I>str2</I>.  Function
returns a value that is: <blockquote></DD>

<DT><B>-1</B> </DT>
<DD>string <I>str1</I> is less than <I>str2</I> </LI><B></B><LI>strings are equal
</LI><B></B><LI></LI>
</OL>
string <I>str1</I> is greater than <I>str2</I> </blockquote>

<DL>

<DT><B>string (<I>any<B>)</B> </B></I></DT>
<DD>Convert argument to string.
</DD>

<DT><B>strncmp (<I>str1<B>, <I>str2<B>, <I>num<B>)</B> </B></I></B></I></B></I></DT>
<DD>Perform a case-sensitive comparision for strings
<I>str1</I> and <I>str2</I> comparing at maximum <I>num<B> characters. </DD>

<DT><B>substring (<I>str<B>, <I>start<B>,
<I>end<B>)</B> </B></I></B></I></B></I></B></I></DT>
<DD>Return a substring of string <I>str</I> starting from position <I>start</I> (inclusively)
to <I>end</I> (exclusively). </DD>
</DL>
</blockquote>
<P>
 
<H2><A NAME="sect6" HREF="#toc6">Builtin Variables</A></H2>

<DL>

<DT><B>$.</B> </DT>
<DD>current input line number </DD>

<DT><B>$<I>n<B></B> </B></I></DT>
<DD>the
<I>n</I>:th parenthesized regular expression sub-expression from the latest state
regular expression or from the <B>regmatch</B> primitive </DD>

<DT><B>$`</B> </DT>
<DD>everything before the
matched regular rexpression.  This is usable when used with the <B>regmatch</B>
primitive; the contents of this variable is undefined when used in action
blocks to refer the data before the block's regular expression. </DD>

<DT><B>$B</B> </DT>
<DD>an alias
for <B>$`</B> </DD>

<DT><B>argv</B> </DT>
<DD>list of input file names </DD>

<DT><B>filename</B> </DT>
<DD>name of the current input
file </DD>

<DT><B>program</B> </DT>
<DD>name of the program (usually <B>states</B>) </DD>

<DT><B>version</B> </DT>
<DD></DD>
</DL>
program version
string </blockquote>
<P>
 
<H2><A NAME="sect7" HREF="#toc7">Files</A></H2>
<BR>
<PRE>c:/progra~1/enscript/share/enscript/hl/*.st<tt> </tt>&nbsp;<tt> </tt>&nbsp;enscript's states definitions
</PRE><P>
 
<H2><A NAME="sect8" HREF="#toc8">See Also</A></H2>
<A HREF="awk.1.html">awk(1)</A>
, <A HREF="enscript.1.html">enscript(1)</A>
 <P>
 
<H2><A NAME="sect9" HREF="#toc9">Author</A></H2>
Markku Rossi &lt;mtr@iki.fi&gt; &lt;<A HREF="http://www.iki.fi/~mtr/">http://www.iki.fi/~mtr/</A>
&gt;
<P>
 GNU Enscript WWW home page: &lt;<A HREF="http://www.iki.fi/~mtr/genscript/">http://www.iki.fi/~mtr/genscript/</A>
&gt; <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Options</A></LI>
<LI><A NAME="toc4" HREF="#sect4">States Program Files</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Primitive Functions</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Builtin Variables</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Files</A></LI>
<LI><A NAME="toc8" HREF="#sect8">See Also</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Author</A></LI>
</UL>
</BODY></HTML>
