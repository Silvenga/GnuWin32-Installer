<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>MAWK(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
mawk - pattern scanning and text processing language 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>mawk</b> [-<b>W
<i>option</i>] [-<b>F <i>value</i>] [-<b>v <i>var=value</i>] [--] &rsquo;program text&rsquo; [file ...] <br>
</b></b></b><b>mawk</b> [-<b>W <i>option</i>] [-<b>F <i>value</i>] [-<b>v <i>var=value</i>] [-<b>f <i>program-file</i>] [--] [file ...] 
<h2><a name='sect2' href='#toc2'></b></b></b></b>Description</a></h2>
<b>mawk</b>
is an interpreter for the AWK Programming Language. The AWK language is
useful for manipulation of data files, text retrieval and processing, and
for prototyping and experimenting with algorithms. <b>mawk</b> is a <i>new awk</i> meaning
it implements the AWK language as defined in Aho, Kernighan and Weinberger,
<i>The AWK Programming Language,</i> Addison-Wesley Publishing, 1988.  (Hereafter
referred to as the AWK book.) <b>mawk</b> conforms to the Posix 1003.2 (draft 11.3)
definition of the AWK language which contains a few features not described
in the AWK book,  and <b>mawk</b> provides a small number of extensions. <p>
An AWK
program is a sequence of <i>pattern {action}</i> pairs and function definitions.
Short programs are entered on the command line usually enclosed in &rsquo; &rsquo; to
avoid shell interpretation. Longer programs can be read in from a file with
the -f option. Data  input is read from the list of files on the command
line or from standard input when the list is empty. The input is broken
into records as determined by the record separator variable, <b>RS</b>.  Initially,
<b>RS</b> = "\n" and records are synonymous with lines. Each record is compared
against each <i>pattern</i> and if it matches, the program text for <i>{action}</i> is
executed. 
<h2><a name='sect3' href='#toc3'>Options</a></h2>

<dl>

<dt>-<b>F <i>value</i></b> </dt>
<dd>sets the field separator, <b>FS</b>, to  <i>value</i>. </dd>

<dt>-<b>f <i>file
</i></b></dt>
<dd>Program text is read from <i>file</i> instead of from the command line.  Multiple
<b>-f</b> options are allowed. </dd>

<dt>-<b>v <i>var=value</i></b> </dt>
<dd>assigns  <i>value</i> to program variable  <i>var</i>.
</dd>

<dt>-- </dt>
<dd>indicates the unambiguous end of options. </dd>
</dl>
<p>
The above options will be available
with any Posix compatible implementation of AWK, and implementation specific
options are prefaced with <b>-W</b>. <b>mawk </b> provides six: 
<dl>

<dt>-<b>W </b>version </dt>
<dd><b>mawk</b> writes its
version and copyright to stdout and compiled limits to stderr and exits
0. </dd>

<dt>-<b>W </b>dump </dt>
<dd>writes an assembler like listing of the internal representation
of the program to stdout and exits 0  (on successful compilation). </dd>

<dt>-<b>W </b>interactive
</dt>
<dd>sets unbuffered writes to stdout and line buffered reads from stdin. Records
from stdin are lines regardless of the value of <b>RS</b>. </dd>

<dt>-<b>W </b>exec <i>file </i></dt>
<dd>Program
text is read from  <i>file</i> and this is the last option. Useful on systems that
support the <b>#!</b> "magic number" convention for executable scripts. </dd>

<dt>-<b>W </b>sprintf=<i>num</i>
</dt>
<dd>adjusts the size of  <b>mawk&rsquo;s</b> internal sprintf buffer to  <i>num</i> bytes.  More
than rare use of this option indicates <b>mawk</b> should be recompiled. </dd>

<dt>-<b>W </b>posix_space
</dt>
<dd>forces <b>mawk</b> not to consider &rsquo;\n&rsquo; to be space. </dd>
</dl>
<p>
The short forms  <b>-W</b>[vdiesp] are
recognized and on some systems <b>-W</b>e is mandatory to avoid command line length
limitations. 
<h2><a name='sect4' href='#toc4'>the AWK Language</a></h2>

<h3><a name='sect5' href='#toc5'><b>1. Program structure</b></a></h3>
An AWK program is a sequence
of  <i>pattern {action}</i>  pairs and user function definitions. <p>
A pattern can
be: <br>
<pre>BEGIN
END
expression
expression , expression

</pre>One, but not both, of <i>pattern {action}</i> can be omitted.   If  <i>{action}</i> is
omitted it is implicitly { print }.  If  <i>pattern</i>  is omitted, then it is
implicitly matched. <b>BEGIN</b> and <b>END</b> patterns require an action. <p>
Statements
are terminated by newlines, semi-colons or both. Groups of statements such
as actions or loop bodies are blocked via { ... } as in C.  The last statement
in a block doesn&rsquo;t need a terminator.  Blank lines have no meaning; an empty
statement is terminated with a semi-colon. Long statements can be continued
with a backslash, \.  A statement can be broken without a backslash after
a comma, left brace, &amp;&amp;, ||,  <b>do</b>,<b></b> <b>else</b>, the right parenthesis of an  <b>if</b>,<b></b> <b>while
</b> or <b>for</b> statement, and the right parenthesis of a function definition. A
comment starts with # and extends to, but does not include the end of line.
<p>
The following statements control program flow inside blocks. <blockquote><p>
<b>if </b> (  ) <i>statement</i>
<p>
<b>if </b> (  ) <i>statement</i> <b>else </b> <i>statement</i> <p>
<b>while</b> (  ) <i>statement</i> <p>
<b>do</b> <i>statement</i> <b>while</b>
(  ) <p>
<b>for</b> ( <i>opt_expr</i> ; <i>opt_expr</i> ; <i>opt_expr</i>  ) <i>statement</i> <p>
<b>for</b> ( <i>var <b>in <i>array</i></b></i>
) <i>statement</i> <p>
<b>continue</b> <p>
<b>break</b> </blockquote>
 
<h3><a name='sect6' href='#toc6'><b>2. Data types, conversion and comparison</b></a></h3>
There
are two basic data types, numeric and string. Numeric constants can be integer
like -2, decimal like 1.08, or in scientific notation like  -1.1e4 or .28E-3.
 All numbers are represented internally and all computations are done in
floating point arithmetic. So for example, the expression 0.2e2 == 20 is
true and true is represented as 1.0. <p>
String constants are enclosed in double
quotes. <p>
<center>"This is a string with a newline at the end.\n"<p>
</center> Strings can be continued
across a line by escaping (\) the newline. The following escape sequences
are recognized. <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\\<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;\
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\"<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\a<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;alert, ascii 7
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\b<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;backspace, ascii 8
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\t<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;tab, ascii 9
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\n<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;newline, ascii 10
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\v<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;vertical tab, ascii 11
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\f<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;formfeed, ascii 12
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\r<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;carriage return, ascii 13
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\ddd<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;1, 2 or 3 octal digits for ascii ddd
<tt> </tt>&nbsp;<tt> </tt>&nbsp;\xhh<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;1 or 2 hex digits for ascii  hh

</pre>If you escape any other character \c, you get \c, i.e.,  <b>mawk</b> ignores the escape.
<p>
There are really three basic data types; the third is  <i>number and string</i>
which has both a numeric value and a string value at the same time. User
defined variables come into existence when first referenced and are initialized
to  <i>null</i>, a number and string value which has numeric value 0 and string
value "". Non-trivial number and string typed data come from input  and are
typically stored in fields.  (See section 4). <p>
The type of an expression is
determined by its context and automatic type conversion occurs if needed.
 For example, to evaluate the statements <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;y = x + 2  ;  z = x  "hello"

</pre>The value stored in variable y will be typed numeric. If x is not numeric,
the value read from x is converted to numeric before it is added to 2 and
stored in y.  The value stored in variable z will be typed string, and the
value of x will be converted to string if necessary and concatenated with
"hello".  (Of course, the value and type stored in x is not changed by any
conversions.) A string expression is converted to numeric using its longest
numeric prefix as with  <a href='atof.3.html'><i>atof</i>(3)</a>
. A numeric expression is converted to string
by replacing <i>expr</i> with  <b>sprintf(CONVFMT</b>, <i>expr</i>), unless  <i>expr</i> can be represented
on the host machine as an exact integer then it is converted to <b>sprintf</b>("%d",
). <b>Sprintf()</b> is an AWK built-in that duplicates the functionality of <a href='sprintf.3.html'><i>sprintf</i>(3)</a>
,
and <b>CONVFMT</b> is a built-in variable used for internal conversion from number
to string and initialized to "%.6g". Explicit type conversions can be forced,
 "" is string and <i>expr</i>+0 is numeric. <p>
To evaluate, d1u <b>rel-op d2u, if both
operands are numeric or number and string then the comparison is numeric;
if both operands are string the comparison is string; if one operand is
string, the non-string operand is converted and the comparison is string.
 The result is numeric, 1 or 0. <p>
In boolean contexts such as, <b>if</b></b> (  ) <i>statement</i>,
a string expression evaluates true if and only if it is not the empty string
"";  numeric values if and only if not numerically zero.  
<h3><a name='sect7' href='#toc7'><b>3. Regular expressions</b></a></h3>
In
the AWK language, records, fields and strings are often tested for matching
a  <i>regular expression</i>. Regular expressions are enclosed in slashes, and
<br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp; ~ /r/

</pre>is an AWK expression that evaluates to 1 if  "matches" <i>r</i>, which means a
substring of  is in the set of strings defined by  <i>r</i>. With no match the
expression evaluates to 0; replacing ~ with the "not match" operator, !~
, reverses the meaning. As  pattern-action pairs, <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;/r/ { action }   and, reverses the meaning.
   $0 ~ /r/ { action }

</pre>are the same, and for each input record that matches <i>r</i>, <i>action</i> is executed.
In fact, /<i>r</i>/ is an AWK expression that is equivalent to (<b>$0</b> ~ /<i>r</i>/) anywhere
except when on the right side of a match operator or passed as an argument
to a built-in function that expects a regular expression  argument. <p>
AWK uses
extended regular expressions as with <a href='egrep.1.html'><i>egrep</i>(1)</a>
. The regular expression metacharacters,
i.e., those with special meaning in regular expressions are <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;&nbsp;^ $ . [ ] | ( ) * + ?

</pre>Regular expressions are built up from characters as follows: <blockquote>
<dl>

<dt><i>c</i> </dt>
<dd>matches
any non-metacharacter <i>c</i>. </dd>

<dt>\<i>c</i> </dt>
<dd>matches a character defined by the same escape
sequences used in string constants or the literal character <i>c</i>  if \<i>c</i> is
not an escape sequence. </li>.<li>matches any character (including newline). </dd>

<dt>^ </dt>
<dd>matches
the front of a string. </dd>

<dt>$ </dt>
<dd>matches the back of a string. </dd>

<dt>[cd1ucd2ucd3u...] </dt>
<dd>matches
any character in the class cd1ucd2ucd3u... .  An interval of characters is
denoted cd1u-cd2u inside a class [...]. </dd>

<dt>[^cd1ucd2ucd3u...] </dt>
<dd>matches any character
not in the class cd1ucd2ucd3u... </dd>
</dl>
</blockquote>
<p>
Regular expressions are built up from other
regular expressions as follows: <blockquote>
<dl>

<dt><i>r</i>d1u<i>r</i>d2u </dt>
<dd>matches  <i>r</i>d1u followed immediately
by <i>r</i>d2u (concatenation). </dd>

<dt><i>r</i>d1u | <i>r</i>d2u </dt>
<dd>matches  <i>r</i>d1u or <i>r</i>d2u (alternation).
</dd>

<dt><i>r</i>* </dt>
<dd>matches <i>r</i> repeated zero or more times. </dd>

<dt><i>r</i>+ </dt>
<dd>matches <i>r</i> repeated one or more
times. </dd>

<dt><i>r</i>? </dt>
<dd>matches <i>r</i> zero or once. </dd>

<dt>(<i>r</i>) </dt>
<dd>matches <i>r</i>, providing grouping. </dd>
</dl>
</blockquote>
<p>
The increasing
precedence of operators is alternation,  concatenation and unary (*, +
or ?). <p>
For example, <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;/^[_a-zA-Z][_a-zA-Z0-9]*$/  and
<tt> </tt>&nbsp;<tt> </tt>&nbsp;/^[-+]?([0-9]+\.?|\.[0-9])[0-9]*([eE][-+]?[0-9]+)?$/

</pre>are matched by AWK identifiers and AWK numeric constants respectively. 
Note that . has to be escaped to be recognized as a decimal point, and that
metacharacters are not special inside character classes. <p>
Any expression
can be used on the right hand side of the ~ or !~ operators or passed to
a built-in that expects a regular expression. If needed, it is converted
to string, and then interpreted as a regular expression.  For example, <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;BEGIN { identifier = "[_a-zA-Z][_a-zA-Z0-9]*" }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;$0 ~ "^" identifier

</pre>prints all lines that start with an AWK identifier. <p>
<b>mawk</b> recognizes the
empty regular expression, //, which matches the empty string and hence
is matched by any string at the front, back and between every character.
 For example, <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;echo  abc | mawk { gsub(//, "X") ; print }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;XaXbXcX

</pre> 
<h3><a name='sect8' href='#toc8'><b>4. Records and fields</b></a></h3>
Records are read in one at a time, and stored in the
<i>field</i> variable  <b>$0</b>. The record is split into <i>fields</i> which are stored in
<b>$1</b>, <b>$2</b>, ..., <b>$NF</b>. The built-in variable <b>NF</b> is set to the number of fields, and
 <b>NR</b> and <b>FNR</b> are incremented by 1. Fields above  <b>$NF</b> are set to "". <p>
Assignment
to <b>$0</b> causes the fields and  <b>NF</b> to be recomputed. Assignment to <b>NF</b> or to
a field causes  <b>$0</b> to be reconstructed by concatenating the <b>$i&rsquo;s</b> separated
by <b>OFS</b>. Assignment to a field with index greater than <b>NF</b>, increases <b>NF</b> and
causes <b>$0</b> to be reconstructed. <p>
Data input stored in fields is string, unless
the entire field has numeric form and then the type is number and string.
For example, <p>
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;echo 24 24E | 
<tt> </tt>&nbsp;<tt> </tt>&nbsp;mawk &rsquo;{ print($1&gt;100, $1&gt;"100", $2&gt;100, $2&gt;"100") }&rsquo;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;0 1 1 1
</pre><p>
<b>$0</b> and <b>$2</b> are string and <b>$1</b> is number and string.  The first comparison
is numeric, the second is string, the third is string (100 is converted
to "100"), and the last is string.  
<h3><a name='sect9' href='#toc9'><b>5. Expressions and operators</b></a></h3>
<p>
The expression
syntax is  similar to C.  Primary expressions are numeric constants, string
constants, variables, fields, arrays and function calls.   The identifier
for a variable, array or function can be a sequence of letters, digits
and underscores, that does not start with a digit. Variables are not declared;
they exist when first referenced and are initialized to <i>null</i>. <p>
New expressions
are composed with the following operators in order of increasing precedence.
<p>
<blockquote><br>
<pre>assignment<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;=  +=  -=  *=  /=  %=  ^=
conditional<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;?  :
logical or<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;||
logical and<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;&amp;&amp;
array membership<tt> </tt>&nbsp;<tt> </tt>&nbsp;in
matching<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;~   !~
relational<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;&lt;  &gt;   &lt;=  &gt;=  ==  !=
concatenation<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;(no explicit operator)
add ops<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;+  -
mul ops<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;*  /  % 
unary<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;+  -
logical not<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;!
exponentiation<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;^
inc and dec<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;++ -- (both post and pre)
field<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;$

</pre>Assignment, conditional and exponentiation associate right to left; the
other operators associate left to right.  Any expression can be parenthesized.
 
<h3><a name='sect10' href='#toc10'><b>6. Arrays</b></a></h3>
Awk provides one-dimensional arrays.  Array elements are expressed
as . <i>Expr</i> is internally converted to string type, so, for example, A[1]
and A["1"] are the same element and the actual index is "1". Arrays indexed
by strings are called associative arrays. Initially an array is empty; elements
exist when first accessed. An expression, <i>expr<b> in<i> array</i></b></i> evaluates to 1 if
  exists, else to 0. <p>
There is a form of the <b>for</b> statement that loops over
each index of an array. <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;for ( var in array ) statement

</pre>sets <i>var</i> to each index of <i>array</i> and executes  <i>statement</i>. The order that
<i>var</i> transverses the indices of <i>array</i> is not defined. <p>
The statement, <b>delete</b>
, causes  not to exist. <b>mawk </b> supports an extension, <b>delete </b> <i>array</i>, which
deletes all elements of  <i>array</i>. <p>
Multidimensional arrays are synthesized
with concatenation using the built-in variable <b>SUBSEP</b>. <i>array</i>[<i>expr</i>d1u,<i>expr</i>d2u]
is equivalent to <i>array</i>[<i>expr</i>d1u <b>SUBSEP <i>expr</i></b>d2u]. Testing for a multidimensional
element uses a parenthesized index, such as <p>
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;if ( (i, j) in A )  print A[i, j]
</pre><p>
 
<h3><a name='sect11' href='#toc11'><b>7. Builtin-variables</b></a></h3>
<p>
The following variables are built-in and initialized
before program execution. <blockquote>
<dl>

<dt><b>ARGC</b> </dt>
<dd>number of command line arguments. </dd>

<dt><b>ARGV</b> </dt>
<dd>array
of command line arguments, 0..ARGC-1. </dd>

<dt><b>CONVFMT</b> </dt>
<dd>format for internal conversion
of numbers to string,  initially = "%.6g". </dd>

<dt><b>ENVIRON</b> </dt>
<dd>array indexed by environment
variables.  An environment string, <i>var=value</i> is stored as  <b>ENVIRON</b>[<i>var</i>]
=  <i>value</i>. </dd>

<dt><b>FILENAME</b> </dt>
<dd>name of the current input file. </dd>

<dt><b>FNR</b> </dt>
<dd>current record number
in <b>FILENAME</b>. </dd>

<dt><b>FS</b> </dt>
<dd>splits records into fields as a regular expression. </dd>

<dt><b>NF</b> </dt>
<dd>number
of fields in the current record. </dd>

<dt><b>NR</b> </dt>
<dd>current record number in the total input
stream. </dd>

<dt><b>OFMT</b> </dt>
<dd>format for printing numbers; initially = "%.6g". </dd>

<dt><b>OFS</b> </dt>
<dd>inserted
between fields on output, initially = " ". </dd>

<dt><b>ORS</b> </dt>
<dd>terminates each record on
output, initially = "\n". </dd>

<dt><b>RLENGTH</b> </dt>
<dd>length set by the last call to the built-in
function, <b>match()</b>. </dd>

<dt><b>RS</b> </dt>
<dd>input record separator, initially = "\n". </dd>

<dt><b>RSTART</b> </dt>
<dd>index
set by the last call to <b>match()</b>. </dd>

<dt><b>SUBSEP</b> </dt>
<dd>used to build multiple array subscripts,
initially = "\034". </dd>
</dl>
</blockquote>
 
<h3><a name='sect12' href='#toc12'><b>8. Built-in functions</b></a></h3>
String functions <blockquote>
<dl>

<dt>gsub(<i>r,s,t</i>)  gsub(<i>r,s</i>)
</dt>
<dd>Global substitution, every match of regular expression <i>r</i> in variable  <i>t</i>
is replaced by string <i>s</i>. The number of replacements is returned. If  <i>t</i> is
omitted, <b>$0 </b> is used.  An &amp; in the replacement string <i>s</i> is replaced by the
matched substring of <i>t</i>. \&amp; and \\ put  literal &amp; and \, respectively, in the replacement
string. </dd>

<dt>index(<i>s,t</i>) </dt>
<dd>If  <i>t</i> is a substring of <i>s</i>, then the position where  <i>t</i>
starts is returned, else 0 is returned. The first character of <i>s</i> is in position
1. </dd>

<dt>length(<i>s</i>) </dt>
<dd>Returns the length of string <i>s</i>. </dd>

<dt>match(<i>s,r</i>) </dt>
<dd>Returns the index
of the first longest match of regular expression <i>r</i> in string <i>s</i>. Returns
0 if no match. As a side effect, <b>RSTART</b> is set to the return value. <b>RLENGTH</b>
is set to the length of the match or -1 if no match.  If the empty string
is matched,  <b>RLENGTH</b> is set to 0, and 1 is returned if the match is at
the front, and length(<i>s</i>)+1 is returned if the match is at the back. </dd>

<dt>split(<i>s,A,r</i>)
 split(<i>s,A</i>) </dt>
<dd>String <i>s</i> is split into fields by regular expression <i>r</i> and the
fields are loaded into array <i>A</i>. The number of fields is returned.  See section
11 below for more detail. If <i>r</i> is omitted,  <b>FS</b> is used. </dd>

<dt>sprintf(<i>format,expr-list</i>)
</dt>
<dd>Returns a string constructed from <i>expr-list</i> according to <i>format</i>. See the
description of printf() below. </dd>

<dt>sub(<i>r,s,t</i>)  sub(<i>r,s</i>) </dt>
<dd>Single substitution,
same as gsub() except at most one substitution. </dd>

<dt>substr(<i>s,i,n</i>)  substr(<i>s,i</i>)
</dt>
<dd>Returns the substring of string <i>s</i>, starting at index  <i>i</i>,<i></i> of length <i>n</i>. If
 <i>n</i> is omitted, the suffix of <i>s</i>, starting at <i>i</i> is returned. </dd>

<dt>tolower(<i>s</i>) </dt>
<dd>Returns
a copy of <i>s</i> with all upper case characters converted to lower case. </dd>

<dt>toupper(<i>s</i>)
</dt>
<dd>Returns a copy of <i>s</i> with all lower case characters converted to upper case.
</dd>
</dl>
</blockquote>
<p>
Arithmetic functions <blockquote><p>
<br>
<pre>
atan2(y,x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;Arctan of y/x between - and .

cos(x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Cosine function, x in radians.

exp(x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Exponential function.

int(x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Returns x truncated towards zero.

log(x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Natural logarithm.

rand()<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Returns a random number between zero and one.

sin(x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Sine function, x in radians.

sqrt(x)<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;Returns square root of x.
</pre>
<dl>

<dt>srand(<i>expr</i>)  srand() </dt>
<dd>Seeds the random number generator, using the clock
if <i>expr</i> is omitted, and returns the value of the previous seed. <b>mawk</b> seeds
the random number generator from the clock at startup so there is no real
need to call srand().  Srand(<i>expr</i>) is useful for repeating pseudo random
sequences. </dd>
</dl>
</blockquote>
 
<h3><a name='sect13' href='#toc13'><b>9. Input and output</b></a></h3>
There are two output statements,  <b>print</b> and
<b>printf</b>. <blockquote>
<dl>

<dt>print </dt>
<dd>writes <b>$0  ORS</b> to standard output. </dd>

<dt>print d1u, d2u, ..., dnu </dt>
<dd>writes
d1u <b>OFS d2u <b>OFS</b></b> ... dnu <b>ORS</b> to standard output.  Numeric expressions are converted
to string with  <b>OFMT</b>. </dd>

<dt>printf <i>format, expr-list</i> </dt>
<dd>duplicates the printf C library
function writing to standard output. The complete ANSI C format specifications
are recognized with conversions %c, %d, %e, %E, %f, %g, %G, %i, %o, %s,
%u, %x, %X and %%, and conversion qualifiers h and l. </dd>
</dl>
</blockquote>
<p>
The argument list
to print or printf can optionally be enclosed in parentheses. Print formats
numbers using <b>OFMT</b> or "%d" for exact integers. "%c" with a numeric argument
prints the corresponding 8 bit  character, with a string argument it prints
the first character of the string. The output of print and printf can be
redirected to a file or command by appending &gt;  <i>file</i>, &gt;&gt; <i>file</i> or | <i>command</i>
to the end of the print statement. Redirection opens  <i>file</i> or <i>command</i> only
once, subsequent redirections append to the already open stream. By convention,
 <b>mawk</b> associates the filename "/dev/stderr" with stderr which allows print
and printf to be redirected to stderr. <b>mawk</b> also associates "-" and "/dev/stdout"
with stdin and stdout which allows these streams to be passed to functions.
<p>
The input function <b>getline</b> has the following variations. <blockquote>
<dl>

<dt>getline </dt>
<dd>reads into
<b>$0</b>, updates the fields, <b>NF</b>, <b>NR</b> and  <b>FNR</b>. </dd>

<dt>getline &lt; <i>file</i> </dt>
<dd>reads into <b>$0</b> from
<i>file</i>,  updates the fields and <b>NF</b>. </dd>

<dt>getline <i>var </i></dt>
<dd>reads the next record into
<i>var</i>, updates <b>NR</b> and <b>FNR</b>. </dd>

<dt>getline <i>var</i> &lt; <i>file </i></dt>
<dd>reads the next record of <i>file</i>
into <i>var</i>. </dd>

<dt><i> command</i> | getline </dt>
<dd>pipes a record from  <i>command</i> into <b>$0</b> and updates
the fields and <b>NF</b>. </dd>

<dt><i> command</i> | getline <i>var </i></dt>
<dd>pipes a record from  <i>command</i> into
<i>var</i>. </dd>
</dl>
</blockquote>
<p>
Getline returns 0 on end-of-file, -1 on error, otherwise 1. <p>
Commands on
the end of pipes are executed by /bin/sh. <p>
The function <b>close</b>() closes the
file or pipe associated with <i>expr</i>. Close returns 0 if <i>expr</i> is an open file,
the exit status if <i>expr</i> is a piped command, and -1 otherwise. Close is used
to reread a file or command, make sure the other end of an output pipe
is finished or conserve file resources. <p>
The function <b>fflush</b>() flushes the
output file or pipe associated with <i>expr</i>. Fflush returns 0 if <i>expr</i> is an
open output stream else -1. Fflush without an argument flushes stdout. Fflush
with an empty argument ("") flushes all open output. <p>
The function  <b>system</b>(<i>expr</i>)
uses  /bin/sh to execute <i>expr</i> and returns the exit status of the command
<i>expr</i>. Changes made to the <b>ENVIRON</b> array are not passed to commands executed
with <b>system</b> or pipes. 
<h3><a name='sect14' href='#toc14'><b>10. User defined functions</b></a></h3>
The syntax for a user defined
function is <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;function name( args ) { statements }

</pre>The function body can contain a return statement <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;return opt_expr

</pre>A return statement is not required.   Function calls may be nested or recursive.
Functions are passed expressions by value and arrays by reference. Extra
arguments serve as local variables and are initialized to  <i>null</i>. For example,
csplit(<i>s,A</i>) puts each character of <i>s</i> into array <i>A</i> and returns the length
of <i>s</i>. <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;function csplit(s, A,<tt> </tt>&nbsp;<tt> </tt>&nbsp;n, i)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  n = length(s)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  for( i = 1 ; i &lt;= n ; i++ ) A[i] = substr(s, i, 1)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  return n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}

</pre>Putting extra space between passed arguments and local  variables is conventional.
Functions can be referenced before they are defined, but the function name
and the &rsquo;(&rsquo; of the arguments must touch to avoid confusion with concatenation.
 
<h3><a name='sect15' href='#toc15'><b>11. Splitting strings, records and files</b></a></h3>
Awk programs use the same algorithm
to  split strings into arrays with split(), and records into fields on
 <b>FS</b>. <b>mawk</b> uses essentially the same algorithm to split files into records
on <b>RS</b>. <p>
Split(<i>expr,A,sep</i>) works as follows: <blockquote>
<ol>
<li>If <i>sep</i> is omitted, it is replaced
by <b>FS</b>. <i>Sep</i>  can be an expression or regular expression.  If it is an expression
of non-string type, it is converted to string. </li><li>If <i>sep</i> = " " (a single space),
then &lt;SPACE&gt; is trimmed from the front and back of  <i>expr</i>, and <i>sep</i> becomes
&lt;SPACE&gt;. <b>mawk</b> defines &lt;SPACE&gt; as the regular expression /[&nbsp;\t\n]+/.   Otherwise
<i>sep</i> is treated as a regular expression, except that meta-characters are
ignored for a string of length 1, e.g., split(x, A, "*") and split(x, A,
/\*/) are the same. </li><li>If  is not string, it is converted to string. If  is then
the empty string "", split() returns 0 and  <i>A</i> is set empty. Otherwise, all
non-overlapping, non-null and longest matches of <i>sep</i> in <i>expr</i>, separate <i>expr</i>
into fields which are loaded into <i>A</i>. The fields are placed in A[1], A[2],
..., A[n] and split() returns n, the number of fields which is the number
 of matches plus one. Data placed in  <i>A</i> that looks numeric is typed number
and string. </li>
</ol>
</blockquote>
<p>
Splitting records into fields works the same except the pieces
are loaded into  <b>$1</b>, <b>$2</b>,..., <b>$NF</b>. If <b>$0</b> is empty, <b>NF</b> is set to 0 and all <b>$i</b>
to "". <p>
<b>mawk</b> splits files into records by the same algorithm, but with the
 slight difference that  <b>RS</b> is really a terminator instead of a separator.
 (<b>ORS</b> is really a terminator too). <blockquote><p>
E.g., if  <b>FS</b> = ":+" and <b>$0</b> = "a::b:" ,
then <b>NF</b> = 3 and <b>$1</b> = "a", <b>$2</b> = "b" and <b>$3</b> = "", but if "a::b:" is the contents
of an input file and <b>RS</b> = ":+", then there are two records "a" and "b".
</blockquote>
<p>
<b>RS</b> = " " is not special. <p>
If  <b>FS </b> = "", then <b>mawk</b> breaks the record into
individual characters, and, similarly, split(<i>s,A,</i>"") places the individual
characters of <i>s</i> into  <i>A</i>.  
<h3><a name='sect16' href='#toc16'><b>12. Multi-line records</b></a></h3>
Since  <b>mawk</b> interprets <b>RS</b>
as a regular expression, multi-line records are easy.  Setting  <b>RS</b> = "\n\n+",
makes one or more blank lines separate records.  If  <b>FS</b> = " " (the default),
then single newlines, by the rules for &lt;SPACE&gt; above, become space and single
newlines are field separators. <blockquote><p>
For example, if a file is "a&nbsp;b\nc\n\n", <b>RS</b> =
"\n\n+" and <b>FS</b> = "&nbsp;", then there is one record "a&nbsp;b\nc" with three fields "a",
"b" and "c".  Changing <b>FS</b> = "\n", gives two fields "a b" and "c"; changing
<b>FS</b> = "", gives one field identical to the record. </blockquote>
<p>
If you want lines with
spaces or tabs to be considered blank, set <b>RS</b> = "\n([&nbsp;\t]*\n)+". For compatibility
with other awks, setting <b>RS</b> = "" has the same effect as if blank lines
are stripped from the front and back of files and then records are determined
as if <b>RS</b> = "\n\n+". Posix requires that "\n" always separates records when
<b>RS</b> = "" regardless of the value of <b>FS</b>. <b>mawk </b> does not support this convention,
because defining "\n" as &lt;SPACE&gt; makes it unnecessary.  <p>
Most of the time when
you change <b>RS</b> for multi-line records, you will also want to change  <b>ORS</b>
to "\n\n" so the record spacing is preserved on output.  
<h3><a name='sect17' href='#toc17'><b>13. Program execution</b></a></h3>
This
section describes the order of program execution. First  <b>ARGC</b> is set to
the total number of command line arguments passed to the execution phase
of the program. <b>ARGV[0]</b> is set the name of the AWK interpreter and <b>ARGV[1]</b>
...  <b>ARGV[ARGC-1]</b> holds the remaining command line arguments exclusive of 
options and program source. For example with <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;mawk  -f  prog  v=1  A  t=hello  B

</pre><b>ARGC</b> = 5 with <b>ARGV[0]</b> = "mawk", <b>ARGV[1]</b> = "v=1", <b>ARGV[2]</b> = "A", <b>ARGV[3]</b>
= "t=hello" and <b>ARGV[4]</b> = "B". <p>
Next, each  <b>BEGIN</b> block is executed in order.
If the program consists entirely of  <b>BEGIN</b> blocks, then execution terminates,
else an input stream is opened and execution continues. If  <b>ARGC</b> equals
1, the input stream is set to stdin, else  the command line arguments <b>ARGV[1]</b>
...  <b>ARGV[ARGC-1]</b> are examined for a file argument. <p>
The command line arguments
divide into three sets:  file arguments, assignment arguments and empty
strings "". An assignment has the form <i>var</i>=<i>string</i>. When an  <b>ARGV[i]</b> is examined
as a possible file argument, if it is empty it is skipped; if it is an
assignment argument, the assignment to <i>var</i> takes place and  <b>i</b> skips to
the next argument; else <b>ARGV[i] </b> is opened for input. If it fails to open,
execution terminates with exit code 2. If no command line argument is a
file argument, then input comes from stdin. Getline in a  <b>BEGIN</b> action opens
input.  "-" as a file argument denotes stdin. <p>
Once an input stream is open,
each input record is tested  against each  <i>pattern</i>, and if it matches,
the associated  <i>action</i> is executed. An expression pattern matches if it
is boolean true (see the end of section 2). A  <b>BEGIN</b> pattern matches before
any input has been read, and an <b>END</b> pattern matches after all input has
been read. A range pattern, <i>expr</i>1,<i>expr</i>2 , matches every record between the
match of  <i>expr</i>1 and the match <i>expr</i>2 inclusively. <p>
When end of file occurs
on the input stream, the remaining command line arguments are examined
for a file argument, and if there is one it is opened, else the <b>END</b> <i>pattern</i>
is considered matched and all  <b>END</b> <i>actions</i> are executed. <p>
In the example,
the assignment v=1 takes place after the <b>BEGIN</b> <i>actions</i> are executed, and
the data placed in v is typed number and string. Input is then read from
file A. On end of file A, t is set to the string "hello", and B is opened
for input. On end of file B, the  <b>END</b> <i>actions</i> are executed. <p>
Program flow
at the <i>pattern</i> <i>{action}</i> level can be changed with the  <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;next
<tt> </tt>&nbsp;<tt> </tt>&nbsp;exit  opt_expr

</pre>statements. A <b>next</b> statement causes the next input record to be read and
pattern testing to restart with the first  <i>pattern {action}</i> pair in the
program. An <b>exit</b> statement causes immediate execution of the  <b>END</b> actions
or program termination if there are none or if the  <b>exit</b> occurs in an 
<b>END</b> action. The  <i>opt_expr</i> sets the exit value of the program unless overridden
by a later <b>exit</b> or subsequent error. 
<h2><a name='sect18' href='#toc18'>Examples</a></h2>
<br>
<pre>1. emulate cat.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{ print }
2. emulate wc.
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{ chars += length($0) + 1  # add one for the \n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  words += NF
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}
<tt> </tt>&nbsp;<tt> </tt>&nbsp;END{ print NR, words, chars }
3. count the number of unique "real words".
<tt> </tt>&nbsp;<tt> </tt>&nbsp;BEGIN { FS = "[^A-Za-z]+" }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{ for(i = 1 ; i &lt;= NF ; i++)  word[$i] = "" }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;END { delete word[""]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;      for ( i in word )  cnt++
<tt> </tt>&nbsp;<tt> </tt>&nbsp;      print cnt
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}
</pre>4. sum the second field of  every record based on the first field. <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;$1 ~ /credit|gain/ { sum += $2 }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;$1 ~ /debit|loss/  { sum -= $2 }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;END { print sum }
5. sort a file, comparing as string
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{ line[NR] = $0 "" }  # make sure of comparison type
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;      # in case some lines look numeric
<tt> </tt>&nbsp;<tt> </tt>&nbsp;END {  isort(line, NR)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  for(i = 1 ; i &lt;= NR ; i++) print line[i]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}
<tt> </tt>&nbsp;<tt> </tt>&nbsp;#insertion sort of A[1..n]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;function isort( A, n,<tt> </tt>&nbsp;<tt> </tt>&nbsp;i, j, hold)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  for( i = 2 ; i &lt;= n ; i++)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    hold = A[j = i]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    while ( A[j-1] &gt; hold )
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    { j-- ; A[j+1] = A[j] }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;    A[j] = hold
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  # sentinel A[0] = "" will be created if needed
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}
</pre>
<h2><a name='sect19' href='#toc19'> "compatibility Issues"</a></h2>
The Posix 1003.2(draft 11.3) definition of the AWK
language is AWK as described in the AWK book with a few extensions that
appeared in SystemVR4 nawk. The extensions are: <p>
<blockquote>New functions: toupper()
and tolower(). 
<p> New variables: ENVIRON[] and CONVFMT. 
<p> ANSI C conversion
specifications for printf() and sprintf(). 
<p> New command options:  -v var=value,
multiple -f options and implementation options as arguments to -W. </blockquote>
<p>

<p> Posix
AWK is oriented to operate on files a line at  a time. <b>RS</b> can be changed
from "\n" to another single character, but it is hard to find any use for
this -- there are no  examples in the AWK book. By convention, <b>RS</b> = "", makes
one or more blank lines separate records, allowing multi-line records.  When
<b>RS</b> = "", "\n" is always a field separator  regardless of the value in <b>FS</b>.
<p>
<b>mawk</b>, on the other hand, allows <b>RS</b> to be a regular expression. When "\n"
appears in records, it is treated as space, and <b>FS</b> always determines fields.
<p>
Removing the line at a time paradigm can make some programs simpler and
can often improve performance.  For example, redoing example 3 from above,
<br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;BEGIN { RS = "[^A-Za-z]+" }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{ word[ $0 ] = "" }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;END { delete  word[ "" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  for( i in word )  cnt++
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  print cnt
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}

</pre>counts the number of unique words by making each word a record. On moderate
size files, <b>mawk</b> executes twice as fast, because of the simplified inner
loop. <p>
The following program replaces each comment by a single space in a
C program file, <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;BEGIN {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  RS = "/\*([^*]|\*+[^/*])*\*+/"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;# comment is record separator
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  ORS = " "
<tt> </tt>&nbsp;<tt> </tt>&nbsp;  getline  hold
       }
       { print hold ; hold = $0 }
       END { printf "%s" , hold }

</pre>Buffering one record is needed to avoid terminating the last record with
a space. <p>
With  <b>mawk</b>, the following are all equivalent, <br>
<pre>
<tt> </tt>&nbsp;<tt> </tt>&nbsp;x ~ /a\+b/    x ~ "a\+b"     x ~ "a\\+b"

</pre>The strings get scanned twice, once as string and once as regular expression.
 On the string scan, <b>mawk</b> ignores the escape on non-escape characters while
the AWK book advocates  <i>\c</i> be recognized as  <i>c</i>  which necessitates the double
escaping of meta-characters in strings.   Posix explicitly declines to define
the behavior which passively forces programs that must run under a variety
of awks to use the more portable but less readable, double escape. <p>
Posix
AWK does not recognize "/dev/std{out,err}" or \x hex escape sequences in
strings.  Unlike ANSI C, <b>mawk</b> limits the number of digits that follows \x
to two as the current implementation only supports 8 bit characters. The
built-in <b>fflush</b> first appeared in a recent (1993) AT&amp;T awk released to netlib,
and is not part of the posix standard.  Aggregate deletion with <b>delete</b> <i>array</i>
is not part of the posix standard. <p>
Posix explicitly leaves the behavior
of  <b>FS</b> = "" undefined, and mentions splitting the record into characters
as a possible interpretation, but currently this use is not portable across
implementations. <p>
Finally, here is how  <b>mawk</b> handles exceptional cases not
discussed in the AWK book or the Posix draft.  It is unsafe to assume  consistency
across awks and safe to skip to the next section. <p>
<blockquote>substr(s, i, n) returns
the characters of s in the intersection of the closed interval [1, length(s)]
and the half-open interval [i, i+n).  When this intersection is empty, the
empty string is returned; so substr("ABC", 1, 0) = "" and substr("ABC",
-4, 6) = "A". <p>
Every string, including the empty string, matches the empty
string at the front so, s ~ // and s ~ "", are always 1 as is match(s,
//) and match(s, "").  The last two set  <b>RLENGTH </b> to 0. <p>
index(s, t) is always
the same as match(s, t1) where t1 is the same as t with metacharacters
escaped.  Hence consistency with match requires that index(s, "") always
returns 1. Also the condition, index(s,t) != 0 if and only t is a substring
of s, requires index("","") = 1. <p>
If getline encounters end of file, getline
var, leaves var unchanged.  Similarly, on entry to the  <b>END</b> actions,  <b>$0</b>,
the fields and <b>NF</b> have their value unaltered from the last record. </blockquote>

<h2><a name='sect20' href='#toc20'>See Also</a></h2>
<a href='egrep.1.html'><i>egrep</i>(1)</a>

<p>
Aho, Kernighan and Weinberger, <i>The AWK Programming Language</i>, Addison-Wesley
Publishing, 1988, (the AWK book), defines the language, opening with a
tutorial and advancing to many interesting programs that delve into issues
of software design and analysis relevant to programming in any language.
<p>
<i>The GAWK Manual</i>, The Free Software Foundation, 1991, is a tutorial and
language reference that does not attempt the depth of the AWK book and
assumes the reader may be a novice programmer.   The section on AWK arrays
is excellent.  It also discusses Posix requirements for AWK. 
<h2><a name='sect21' href='#toc21'>Bugs</a></h2>
<b>mawk</b> cannot
handle ascii NUL \0 in the source or data files.  You can output NUL using
printf with %c, and any other 8 bit character is acceptable input. <p>
<b>mawk</b>
implements printf() and sprintf() using the C library functions, printf
and sprintf, so full ANSI compatibility requires an ANSI C library.  In
practice this means the h conversion qualifier may not be available.  Also
 <b>mawk</b> inherits any bugs or limitations of the library functions. <p>
Implementors
of the AWK language have shown a consistent lack of imagination when naming
their programs. 
<h2><a name='sect22' href='#toc22'>Author</a></h2>
Mike Brennan (brennan@whidbey.com). <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>the AWK Language</a></li>
<ul>
<li><a name='toc5' href='#sect5'>1. Program structure</a></li>
<li><a name='toc6' href='#sect6'>2. Data types, conversion and comparison</a></li>
<li><a name='toc7' href='#sect7'>3. Regular expressions</a></li>
<li><a name='toc8' href='#sect8'>4. Records and fields</a></li>
<li><a name='toc9' href='#sect9'>5. Expressions and operators</a></li>
<li><a name='toc10' href='#sect10'>6. Arrays</a></li>
<li><a name='toc11' href='#sect11'>7. Builtin-variables</a></li>
<li><a name='toc12' href='#sect12'>8. Built-in functions</a></li>
<li><a name='toc13' href='#sect13'>9. Input and output</a></li>
<li><a name='toc14' href='#sect14'>10. User defined functions</a></li>
<li><a name='toc15' href='#sect15'>11. Splitting strings, records and files</a></li>
<li><a name='toc16' href='#sect16'>12. Multi-line records</a></li>
<li><a name='toc17' href='#sect17'>13. Program execution</a></li>
</ul>
<li><a name='toc18' href='#sect18'>Examples</a></li>
<li><a name='toc19' href='#sect19'> "compatibility Issues"</a></li>
<li><a name='toc20' href='#sect20'>See Also</a></li>
<li><a name='toc21' href='#sect21'>Bugs</a></li>
<li><a name='toc22' href='#sect22'>Author</a></li>
</ul>
</body>
</html>
