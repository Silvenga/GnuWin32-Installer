<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>AWKA-ELMREF(5) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
     
<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
<p>
awka-elmref - Awka API Reference for use with Awka-ELM libraries.

<p> 
<h2><a name='sect1' href='#toc1'>Description</a></h2>
<b>Awka</b> is a translator of AWK programs to ANSI-C code, and a library
(<i>libawka.a</i>) against which the code is linked to create executables. Awka
is described in the <b>awka</b> manpage. <p>
The Extended Library Methods (ELM) provide
a way of adding new functions to the AWK language, so that they appear
in your AWK code as if they were builtin functions such as substr() or
index().  The <b>awka-elm</b> manpage contains an introduction to Awka-ELM. <p>
This page
lists the available data structures, definitions, functions and macros
provided by <i>libawka.h</i> that you may use in creating C libraries that link
with awka-generated code. <p>
I have broken the page into the following main
sections: BASIC VARIABLE METHODS, ARRAY METHODS, BUILTIN FUNCTIONS, I/O
METHODS, REGULAR EXPRESSION METHODS.  So, without further ado... 
<p> 
<h2><a name='sect2' href='#toc2'>Basic Variable
Methods</a></h2>
<p>
<i>Data Structures</i> <blockquote><br>
<pre>



















</pre></blockquote>
<p>

<dl>

<dt><b>a_VAR</b>typedef struct {  double dval;          /* the variable&rsquo;s numeric value
*/  char * ptr;           /* pointer to string, array or RE structure */
 unsigned int slen;    /* length of string ptr as per strlen */  unsigned
int allc;    /* space mallocated for string ptr */  char type;        
   /* records current cast of variable */  char type2;           /* double-typed
variable flag, explained later. */  char temp;            /* TRUE if a temporary
variable */} a_VAR;The <b>a_VAR</b> structure is used to store everything related
to AWKvariables.  This includes those named &amp; used in your program, and transient
variables created to return values from functions and otheroperations like
string concatenation.  As such, this structure isubiquitous throughout libawka
and awka-generated code.The <i>type</i> value is set to one of a number of #define
values, described in the Defines paragraph below.  Many functions and macros
exist for working with the contents of a_VARs - see the Functions &amp; Macros
paragraph for details. </dt>
<dd><blockquote><br>
<pre>








</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VARARG</b>typedef struct {  a_VAR *var[256];  int used;} a_VARARG;This structure
is typically used to pass variable numbers of a_VARs to functions.  Up to
256 a_VARs may be referenced by an a_VARARG, and the<i>used</i> value contains
the number of a_VARs present. </dt>
<dd><blockquote><br>
<pre>







</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>struct gvar_struct</b>struct gvar_struct {  char *name;  a_VAR *var;};Provides
a mapping of the global variable names in an AWK script to pointersto their
a_VAR structures. </dt>
<dd><i>Internal Libawka Variables</i> <blockquote><br>
<pre>






</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR * a_bivar[a_BIVARS]</b>This array contains all the AWK internal variables,
such as ARGV, ARGV, CONVFMT, ENVIRON and so on, along with $0 and the field
variables $1..$n.  <i>a_BIVARS</i> is a define, as are the identities of which element
in the array belongs to which variable.  Again, look for functions that
manage these variables rather than working with them directly if possible.
</dt>
<dd><blockquote><br>
<pre>






</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>extern struct gvar_struct *_gvar;</b>This is actually created &amp; populated by
the translated C code generated by <i>awka</i>, rather than by libawka.a.  It is
a NULL-terminated array of the gvar_struct structure defined earlier in
this page, and contains the names of all global variables in an AWK script,
mapped to their a_VAR structures. </dt>
<dd><i>Defines</i> </dd>
</dl>
<p>
<blockquote><br>
<pre>
</pre></blockquote>

<dl>

<dt><p>
<b>a_VARNUL</b> - the <i>type</i> value of an a_VAR if the variable is unused. </dt>
<dd><br>
<blockquote><br>
<pre>
</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARDBL</b> - the <i>type</i> value for an a_VAR cast to a number. </dt>
<dd><br>
<blockquote><br>
<pre>
</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARSTR</b> - <i>type</i> where the a_VAR has been cast to a string. </dt>
<dd><br>
<blockquote><br>
<pre>
</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARARR</b> - <i>type</i> where the a_VAR contains an array. </dt>
<dd><br>
<blockquote><br>
<pre>
</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARREG</b> - <i>type</i> where the a_VAR contains a regular expression. </dt>
<dd><br>
<blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARUNK</b> - <i>type</i> where the a_VAR is a string, but could also be a       
 number.  Variables populated by getline, the FILENAME variable,       
 and elements of an array created by split(), are all of this         special
type. </dt>
<dd></dd>
</dl>
<p>
<blockquote><br>
<pre>


</pre></blockquote>

<dl>

<dt><p>
<b>a_DBLSET</b> - for a string a_VAR that has been read in context as a number,
the         <i>type2</i> flag is set to this #define to prevent the string-to-number
        conversion being done again. </dt>
<dd><br>
<blockquote><br>
<pre>


</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_STRSET</b> - the opposite of the above.  The variable is a number, has been
read         as a string, hence the value of <i>ptr</i> is current, and the <i>type2</i>
        flag is set to this #define. </dt>
<dd></dd>
</dl>
<p>
<blockquote><br>
<pre>
</pre></blockquote>

<dl>

<dt><p>
<b>a_BIVARS</b> provides the number of elements in the a_bivar[] array. </dt>
<dd></dd>
</dl>
<p>
<b>a_ARGC</b>,
<b>a_ARGIND</b>, <b>a_ARGV</b>, <b>a_CONVFMT</b>, <b>a_ENVIRON</b>, <b>a_FILENAME</b>, <b>a_FNR</b>, <b>a_FS</b>, <b>a_NF</b>,
<b>a_NR</b>,  <b>a_OFMT</b>, <b>a_OFS</b>, <b>a_ORS</b>, <b>a_RLENGTH</b>, <b>a_RS</b>, <b>a_RSTART</b>, <b>a_RT</b>, <b>a_SUBSEP</b>,
<b>a_DOL0</b>,  <b>a_DOLN</b>, <b>a_FIELDWIDTHS</b>, <b>a_SAVEWIDTHS</b>, <b>a_SORTTYPE</b> provide indexes
to which elements in the a_bivar[] array are for which AWK internal variable.
<p>
<i>Functions &amp; Macros</i> <blockquote><br>
<pre>








</pre></blockquote>
<p>

<dl>

<dt><b>awka_getd(a_VAR *)</b>This macro calls the awka_getdval() function, appending
the calling file &amp; line number for debug purposes.  It read-casts the variable
to a number, and returns the doublevalue of the variable.  By read-cast,
we mean that if the variable is a string itremains so, but <i>dval</i> is set,
and <i>type2</i> is set to a_DBLSET.  But if the a_VARis a regular expression,
the re structure is dropped and the variable converted to anumber.  If you&rsquo;re
not sure whether an a_VAR you&rsquo;re about to read is a number, and youwant
to read it as one, simply call awka_getd(varname) - its the easiest way.
</dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>awka_getd1(a_VAR *)</b>Same as awka_getd, except this will be faster if the
a_VAR * is a variable.  Do notuse this if the a_VAR * is a function call
return value, as it&rsquo;ll call the functionseveral times!  In this case, use
awka_getd() instead. </dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>awka_gets(a_VAR *)</b>Similar to awka_getd(), this read-casts an a_VAR to a
string, and returns the characterarray pointed to by <i>ptr</i>. </dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>awka_gets1(a_VAR *)</b>Use this where the a_VAR * is a variable, not a function
call that returns an a_VAR *,for faster performance. </dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>awka_getre(a_VAR *)</b>Write-casts the a_VAR * to a regular expression, and
returns the pointer to the awka_regexpstructure.  Write-cast means that the
existing contents of the variable are dropped infavour of the new contents.
</dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>static char *awka_strcpy(a_VAR *var, char *str)</b>This function sets <i>var</i> to
string type, and copies to it the contents of <i>str</i>.It returns a pointer to
<i>var-&gt;ptr</i>. </dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR *awka_varcpy(a_VAR *va, a_VAR *vb)</b>This function copies the contents
of scalar a_VAR *<i>vb</i> to scalar a_VAR *<i>va</i>, and returns a pointer to <i>va</i>. </dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>double awka_varcmp(a_VAR *va, a_VAR *vb)</b>This function compares the contents
of the two scalar variables, and returns 0 if the variables are equal,
-1 if va is less than vb, or 1 if va is greater.  Numerical comparison is
used where possible, otherwise string. </dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR *awka_vardup(a_VAR *va)</b>This function creates a new a_VAR *, copies
the contents of <i>va</i>, and returns a pointerto the new structure. </dt>
<dd><blockquote><br>
<pre>


</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>awka_varinit(a_VAR *)</b>A macro that takes a NULL a_VAR *, mallocs space for
it, and initialises it to a_VARNUL. </dt>
<dd><blockquote><br>
<pre>


</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>void awka_killvar(a_VAR *)</b>Frees all memory used by the a_VAR, except the
structure itself. </dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>static a_VAR * awka_argv()</b>You can use a_bivar[a_ARGV] directly when reading
the value of elements in the array,but when you want to write to the array,
use the above function instead, as it willmake sure the changes are recognised
elsewhere in libawka. </dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>static a_VAR * awka_argc()</b>You can use a_bivar[a_ARGC] directly when reading
its value, but when you want to write to it, use the above function instead,
as it will make sure the change is recognised elsewhere in libawka. </dt>
<dd></dd>
</dl>

<h2><a name='sect3' href='#toc3'>Array
Methods</a></h2>
<p>
<i>Data Structures &amp; Variables</i> <br>
These are strictly internal to the array module within libawka.  If you
need  functionality other than that provided by the array functions, I
recommend  creating your own custom array data structures and interface
functions,  otherwise you could cause serious problems.  The structure definitions
are too lengthy to list here, and the foolhardy may find them in lib/array.h
within the awka distribution. <p>
<i>Defines</i> <blockquote><br>
<pre>

</pre></blockquote>

<dl>

<dt><p>
<b>a_ARR_TYPE_NULL</b>The &rsquo;type&rsquo; of an array that has not been initialised, or has
been deleted. </dt>
<dd><br>
<blockquote><br>
<pre>

</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_ARR_TYPE_SPLIT</b>The &rsquo;type&rsquo; of an array populated by the split() builtin function.
</dt>
<dd><br>
<blockquote><br>
<pre>

</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_ARR_TYPE_HSH</b>The &rsquo;type&rsquo; of arrays populated within the AWK script, eg. arr["pigs"]
= cows. </dt>
<dd></dd>
</dl>
<p>
<blockquote><br>
<pre>


</pre></blockquote>

<dl>

<dt><p>
<b>a_ARR_CREATE</b>When searching arrays, specifies that an element is to be created
if it doesn&rsquo;talready exist in the array. </dt>
<dd><br>
<blockquote><br>
<pre>


</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_ARR_QUERY</b>When searching arrays, this will not create a new element if
it doesn&rsquo;t alreadyexist. </dt>
<dd><br>
<blockquote><br>
<pre>

</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_ARR_DELETE</b>In an array search, this flag will cause the element to be
deleted from the array. </dt>
<dd></dd>
</dl>
<p>
<i>Functions</i> <blockquote><br>
<pre>





</pre></blockquote>
<p>

<dl>

<dt><b>void awka_arraycreate( a_VAR *var, char type );</b>Allocates an array structure
of type <i>type</i>, makes <i>var-&gt;ptr</i> pointto it, and sets <i>var-&gt;type</i> to a_VARARR.  The
<i>type</i> argument maybe one of a_ARR_TYPE_NULL, a_ARR_TYPE_SPLIT or a_ARR_TYPE_HSH,
according tohow the array will be populated. </dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>void awka_arrayclear( a_VAR *var );</b>Assumes <i>var</i> is an a_VARARR, this deletes
the contents of the array structurepointed to by <i>var-&gt;ptr</i>. </dt>
<dd><blockquote><br>
<pre>






</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR * awka_arraysearch1( a_VAR *v, a_VAR *element, char create, int set
);</b>Searches array variable <i>v</i> for index <i>element</i>.  If it does not exist, and<i>create</i>
is a_ARR_CREATE, a new element in the array for this value will be added.If
the element is found (or created) and <i>create</i> is not a_ARR_DELETE, thefunction
will return a pointer to the a_VAR for that element.  For a_ARR_DELETE,
theelement will be deleted from the array.  The <i>set</i> value should be FALSE.
</dt>
<dd><blockquote><br>
<pre>



</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR * awka_arraysearch( a_VAR *v, a_VARARG *va, char create );</b>Searches
array variable <i>v</i> as per awka_arraysearch1(), except that this workswith
multiple index subscripts (eg, arr[x, y]). </dt>
<dd><blockquote><br>
<pre>






</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>double awka_arraysplitstr( char *str, a_VAR *v, a_VAR *fs, int max );</b>The
AWK builtin split() function.  It splits <i>str</i> into array variable <i>v</i>,based
on <i>fs</i>, up to <i>max</i> number of fields.  If <i>fs</i> is NULL, thena_bivar[a_FS] will
be used.  Otherwise <i>fs</i> may contain an empty string, asingle-character string,
or a regular expression.  The number of fields createdin <b>v</b> is returned. </dt>
<dd><blockquote><br>
<pre>







</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>int awka_arrayloop( a_ListHdr *ah, a_VAR *v );</b>This function implements
the "for (i in j)" feature in AWK.  You provide <i>ah</i>, making sure it is initialised
to zeroes. The best way to understand how to call this function is to type:
 awka &rsquo;BEGIN { for (i in j) x = j[i]; }&rsquo;and see what is generated as a result.
 You don&rsquo;t have to understand the a_ListHdrstructure or sub-structures to
use this function. </dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>int awka_arraynext( a_VAR *v, a_ListHdr *ah, int pos );</b>Given that <i>ah</i> has
been populated by a call to awka_arrayloop(), this functioncopies the (string
or integer) element at position <i>pos</i> in the list to <i>v</i>, then returns <i>pos</i>+1,
or zero if there are no more elements in the array list. </dt>
<dd><blockquote><br>
<pre>


</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>void awka_alistfree( a_ListHdr *ah );</b>Frees the last list element in <b>ah</b>.
</dt>
<dd><blockquote><br>
<pre>


</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>void awka_alistfreeall( a_ListHdr *ah );</b>Frees all memory held by <i>ah</i>, and
sets its contents to zero/NULL. </dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR * awka_dol0(int set);</b>The best means of accessing the $0 a_VAR, as
it updates its contents with any pendingchanges.  Make <i>set</i> zero if you&rsquo;re
reading the value of $0, but if you want toset $0, make it 1. </dt>
<dd><blockquote><br>
<pre>




</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR * awka_doln(int fld, int set);</b>This function returns the a_VAR * of
the $1..$n variable identified by <i>fld</i>, updating the field array with any
refreshed $0 contents first if necessary.  If youwant to read the value
of $<i>fld</i>, make <i>set</i> zero, otherwise it should be 1. </dt>
<dd></dd>
</dl>

<h2><a name='sect4' href='#toc4'>Builtin Functions</a></h2>
<p>
These
are documented in lib/builtin.h in the awka distribution.  You can call any
of  the builtin functions as often as you like.  Those that return a_VAR&rsquo;s
also provide a <i>keep</i> flag that, if TRUE, will return a variable that you
must free, otherwise they will use a temporary variable that you don&rsquo;t have
to worry about freeing, but  will be reused elsewhere sooner or later. 
The functions should be pretty much as you&rsquo;d expect them, except that many
require an a_VARARG as input, and we haven&rsquo;t  discussed how to create one
- we will now. <blockquote><br>
<pre>
</pre></blockquote>

<dl>

<dt><p>
<b>a_VARARG * awka_arg0(char);</b> </dt>
<dd><br>
<blockquote><br>
<pre>
</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARARG * awka_arg1(char, a_VAR *);</b> </dt>
<dd><br>
<blockquote><br>
<pre>
</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARARG * awka_arg2(char, a_VAR *, a_VAR *);</b> </dt>
<dd><br>
<blockquote><br>
<pre>
</pre></dd>
</dl>
</blockquote>

<dl>

<dt><p>
<b>a_VARARG * awka_arg3(char, a_VAR *, a_VAR *, a_VAR *);</b> </dt>
<dd><blockquote><br>
<pre>








</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VARARG * awka_vararg(char, a_VAR *var, ...);</b>These functions populate &amp; return
a pointer to an a_VARARG structure.  The char argument, if TRUE, will make
you responsible for freeing the structure, otherwiseit&rsquo;ll be a temporary
one that libawka will manage.  awka_arg0() will return anempty structure
(ie. no args), awka_arg1() will have one a_VAR * in it, and soon.  Where
you want to put more than four a_VAR *&rsquo;s inside an a_VARARG, you can call
awka_vararg with as many as you like, or if there&rsquo;s seriously a lot, maybewrite
your own loop of code to populate an a_VARARG - its not rocket science. </dt>
<dd></dd>
</dl>

<h2><a name='sect5' href='#toc5'>I/O
Methods</a></h2>
<p>
<i>Data Structures &amp; Variables<b> <blockquote><br>
<pre>



















</pre></blockquote>
<p>

<dl>

<dt></b></i><b>_a_IOSTREAM</b>typedef struct {  char *name;       /* name of output file or
device */  FILE *fp;         /* file pointer */  char *buf;        /* input
buffer */  char *current;    /* where up to in buffer */  char *end;  
     /* end of data in buffer */  int alloc;        /* size of input buffer
*/  char io;          /* input or output stream flag */  char pipe;   
    /* true/false */  char interactive; /* whether from a /dev/xxx stream
or not */} _a_IOSTREAM;<b>extern _a_IOSTREAM *_a_iostream;</b><b>extern int _a_ioallc,
_a_ioused;</b>Controls input and output streams used by AWK&rsquo;s getline, print
and printfbuiltin functions.  The two int variables record the space allocated
in the _a_iostream array, and the number of elements used, respectively.
 I list this information here in case you wish to create fread, fwrite
and fseek functions for awka, as these will need low-level access to the
streams. </dt>
<dd><i>Functions</i> <blockquote><br>
<pre>








</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR * awka_getline(char keep, a_VAR *target, char *input, int pipe, char
main);</b>As previously described, <i>keep</i> controls whether you want to be responsible
forfreeing the a_VAR the function returns or not.  Moving on, <i>target</i> is
the a_VARto hold the line of data to be read (you provide this one).  <i>input</i>
is the nameof the input file or command.  <i>pipe</i> is TRUE if <i>input</i> is a command
ratherthan a file, eg. "sort stuff | getline x".  <i>main</i> should always be false.If
<i>input</i> is NULL, getline will try to read from the file identified by a_bivar[a_FILENAME],
or from the next element in the a_bivar[a_ARGV] array. </dt>
<dd>I won&rsquo;t go into detail
about awka_fflush, awka_close, awka_printf &amp; so on, as these should be easy
enough to understand and use, and the chances are you should use the native
C variety anyway where possible. </dd>
</dl>
<p>

<h2><a name='sect6' href='#toc6'>Regular Expressions</a></h2>
<p>
Ah, now we&rsquo;re in murky
water indeed, as awka inherited its RE library from Libc, and treats it
like a magical black box that does its bidding.  Want my advice?  Treating
the RE library &amp; structure like a black box is a wise thing to do, as its
ugly-looking stuff. <p>
Ok, we know that when an a_VAR has been set to a_VARREG,
its <i>ptr</i> value will  point to an awka_regexp structure.  Do we need to know
what&rsquo;s in this structure?  I don&rsquo;t think so.  What we do need are the functions
that help us compile and execute regular expressions.  Oops, getting ahead
of myself.  RE&rsquo;s are like C programs, they need to be compiled before they
can be used to search strings.  This basically is a parsing of the RE pattern
into a tree structure that is easier to navigate while searching, and is
a one-off task. <blockquote><br>
<pre>



</pre></blockquote>
<p>

<dl>

<dt><b>awka_getre(a_VAR *)</b>This macro is the easiest method of creating &amp; compiling
a regexp.  Providing you&rsquo;veset the a_VAR to the string value of the re pattern,
this macro call works a treat. </dt>
<dd><blockquote><br>
<pre>







</pre></dd>
</dl>
</blockquote>
<p>

<dl>

<dt><b>a_VAR *awka_match(char keep, char fcall, a_VAR *va, a_VAR *rva);</b>This function
is the implementation of AWK&rsquo;s match() function, and is the mostsimple way
of evaluating an RE against a string.  <i>keep</i> is as previouslydiscussed, <i>fcall</i>
should be set to TRUE if you want a_bivar[a_RSTART] anda_bivar[a_RLENGTH]
to be set, otherwise FALSE, <i>va</i> contains the string, and<i>rva</i> contains the
regular expression.  The numerical a_VAR returned is1 on success, zero on
failure. </dt>
<dd>I was going to describe the lower-level methods of compiling and
matching against RE&rsquo;s, but when I looked at it, there seemed to be a lot
of complexity for no real gain in functionality.  All you get is the ability
to avoid using a_VAR structures to manage the regular expressions, and
honestly I don&rsquo;t see what you&rsquo;d gain from this given how much more complexity
you&rsquo;d have to deal with. 
<p> </dd>
</dl>

<h2><a name='sect7' href='#toc7'>Notes</a></h2>
<p>
I haven&rsquo;t described all of the functions available
in libawka.h, not by any means. But I have tried to avoid functions that
are really only meant for internal use, or that are only needed by translated
code and should be done in other ways by  library code.  In the same way
I&rsquo;ve avoided describing structures that were intended  to remain privy to
a module within libawka, and you really shouldn&rsquo;t need to tamper  with them.
<p>
Any questions at all, or suggestions for improving this page, let me know
via andrewsumner@yahoo.com.  Make sure you preface any message title with
the word "awka" so I know its not spam. 
<p> 
<h2><a name='sect8' href='#toc8'>See Also</a></h2>
<a href='awka.1.html'><b>awka</b>(1)</a>
, <a href='awka-elm.5.html'><b>awka-elm</b>(5)</a>
. 
<p> 
<p> 
<p>

<p> 
<p> 
<p> 
<p> 
<p> 
<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Description</a></li>
<li><a name='toc2' href='#sect2'>Basic Variable Methods</a></li>
<li><a name='toc3' href='#sect3'>Array Methods</a></li>
<li><a name='toc4' href='#sect4'>Builtin Functions</a></li>
<li><a name='toc5' href='#sect5'>I/O Methods</a></li>
<li><a name='toc6' href='#sect6'>Regular Expressions</a></li>
<li><a name='toc7' href='#sect7'>Notes</a></li>
<li><a name='toc8' href='#sect8'>See Also</a></li>
</ul>
</body>
</html>
