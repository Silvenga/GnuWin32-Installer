                         <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>COLOR(3TIFF) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
TIFFYCbCrToRGBInit, TIFFYCbCrtoRGB, TIFFCIELabToRGBInit,
TIFFCIELabToXYZ, TIFFXYZToRGB - color conversion routines. 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>#include
&lt;tiffio.h&gt;</b> <p>
<b>int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB *</b><i>ycbcr</i><b>, float *</b><i>luma</i><b>, float
*</b><i>refBlackWhite"</i><b>);"</b> <br>
<b>void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *</b><i>ycbcr</i><b>, uint32 </b><i>Y</i><b>, int32 </b><i>Cb</i><b>, int32 </b><i>Cr</i><b>,
uint32 *</b><i>R</i><b>, uint32 *</b><i>G</i><b>, uint32 *</b><i>B</i><b> );</b> <p>
<b>int TIFFCIELabToRGBInit(TIFFCIELabToRGB
*</b><i>cielab</i><b>, TIFFDisplay *</b><i>display</i><b>, float *</b><i>refWhite</i><b>);</b> <br>
<b>void TIFFCIELabToXYZ(TIFFCIELabToRGB *</b><i>cielab</i><b>, uint32 </b><i>L</i><b>, int32 </b><i>a</i><b>, int32
</b><i>b</i><b>, float *</b><i>X</i><b>, float *</b><i>Y</i><b>, float *</b><i>Z</i><b>);</b> <br>
<b>void TIFFXYZToRGB(TIFFCIELabToRGB *</b><i>cielab</i><b>, float </b><i>X</i><b>, float </b><i>Y</i><b>, float </b><i>Z"</i><b>,</b><i>uint32</i><b>*"</b><i>R</i><b>,
uint32 *</b><i>G</i><b>, uint32 *</b><i>B</i><b>);</b> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
TIFF supports several color spaces for
images stored in that format. There is usually a problem of application
to handle the data properly and convert between different colorspaces for
displaying and printing purposes. To simplify this task libtiff implements
several color conversion routines itself. In particular, these routines
used in <a href='TIFFRGBAImage.3TIFF.html'><b>TIFFRGBAImage(3TIFF)</b></a>
 interface. <p>
<b>TIFFYCbCrToRGBInit()</b> used to initialize
<i>YCbCr</i> to <i>RGB</i> conversion state. Allocating and freeing of the <i>ycbcr</i> structure
belongs to programmer. <i>TIFFYCbCrToRGB</i> defined in <b>tiffio.h</b> as <p>
<blockquote><br>
<pre>typedef struct {                /* YCbCr-&gt;RGB support */
        TIFFRGBValue* clamptab; /* range clamping table */
        int*<tt> </tt>&nbsp;<tt> </tt>&nbsp;      Cr_r_tab;
        int*<tt> </tt>&nbsp;<tt> </tt>&nbsp;      Cb_b_tab;
        int32*<tt> </tt>&nbsp;<tt> </tt>&nbsp;      Cr_g_tab;
        int32*<tt> </tt>&nbsp;<tt> </tt>&nbsp;      Cb_g_tab;
        int32*        Y_tab;
} TIFFYCbCrToRGB;
</pre></blockquote>
<p>
<i>luma</i> is a float array of three values representing proportions of the red,
green and blue in luminance, Y (see section 21 of the TIFF 6.0 specification,
where the YCbCr images discussed). <i>TIFFTAG_YCBCRCOEFFICIENTS</i> holds that
values in TIFF file. <i>refBlackWhite</i> is a float array of 6 values which specifies
a pair of headroom and footroom image data values (codes) for each image
component (see section 20 of the TIFF 6.0 specification where the colorinmetry
fields discussed). <i>TIFFTAG_REFERENCEBLACKWHITE</i> is responsible for storing
these values in TIFF file. Following code snippet should helps to understand
the the technique: <p>
<blockquote><br>
<pre>float *luma, *refBlackWhite;
uint16 hs, vs;
/* Initialize structures */
ycbcr = (TIFFYCbCrToRGB*)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;_TIFFmalloc(TIFFroundup(sizeof(TIFFYCbCrToRGB), sizeof(long))
        <tt> </tt>&nbsp;<tt> </tt>&nbsp;+ 4*256*sizeof(TIFFRGBValue)
        <tt> </tt>&nbsp;<tt> </tt>&nbsp;+ 2*256*sizeof(int)
        <tt> </tt>&nbsp;<tt> </tt>&nbsp;+ 3*256*sizeof(int32));
if (ycbcr == NULL) {
        TIFFError("YCbCr-&gt;RGB",
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"No space for YCbCr-&gt;RGB conversion state");
        exit(0);
}
TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRCOEFFICIENTS, &amp;luma);
TIFFGetFieldDefaulted(tif, TIFFTAG_REFERENCEBLACKWHITE, &amp;refBlackWhite);
if (TIFFYCbCrToRGBInit(ycbcr, luma, refBlackWhite) &lt; 0)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;exit(0);
/* Start conversion */
uint32 r, g, b;
uint32 Y;
int32 Cb, Cr;
for each pixel in image
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TIFFYCbCrtoRGB(img-&gt;ycbcr, Y, Cb, Cr, &amp;r, &amp;g, &amp;b);
/* Free state structure */
_TIFFfree(ycbcr);
</pre></blockquote>
<p>

<p> <p>
<b>TIFFCIELabToRGBInit()</b> initializes the <i>CIE</i> L*a*b* 1976 to <i>RGB</i> conversion
state. <b>TIFFCIELabToRGB</b> defined as <p>
<blockquote><br>
<pre>#define CIELABTORGB_TABLE_RANGE 1500
typedef struct {<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;     /* CIE Lab 1976-&gt;RGB support */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;int<tt> </tt>&nbsp;<tt> </tt>&nbsp;range;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;     /* Size of conversion table */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;rstep, gstep, bstep;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;X0, Y0, Z0;<tt> </tt>&nbsp;<tt> </tt>&nbsp;     /* Reference white point */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TIFFDisplay display;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;Yr2r[CIELABTORGB_TABLE_RANGE + 1]; /* Conversion of Yr to r */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;Yg2g[CIELABTORGB_TABLE_RANGE + 1]; /* Conversion of Yg to g */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float<tt> </tt>&nbsp;<tt> </tt>&nbsp;Yb2b[CIELABTORGB_TABLE_RANGE + 1]; /* Conversion of Yb to b */
} TIFFCIELabToRGB;
</pre></blockquote>
<p>
<i>display</i> is a display device description, declared as <p>
<blockquote><br>
<pre>typedef struct {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_mat[3][3]; /* XYZ -&gt; luminance matrix */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_YCR;       /* Light o/p for reference white */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_YCG;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_YCB;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;uint32 d_Vrwr;     /* Pixel values for ref. white */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;uint32 d_Vrwg;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;uint32 d_Vrwb;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_Y0R;       /* Residual light for black pixel */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_Y0G;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_Y0B;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_gammaR;    /* Gamma values for the three guns */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_gammaG;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;float d_gammaB;
} TIFFDisplay;
</pre></blockquote>
<p>
For example, the one can use sRGB device, which has the following parameters:
<p>
<blockquote><br>
<pre>TIFFDisplay display_sRGB = {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{       /* XYZ -&gt; luminance matrix */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;{  3.2410F, -1.5374F, -0.4986F },
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;{  -0.9692F, 1.8760F, 0.0416F },
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;{  0.0556F, -0.2040F, 1.0570F }
<tt> </tt>&nbsp;<tt> </tt>&nbsp;},<tt> </tt>&nbsp;<tt> </tt>&nbsp;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;100.0F, 100.0F, 100.0F, /* Light o/p for reference white */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;255, 255, 255,      /* Pixel values for ref. white */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;1.0F, 1.0F, 1.0F,   /* Residual light o/p for black pixel */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;2.4F, 2.4F, 2.4F,   /* Gamma values for the three guns */
};
</pre></blockquote>
<p>
<i>refWhite</i> is a color temperature of the reference white. The <i>TIFFTAG_WHITEPOINT</i>
contains the chromaticity of the white point of the image from where the
reference white can be calculated using following formulae: <p>
<blockquote>refWhite_Y
= 100.0 <br>
refWhite_X = whitePoint_x / whitePoint_y * refWhite_Y <br>
refWhite_Z = (1.0 - whitePoint_x - whitePoint_y) / whitePoint_y * refWhite_X
<br>
</blockquote>
<p>
The conversion itself performed in two steps: at the first one we will
convert <i>CIE</i> L*a*b* 1976 to <i>CIE</i> XYZ using <b>TIFFCIELabToXYZ()</b> routine, and
at the second step we will convert <i>CIE</i> XYZ to <i>RGB</i> using <b>TIFFXYZToRGB().</b>
Look at the code sample below: <p>
<blockquote><br>
<pre>float   *whitePoint;
float   refWhite[3];
/* Initialize structures */
img-&gt;cielab = (TIFFCIELabToRGB *)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;_TIFFmalloc(sizeof(TIFFCIELabToRGB));
if (!cielab) {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TIFFError("CIE L*a*b*-&gt;RGB",
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"No space for CIE L*a*b*-&gt;RGB conversion state.");
<tt> </tt>&nbsp;<tt> </tt>&nbsp;exit(0);
}
TIFFGetFieldDefaulted(tif, TIFFTAG_WHITEPOINT, &amp;whitePoint);
refWhite[1] = 100.0F;
refWhite[0] = whitePoint[0] / whitePoint[1] * refWhite[1];
refWhite[2] = (1.0F - whitePoint[0] - whitePoint[1])
<tt> </tt>&nbsp;<tt> </tt>&nbsp;      / whitePoint[1] * refWhite[1];
if (TIFFCIELabToRGBInit(cielab, &amp;display_sRGB, refWhite) &lt; 0) {
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TIFFError("CIE L*a*b*-&gt;RGB",
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;"Failed to initialize CIE L*a*b*-&gt;RGB conversion state.");
<tt> </tt>&nbsp;<tt> </tt>&nbsp;_TIFFfree(cielab);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;exit(0);
}
/* Now we can start to convert */
uint32 r, g, b;
uint32 L;
int32 a, b;
float X, Y, Z;
for each pixel in image
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TIFFCIELabToXYZ(cielab, L, a, b, &amp;X, &amp;Y, &amp;Z);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TIFFXYZToRGB(cielab, X, Y, Z, &amp;r, &amp;g, &amp;b);
/* Don&rsquo;t forget to free the state structure */
_TIFFfree(cielab);
</pre></blockquote>
<p>

<h2><a name='sect3' href='#toc3'>See Also</a></h2>
<a href='TIFFRGBAImage.3TIFF.html'><b>TIFFRGBAImage</b>(3TIFF)</a>
 <a href='libtiff.3TIFF.html'><b>libtiff</b>(3TIFF)</a>
, <p>
Libtiff library home page:
<a href='http://www.remotesensing.org/libtiff/'><b>http://www.remotesensing.org/libtiff/</b></a>
 <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>See Also</a></li>
</ul>
</body>
</html>
