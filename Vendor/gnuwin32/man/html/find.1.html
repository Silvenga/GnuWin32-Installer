<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>FIND(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
find - search for files in a directory hierarchy 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>find </b> [-H] [-L]
[-P] [path...] [expression] 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
This manual page documents the GNU version
of <b>find</b>. GNU <b>find</b> searches the directory tree rooted at each given file
name by evaluating the given expression from left to right, according to
the rules of precedence (see section OPERATORS), until the outcome is known
(the left hand side is false for <i>and</i> operations, true for <i>or</i>), at which
point <b>find</b> moves on to the next file name. <p>
If you are using  <b>find </b> in an
environment where security is important (for example if you are using it
to seach directories that are writable by other users), you should read
the "Security Considerations" chapter of the findutils documentation, which
is called <b>Finding Files</b> and comes with findutils.   That document also includes
a lot more detail  and discussion than this manual page, so you may find
it a more useful  source of information. 
<h2><a name='sect3' href='#toc3'>Options</a></h2>
The &lsquo;-H&rsquo;, &lsquo;-L&rsquo; and &lsquo;-P&rsquo; options control
the treatment of symbolic links.  Command-line arguments following these
are taken to be names of files or directories to be examined, up to the
first argument that begins with &lsquo;-&rsquo;, &lsquo;(&rsquo;, &lsquo;)&rsquo;, &lsquo;,&rsquo;, or &lsquo;!&rsquo;.  That argument and any
following arguments are taken to be the expression describing what is to
be searched for.  If no paths are given, the current directory is used. 
If no expression is given, the expression &lsquo;-print&rsquo; is used (but you should
probably consider using &lsquo;-print0&rsquo; instead, anyway). <p>
This manual page talks
about &lsquo;options&rsquo; within the expression list. These options control the behaviour
of  <b>find</b> but are specified immediately after the last path name.  The three
&lsquo;real&rsquo; options &lsquo;-H&rsquo;, &lsquo;-L&rsquo; and &lsquo;-P&rsquo; must appear before the first path name, if at all.

<dl>

<dt>-P</dt>
<dd>Never follow symbolic links.  This is the default behaviour.  When  <b>find</b>
examines or prints information a file, and the file is a symbolic link,
the information used shall be taken from the properties of the symbolic
link itself.   
<p> </dd>

<dt>-L</dt>
<dd>Follow symbolic links.  When  <b>find</b> examines or prints information
about files, the information used shall be taken from the properties of
the file to which the link points, not from the link itself (unless it
is a broken symbolic link or  <b>find</b> is unable to examine the file to which
the link points).  Use of this option implies -noleaf.  If you later use the
-P option, -noleaf will still be in effect.  If -L is in effect and  <b>find </b>
discovers a symbolic link to a subdirectory during its search,  the subdirectory
pointed to by the symbolic link will be searched. </dd>

<dt>When the -L option is in
effect, the -type predicate will always </dt>
<dd>match against the type of the file
that a symbolic link points to rather than the link itself (unless the
symbolic link is broken). Using -L causes the -lname and -ilname predicates
always to return false. 
<p> </dd>

<dt>-H</dt>
<dd>Do not follow symbolic links, except while processing
the command line arguments.  When <b>find</b> examines or prints information about
files, the information used  shall be taken from the properties of the
symbolic link itself.   The only exception to this behaviour is when a file
specified on the command line is a symbolic link, and the link can be resolved.
 For that situation, the information used is taken from whatever the link
points to (that is, the link is followed).  The information about the link
itself is used as a fallback if the file pointed to by the symbolic link
cannot be examined.  If -H is in effect and one of the paths specified on
the command line is a symbolic link to a directory, the contents of that
directory will be examined (though of course -maxdepth 0 would prevent this).
</dd>
</dl>
<p>
If more than one of -H, -L and -P is specified, each overrides the others;
the last one appearing on the command line takes effect. Since it is the
default, the -P option should be considered to be in effect unless either
-H or -L is specified. 
<p> GNU  <b>find</b> frequently stats files during the processing
of the command line itself, before any searching has begun.  These options
also affect how those arguments are processed.  Specifically, there are
a number of tests that compare files listed on the command line against
a file we are currently considering.  In each case, the file specified on
the command line will have been examined and some of its properties will
have been saved.  If the named file is in fact a symbolic link, and the
-P option is in effect (or if neither -H nor -L were specified), the information
used for the comparison will be taken from the properties of the symbolic
link.  Otherwise, it will be taken from the properties of the file the link
points to.  If <b>find </b> cannot follow the link (for example because it has
insufficient privileges or the link points to a nonexistent file) the properties
of the link itself will be used. <p>
When the -H or -L options are in effect,
any symbolic links listed as the argument of -newer will be dereferenced,
and the timestamp will be taken from the file to which the symbolic link
points.  The same consideration applies to -anewer and -cnewer. 
<p> The -follow
option has a similar effect to -L, though it takes effect at the point where
it appears (that is, if -L is not used but -follow is, any symbolic links
appearing after -follow on the command line will be dereferenced, and those
before it will not). 
<p> <p>

<h2><a name='sect4' href='#toc4'>Expressions</a></h2>
The expression is made up of options (which
affect overall operation rather than the processing of a specific file,
and always return true), tests (which return a true or false value), and
actions (which have side effects and return a true or false value), all
separated by operators. -and is assumed where the operator is omitted.  If
the expression contains no actions other than -prune, -print is performed
on all files for which the expression is true. 
<h3><a name='sect5' href='#toc5'>Options</a></h3>
<p>
All options always
return true.  Except for -follow and -daystart, they always take effect, rather
than being processed only when their place in the expression is reached.
 Therefore, for clarity, it is best to place them at the beginning of the
expression.  A warning is issued if you don&rsquo;t do this. 
<dl>

<dt>-daystart</dt>
<dd>Measure times
(for -amin, -atime, -cmin, -ctime, -mmin, and -mtime) from the beginning of today
rather than from 24 hours ago.  This option only affects tests which appear
later on the command line. </dd>

<dt>-depth</dt>
<dd>Process each directory&rsquo;s contents before
the directory itself. </dd>

<dt>-d</dt>
<dd>A synonym for -depth, for compatibility with FreeBSD,
NetBSD, MacOS X and OpenBSD. </dd>

<dt>-follow</dt>
<dd>Deprecated; use the -L option instead.
 Dereference symbolic links. Implies -noleaf.  Unless the -H or -L option has
been specified, the position of the -follow option changes the behaviour
of the -newer predicate; any files listed as the argument of -newer will
be dereferenced if they are symbolic links.  The same consideration applies
to -anewer and -cnewer.  Similarly, the -type predicate will always match against
the type of the file that a symbolic link points to rather than the link
itself.  Using -follow causes the -lname and -ilname predicates always to return
false. </dd>

<dt>-help, --help</dt>
<dd>Print a summary of the command-line usage of <b>find</b> and exit.
</dd>

<dt>-ignore_readdir_race</dt>
<dd>Normally, <b>find</b> will emit an error message when it fails
to stat a file. If you give this option and a file is deleted between the
time <b>find</b>  reads the name of the file from the directory and the time it
tries to stat  the file, no error message will be issued.    This also applies
to files or directories whose names are given on the command line.  This
option takes effect at the time the command line is read, which means that
you cannot search one part of the filesystem with this option on and part
of it with this option off (if you need to do that, you will need to issue
two <b>find</b> commands instead, one with the option and one without it). </dd>

<dt>-maxdepth
<i>levels</i></dt>
<dd>Descend at most <i>levels</i> (a non-negative integer) levels of directories
below the command line arguments.  &lsquo;-maxdepth 0&rsquo; means only apply the tests
and actions to the command line arguments. </dd>

<dt>-mindepth <i>levels</i></dt>
<dd>Do not apply any
tests or actions at levels less than <i>levels</i> (a non-negative integer).  &lsquo;-mindepth
1&rsquo; means process all files except the command line arguments. </dd>

<dt>-mount</dt>
<dd>Don&rsquo;t descend
directories on other filesystems.  An alternate name for -xdev, for compatibility
with some other versions of <b>find</b>. </dd>

<dt>-noignore_readdir_race</dt>
<dd>Turns off the effect
of -ignore_readdir_race.  </dd>

<dt>-noleaf</dt>
<dd>Do not optimize by assuming that directories
contain 2 fewer subdirectories than their hard link count.  This option
is needed when searching filesystems that do not follow the Unix directory-link
convention, such as CD-ROM or MS-DOS filesystems or AFS volume mount points.
 Each directory on a normal Unix filesystem has at least 2 hard links:
its name and its &lsquo;.&rsquo;  entry.  Additionally, its subdirectories (if any) each
have a &lsquo;..&rsquo;  entry linked to that directory.  When <b>find</b> is examining a directory,
after it has statted 2 fewer subdirectories than the directory&rsquo;s link count,
it knows that the rest of the entries in the directory are non-directories
(&lsquo;leaf&rsquo; files in the directory tree).  If only the files&rsquo; names need to be
examined, there is no need to stat them; this gives a significant increase
in search speed. </dd>

<dt>-version, --version</dt>
<dd>Print the <b>find</b> version number and exit.
</dd>

<dt>-warn, -nowarn</dt>
<dd>Turn warning messages on or off.  These warnings apply only
to the command line usage, not to any conditions that  <b>find </b> might encounter
when it searches directories.  The default behaviour corresponds to -warn
if standard input is a tty, and to -nowarn otherwise. </dd>

<dt>-xdev</dt>
<dd>Don&rsquo;t descend directories
on other filesystems. 
<p> </dd>
</dl>

<h3><a name='sect6' href='#toc6'>Tests</a></h3>
<p>
Numeric arguments can be specified as 
<dl>

<dt><i>+n</i></dt>
<dd>for
greater than <i>n</i>, </dd>

<dt><i>-n</i></dt>
<dd>for less than <i>n</i>, </dd>

<dt><i>n</i></dt>
<dd>for exactly <i>n</i>. </dd>

<dt>-amin <i>n</i></dt>
<dd>File was last accessed
<i>n</i> minutes ago. </dd>

<dt>-anewer <i>file</i></dt>
<dd>File was last accessed more recently than <i>file</i>
was modified.  If <i>file</i> is a symbolic link and the -H option or the -L option
is in effect, the access time of the file it points to is always used. </dd>

<dt>-atime
<i>n</i></dt>
<dd>File was last accessed <i>n</i>*24 hours ago.   When find figures out how many
24-hour preiods ago the file  was last accessed, any fractional part is
ignored, so to match  <b>-atime </b> <b>+1</b>, a file has to have been modified at least
 <i>two</i> days ago. </dd>

<dt>-cmin <i>n</i></dt>
<dd>File&rsquo;s status was last changed <i>n</i> minutes ago. </dd>

<dt>-cnewer
<i>file</i></dt>
<dd>File&rsquo;s status was last changed more recently than <i>file</i> was modified.
 If <i>file</i> is a symbolic link and the -H option or the -L option is in effect,
the status-change time of the file it points to is always used. 
<p> </dd>

<dt>-ctime <i>n</i></dt>
<dd>File&rsquo;s
status was last changed <i>n</i>*24 hours ago. See the comments for  <b>-atime </b> to
understand how rounding affects the interpretation of file status change
times. </dd>

<dt>-empty</dt>
<dd>File is empty and is either a regular file or a directory. </dd>

<dt>-false</dt>
<dd>Always
false. </dd>

<dt>-fstype <i>type</i></dt>
<dd>File is on a filesystem of type <i>type</i>.  The valid filesystem
types vary among different versions of Unix; an incomplete list of filesystem
types that are accepted on some version of Unix or another is: ufs, 4.2,
4.3, nfs, tmp, mfs, S51K, S52K.  You can use -printf with the %F directive
to see the types of your filesystems. </dd>

<dt>-gid <i>n</i></dt>
<dd>File&rsquo;s numeric group ID is <i>n</i>. </dd>

<dt>-group
<i>gname</i></dt>
<dd>File belongs to group <i>gname</i> (numeric group ID allowed). </dd>

<dt>-ilname <i>pattern</i></dt>
<dd>Like
-lname, but the match is case insensitive. If the -L option or the -follow
option is in effect, this test  returns false unless the symbolic link
is broken. </dd>

<dt>-iname <i>pattern</i></dt>
<dd>Like -name, but the match is case insensitive.  For
example, the patterns &lsquo;fo*&rsquo; and &lsquo;F??&rsquo; match the file names &lsquo;Foo&rsquo;, &lsquo;FOO&rsquo;, &lsquo;foo&rsquo;, &lsquo;fOo&rsquo;,
etc.   In these patterns, unlike filename expansion by the shell, an initial
&rsquo;.&rsquo; can be matched by &rsquo;*&rsquo;.  That is,  <b>find -name *bar </b> will match the file &lsquo;.foobar&rsquo;.

<p> </dd>

<dt>-inum <i>n</i></dt>
<dd>File has inode number <i>n</i>.  It is normally easier to use the  <b>-samefile</b>
test instead. </dd>

<dt>-ipath <i>pattern</i></dt>
<dd>Behaves in the same way as -iwholename.  This option
is deprecated, so please do not use it. </dd>

<dt>-iregex <i>pattern</i></dt>
<dd>Like -regex, but the
match is case insensitive. </dd>

<dt>-iwholename <i>pattern</i></dt>
<dd>Like -wholename, but the match
is case insensitive. </dd>

<dt>-links <i>n</i></dt>
<dd>File has <i>n</i> links. </dd>

<dt>-lname <i>pattern</i></dt>
<dd>File is a symbolic
link whose contents match shell pattern <i>pattern</i>.  The metacharacters do
not treat &lsquo;/&rsquo; or &lsquo;.&rsquo; specially. If the -L option or the -follow option is in effect,
this test  returns false unless the symbolic link is broken. </dd>

<dt>-mmin <i>n</i></dt>
<dd>File&rsquo;s
data was last modified <i>n</i> minutes ago. </dd>

<dt>-mtime <i>n</i></dt>
<dd>File&rsquo;s data was last modified
<i>n</i>*24 hours ago. See the comments for  <b>-atime </b> to understand how rounding
affects the interpretation of file modification times. </dd>

<dt>-name <i>pattern</i></dt>
<dd>Base
of file name (the path with the leading directories removed) matches shell
pattern <i>pattern</i>.  The metacharacters (&lsquo;*&rsquo;, &lsquo;?&rsquo;, and &lsquo;[]&rsquo;) match a &lsquo;.&rsquo; at the start
of the base name (this is a change in findutils-4.2.2; see section STANDARDS
CONFORMANCE below).  To ignore a directory and the files under it, use -prune;
see an example in the description of -wholename.  Braces are not recognised
as being special, despite the fact that some shells including Bash imbue
braces with a special meaning in shell patterns.  The filename matching
is performed with the use of the <a href='fnmatch.3.html'><b>fnmatch</b>(3)<b></b></a>
 library function. </dd>

<dt>-newer <i>file</i></dt>
<dd>File
was modified more recently than <i>file</i>.  If <i>file</i> is a symbolic link and the
-H option or the -L option is in effect, the modification time of the file
it points to is always used. </dd>

<dt>-nouser</dt>
<dd>No user corresponds to file&rsquo;s numeric
user ID. </dd>

<dt>-nogroup</dt>
<dd>No group corresponds to file&rsquo;s numeric group ID. </dd>

<dt>-path <i>pattern</i></dt>
<dd>See
-wholename.   The predicate -path is also supported by HP-UX  <b>find</b>. </dd>

<dt>-perm <i>mode</i></dt>
<dd>File&rsquo;s
permission bits are exactly <i>mode</i> (octal or symbolic). Since an exact match
is required, if you want to use this form for symbolic modes, you may have
to specify a rather complex mode string. For example &rsquo;-perm g=w&rsquo; will only
match files which have mode 0020 (that is, ones for which group write permission
is the only permission set).  It is more likely that you will want to use
the &rsquo;+&rsquo; or &rsquo;-&rsquo; forms, for example &rsquo;-perm -g=w&rsquo;, which matches any file with group
write permission.  See the <b>EXAMPLES </b> section for some illustrative examples.
</dd>

<dt>-perm -<i>mode</i></dt>
<dd>All of the permission bits <i>mode</i> are set for the file. Symbolic
modes are accepted in this form, and this is usually the way in which would
want to use them.  You must specify &rsquo;u&rsquo;, &rsquo;g&rsquo; or &rsquo;o&rsquo; if you use a symbolic mode.
  See the  <b>EXAMPLES </b> section for some illustrative examples. </dd>

<dt>-perm +<i>mode</i></dt>
<dd>Any
of the permission bits <i>mode</i> are set for the file.  Symbolic modes are accepted
in this form.  You must specify &rsquo;u&rsquo;, &rsquo;g&rsquo; or &rsquo;o&rsquo; if you use a symbolic mode.  See
the <b>EXAMPLES </b> section for some illustrative examples. </dd>

<dt>-regex <i>pattern</i></dt>
<dd>File
name matches regular expression <i>pattern</i>.  This is a match on the whole path,
not a search.  For example, to match a file named &lsquo;./fubar3&rsquo;, you can use the
regular expression &lsquo;.*bar.&rsquo; or &lsquo;.*b.*3&rsquo;, but not &lsquo;f.*r3&rsquo;.  The regular expressions
understood by  <b>find </b> follow the conventions for the  <b>re_match </b> system library
function where this is present (i.e. on systems using the GNU C Library).
 On other systems, the implementation within Gnulib is used; by default,
Gnulib provides &lsquo;&lsquo;basic&rsquo;&rsquo; regular expressions. </dd>

<dt>-samefile <i>name</i></dt>
<dd>File refers to the
same inode as <i>name</i>.   When -L is in effect, this can include symbolic links.
</dd>

<dt>-size <i>n</i>[cwbkMG]</dt>
<dd>File uses <i>n</i> units of space.  The following suffixes  can be
used: <blockquote></dd>

<dt>&lsquo;b&rsquo;</dt>
<dd>for 512-byte blocks (this is the default if no suffix is used) </dd>

<dt>&lsquo;c&rsquo;</dt>
<dd>for
bytes </dd>

<dt>&lsquo;w&rsquo;</dt>
<dd>for two-byte words </dd>

<dt>&lsquo;k&rsquo;</dt>
<dd>for Kilobytes (units of 1024 bytes) </dd>

<dt>&lsquo;M&rsquo;</dt>
<dd>for Megabytes
(units of 1048576 bytes) </dd>

<dt>&lsquo;G&rsquo;</dt>
<dd>for Gigabytes (units of 1073741824 bytes) </dd>
</dl>
</blockquote>

<dl>

<dt>The
size does not count indirect blocks, but it does count blocks in </dt>
<dd>sparse
files that are not actually allocated.  Bear in mind that the &lsquo;%k&rsquo; and &lsquo;%b&rsquo;
format specifiers of -printf handle sparse files differently.  The &lsquo;b&rsquo; suffix
always denotes 512-byte blocks and never 1 Kilobyte blocks, which is different
to the behaviour of -ls. 
<p> </dd>

<dt>-true</dt>
<dd>Always true. </dd>

<dt>-type <i>c</i></dt>
<dd>File is of type <i>c</i>: <blockquote></dd>

<dt>b</dt>
<dd>block
(buffered) special </dd>

<dt>c</dt>
<dd>character (unbuffered) special </dd>

<dt>d</dt>
<dd>directory </dd>

<dt>p</dt>
<dd>named pipe
(FIFO) </dd>

<dt>f</dt>
<dd>regular file </dd>

<dt>l</dt>
<dd>symbolic link (never true if the -L option or the
-follow option is in effect, unless the symbolic link is broken). </dd>

<dt>s</dt>
<dd>socket
</dd>

<dt>D</dt>
<dd>door (Solaris) </dd>
</dl>
</blockquote>

<dl>

<dt>-uid <i>n</i></dt>
<dd>File&rsquo;s numeric user ID is <i>n</i>. </dd>

<dt>-used <i>n</i></dt>
<dd>File was last accessed
<i>n</i> days after its status was last changed. </dd>

<dt>-user <i>uname</i></dt>
<dd>File is owned by user
<i>uname</i> (numeric user ID allowed). </dd>

<dt>-wholename <i>pattern</i></dt>
<dd>File name matches shell
pattern <i>pattern</i>.  The metacharacters do not treat &lsquo;/&rsquo; or &lsquo;.&rsquo; specially; so, for
example, <br>
 find . -wholename &rsquo;./sr*sc&rsquo; <br>
 will print an entry for a directory called &rsquo;./src/misc&rsquo; (if one exists). 
To ignore a whole directory tree, use -prune rather than checking every
file in the tree.  For example, to skip the directory &lsquo;src/emacs&rsquo; and all
files and directories under it, and print the names of the other files
found, do something like this: <br>
 find . -wholename &rsquo;./src/emacs&rsquo; -prune -o -print <br>
 </dd>

<dt>-xtype <i>c</i></dt>
<dd>The same as -type unless the file is a symbolic link.  For symbolic
links: if the -H or -P option was specified, true if the file is a link to
a file of type <i>c</i>; if the -L option has been given, true if <i>c</i> is &lsquo;l&rsquo;.  In other
words, for symbolic links, -xtype checks the type of the file that -type
does not check. 
<p> </dd>
</dl>

<h3><a name='sect7' href='#toc7'>Actions</a></h3>

<dl>

<dt>-delete</dt>
<dd>Delete files; true if removal succeeded.  If
the removal failed, an error message is issued. 
<p> </dd>

<dt>-exec <i>command</i> ;</dt>
<dd>Execute <i>command</i>;
true if 0 status is returned.  All following arguments to <b>find</b> are taken
to be arguments to the command until an argument consisting of &lsquo;;&rsquo; is encountered.
 The string &lsquo;{}&rsquo; is replaced by the current file name being processed everywhere
it occurs in the arguments to the command, not just in arguments where
it is alone, as in some versions of <b>find</b>. Both of these constructions might
need to be escaped (with a &lsquo;\&rsquo;) or quoted to protect them from expansion by
the shell.  See the <b>EXAMPLES</b> section for examples of the use of the &lsquo;-exec&rsquo;
option.  The specified command is run once for each matched file. The command
is executed in the starting directory.   There are unavoidable security
problems surrounding use of the -exec option; you should use the -execdir
option instead.   
<p> </dd>

<dt>-exec <i>command</i> {} +</dt>
<dd>This variant of the -exec option runs
the specified command on the selected files, but the command line is built
by appending each selected file name at the end; the total number of invocations
of the command will be much less than the number of matched files.  The
command line is built in much the same way that <b>xargs</b> builds its command
lines.  Only one instance of &rsquo;{}&rsquo; is allowed within the command.  The command
is executed in the starting directory. 
<p> </dd>

<dt>-execdir <i>command</i> ;</dt>
<dd></dd>

<dt>-execdir <i>command</i>
{} +</dt>
<dd>Like -exec, but the specified command is run from the subdirectory containing
the matched file, which is not normally the directory in which you started
 <b>find</b>. This a much more secure method for invoking commands, as it avoids
race conditions during resolution of the paths to the matched files. As
with the -exec option, the &rsquo;+&rsquo; form of -execdir will build a command line to
process more than one matched file, but any given invocation of <i>command</i>
 will only list files that exist in the same subdirectory.  If you use this
option, you must ensure that your  <b>$PATH</b> environment variable does not
reference the current directory; otherwise, an attacker can run any commands
they like by leaving an appropriately-named file in a directory in which
you will run -execdir. 
<p> </dd>

<dt>-fls <i>file</i></dt>
<dd>True; like -ls but write to <i>file</i> like -fprint.
The output file is always created, even if the predicate is never matched.
</dd>

<dt>-fprint <i>file</i></dt>
<dd>True; print the full file name into file <i>file</i>.  If <i>file</i> does
not exist when <b>find</b> is run, it is created; if it does exist, it is truncated.
 The file names &lsquo;&lsquo;/dev/stdout&rsquo;&rsquo; and &lsquo;&lsquo;/dev/stderr&rsquo;&rsquo; are handled specially; they
refer to the standard output and standard error output, respectively. The
output file is always created, even if the predicate is never matched. </dd>

<dt>-fprint0
<i>file</i></dt>
<dd>True; like -print0 but write to <i>file</i> like -fprint. The output file is
always created, even if the predicate is never matched. </dd>

<dt>-fprintf <i>file</i> <i>format</i></dt>
<dd>True;
like -printf but write to <i>file</i> like -fprint. The output file is always created,
even if the predicate is never matched. </dd>

<dt>-ok <i>command</i> ;</dt>
<dd>Like -exec but ask the
user first (on the standard input); if the response does not start with
&lsquo;y&rsquo; or &lsquo;Y&rsquo;, do not run the command, and return false. </dd>

<dt>-print</dt>
<dd>True; print the full
file name on the standard output, followed by a newline.   If you are piping
the output of  <b>find </b> into another program and there is the faintest possibility
that the files  which you are searching for might contain a newline, then
you should  seriously consider using the &lsquo;-print0&rsquo; option instead of &lsquo;-print&rsquo;.
</dd>

<dt>-okdir <i>command</i> ;</dt>
<dd>Like -execdir but ask the user first (on the standard input);
if the response does not start with &lsquo;y&rsquo; or &lsquo;Y&rsquo;, do not run the command, and
return false. </dd>

<dt>-print0</dt>
<dd>True; print the full file name on the standard output,
followed by a null character (instead of the newline character that &lsquo;-print&rsquo;
uses). This allows file names that contain newlines or other types of white
space to be correctly interpreted by programs that process the <b>find</b> output.
 This option corresponds to the &lsquo;-0&rsquo; option of <b>xargs</b>. </dd>

<dt>-printf <i>format</i></dt>
<dd>True; print
<i>format</i> on the standard output, interpreting &lsquo;\&rsquo; escapes and &lsquo;%&rsquo; directives. 
Field widths and precisions can be specified as with the &lsquo;printf&rsquo; C function.
 Please note that many of the fields are printed as %s rather than %d,
and this may mean that flags don&rsquo;t work as you might expect.  This also means
that the &lsquo;-&rsquo; flag does work (it forces fields to be left-aligned).  Unlike -print,
-printf does not add a newline at the end of the string.  The escapes and
directives are: <blockquote></dd>

<dt>\a</dt>
<dd>Alarm bell. </dd>

<dt>\b</dt>
<dd>Backspace. </dd>

<dt>\c</dt>
<dd>Stop printing from this format
immediately and flush the output. </dd>

<dt>\f</dt>
<dd>Form feed. </dd>

<dt>\n</dt>
<dd>Newline. </dd>

<dt>\r</dt>
<dd>Carriage return. </dd>

<dt>\t</dt>
<dd>Horizontal
tab. </dd>

<dt>\v</dt>
<dd>Vertical tab. </dd>

<dt>\ </dt>
<dd>ASCII NUL. </dd>

<dt>\\</dt>
<dd>A literal backslash (&lsquo;\&rsquo;). </dd>

<dt>\NNN</dt>
<dd>The character whose
ASCII code is NNN (octal). </dd>
</dl>
<p>
A &lsquo;\&rsquo; character followed by any other character
is treated as an ordinary character, so they both are printed. 
<dl>

<dt>%%</dt>
<dd>A literal
percent sign. </dd>

<dt>%a</dt>
<dd>File&rsquo;s last access time in the format returned by the C &lsquo;ctime&rsquo;
function. </dd>

<dt>%A<i>k</i></dt>
<dd>File&rsquo;s last access time in the format specified by <i>k</i>, which
is either &lsquo;@&rsquo; or a directive for the C &lsquo;strftime&rsquo; function.  The possible values
for <i>k</i> are listed below; some of them might not be available on all systems,
due to differences in &lsquo;strftime&rsquo; between systems.   <blockquote></dd>

<dt>@</dt>
<dd>seconds since Jan. 1,
1970, 00:00 GMT. </dd>
</dl>
<p>
Time fields: 
<dl>

<dt>H</dt>
<dd>hour (00..23) </dd>

<dt>I</dt>
<dd>hour (01..12) </dd>

<dt>k</dt>
<dd>hour ( 0..23) </dd>

<dt>l</dt>
<dd>hour
( 1..12) </dd>

<dt>M</dt>
<dd>minute (00..59) </dd>

<dt>p</dt>
<dd>locale&rsquo;s AM or PM </dd>

<dt>r</dt>
<dd>time, 12-hour (hh:mm:ss [AP]M)
</dd>

<dt>S</dt>
<dd>second (00..61) </dd>

<dt>T</dt>
<dd>time, 24-hour (hh:mm:ss) </dd>

<dt>+</dt>
<dd>Date and time, separated by &rsquo;+&rsquo;,
for example &lsquo;2004-04-28+22:22:05&rsquo;. The time is given in the current timezone
(which may be affected by setting the TZ environment variable).  This is
a GNU extension. </dd>

<dt>X</dt>
<dd>locale&rsquo;s time representation (H:M:S) </dd>

<dt>Z</dt>
<dd>time zone (e.g., EDT),
or nothing if no time zone is determinable </dd>
</dl>
<p>
Date fields: 
<dl>

<dt>a</dt>
<dd>locale&rsquo;s abbreviated
weekday name (Sun..Sat) </dd>

<dt>A</dt>
<dd>locale&rsquo;s full weekday name, variable length (Sunday..Saturday)
</dd>

<dt>b</dt>
<dd>locale&rsquo;s abbreviated month name (Jan..Dec) </dd>

<dt>B</dt>
<dd>locale&rsquo;s full month name, variable
length (January..December) </dd>

<dt>c</dt>
<dd>locale&rsquo;s date and time (Sat Nov 04 12:02:33 EST
1989) </dd>

<dt>d</dt>
<dd>day of month (01..31) </dd>

<dt>D</dt>
<dd>date (mm/dd/yy) </dd>

<dt>h</dt>
<dd>same as b </dd>

<dt>j</dt>
<dd>day of year (001..366)
</dd>

<dt>m</dt>
<dd>month (01..12) </dd>

<dt>U</dt>
<dd>week number of year with Sunday as first day of week (00..53)
</dd>

<dt>w</dt>
<dd>day of week (0..6) </dd>

<dt>W</dt>
<dd>week number of year with Monday as first day of week
(00..53) </dd>

<dt>x</dt>
<dd>locale&rsquo;s date representation (mm/dd/yy) </dd>

<dt>y</dt>
<dd>last two digits of year
(00..99) </dd>

<dt>Y</dt>
<dd>year (1970...) </dd>
</dl>
</blockquote>

<dl>

<dt>%b</dt>
<dd>File&rsquo;s size in 512-byte blocks (rounded up). </dd>

<dt>%c</dt>
<dd>File&rsquo;s
last status change time in the format returned by the C &lsquo;ctime&rsquo; function.
</dd>

<dt>%C<i>k</i></dt>
<dd>File&rsquo;s last status change time in the format specified by <i>k</i>, which is
the same as for %A. </dd>

<dt>%d</dt>
<dd>File&rsquo;s depth in the directory tree; 0 means the file
is a command line argument. </dd>

<dt>%D</dt>
<dd>The device number on which the file exists
(the st_dev field of struct stat), in decimal. </dd>

<dt>%f</dt>
<dd>File&rsquo;s name with any leading
directories removed (only the last element). </dd>

<dt>%F</dt>
<dd>Type of the filesystem the
file is on; this value can be used for -fstype. </dd>

<dt>%g</dt>
<dd>File&rsquo;s group name, or numeric
group ID if the group has no name. </dd>

<dt>%G</dt>
<dd>File&rsquo;s numeric group ID. </dd>

<dt>%h</dt>
<dd>Leading directories
of file&rsquo;s name (all but the last element). If the file name contains no slashes
(since it is in the current  directory) the %h specifier expands to ".".
</dd>

<dt>%H</dt>
<dd>Command line argument under which file was found. </dd>

<dt>%i</dt>
<dd>File&rsquo;s inode number
(in decimal). </dd>

<dt>%k</dt>
<dd>The amount of disk space used for this file in 1K blocks
(rounded up).  This is different from %s/1024 if the file is a sparse file.
</dd>

<dt>%l</dt>
<dd>Object of symbolic link (empty string if file is not a symbolic link).
</dd>

<dt>%m</dt>
<dd>File&rsquo;s permission bits (in octal).  This option uses the &rsquo;traditional&rsquo; numbers
which most Unix implementations use, but if your particular  implementation
uses an unusual ordering of octal permissions bits, you will see a difference
between the actual value of the file&rsquo;s mode and the output of %m.   Normally
you will want to have a leading zero on this number, and to do this, you
should use the  <b>#</b> flag (as in, for example, &rsquo;%#m&rsquo;). </dd>

<dt>%n</dt>
<dd>Number of hard links
to file. </dd>

<dt>%p</dt>
<dd>File&rsquo;s name. </dd>

<dt>%P</dt>
<dd>File&rsquo;s name with the name of the command line argument
under which it was found removed. </dd>

<dt>%s</dt>
<dd>File&rsquo;s size in bytes. </dd>

<dt>%t</dt>
<dd>File&rsquo;s last modification
time in the format returned by the C &lsquo;ctime&rsquo; function. </dd>

<dt>%T<i>k</i></dt>
<dd>File&rsquo;s last modification
time in the format specified by <i>k</i>,  which is the same as for %A. </dd>

<dt>%u</dt>
<dd>File&rsquo;s
user name, or numeric user ID if the user has no name. </dd>

<dt>%U</dt>
<dd>File&rsquo;s numeric user
ID. </dd>

<dt>%y</dt>
<dd>File&rsquo;s type (like in ls -l), U=unknown type (shouldn&rsquo;t happen) </dd>

<dt>%Y</dt>
<dd>File&rsquo;s
type (like %y), plus follow symlinks: L=loop, N=nonexistent </dd>
</dl>
<p>
A &lsquo;%&rsquo; character
followed by any other character is discarded (but the other character is
printed). 
<p> The %m and %d directives support the  <b>#</b> ,  <b>0 </b> and  <b>+ </b> flags,
but the other directives do not, even if they print numbers.  Numeric directives
that do not support these flags include  <b>G</b>,<b></b> <b>U</b>,<b></b> <b>b</b>,<b></b> <b>D</b>,<b></b> <b>k </b> and  <b>n</b>. The &lsquo;-&rsquo; format
flag is supported and changes the alignment of a field from right-justified
(which is the default) to left-justified. 
<p> 
<p> </blockquote>

<dl>

<dt>-prune</dt>
<dd>If -depth is not given, true;
if the file is a directory, do not descend into it. <br>
If -depth is given, false; no effect. 
<p> </dd>

<dt>-quit</dt>
<dd>Exit immediately.  No child proceses
will be left running, but no more paths specified on the command line will
be processed.  For example, <b>find /tmp/foo /tmp/bar -print -quit</b> will print
only <b>/tmp/foo</b>. Any command lines which have been built up with <b>-execdir ...
{} +</b> will be invoked before  <b>find</b> exits.   The exit status may or may not
be zero, depending on whether an error has already occurred.   
<p> </dd>

<dt>-ls</dt>
<dd>True;
list current file in &lsquo;ls -dils&rsquo; format on standard output. The block counts
are of 1K blocks, unless the environment variable POSIXLY_CORRECT is set,
in which case 512-byte blocks are used. 
<p> </dd>
</dl>

<h3><a name='sect8' href='#toc8'>Operators</a></h3>
<p>
Listed in order of decreasing
precedence: 
<dl>

<dt>( <i>expr</i> )</dt>
<dd>Force precedence. </dd>

<dt>! <i>expr</i></dt>
<dd>True if <i>expr</i> is false. </dd>

<dt>-not <i>expr</i></dt>
<dd>Same
as ! <i>expr</i>, but not POSIX compliant. </dd>

<dt><i>expr1 expr2</i></dt>
<dd>Two expressions in a row
are taken to be joined with an  implied "and"; <i>expr2</i> is not evaluated if
<i>expr1</i> is false. </dd>

<dt><i>expr1</i> -a <i>expr2</i></dt>
<dd>Same as <i>expr1 expr2</i>. </dd>

<dt><i>expr1</i> -and <i>expr2</i></dt>
<dd>Same as
<i>expr1 expr2</i>, but not POSIX compliant. </dd>

<dt><i>expr1</i> -o <i>expr2</i></dt>
<dd>Or; <i>expr2</i> is not evaluated
if <i>expr1</i> is true. </dd>

<dt><i>expr1</i> -or <i>expr2</i></dt>
<dd>Same as <i>expr1</i> -o <i>expr2</i>, but not POSIX compliant.
</dd>

<dt><i>expr1</i> , <i>expr2</i></dt>
<dd>List; both <i>expr1</i> and <i>expr2</i> are always evaluated. The value
of <i>expr1</i> is discarded; the value of the list is the value of <i>expr2</i>.<tt> </tt>&nbsp;<tt> </tt>&nbsp; The
comma operator can be useful for searching for several different types
of thing, but traversing the filesystem hierarchy only once.   The  <b>-fprintf
 </b> action can be used to list the various matched items into several different
output files. 
<p> 
<p> </dd>
</dl>

<h2><a name='sect9' href='#toc9'>Standards Conformance</a></h2>
The following options are specified
in the POSIX standard  (IEEE Std 1003.1, 2003 Edition): 
<dl>

<dt>-H</dt>
<dd>This option is
supported. </dd>

<dt>-L</dt>
<dd>This option is supported. </dd>

<dt>-name</dt>
<dd>This option is supported, but POSIX
conformance depends on the  POSIX conformance of the system&rsquo;s  <a href='fnmatch.3.html'><b>fnmatch</b>(3)<b></b></a>

library function.  As of findutils-4.2.2, shell metacharacters (&rsquo;*&rsquo;. &rsquo;?&rsquo; or &rsquo;[]&rsquo; for
example) will match a leading &rsquo;.&rsquo;, because  IEEE PASC interpretation 126 requires
this.   This is a change from previous versions of findutils. </dd>

<dt>-type</dt>
<dd>Supported.
  POSIX specifies &lsquo;b&rsquo;, &lsquo;c&rsquo;, &lsquo;d&rsquo;, &lsquo;l&rsquo;, &lsquo;p&rsquo;, &lsquo;f&rsquo; and &lsquo;s&rsquo;. GNU find also supports &lsquo;D&rsquo;, representing
a Door, where the OS provides these. 
<p> </dd>

<dt>-ok</dt>
<dd>Supported.   Interpretation of the
response is not locale-dependent (see ENVIRONMENT VARIABLES). 
<p> </dd>

<dt>-newer</dt>
<dd>Supported.
 If the file specified is a symbolic link, it is always dereferenced.  This
is a change from previous behaviour, which used to  take the relevant time
from the symbolic link; see the HISTORY section below. 
<p> </dd>

<dt>Other predicates</dt>
<dd>The
predicates &lsquo;-atime&rsquo;, &lsquo;-ctime&rsquo;, &lsquo;-depth&rsquo;, &lsquo;-group&rsquo;, &lsquo;-links&rsquo;, &lsquo;-mtime&rsquo;, &lsquo;-nogroup&rsquo;, &lsquo;-nouser&rsquo;, &lsquo;-perm&rsquo;,
&lsquo;-print&rsquo;, &lsquo;-prune&rsquo;, &lsquo;-size&rsquo;, &lsquo;-user&rsquo; and  &lsquo;-xdev&rsquo;, are all supported. 
<p> </dd>
</dl>
<p>
The POSIX standard
specifies parentheses &lsquo;(&rsquo;, &lsquo;)&rsquo;, negation &lsquo;!&rsquo; and the &lsquo;and&rsquo; and &lsquo;or&rsquo; operators (&lsquo;-a&rsquo;,
&lsquo;-o&rsquo;).    <p>
All other options, predicates, expressions and so forth are extensions
 beyond the POSIX standard.  Many of these extensions are not unique to
 GNU find, however. <p>
The POSIX standard requires that  
<dl>

<dt>The  </dt>
<dd><b>find</b> utility
shall detect infinite loops; that is, entering a previously visited directory
that is an ancestor of the last file encountered. When it detects an infinite
loop, find shall write a diagnostic message to standard error and shall
either recover its position in the hierarchy or terminate. </dd>
</dl>
<p>
The link count
of directories which contain entries which are hard links to an ancestor
will often be lower than they otherwise should be.  This can mean that GNU
find will sometimes optimise away the visiting of a subdirectory which
is actually a link to an ancestor. Since  <b>find</b> does not actually enter such
a subdirectory, it is allowed to avoid emitting a diagnostic message.  Although
this behaviour may be somewhat confusing, it is unlikely that anybody actually
depends on this behaviour.  If the leaf optimisation has been turned off
with <b>-noleaf</b>, the directory entry will always be examined and the diagnostic
message will be issued where it is appropriate.  Symbolic links cannot be
used to create filesystem cycles as such, but if the -L option or the -follow
option is in use, a diagnostic message is issued when  <b>find </b> encounters
a loop of symbolic links.  As with loops containing hard links, the leaf
optimisation will often mean that  <b>find</b> knows that it doesn&rsquo;t need to call
 <i>stat()</i> or <i>chdir()</i>  on the symbolic link, so this diagnostic is frequently
not necessary. <p>
The -d option is supported for comatibility with various BSD
systems, but you should use the POSIX-compliant predicate -depth instead.

<h2><a name='sect10' href='#toc10'>Environment Variables</a></h2>

<dl>

<dt>LANG</dt>
<dd>Provides a default value for the internationalization
variables that are unset or null. </dd>

<dt>LC_ALL</dt>
<dd>If set to a non-empty string value,
override the values of all the other internationalization variables. </dd>

<dt>LC_COLLATE</dt>
<dd>The
POSIX standard specifies that this variable affects the pattern matching
to be used for the &lsquo;-name&rsquo; option.   GNU find uses the  <a href='fnmatch.3.html'><b>fnmatch</b>(3)<b></b></a>
 library
function, and so support for &lsquo;LC_COLLATE&rsquo; depends on the system library. 
   </dd>

<dt>POSIX also specifies that the &lsquo;LC_COLLATE&rsquo; environment  </dt>
<dd>variable affects
the interpretation of the user&rsquo;s response to the  query issued by &lsquo;-ok&rsquo;, but
this is not the case for GNU find. </dd>

<dt>LC_CTYPE</dt>
<dd>This variable affects the treatment
of character classes used with  the &lsquo;-name&rsquo; option, if the system&rsquo;s  <a href='fnmatch.3.html'><b>fnmatch</b>(3)<b></b></a>

library function supports this.   It has no effect on the behaviour  of
the &lsquo;-ok&rsquo; expression. </dd>

<dt>LC_MESSAGES</dt>
<dd>Determines the locale to be used for internationalised
messages. </dd>

<dt>NLSPATH</dt>
<dd>Determines the location of the internationalisation message
catalogues. </dd>

<dt>PATH</dt>
<dd>Affects the directores which are searched to find the executables
 invoked by &lsquo;-exec&rsquo; and &lsquo;-ok&rsquo;. </dd>

<dt>POSIXLY_CORRECT</dt>
<dd>Determines the block size used by
&lsquo;-ls&rsquo;. </dd>

<dt>TZ</dt>
<dd>Affects the time zone used for some of the time-related format directives
of -printf and -fprintf. </dd>
</dl>

<h2><a name='sect11' href='#toc11'>Examples</a></h2>
<br>
<pre>find /tmp -name core -type f -print | xargs /bin/rm -f</pre>Find files named  <b>core</b>
in or below the directory  <b>/tmp </b> and delete them.  Note that this will work
incorrectly if there are  any filenames containing newlines, single or
double quotes, or spaces. <p>
<b>find /tmp -name core -type f -print0 | xargs -0 /bin/rm

<p>-
<p>f</b> 
<p> </pre>Find files named  <b>core</b> in or below the directory  <b>/tmp </b> and delete them,
processing filenames in such a way that file or directory names containing
single or double quotes, spaces or newlines are correctly handled.  The
<b>-name </b> test comes before the  <b>-type</b> test in order to avoid having to call
 <a href='stat.2.html'><b>stat(2)</a>
 </b> on every file. 
<p> <p>
<br>
<pre>find . -type f -exec file &rsquo;{}&rsquo; \;</pre>Runs &lsquo;file&rsquo; on every file in or below the current
directory.  Notice that the braces are enclosed in single quote marks to
protect them from interpretation as shell script punctuation.   The semicolon
is similarly protected by the use of a backslash, though &rsquo;;&rsquo; could have been
used in that case also. 
<p> <p>
<br>
<pre>find /  t( -perm +4000 -fprintf /root/suid.txt &rsquo;%#m %u %p\n&rsquo; ) , \tt( -size +100M
-fprintf /root/big.txt  &rsquo;%-10s %p\n&rsquo;  )</pre>Traverse the filesystem just once, listing
setuid files and directories into <b>/root/suid.txt</b> and large files into  <b>/root/big/txt</b>.

<p> <p>
<br>
<pre>find $HOME  -mtime 0</pre>Search for files in your home directory which have been
modified in the last twenty-four hours.  This command works this way because
the time since each file was last accessed is divided by 24 hours and any
 remainder is discarded.  That means that to match  <b>-atime </b> <b>0</b>, a file will
have to have a modification in the past which is less than 24 hours ago.

<p> 
<p> <p>
<br>
<pre>find . -perm 664</pre>Search for files which have read and write permission for
their owner, and group, but which the rest of the world can read but not
write to.   Files which meet these criteria but have other permissions bits
set (for example if someone can execute the file) will not be matched. 
<p>
<p>
<br>
<pre>find . -perm -664</pre>Search for files which have read and write permission for
their owner, and group, but which the rest of the world can read but not
write to, without regard to the presence of any extra permission bits (for
example the executable bit).  This will match a file which has mode 0777,
for example. 
<p> <p>
<br>
<pre>find . -perm +222</pre>Search for files which are writeable by somebody (their
owner, or their group, or anybody else). 
<p> <p>
<br>
<pre>find . -perm +022find . -perm +g+w,o+wfind . -perm +g=w,o=w</pre>All three of these
commands do the same thing, but the first one uses the octal representation
of the file mode, and the other two use the symbolic form.  These commands
all search for files which are writeable by either their owner or their
group.  The files don&rsquo;t have to be writeable by both the owner and group
to be matched; either will do. 
<p> <p>
<br>
<pre>find . -perm -022find . -perm -g+w,o+w</pre>Both these commands do the same thing;
search for files which are writeable by both their owner and their group.

<p> 
<p> 
<p> 
<h2><a name='sect12' href='#toc12'>Exit Status</a></h2>
<p>
<b>find</b> exits with status 0 if all files are processed successfully,
greater than 0 if errors occur.   This is deliberately a very broad description,
but if the return value is non-zero, you should not rely on the correctness
of the results of  <b>find</b>. 
<p> 
<h2><a name='sect13' href='#toc13'>See Also</a></h2>
<a href='locate.1.html'><b>locate</b>(1)</a>
, <a href='locatedb.5.html'><b>locatedb</b>(5)</a>
, <a href='updatedb.1.html'><b>updatedb</b>(1)</a>
, <a href='xargs.1.html'><b>xargs</b>(1)</a>
,
<a href='fnmatch.3.html'><b>fnmatch</b>(3)</a>
, <a href='regex.7.html'><b>regex</b>(7)</a>
, <a href='stat.2.html'><b>stat</b>(2)</a>
, <a href='lstat.2.html'><b>lstat</b>(2)</a>
, <a href='ls.1.html'><b>ls</b>(1)</a>
, <a href='printf.3.html'><b>printf</b>(3)</a>
, <a href='strftime.3.html'><b>strftime</b>(3)</a>
,
<a href='ctime.3.html'><b>ctime</b>(3)</a>
, <b>Finding Files</b> (on-line in Info, or printed),  
<h2><a name='sect14' href='#toc14'>History</a></h2>
As of findutils-4.2.2,
shell metacharacters (&rsquo;*&rsquo;. &rsquo;?&rsquo; or &rsquo;[]&rsquo; for example) used in filename patterns
will match a leading &rsquo;.&rsquo;, because IEEE POSIX interpretation 126 requires this.

<p> 
<h2><a name='sect15' href='#toc15'>Bugs</a></h2>
<p>
There are security problems inherent in the behaviour that the POSIX
standard specifies for <b>find</b>, which therefore cannot be fixed.  For example,
the -exec action is inherently insecure, and -execdir should be used instead.
  Please see <b>Finding Files</b> for more information.  <p>
The best way to report
a bug is to use the form at <a href='http://savannah.gnu.org/bugs/?group=findutils.'>http://savannah.gnu.org/bugs/?group=findutils.</a>

  The reason for this is that you will then be able to track progress in
fixing the problem.   Other comments about <a href='find.1.html'><b>find</b>(1)</a>
 and about the findutils
package in general can be sent to the  <i>bug-findutils</i> mailing list.  To join
the list, send email to  <i>bug-findutils-request@gnu.org</i>. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Expressions</a></li>
<ul>
<li><a name='toc5' href='#sect5'>Options</a></li>
<li><a name='toc6' href='#sect6'>Tests</a></li>
<li><a name='toc7' href='#sect7'>Actions</a></li>
<li><a name='toc8' href='#sect8'>Operators</a></li>
</ul>
<li><a name='toc9' href='#sect9'>Standards Conformance</a></li>
<li><a name='toc10' href='#sect10'>Environment Variables</a></li>
<li><a name='toc11' href='#sect11'>Examples</a></li>
<li><a name='toc12' href='#sect12'>Exit Status</a></li>
<li><a name='toc13' href='#sect13'>See Also</a></li>
<li><a name='toc14' href='#sect14'>History</a></li>
<li><a name='toc15' href='#sect15'>Bugs</a></li>
</ul>
</body>
</html>
