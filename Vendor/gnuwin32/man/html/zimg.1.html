<!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>ZIMG(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<p>                                   
<p> 
<p>   
<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
zimg - render 2d data of arbitrary

<p>format 
<p> 
<p> 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<dl>

<dt><b>zimg</b> [<i>options</i>] [<i>file ...</i>] </dt>
<dd>
<p> 
<p> </dd>
</dl>

<h2><a name='sect2' href='#toc2'>Description</a></h2>
The <b>zimg</b> program generates
png images from arbitrary formatted 2-D ascii or binary data. Optionally,
jpeg, ppm or pgm images can be generated instead of png. 
<p> 
<p> 
<h2><a name='sect3' href='#toc3'>Input Files</a></h2>

<p> If
no input files are given, <b>zimg</b> reads from stdin. 
<p> If the input file ends
in <b>.gz</b>, <b>.bz2</b>, <b>.z</b> or <b>.Z</b> and your operating system supports the popen() call,
the file is filtered through gunzip, bunzip2 or uncompress, respectively.

<p> If an input file is not accessible, the availability of the file with
the suffixes <b>.gz</b>, <b>.bz2</b>, <b>.z</b> or <b>.Z</b> appended is checked (<b>multiview</b>). 
<p> If no command
line options are specified, <b>zimg</b> assumes plain ascii input, where the dimensions
of the image are taken from the first two convertable integers and comment
lines are marked by a  hash &lsquo;#&rsquo; mark at the very first column of each line.
 If ascii data is read the first lines are parsed for zimg <b>modelines</b> until
the first data point is read. See below in the section <b>MODELINES</b>. 
<p> Currently
the &lsquo;ESRF data format&rsquo; (edf and ehf) is the only binary input format which
is detected automatically by <b>zimg</b> (if this option was not disabled at compile
time). In the case of ehf, the data is read from a different file as specified
by the tag <i>EDF_BinaryFileName</i>. 
<p> If the size was not specified and no binary
option was selected, the first bytes of the source file are examined to
check if the source is already a png file. This works only on systems where
there&rsquo;s no difference between reading ascii and binary data (UNIX). If the
source file is a png, all options except the colormap, labelling and output
options are ignored. This is mainly useful for labelling a png file later
(or a png file that was not created by <b>zimg</b>).  It can also be used to just
convert png to jpeg. Or you can specify a different colormap, to change
the colormap entries of the source png.  Note that this check for source
png&rsquo;s is not available if <b>zimg</b> was linked with an older libgd version. If
the source is a png, the <b>--dump-colormap</b> switch dumps the colormap entries
of the png file instead of the zimg colors. 
<p> 
<h2><a name='sect4' href='#toc4'>Options</a></h2>

<p> In almost all cases
you&rsquo;ll need to specify at least a few command line options to tell <b>zimg</b>
something about the input format and specify the output style. 
<p> <p>
Note, that
the order of command line options is important: in the case of mutually
exclusive options the last one wins;  in the case of a switch which turns
an option on, a second occurence of this switch turns the option off again.
 Example: -x -x does nothing. This is useful for overwriting options which
were set in the resource files ~/.zimgrc and .zimgrc (see section FILES).
If an options overwrites another option (e.g. in &lsquo;--red --blue&rsquo;, the second switch
would overwrite the first), this is silently ignored. 
<p> Some switches can
be defined more than once and are <i>position dependent</i>. These switches include
    <b>--differentiate</b><br>
     <b>--curvature</b><br>
     <b>--smooth</b><br>
     <b>--logarithmic</b><br>
     <b>--fabs</b><br>
     <b>--absolute</b><br>
     <b>--relative</b><br>
 
<p> This means that in <blockquote><br>
<pre>    zimg --relative=10-60 --differentiate
</pre></blockquote>
 the relative scaling applies to the raw data, but in <blockquote><br>
<pre>    zimg --differentiate --relative=10-60
</pre></blockquote>
 the relative scaling applies to the differentiated data. 
<p> <p>
Spaces separating
the single-letter options from their parameters are optional. 
<p> The availability
of some options are compile-time dependent.  Use the <b>--help</b> option to get a
list of valid options for your binary version of <b>zimg</b>. 
<p> 
<p> 
<dl>

<dt><b>-r, --size</b>=<i>width</i>[,<i>height</i>]
</dt>
<dd>specifies the <i>width</i> and <i>height</i> of the 2-D data. If <i>height</i> is not given it
is set equal to <i>width</i>. The separator &rsquo;x&rsquo; (instead of &rsquo;,&rsquo;) can be used also for
backwards compatibility.   
<p> </dd>

<dt><b>-M, --matrix</b> </dt>
<dd>Input is assumed to be in ascii matrix
format. The ascii input file should have the data in rows and columns. The
number of rows is the image dimension in vertical direction. The number
of columns is the image in horizontal direction. The dimension of the data
can be overwritten by the <i>--size</i> switch. 
<p> </dd>

<dt><b>-p, --pattern</b>=<i>pattern</i> </dt>
<dd>Mark comment
blocks.  This option is used when reading unformatted ascii data. Each line
will be truncated at <i>pattern</i>.  This options might be used repeatedly to
specify more than one comment pattern. This option was not really tested
and might be still buggy. For the future it is planned to include also regular
expressions. 
<p> </dd>

<dt><b>-n, --column</b>=<i>number</i> </dt>
<dd>read column <i>number</i> (ascii input). Multiple
columns can be selected by using this option repeatedly.  Currently this
is limited to the 32 first columns.  If <i>number</i> is omitted, the data of all
columns will be used. 
<p> </dd>

<dt><b>--skip</b>[=<i>bytes/lines</i>] </dt>
<dd>skip this amount of <i>lines</i> when
reading ascii data. Skip <i>bytes</i>, if reading binary data. Note that the unit
is <i>bytes</i>, irrespective of the input type (short ..). If the optional size
argument is missing, the option is reset to its default. This default behavior
is as follows: for binary data, all available data is read from the input
stream and the header size (which will be skipped) is then calculated as
the difference between the size of input data and the size of the image
as specified by the -r switch. Or in short: the last &lt;width&gt;x&lt;height&gt; items of
the input stream will be taken.  If you don&rsquo;t like this feature you can disable
it explicitly by using the switch &lsquo;--skip=0&rsquo;. For ascii data no skipping will
be done by default. 
<p> </dd>

<dt><b>--options</b>=/<i>regexp</i>/<i>switches</i> </dt>
<dd>apply <i>switches</i>, if the input
filename matches <i>regexp</i>. Especially useful if used in a <b>.zimgrc</b> file. The
separator character can be any character which is not present in regexp,
for example <b>--options</b>=#<i>/usr/local</i>#<i>switches</i>. See also the <b>--input-filter</b> switch.
<b>--options</b> is only available if your system provides the POSIX regular expression
functions regcomp / regexec (check <b>zimg -V</b> for availability). 
<p> </dd>

<dt><b>--input-filter</b>=<i>filter</i>
</dt>
<dd>filter input files thru <i>filter</i>. If <i>filter</i> contains a %s, it is substituted
with the file name, else the filename is appended to the <i>filter</i>. This switch
is especially useful if used in a <b>.zimgrc</b> file. Example: --options=&rsquo;/.int$/--input-filter=int
&lt; %s&rsquo;. See also the <b>--options</b> switch. <b>--input-filter</b> is only available if your system
supports the popen() call (check <b>zimg -V</b> for availability). 
<p> </dd>

<dt><b>-o, --output</b>=<i>path</i>
</dt>
<dd>normally <b>zimg</b> writes to stdout. You don&rsquo;t ever need this option, if you redirect
stdout to you destination file or pipe. If more than one input file is given,
<i>path</i> should be an existing directory where the output files should be stored.
In this case the output names are constructed from <i>path</i>, the input file
name and a suffix ".gif", ".png", ".jpg", "ppm" or "pgm" depending on the
gd version which was used at compile time and eventually the <b>-j</b>, <b>-P</b>, <b>--ppm</b>
or <b>--pgm</b> switch. Using <i>-</i> for <i>path</i> will force stdout also for multiple input
files; however, this makes sense only with <i>ppm</i> and <i>pgm</i> output image formats
because png and jpeg formats do not allow multiple images in one file (only
the first one would be read). 
<p> </dd>

<dt><b>--big-endian </b></dt>
<dd>binary input data is big-endian.
This option overwrites <b>--swap</b> and can be overwritten by <b>--swap</b> and <b>--little-endian</b>.
This switch does nothing if the machine where <b>zimg</b> runs is also big-endian,
otherwise the words get swapped. 
<p> </dd>

<dt><b>--little-endian </b></dt>
<dd>binary input data is little-endian.
This option is the opposite of big-endian, overwrites <b>--swap</b> and can be overwritten
by <b>--swap</b> and <b>--big-endian</b>.  This switch does nothing if the machine where <b>zimg</b>
runs is also little-endian, otherwise the words get swapped. 
<p> </dd>

<dt><b>--swap </b></dt>
<dd>swap bytes
when reading binary input. This might be necessary when using binary files
from different platforms. If <b>zimg</b> runs on a little-endian machine (e.g. Intel)
<b>--swap</b> assumes the binary input data created by a big-endian machine and vice
versa. All three switches <b>--swap</b>, <b>--big-endian</b> and <b>--little-endian</b> overwrite each
other and therefore it is recommended to use only one of these switches.

<p> </dd>

<dt><b>-f, --float </b></dt>
<dd>read binary float (normally 4 bytes) data. 
<p> </dd>

<dt><b>-d, --double </b></dt>
<dd>read binary
double (normally 8 bytes) data. 
<p> </dd>

<dt><b>--char </b></dt>
<dd>read signed char data. 
<p> </dd>

<dt><b>--short </b></dt>
<dd>read
signed short data. 
<p> </dd>

<dt><b>--int </b></dt>
<dd>read signed int data. 
<p> </dd>

<dt><b>--long-int </b></dt>
<dd>read signed long-int
data. 
<p> </dd>

<dt><b>-c, --unsigned-char </b></dt>
<dd>read unsigned char data. 
<p> </dd>

<dt><b>-s, --unsigned-short </b></dt>
<dd>read unsigned
short data. 
<p> </dd>

<dt><b>-i, --unsigned-int </b></dt>
<dd>read unsigned int data. 
<p> </dd>

<dt><b>--unsigned-long-int </b></dt>
<dd>read
unsigned long int data. 
<p> </dd>

<dt><b>--complex-float</b>[=<i>(abs/length|phase|real|imaginary)</i>] </dt>
<dd>input
data is <i>binary</i> complex float. (ascii parsing of complex numbers is not implemented
yet. The value of the switch determines how to display the complex numbers.
The default is <i>abs</i> or the alias <i>length</i> (the length of the complex number).

<p> </dd>

<dt><b>--complex-double</b>=<i>(abs/length|phase|real|imaginary)</i> </dt>
<dd>Like <i>--complex-float</i>, but for
complex double <i>binary</i> input data. 
<p> </dd>

<dt><b>--red </b></dt>
<dd>use a red scale color map. 
<p> </dd>

<dt><b>--blue </b></dt>
<dd>use
a blue scale color map. 
<p> </dd>

<dt><b>--grey, --gray </b></dt>
<dd>use a grey scale color map. 
<p> </dd>

<dt><b>-m, --colormap</b>[=<i>path</i>]
</dt>
<dd>use custom colormap from the file <i>path</i>. The file must hold r g b triplets
with values ranging from 0 to 0xff (255). There must be exactly one triplet
per line, where empty lines and lines beginning with a hash &lsquo;#&rsquo; mark are
skipped. The maximum number of colors is defined in zimg.h and it is currently
240 (16 colors are reserved for "LINE COLORS"). The colormap file is searched
in the current directory, then in ~/.zimg/cmap, then in /usr/local/share/zimg/cmap.
If the optional argument <i>number</i> is omitted, the colormap is reset to the
default. 
<p> </dd>

<dt><b>-m, --colormap</b>[=<i>red[,green[,blue]]</i>] </dt>
<dd>create a colormap using predefined
colormap formulae.  red, green and blue must be integers between -36 and
36.  If <i>blue</i> and/or <i>green</i> are missing, they&rsquo;re set to green or red respectively
(so a gray colormap value can be created by specifying red only). The numbers
select one of the predefined formulae which are used to map the z value
to a color intensity.  Negative numbers invert the color intensity. Currently
the following formulae are defined where x ranges from [0, 1]: If the optional
argument <i>number</i> is omitted, the colormap is reset to the default. Note:
these formulae are the same as in <b>gnuplot</b> (version 3.8 and later), where
you can try and test them using commands <i>[set|show|test] palette</i>. 
<p> <blockquote><br>
<pre>    0    x = 0
    1    x = 0.5
    2    x = 1
    3    x = x    (identity)
    4    x = x * x
    5    x = x * x * x
    6    x = x * x * x * x
    7    x = sqrt(x)
    8    x = sqrt(sqrt(x))
    9    x = sin(90 * x)
   10    x = cos(90 * x)
   11    x = fabs(x - 0.5); 
   12    x = (2 * x - 1) * (2 * x - 1); 
   13    x = sin(180 * x); 
   14    x = fabs(cos(180 * x)); 
   15    x = sin(360 * x); 
   16    x = cos(360 * x); 
   17    x = fabs(sin(360 * x)); 
   18    x = fabs(cos(360 * x)); 
   19    x = fabs(sin(720 * x)); 
   20    x = fabs(cos(720 * x)); 
   21    x = 3 * x; 
   22    x = 3 * x - 1; 
   23    x = 3 * x - 2; 
   24    x = fabs(3 * x - 1); 
   25    x = fabs(3 * x - 2); 
   26    x = (1.5 * x - 0.5); 
   27    x = (1.5 * x - 1.0); 
   28    x = fabs(1.5 * x - 0.5); 
   29    x = fabs(1.5 * x - 1.0); 
   30
            if (x &lt;= 0.25)
                return 0;
            if (x &gt;= 0.57)
                return 1;
            x = x / 0.32 - 0.78125; 
   31
            if (x &lt;= 0.42)
                return 0;
            if (x &gt;= 0.92)
                return 1;
            x = 2 * x - 0.84; 
   32
            if (x &lt;= 0.42)
                x *= 4;
            else
                x = (x &lt;= 0.92) ? -2 * x + 1.84 : x / 0.08 - 11.5;
   33
            x = fabs(2 * x - 0.5); 
   34
            x = 2 * x;
   35
            x = 2 * x - 0.5;
   36
            x = 2 * x - 1;
</pre></dd>
</dl>
</blockquote>
 
<p> 
<dl>

<dt><b>-b, --cbox, --colorbox</b>[=<i>n</i>] </dt>
<dd>draw a labelled colorbox right to the image. If
the number of labels <i>n</i> isn&rsquo;t given, it is calculated automatically according
to the image and font heights. Labelling can be turned off by specifying
--colorbox=0. 
<p> </dd>

<dt><b>--cbox-fmt, --cbox-format</b>=<i>format</i> </dt>
<dd><i>format</i> is a c sprintf format string
for floats, e.g. %3.6g (see the <a href='sprintf.3.html'>sprintf(3)</a>
 manual), which is used for formatting
the colorbox legend. Turns on <b>--cbox</b> implicitely. 
<p> </dd>

<dt><b>--cbox-label</b>=<i>string</i> </dt>
<dd>Print <i>string</i>
next to the colorbox (e.g. a unit for the colorbox numbers). Turns on <b>--cbox</b>
implicitely. <i>string</i> can be a multiline string, see for example the <b>--label</b>
switch. 
<p> </dd>

<dt><b>--dump-colormap</b> </dt>
<dd>dump a colormap to stdout as it can be read back with
the <i>-m</i> switch. This can be useful for manually editing and reading back the
colormap. The <b>--dump-colormap</b> switch disables most of the other switches -- no
processing of data files is done. The only exception is if the source files
are png files: in this case not the (specified) colormap of zimg, but the
color entries of the source png are dumped. 
<p> </dd>

<dt><b>-I, --invert</b> </dt>
<dd>invert the selected
color map. 
<p> </dd>

<dt><b>-x, --xor</b>[=<i>color</i>] </dt>
<dd>do an exclusive or with the specified <i>color</i> (defaults
to white). For the gray scale color map this equivalent to the <b>--invert</b> switch.

<p> </dd>

<dt><b>--differentiate</b> </dt>
<dd>apply a discrete differentiation (1&rsquo;st derivative) to the
data. This is a <i>position dependent</i> switch 
<p> </dd>

<dt><b>-u, --curvature</b> </dt>
<dd>display the curvature
(2&rsquo;nd derivative) of the data. This is a <i>position dependent</i> switch 
<p> </dd>

<dt><b>--smooth</b>[=<i>threshold</i>]
</dt>
<dd>wipe out hot spots. The average and sigma of the nearest neighbors of each
pixel are calculated. If the pixel&rsquo;s value is greater than (&lsquo;threshold&rsquo; * sigma
+ average), it will be set to the average of the neighbors. This is a <i>position

<p>dependent</i> switch 
<p> </dd>

<dt><b>-z, --crange</b>=<i>min,max</i> </dt>
<dd>sets data range for the color mappings
to <i>min</i> to <i>min</i>.  Default is autoscaled color range according to the image
data values. The partial notations <b>--crange</b>=<i>min,</i> and <b>--crange</b>=<i>,max</i> can be used,
denoting the missing limiting value to be autoscaled. 
<p> </dd>

<dt><b>-l, --logarithmic</b>[=<i>scale</i>]
</dt>
<dd>use a logarithmic color scale where <i>scale</i> must be strictly positive. The
data is scaled to the range 0 - <i>scale</i>, then the log1p () is taken. The default
for <i>scale</i> is 1. The best way to understand this is to compare the results
for different <i>scale</i> values. This is a <i>position dependent</i> switch 
<p> </dd>

<dt><b>-a, --fabs</b>
</dt>
<dd>take the absolute value of the input data. The long option <b>--fabs</b> was named
after the c function fabs(), because the <b>--absolute</b> switch is used for absolute
scaling (see below). This is a <i>position dependent</i> switch 
<p> </dd>

<dt><b>--absolute</b>=<i>min,max</i>
</dt>
<dd>set everything below <i>min</i> to <i>min</i> and every thing above <i>max</i> to <i>max</i>. The partial
notations <b>--abs</b>=<i>min,</i> and <b>--abs</b>=<i>,max</i> can be used. If both <i>min</i> and <i>max</i> are given,
a <i>-</i> can be used as separator instead of the <i>,</i>. This is a <i>position dependent</i>

<p>switch 
<p> </dd>

<dt><b>--relative</b>=<i>min,max</i> </dt>
<dd>same as above, but <i>min</i> and <i>max</i> are to be given
relative (in percent) to the data&rsquo;s <i>min</i> and <i>max</i>. This is a <i>position dependent</i>

<p>switch 
<p> </dd>

<dt><b>-N, --no-data, --nda</b>=<i>[val|@percent[,color]]</i> </dt>
<dd>set data points which are
equal to <i>val</i> to the color <i>color</i> (default: black). If <i>val</i> isn&rsquo;t specified,
or if <i>@percent</i> is specified instead of val, the nda value is determined
automatically from the border values: The border value which occurs most
frequently will be the NDA value. The value <i>@percent</i> if given, must be 0
&lt; @percent &lt;= 100. If <i>@percent</i> &gt; 1 it is divided by 100, so @75 is equivalent
to @0.75. The <i>@percent</i> value gives the fraction of nda border values compared
to the number of border pixels which must be reached at least for the automatically
determined nda value to be valid. Example: suppose your image is 100 x 200
pixels large, so the number of border pixels is 600 - 2 = 598. If you specify
--nda=@.75 and the most frequent border value occurs 350 times, the nda feature
won&rsquo;t be applied, since 350 is smaller than 0.75 * 598. 
<p> </dd>

<dt><b>-e, --expr</b>=<i>string</i> </dt>
<dd>filter
data through the c-style string expression <i>string</i>. This feature is compile-time
dependent and only available, if <i>zimg -V</i> shows the string <i>dynaload</i>. The expression
string <i>string</i> will be compiled on the fly by "gcc -c -O3 -shared -o". The expression
is wrapped in a function which will be called for each data value <i>z (double)</i>
with the current <i>x (unsigned int)</i>, <i>width (unsigned int)</i> and <i>y (unsigned
int)</i>, <i>height (unsigned int)</i> values supplied. Example: <br>
<pre>    # zimg -e "cos(z) - (width - x)" ...
</pre>
<p> 
<p> </dd>

<dt><b>-R, --expr-source</b>=<i>file.c</i> </dt>
<dd>Use <i>file.c</i> as input file name for compiling the expression.
If the switch <b>--expr</b> is not given, <b>--expr-source</b> should point to an existing
file which holds the c source for the expression function. If the switch
<b>--expr</b> is given, it will be wrapped in a c function and stored in the <i>file.c</i>
given by <b>--expr-source</b>. If <b>--expr-source</b> is not given, the expression given by
<b>--expr</b> will be stored in a temporary c-file which will be deleted after the
expression evaluation. 
<p> The switch <b>--expr-source</b> can be used for reusing the
expression source: <br>
<pre>    # zimg -e "cos(z) - (width - x)" -R myfunc.c
    # zimg -R myfunc.c ... file.dat
</pre>
<p> </dd>

<dt><b>-O, --expr-object</b>=<i>file.so</i> </dt>
<dd>Use <i>file.so</i> as output file name for compiling the
expression. If none of the switches <b>--expr</b> and <b>--expr-source</b> is given, <i>file.so</i>
should exist and be a valid object file which was probably compiled before
by <b>zimg</b>. Shared objects are searched in the current directory, then in the
directory ~/.zimg/expr, then in /usr/local/lib/zimg/expr and then in the
search path of your dynamic loader (refer to the manual pages of dlopen()
or shl_load(), depending on the implementation). If <b>--expr-object</b> is not given,
the expression given by <b>--expr</b> or <b>--expr-source</b> will be compiled to a temporary
shared object file which will be deleted after the expression evaluation.

<p> If at least one of the switches <b>--expr</b> or <b>--expr-source</b> are given, the expression
will be compiled to <i>file.so</i>. This can be used for compiling a shared object
file for later use: <br>
<pre>    # zimg -e "cos(z) - (width - x)" -O myfunc.so
    # zimg -O myfunc.so ... file.dat
</pre>
<p> For complicated expressions it might be useful to create the c-source for
the expression with an editor and compile it &rsquo;by hand&rsquo;. Please refer to the
manual page of your c-compiler for how to create shared object files (for
gcc it is the switch -shared). The shared object must export a function <i>zimg_expression</i>
with <i>the zimg_expression_t</i> as given in zimg.h. Example: 
<p> <br>
<pre>    #include &lt;zimg.h&gt;
    float
    zimg_expression(unsigned int x, unsigned int y,
        float z, const zimg_expression_info_t* info)
    {
        unsigned int height = info-&gt;height;
        return z - (float)x * (float)(height - y);
    }
</pre>
<p> </dd>

<dt><b>-S, --scale</b>=<i>xy</i> </dt>
<dd></dd>

<dt><b>-S, --scale</b>=<i>x</i>,<i>y</i> </dt>
<dd>Scaling of the image. If only one number is given,
it is used for both directions. Any non-numeric character may be used as
separator.   
<p>        
<p> </dd>

<dt><b>-C, --crop[</b>=<i>left</i>-<i>right</i>x<i>top</i>-<i>bottom</i>] </dt>
<dd>crop the raw data to
the specified size. Note that the numbers given apply to the raw data, not
to the eventually enlarged or binned image. If the optional argument is
omitted, the data is cropped automatically: all data with the same value
as the border is cropped. 
<p> </dd>

<dt><b>-A, --align</b>=<i>horizontal</i>[x<i>vertical</i>][,<i>bordercolor</i>]
</dt>
<dd>align to an integer multiple of the specified pixels. If <i>vertical</i> is omitted,
it it set to <i>horizontal</i>. Example: -A16 will pad the resulting image so that
its (both) dimensions are multiples of 16. This is useful, if the images
are used to create an mpeg sequence for example (otherwise mpeg_encode
will cut the images down so that the dimensions are multiples of 16). The
data is centered within the resulting image. The optional argument <i>bordercolor</i>
must be given as 6-digit hexadecimal number, where the first digits are
the red value, the second two digits the green value and the last two digits
the blue value (so the color values for each color are between 0 and ff).
Note that zimg will try to choose a color out of the existing color map
which comes close to what you&rsquo;ve specified, but depending on the color map
you might not get exactly what you&rsquo;ve requested. See also the <i>--textcolor</i> switch.
If the <i>bordercolor</i> is not given, the image border color is chosen to be
the most frequent color of the original data&rsquo;s border. 
<p> </dd>

<dt><b>--contours</b>=<i>levels</i>[,<i>log</i>][,<i>bg=color</i>|<i>fg=color</i>]
</dt>
<dd>draw contour lines. This option is still experimental. Optional arguments
are probably subject to future changes. The optional argument &lsquo;log&rsquo; distributes
the contour levels logarithmically over the image. The optional argument
<i>bg=color</i> forces contour-only drawing i.e. colors the background with the specified
color. This color must be given as 3 or 6 digit hex value or by the special
keyword &rsquo;black&rsquo;. <i>fg=color</i> uses the specified color as contour line color. bg
and fg and should not be used together. The contour algorithm is pretty
fast and does not spline when enlarging the image. 
<p> </dd>

<dt><b>--interlace</b> </dt>
<dd>write an interlaced
image. <b>--interlace</b> is off by default. If you write a jpeg image using the <i>--jpeg</i>
switch, the <b>--interlace</b> switch will be interpreted to write a progressive
JPEG. 
<p> </dd>

<dt><b>-g, --gif</b> </dt>
<dd>write a gif instead of a png image. This switch is only available
if libgd supports both png and gif. 
<p> </dd>

<dt><b>-j, --jpeg[=quality]</b> </dt>
<dd>write a jpeg instead
of a png image. <i>quality</i> must be an integer number between (inclusive) 0
and 100. If <i>quality</i> is omitted, an appropriate default quality is used. Jpeg
is only available, if <b>zimg</b> was compiled with libgd &gt;= 1.8. If you have set
image interlacing using the <i>--interlace</i> switch, this switch is interpreted
to write a progressive JPEG. Some programs (e.g., Web browsers) can display
progressive JPEGs incrementally; this can be useful when browsing over
a relatively slow communications link, for example.  Progressive JPEGs can
also be slightly smaller than sequential (non-progressive) JPEGs. 
<p> </dd>

<dt><b>-P, --ppmorpgm</b>
</dt>
<dd>write a portable pixmap (ppm) or portable graymap (pgm) instead of a png
image according to <i>--gray</i> palette. These image formats are useful when piping
<b>zimg</b>&rsquo;s output directly to other programs (filters). Further, as there can
be just a single png or jpeg image in one png or jpeg file, but several
ppm or pgm images in one ppm or pgm file, it makes ppm and pgm output very
useful for producing image movies from a series of input data files, see
examples below. 
<p> </dd>

<dt><b>--ppm</b> </dt>
<dd>write a portable pixmap (ppm) instead of a png image.

<p> </dd>

<dt><b>-P, --pgm</b> </dt>
<dd>write a portable graymap (pgm) instead of a png image; this should
be used only together with <i>--gray</i> option, otherwise a function of r,g,b values
of a pixel is calculated as its gray value. 
<p> </dd>

<dt><b>-t, --label</b>=<i>[+-][+-]y</i>,<i>string</i> </dt>
<dd>print
<i>string</i> at the specified position of the FINAL image. &rsquo;Final&rsquo; means the image
size with all padding and scaling applied.  The string can be a multiline
string separated by &rsquo;\n&rsquo;, e.g. "this\nis\nmultiline\ntext". <i>x</i> and <i>y</i> can be negative
coordinates, in which case they&rsquo;re interpreted as offsets of the right and
bottom text bounding box from the right and bottom border of the image
respectively. If you specify for example <b>--label</b>=<i>-1-1</i>,<i>string</i>, the <i>string</i> is
entirely visible, having the lower right border of its bounding box in
the bottom right corner on the image. Long multiline strings should preferably
be passed by specifying this option several times (e.g. for each line separately)
because of limitations of the option parser. See also STRING ESCAPES. 
<p> </dd>

<dt><b>--vlabel</b>=<i>[+-][+-]y</i>,<i>string</i>
</dt>
<dd>same as the <b>--label</b> option, but prints the string vertically. See also STRING
ESCAPES. 
<p>     
<p> </dd>

<dt><b>--legend</b>=<i>string</i> </dt>
<dd>print <i>string</i> <b>outside</b> the image region black
on white. The legend is either placed right or botto. of the image depending
on the ratio of the resulting total image (smaller ratio wins).  The string
can be a multiline string separated by &rsquo;\n&rsquo;, e.g. "this\nis\nmultiline\ntext". The
extra space needed for the legend is reserved automatically. Long multiline
strings should preferably be passed by specifying this option several times
(e.g. for each line separately) because of limitations of the option parser.
The <i>string</i> can be reset to zero length (e.g. for multifile input together
with modelines) by using <b>--legend</b> w/o string argument. See also STRING ESCAPES.

<p> </dd>

<dt><b>-F, --font</b>=<i>integer</i> </dt>
<dd>font size. Must be between (inclusive) 1 and 4. If the font
size is not specified, it is chosen according to the image dimensions:
a larger image gets a larger font size. 
<p> </dd>

<dt><b>-T, --textcolor</b>=<i>xxxxxx</i> </dt>
<dd>The <i>xxxxxx</i>
must be given as 6-digit or 3-digit hexadecimal number, where the first digit(s)
are the red value, the second two digit(s) the green value and the last
two digit(s) the blue value (so the color values for each color are between
0 and ff). Note that zimg will try to choose a color out of the existing
color map which comes close to what you&rsquo;ve specified, but depending on the
color map you might not get exactly what you&rsquo;ve requested. Alternatively
the color can be also specified by one of the predefined color names, see
the section "LINE COLORS". If the text color is not given, it will be chosen
automatically and should give normally a high contrast. 
<p> </dd>

<dt><b>--line</b>=<i>[+-]x1[+-]y1[+-]x2[+-]y2</i>[...]
</dt>
<dd>draw a line or polyline from x1, y1 to x2, y2 (and more vertices) on the
FINAL image.  Example --line=+10+10+10+20 draws a horizontal line. All coordinates
are absolute. Negative coordinates are interpreted from the right and bottom
border respectively. 
<p> </dd>

<dt><b>--rline</b>=<i>[+-]x1[+-]y1[+-]x2[+-]y2</i>[...] </dt>
<dd>same as <b>--line</b>, but all
coordinates except <i>x1</i> and <i>x2</i> are interpreted relatively to <i>x1</i> and <i>x2</i>. 
<p> </dd>

<dt><b>-L,
--license</b> </dt>
<dd>Display some license information. <b>zimg</b> is published under the  terms
of a BSD type License. 
<p> </dd>

<dt><b>-V, --version</b> </dt>
<dd>Prints a version identifier for <b>zimg</b>
to standard error. This is guaranteed to always contain the string "zimg"
and the version number. Additionally the string "png" or "gif" indicates
the output format which depends on the gd driver which was compiled in.
Compile time options as edf support are appended in brackets. 
<p> </dd>

<dt><b>-v, --verbose</b>
</dt>
<dd>switch on some informational output. Might not be too useful. 
<p> </dd>

<dt><b>--statistics
</b></dt>
<dd>print histogram like statistics of the <b>processed</b> data to stderr. 
<p> </dd>

<dt><b>--help</b> </dt>
<dd>Prints
a help message to stderr and dies. 
<p> </dd>
</dl>

<h2><a name='sect5' href='#toc5'>String Escapes</a></h2>
The switches <b>--label</b>, <b>--vlabel</b>
and <b>--legend</b> accept some string escapes. The replacement of these string escape
takes place <b>after</b> the data has been read and processed. String escape start
with a percent sign &rsquo;%&rsquo; followed by a single character which indicates the
type of the substitution. The following string escapes are supported: 
<p> 
<dl>

<dt><b>%c</b>
</dt>
<dd>Current time in RFC822-conformant format. 
<p> </dd>

<dt><b>%f</b> </dt>
<dd>The filename of the input file

<p> </dd>

<dt><b>%m</b> </dt>
<dd>The minimum of the <b>processed</b> data. 
<p> </dd>

<dt><b>%M</b> </dt>
<dd>The maximum of the <b>processed</b>
data. 
<p> </dd>

<dt><b>%i</b> </dt>
<dd>The integral of the <b>processed</b> data (valid data points only, see
also the --no-data switch). 
<p> </dd>

<dt><b>%{</b>...<b>}</b> </dt>
<dd>Will be substituted with the standard output
of the shell command  which is given between the opening <b>{</b> and the closing
<b>}</b>. 
<p> 
<p> </dd>
</dl>

<h2><a name='sect6' href='#toc6'>Line Colors</a></h2>
Some of the switches accept a color specification, e.g. <b>--no-data</b>,
<b>--align</b>, <b>--contours</b>, <b>--textcolor</b> and <b>--xor</b>. These "line colors" are not chosen from
the colormap which is used for rendering the data. Line colors can be specified
either as 6-digit or 3-digit hex value or as one of the predefined strings
"black", "white", "red", "green", "blue", "magenta", "cyan", "yellow". In
the case of a 6-digit hex value, the first two digits represent the red
value, the second two digits the green value and the last two digits the
blue value. In the case of a 3-digit hex value, the first digit represent
the red value, the second digit the green value and the last digit the
blue value. 
<p> 
<h2><a name='sect7' href='#toc7'>Modelines</a></h2>

<p> If the input data is ascii (or at least the header
is ascii), <b>zimg</b> looks for <b>modelines</b> like some versions of vi or vim do.
This is done only until the first data point is read. The format for modelines
is as follows: <blockquote><br>
<pre>    &lt;space&gt;zimg:&lt;zimg options&gt;:
</pre></blockquote>
 You can have multiple modelines and even use a modeline to switch to binary
input. Example: 
<p> <blockquote><br>
<pre>    #!/usr/local/bin/zimg
    # zimg: -l10 -C50-550x200-450:
    # zimg: -m7,5,15 -t -r547x633 -s --swap:
    ...
</pre></blockquote>
 Note that in this case the order is important. Everything after the line
containing the -s (unsigned short binary) is considered as binary data. So
exchanging the two modelines like in the next example would interpret the
second modeline as binary data (which is probably not what you want): <blockquote><br>
<pre>    #!/usr/local/bin/zimg
    # zimg: -m7,5,15 -t -r547x633 -s --swap:
    # zimg: -l10 -C50-550x200-450:
    ...
</pre></blockquote>
 
<p> 
<h2><a name='sect8' href='#toc8'>Examples</a></h2>

<p> 
<dl>

<dt><b>zimg my.dat &gt; my.png</b> </dt>
<dd>This one of the most simple examples.  The
file my.dat is assumed to hold the dimensions of your 2-D data as the first
two convertable integers. Everything before the first convertable integer
is silently skipped, so it is also valid to have the dimension specifiers
after a comment  (hash) mark like this: <blockquote><br>
<pre>    # 128 128
    45.12
    76.70
    ...
</pre></dd>
</dl>
</blockquote>
 
<p> 
<dl>

<dt><b>my.dat &gt; my.png</b> </dt>
<dd>If your operating system supports the specification of an
interpreter by preceding it with #! you can make your data file an executable
like this (you probably have also to change the permissions of my.dat e.g.
&lsquo;chmod +x my.dat&rsquo; on UNIX): 
<p> <blockquote><br>
<pre>    #!/usr/local/bin/zimg
    # 128 128
    # zimg:--red:
    45.12
    76.70
    ...
</pre></dd>
</dl>
</blockquote>
 
<p> 
<dl>

<dt><b>zimg my.dat.gz | xv -</b> </dt>
<dd>pipe the output of <b>zimg</b> directly to your favorite image
viewer (here: <b>xv</b>). The file will be filtered by gunzip. 
<p> </dd>

<dt><b>zimg --red -r1200x1200
--skip=2400 -S0.5 -s l408_01.image | xv -</b> </dt>
<dd>read binary data which hold 1200 x 1200
unsigned short data values. Skip the first 2400 bytes.  Use the red scale
color map. Scale the image down to 600 x 600 pixels and pipe it to xv. 
<p> Note
that the skip option is not really necessary as long as the data is located
at the very end of the input file.  In this case the header size would be
calculated by <b>zimg</b>. 
<p> </dd>

<dt><b>zimg my.png --xlabel=10,10,&rsquo;love is like oxygen&rsquo; --jpeg &gt; my.jpg</b>
</dt>
<dd>read the png as source image, apply a label and write it as jpeg. 
<p> </dd>

<dt><b>zimg
-P -o- --crange=0,100 *.edf | animate -delay 50</b> </dt>
<dd>read all edf files, and animate
them with delay of 50 ms. 
<p> </dd>

<dt><b>zimg -P -o- --scale=0.25 --gray *.edf | convert -delay 100
- movie.mng</b> </dt>
<dd>read all edf files, scale them down and convert them into a gray
scale movie (mng is an animated png). Note that not using <i>--crange</i> makes color
scaling (z-range) individually autoscaled in each image instead of using
the same z-range for all images as in the previous example. 
<p> </dd>

<dt><b>zimg for displaying
function expressions w/o input data</b> </dt>
<dd>
<p> First you&rsquo;ve to create the c source
which holds the function expression, for example sinc.c: 
<p> <br>
<pre>    #include &lt;zimg.h&gt;
    #include &lt;math.h&gt;
    float
    zimg_expression(unsigned int x, unsigned int y,
        float z, const zimg_expression_info_t* info)
    {
       double width = (double)info-&gt;width;
       double height = (double)info-&gt;height;
       double xd = (double)x - width * 0.5;
       double yd = (double)y - height * 0.5;
       double value;
       xd *= 10 / width;
       yd *= 10 / height;
       value = sqrt(xd*xd+yd*yd);
       return value ? sin(value) / value : 1
    }
</pre>This expression can be displayed w/o any data file by using /dev/zero as
input source. As the input data is not used at all, you can use the <b>-c</b> switch
-- tell <b>zimg</b> to treat the input as bytes. Furthermore you&rsquo;ve to specify the
dimension of the image with the <b>-r</b> switch: <br>
<pre># zimg -c -r300 --skip=0 -Rsinc.c -Osinc.so &lt; /dev/zero | xv -
</pre>The object file sinc.so can now be reused in subsequent <b>zimg</b> runs, e.g. <br>
<pre># zimg -c -r500 --skip=0 -Osinc.so &lt; /dev/zero | xv -
</pre>Note, that you have to tell <b>zimg</b> explicitly not to skip the file header,
otherwise it will read from /dev/zero infinitely as it thinks it is the
data header. 
<p> </dd>
</dl>

<h2><a name='sect9' href='#toc9'>Environment Variables</a></h2>

<p>          
<p> 
<dl>

<dt><b>HOME</b> </dt>
<dd>When this variable is
found, <b>zimg</b> looks there for a file with the name <b>.zimgrc</b> which may contain
command line options. If expression evaluation support is compiled in, object
files are searched in the directory $HOME/.zimg/expr/. 
<p> </dd>

<dt><b>ZIMG_VIEWER</b> </dt>
<dd>used
to view stdout, if zimg detects that stdout goes to a terminal (which is
probably not what you want). Defaults to "xv -". 
<p> 
<p> </dd>
</dl>

<h2><a name='sect10' href='#toc10'>Files</a></h2>

<p> The following <b>zimgrc</b>
resource files are read in this order: 
<p> </pre>    /usr/local/etc/zimgrc<br>
     $HOME/.zimgrc<br>
     .zimgrc<br>
     zimgrc<br>
 <br>
<pre>These files are read before command line parsing is done, so command line
options given on the command line will eventually overwrite previously
defined
settings of the resource files.
The zimgrc recource files might contain command line options separated
by
any white spaces including newlines. Blank lines and everything behind a
hash
&lsquo;#&rsquo; mark is considered to be a comment.
Bugsprobably.   See AlsoThe official zimg web site at:  http://zimg.sourceforge.net/
  
AuthorJohannes Zellner &lt;johannes@zellner.org&gt;   HistoryThis version of zimg
was originally derived from the program z2ppm which was able to write portable
pixmap (ppm) files.  CreditsThomas Boutell &lt;boutell@boutell.com&gt;, the author
of the gd driver. Petr Mikulik &lt;mikulik@physics.muni.cz&gt; for the color code
in getcolor.c, see also http://www.sci.muni.cz/~mikulik/gnuplot.html, the OS/2
port, and options --crange, -P, --ppm, --pgm, -o-. Levente Novak &lt;novak@jaguar.dote.hu&gt;
for the DOS/DJGPP port. 