 <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>RPCGEN(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
rpcgen - an RPC protocol compiler 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>rpcgen</b><i> infile</i> <br>
<b>rpcgen</b> <b>-c</b>|<b>-h</b>|<b>-l</b>|<b>-m [ <b>-o</b><i> outfile</i> ] [ <i>infile</i> ] <br>
</b><b>rpcgen -s</b> <i>transport</i> [ <b>-o</b><i> outfile</i> ] [ <i>infile</i> ] <br>

<h2><a name='sect2' href='#toc2'>Description</a></h2>
   <b>rpcgen</b> is a tool that generates C code to implement an <font size='-1'>RPC</font>

protocol.  The input to <b>rpcgen</b> is a language similar to C known as <font size='-1'>RPC</font>
 Language
(Remote Procedure Call Language).  Information about the syntax of <font size='-1'>RPC</font>
 Language
is available in the &lsquo;<i>rpcgen</i>&rsquo;<i> Programming Guide.</i> <p>
<b>rpcgen</b> is normally used as
in the first synopsis where it takes an input file and generates four output
files. If the <i>infile</i> is named <b>proto.x</b>, then <b>rpcgen</b> will generate a header
file in <b>proto.h</b>, <font size='-1'>XDR</font>
 routines in <b>proto_xdr.c</b>, server-side stubs in <b>proto_svc.c</b>,
and client-side stubs in <b>proto_clnt.c</b>. <p>
The other synopses shown above are
used when one does not want to generate all the output files, but only
a particular one.  Their usage is described in the <font size='-1'>USAGE</font>
 section below. <p>
The
C-preprocessor, <a href='cpp.1.html'><b>cpp</b>(1)</a>
, is run on all input files before they are actually
interpreted by <b>rpcgen</b>, so all the <b>cpp</b> directives are legal within an <b>rpcgen</b>
input file.  For each type of output file, <b>rpcgen</b> defines a special <b>cpp</b>
symbol for use by the <b>rpcgen</b> programmer: <p>
 <font size='-1'></font>

<dl>

<dt>RPC_HDR </dt>
<dd>defined when compiling
into header files <font size='-1'></font>
</dd>

<dt>RPC_XDR </dt>
<dd>defined when compiling into <font size='-1'>XDR</font>
 routines <font size='-1'></font>
</dd>

<dt>RPC_SVC
</dt>
<dd>defined when compiling into server-side stubs <font size='-1'></font>
</dd>

<dt>RPC_CLNT </dt>
<dd>defined when compiling
into client-side stubs  </dd>
</dl>
<p>
In addition, <b>rpcgen</b> does a little preprocessing
of its own. Any line beginning with &lsquo;<b>%</b>&rsquo; is passed directly into the output
file, uninterpreted by <b>rpcgen</b>. <p>
You can customize some of your <font size='-1'>XDR</font>
 routines
by leaving those data types undefined.  For every data type that is undefined,
<b>rpcgen</b> will assume that there exists a routine with the name <b>xdr_</b> prepended
to the name of the undefined type. 
<h2><a name='sect3' href='#toc3'>Options</a></h2>

<dl>

<dt><b>-c</b> </dt>
<dd>Compile into <font size='-1'>XDR</font>
 routines. </dd>

<dt><b>-h</b>
</dt>
<dd>Compile into <b>C</b> data-definitions (a header file) </dd>

<dt><b>-l</b> </dt>
<dd>Compile into client-side
stubs. </dd>

<dt><b>-m</b> </dt>
<dd>Compile into server-side stubs, but do not generate a lqmainrq routine.
This option is useful for doing callback-routines and for people who need
to write their own lqmainrq routine to do initialization. </dd>

<dt><b>-o</b><i> outfile</i> </dt>
<dd>Specify
the name of the output file. If none is specified, standard output is used
(<b>-c</b>, <b>-h</b>, <b>-l</b> and <b>-s</b> modes only). </dd>

<dt><b>-s</b><i> transport</i> </dt>
<dd>Compile into server-side stubs, using
the the given transport.  The supported transports are <b>udp</b> and <b>tcp</b>. This
option may be invoked more than once so as to compile a server that serves
multiple transports. <br>
 </dd>
</dl>

<h2><a name='sect4' href='#toc4'>See Also</a></h2>
<a href='cpp.1.html'><b>cpp</b>(1)</a>
 <p>
&lsquo;<i>rpcgen</i>&rsquo;<i> Programming Guide.</i> <br>
 
<h2><a name='sect5' href='#toc5'>Bugs</a></h2>
<p>
Nesting is not supported. As a work-around, structures can be declared
at top-level, and their name used inside other structures in order to achieve
the same effect. <p>
Name clashes can occur when using program definitions,
since the apparent scoping does not really apply. Most of these can be avoided
by giving unique names for programs, versions, procedures and types. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
<li><a name='toc5' href='#sect5'>Bugs</a></li>
</ul>
</body>
</html>
