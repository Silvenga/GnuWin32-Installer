                             <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>archive_entry(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>NAME</a></h2>
                                     
                                
<h2><a name='sect1' href='#toc1'>SYNOPSIS</a></h2>
                              
                                                                      
                                   
<h2><a name='sect2' href='#toc2'>DESCRIPTION</a></h2>
These functions create and
manipulate data objects that represent entries within an archive. You can
think of a  as a heavy-duty version of  it includes everything from  plus
associated pathname, textual group and user names, etc. These objects are
used by  to represent the metadata associated with a particular entry in
an archive.  There are functions to allocate, destroy, clear, and copy 
objects:   Erases the object, resetting all internal fields to the same
state as a newly-created object. This is provided to allow you to quickly
recycle objects without thrashing the heap.  A deep copy operation; all
text fields are duplicated.  Releases the  object.  Allocate and return a
blank  object.   Most of the functions here set or read entries in an object.
Such functions have one of the following forms:   Stores the provided data
in the object. In particular, for strings, the pointer is stored, not the
referenced string.  As above, except that the referenced data is copied
into the object.  Returns the specified data. In the case of strings, a const-qualified
pointer to the string is returned.  String data can be set or accessed as
wide character strings or normal  strings. The functions that use wide character
strings are suffixed with  Note that these are different representations
of the same data: For example, if you store a narrow string and read the
corresponding wide string, the object will transparently convert formats
using the current locale. Similarly, if you store a wide string and then
store a narrow string for the same data, the previously-set wide string
will be discarded in favor of the new data.  There are a few set/get functions
that merit additional description:   This function sets the symlink field
if it is already set. Otherwise, it sets the hardlink field.   File flags
are transparently converted between a bitmap representation and a textual
format. For example, if you set the bitmap and ask for text, the library
will build a canonical text format. However, if you set a text format and
request a text format, you will get back the same text, even if it is ill-formed.
If you need to canonicalize a textual flags string, you should first set
the text form, then request the bitmap form, then use that to set the bitmap
form. Setting the bitmap format will clear the internal text representation
and force it to be reconstructed when you next request the text form.  The
bitmap format consists of two integers, one containing bits that should
be set, the other specifying bits that should be cleared. Bits not mentioned
in either bitmap will be ignored. Usually, the bitmap of bits to be cleared
will be set to zero. In unusual circumstances, you can force a fully-specified
set of file flags by setting the bitmap of flags to clear to the complement
of the bitmap of flags to set. (This differs from  which only includes names
for set bits.) Converting a bitmap to a textual string is a platform-specific
operation; bits that are not meaningful on the current platform will be
ignored.  The canonical text format is a comma-separated list of flag names.
The  function parses the provided text and sets the internal bitmap values.
This is a platform-specific operation; names that are not meaningful on
the current platform will be ignored. The function returns a pointer to
the start of the first name that was not recognized, or NULL if every name
was recognized. Note that every name--including names that follow an unrecognized
name--will be evaluated, and the bitmaps will be set to reflect every name
that is recognized. (In particular, this differs from  which stops parsing
at the first unrecognized name.)  XXX This needs serious help. XXX  An  (ACL)
is a list of permissions that grant access to particular users or groups
beyond what would normally be provided by standard POSIX mode bits. The
ACL handling here addresses some deficiencies in the POSIX.1e draft 17 ACL
specification. In particular, POSIX.1e draft 17 specifies several different
formats, but none of those formats include both textual user/group names
and numeric UIDs/GIDs.  XXX explain ACL stuff XXX    
<h2><a name='sect3' href='#toc3'>SEE ALSO</a></h2>
 
<h2><a name='sect4' href='#toc4'>HISTORY</a></h2>
The
 library first appeared in  
<h2><a name='sect5' href='#toc5'>AUTHORS</a></h2>
 The  library was written by   <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>NAME</a></li>
<li><a name='toc1' href='#sect1'>SYNOPSIS</a></li>
<li><a name='toc2' href='#sect2'>DESCRIPTION</a></li>
<li><a name='toc3' href='#sect3'>SEE ALSO</a></li>
<li><a name='toc4' href='#sect4'>HISTORY</a></li>
<li><a name='toc5' href='#sect5'>AUTHORS</a></li>
</ul>
</body>
</html>
