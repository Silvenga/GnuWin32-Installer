                     <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>mktemp(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>NAME</a></h2>
  
<h2><a name='sect1' href='#toc1'>SYNOPSIS</a></h2>
  |    
<h2><a name='sect2' href='#toc2'>DESCRIPTION</a></h2>
The  utility takes
the given filename  and overwrites a portion of it to create a unique filename.
The  may be any filename with some number of  appended to it, for example
 If no  is specified a default of  is used and the  flag is implied (see
below).  The trailing  are replaced with a combination of the current process
number and random letters. The name chosen depends both on the number of
 in the  and the number of collisions with pre-existing files. The number
of unique filenames  can return depends on the number of  provided; ten
 will result in  testing roughly 26 ** 10 combinations.  If  can successfully
generate a unique filename, the file (or directory) is created with file
permissions such that it is only readable and writable by its owner (unless
the  flag is given) and the filename is printed to standard output.   is
provided to allow shell scripts to safely use temporary files. Traditionally,
many shell scripts take the name of the program with the PID as a suffix
and use that as a temporary filename. This kind of naming scheme is predictable
and the race condition it creates is easy for an attacker to win. A safer,
though still inferior approach is to make a temporary directory using the
same naming scheme. While this does allow one to guarantee that a temporary
file will not be subverted, it still allows a simple denial of service
attack. For these reasons it is suggested that  be used instead.  The options
are as follows:   Print the version and exit.  Make a directory instead
of a file.  Use the specified  as a prefix when generating the temporary
filename. The  will be overridden by the user&rsquo;s  environment variable if
it is set. This option implies the  flag (see below).  Fail silently if an
error occurs. This is useful if a script does not want error output to go
to standard error.  Generate a path rooted in a temporary directory. This
directory is chosen as follows:   If the user&rsquo;s  environment variable is
set, the directory contained therein is used.  Otherwise, if the  flag was
given the specified directory is used.  If none of the above apply,  is
used.   In this mode, the  (if specified) should be a directory component
(as opposed to a full path) and thus should not contain any forward slashes.
 Operate in  mode. The temp file will be unlinked before  exits. This is
slightly better than  but still introduces a race condition. Use of this
option is not encouraged.   The  utility exits with a value of 0 on success
or 1 on failure. 
<h2><a name='sect3' href='#toc3'>ENVIRONMENT</a></h2>
  directory in which to place the temporary
file when in  mode  
<h2><a name='sect4' href='#toc4'>EXAMPLES</a></h2>
The following  fragment illustrates a simple
use of  where the script should quit if it cannot get a safe temporary
file.  TMPFILE=&lsquo;mktemp /tmp/example.XXXXXXXXXX&lsquo; || exit 1 echo "program output"
&gt;&gt; $TMPFILE   The same fragment with support for a user&rsquo;s  environment variable
can be written as follows.  TMPFILE=&lsquo;mktemp -t example.XXXXXXXXXX&lsquo; || exit 1 echo
"program output" &gt;&gt; $TMPFILE   This can be further simplified if we don&rsquo;t
care about the actual name of the temporary file. In this case the  flag
is implied.  TMPFILE=&lsquo;mktemp&lsquo; || exit 1 echo "program output" &gt;&gt; $TMPFILE   In
some cases, it may be desirable to use a default temporary directory other
than  In this example the temporary file will be created in  unless the
user&rsquo;s  environment variable specifies otherwise.  TMPFILE=&lsquo;mktemp -p /extra/tmp
example.XXXXXXXXXX&lsquo; || exit 1 echo "program output" &gt;&gt; $TMPFILE   In some cases,
we want the script to catch the error. For instance, if we attempt to create
two temporary files and the second one fails we need to remove the first
before exiting.  TMP1=&lsquo;mktemp -t example.1.XXXXXXXXXX&lsquo; || exit 1 TMP2=&lsquo;mktemp -t
example.2.XXXXXXXXXX&lsquo; if [ $? -ne 0 ]; then <tt> </tt>&nbsp;<tt> </tt>&nbsp;rm -f $TMP1<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;exit 1<br>
 fi   Or perhaps you don&rsquo;t want to exit if  is unable to create the file.
In this case you can protect that part of the script thusly.  TMPFILE=&lsquo;mktemp
-q -t example.XXXXXXXXXX&lsquo; &amp;&amp; { <tt> </tt>&nbsp;<tt> </tt>&nbsp;# Safe to use $TMPFILE in this block<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;echo data &gt; $TMPFILE<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;...<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;rm -f $TMPFILE<br>
 }  
<h2><a name='sect5' href='#toc5'>SEE ALSO</a></h2>
   
<h2><a name='sect6' href='#toc6'>HISTORY</a></h2>
The  utility appeared in OpenBSD 2.1. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>NAME</a></li>
<li><a name='toc1' href='#sect1'>SYNOPSIS</a></li>
<li><a name='toc2' href='#sect2'>DESCRIPTION</a></li>
<li><a name='toc3' href='#sect3'>ENVIRONMENT</a></li>
<li><a name='toc4' href='#sect4'>EXAMPLES</a></li>
<li><a name='toc5' href='#sect5'>SEE ALSO</a></li>
<li><a name='toc6' href='#sect6'>HISTORY</a></li>
</ul>
</body>
</html>
