                             <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>archive_write(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>NAME</a></h2>
                         
<h2><a name='sect1' href='#toc1'>SYNOPSIS</a></h2>
    
                                            
<h2><a name='sect2' href='#toc2'>DESCRIPTION</a></h2>
These functions
provide a complete API for creating streaming archive files. The general
process is to first create the  object, set any desired options, initialize
the archive, append entries, then close the archive and release all resources.
The following summary describes the functions in approximately the order
they are ordinarily used:   Allocates and initializes a  object suitable
for writing a tar archive.  Sets the block size used for writing the archive
data. Every call to the write callback function, except possibly the last
one, will use this value for the length. The third parameter is a boolean
that specifies whether or not the final block written will be padded to
the full block size. If it is zero, the last block will not be padded. If
it is non-zero, padding will be added both before and after compression.
The default is to use a block size of 10240 bytes and to pad the last block.
Note that a block size of zero will suppress internal blocking and cause
writes to be sent directly to the write callback as they occur.  Retrieve
the block size to be used for writing. A value of -1 here indicates that
the library should use default values. A value of zero indicates that internal
blocking is suppressed.  Sets the block size used for writing the last block.
If this value is zero, the last block will be padded to the same size as
the other blocks. Otherwise, the final block will be padded to a multiple
of this size. In particular, setting it to 1 will cause the final block
to not be padded. For compressed output, any padding generated by this option
is applied only after the compression. The uncompressed data is always unpadded.
The default is to pad the last block to the full block size (note that
 will set this based on the file type). Unlike the other  functions, this
function can be called after the archive is opened.  Retrieve the currently-set
value for last block size. A value of -1 here indicates that the library
should use default values.  Sets the format that will be used for the archive.
The library can write POSIX octet-oriented cpio format archives, POSIX-standard
 format archives, traditional  archives, enhanced  shar archives that store
a variety of file attributes and handle binary files, and POSIX-standard
 archives. The pax interchange format is a backwards-compatible tar format
that adds key/value attributes to each entry and supports arbitrary filenames,
linknames, uids, sizes, etc.  is the library default; this is the same as
pax format, but suppresses the pax extended header for most normal files.
In most cases, this will result in ordinary ustar archives.  The resulting
archive will be compressed as specified. Note that the compressed output
is always properly blocked.  The archive will be fed into the specified
compression program. The output of that program is blocked and written to
the client write callbacks.  Freeze the settings, open the archive, and
prepare for writing entries. This is the most generic form of this function,
which accepts pointers to three callback functions which will be invoked
by the compression layer to write the constructed archive.  A convenience
form of  that accepts a file descriptor. The  function is safe for use with
tape drives or other block-oriented devices.  A convenience form of  that
accepts a  pointer. Note that  is not safe for writing to tape drives or
other devices that require correct blocking.  A deprecated synonym for 
 A convenience form of  that accepts a filename. A NULL argument indicates
that the output should be written to standard output; an argument of  will
open a file with that name. If you have not invoked  then  will adjust the
last-block padding depending on the file: it will enable padding when writing
to standard output or to a character or block device node, it will disable
padding otherwise. You can override this by manually invoking  before calling
 The  function is safe for use with tape drives or other block-oriented
devices.  A convenience form of  that accepts a pointer to a block of memory
that will receive the archive. The final  argument points to a variable
that will be updated after each write to reflect how much of the buffer
is currently in use. You should be careful to ensure that this variable
remains allocated until after the archive is closed.  Build and write a
header using the data in the provided  structure. See  for information on
creating and populating  objects.  Write data corresponding to the header
just written. Returns number of bytes written or -1 on error.  Close out the
entry just written. In particular, this writes out the final padding required
by some formats. Ordinarily, clients never need to call this, as it is called
automatically by  and  as needed.  Complete the archive and invoke the close
callback.  Invokes  if it was not invoked manually, then releases all resources.
Note that this function was declared to return  in libarchive 1.x, which
made it impossible to detect errors when  was invoked implicitly from this
function. This is corrected beginning with libarchive 2.0.  More information
about the  object and the overall design of the library can be found in
the  overview. 
<h2><a name='sect3' href='#toc3'>IMPLEMENTATION</a></h2>
Compression support is built-in to libarchive,
which uses zlib and bzlib to handle gzip and bzip2 compression, respectively.

<h2><a name='sect4' href='#toc4'>CLIENT CALLBACKS</a></h2>
To use this library, you will need to define and register
callback functions that will be invoked to write data to the resulting
archive. These functions are registered by calling        The open callback
is invoked by  It should return  if the underlying file or data source
is successfully opened. If the open fails, it should call  to register an
error code and message and return        The write callback is invoked
whenever the library needs to write raw bytes to the archive. For correct
blocking, each call to the write callback function should translate into
a single  system call. This is especially critical when writing archives
to tape drives. On success, the write callback should return the number
of bytes actually written. On error, the callback should invoke  to register
an error code and message and return -1.       The close callback is invoked
by archive_close when the archive processing is complete. The callback should
return  on success. On failure, the callback should invoke  to register
an error code and message and return  
<h2><a name='sect5' href='#toc5'>EXAMPLE</a></h2>
The following sketch illustrates
basic usage of the library. In this example, the callback functions are
simply wrappers around the standard   and  system calls.  #include &lt;sys/stat.h&gt;
#include &lt;archive.h&gt; #include &lt;archive_entry.h&gt; #include &lt;fcntl.h&gt; #include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; 
<p> struct mydata { <tt> </tt>&nbsp;<tt> </tt>&nbsp;const char *name;<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;int fd;<br>
 }; 
<p> int myopen(struct archive *a, void *client_data) {   struct mydata
*mydata = client_data;<br>
 
<p>   mydata-&gt;fd = open(mydata-&gt;name, O_WRONLY | O_CREAT, 0644);<br>
   if (mydata-&gt;fd &gt;= 0)<br>
     return (ARCHIVE_OK);<br>
   else<br>
     return (ARCHIVE_FATAL);<br>
 } 
<p> ssize_t mywrite(struct archive *a, void *client_data, void *buff, size_t
n) {   struct mydata *mydata = client_data;<br>
 
<p>   return (write(mydata-&gt;fd, buff, n));<br>
 } 
<p> int myclose(struct archive *a, void *client_data) {   struct mydata
*mydata = client_data;<br>
 
<p>   if (mydata-&gt;fd &gt; 0)<br>
     close(mydata-&gt;fd);<br>
   return (0);<br>
 } 
<p> void write_archive(const char *outname, const char **filename) {  
struct mydata *mydata = malloc(sizeof(struct mydata));<br>
   struct archive *a;<br>
   struct archive_entry *entry;<br>
   struct stat st;<br>
   char buff[8192];<br>
   int len;<br>
   int fd;<br>
 
<p>   a = archive_write_new();<br>
   mydata-&gt;name = outname;<br>
   archive_write_set_compression_gzip(a);<br>
   archive_write_set_format_ustar(a);<br>
   archive_write_open(a, mydata, myopen, mywrite, myclose);<br>
   while (*filename) {<br>
     stat(*filename, &amp;st);<br>
     entry = archive_entry_new();<br>
     archive_entry_copy_stat(entry, &amp;st);<br>
     archive_entry_set_pathname(entry, *filename);<br>
     archive_write_header(a, entry);<br>
     fd = open(*filename, O_RDONLY);<br>
     len = read(fd, buff, sizeof(buff));<br>
     while ( len &gt; 0 ) {<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;archive_write_data(a, buff, len);<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;len = read(fd, buff, sizeof(buff));<br>
     }<br>
     archive_entry_free(entry);<br>
     filename++;<br>
   }<br>
   archive_write_finish(a);<br>
 } 
<p> int main(int argc, const char **argv) { <tt> </tt>&nbsp;<tt> </tt>&nbsp;const char *outname;<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;argv++;<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;outname = argv++;<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;write_archive(outname, argv);<br>
 <tt> </tt>&nbsp;<tt> </tt>&nbsp;return 0;<br>
 }  
<h2><a name='sect6' href='#toc6'>RETURN VALUES</a></h2>
Most functions return  (zero) on success, or one of several
non-zero error codes for errors. Specific error codes include:  for operations
that might succeed if retried,  for unusual conditions that do not prevent
further operations, and  for serious errors that make remaining operations
impossible. The  and  functions can be used to retrieve an appropriate error
code and a textual error message.   returns a pointer to a newly-allocated
 object.   returns a count of the number of bytes actually written. On error,
-1 is returned and the  and  functions will return appropriate values. Note
that if the client-provided write callback function returns a non-zero value,
that error will be propagated back to the caller through whatever API function
resulted in that call, which may include    or  The client callback can
call  to provide values that can then be retrieved by  and  
<h2><a name='sect7' href='#toc7'>SEE ALSO</a></h2>
  

<h2><a name='sect8' href='#toc8'>HISTORY</a></h2>
The  library first appeared in  
<h2><a name='sect9' href='#toc9'>AUTHORS</a></h2>
 The  library was written
by  
<h2><a name='sect10' href='#toc10'>BUGS</a></h2>
There are many peculiar bugs in historic tar implementations that
may cause certain programs to reject archives written by this library. For
example, several historic implementations calculated header checksums incorrectly
and will thus reject valid archives; GNU tar does not fully support pax
interchange format; some old tar implementations required specific field
terminations.  The default pax interchange format eliminates most of the
historic tar limitations and provides a generic key/value attribute facility
for vendor-defined extensions. One oversight in POSIX is the failure to provide
a standard attribute for large device numbers. This library uses  and  for
device numbers that exceed the range supported by the backwards-compatible
ustar header. These keys are compatible with Joerg Schilling&rsquo;s  archiver.
Other implementations may not recognize these keys and will thus be unable
to correctly restore device nodes with large device numbers from archives
created by this library. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>NAME</a></li>
<li><a name='toc1' href='#sect1'>SYNOPSIS</a></li>
<li><a name='toc2' href='#sect2'>DESCRIPTION</a></li>
<li><a name='toc3' href='#sect3'>IMPLEMENTATION</a></li>
<li><a name='toc4' href='#sect4'>CLIENT CALLBACKS</a></li>
<li><a name='toc5' href='#sect5'>EXAMPLE</a></li>
<li><a name='toc6' href='#sect6'>RETURN VALUES</a></li>
<li><a name='toc7' href='#sect7'>SEE ALSO</a></li>
<li><a name='toc8' href='#sect8'>HISTORY</a></li>
<li><a name='toc9' href='#sect9'>AUTHORS</a></li>
<li><a name='toc10' href='#sect10'>BUGS</a></li>
</ul>
</body>
</html>
