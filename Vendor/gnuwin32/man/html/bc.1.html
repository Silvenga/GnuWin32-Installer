                              <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>bc(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
bc - An arbitrary precision calculator
language 
<h2><a name='sect1' href='#toc1'>Syntax</a></h2>
<b>bc</b> [ <b>-hlwsqv</b> ] [long-options] [ <i> file ...</i> ] 
<h2><a name='sect2' href='#toc2'>Version</a></h2>
This man page
documents GNU bc version 1.06. 
<h2><a name='sect3' href='#toc3'>Description</a></h2>
<b>bc</b> is a language that supports
arbitrary precision numbers with interactive execution of statements.  There
are some similarities in the syntax to the C programming language.  A standard
math library is available by command line option. If requested, the math
library is defined before processing any files. <b>bc</b> starts by processing
code from all the files listed on the command line in the order listed.
 After all files have been processed, <b>bc</b> reads from the standard input.
 All code is executed as it is read.  (If a file contains a command to halt
the processor, <b>bc</b> will never read from the standard input.) <p>
This version
of <b>bc</b> contains several extensions beyond traditional <b>bc</b> implementations
and the POSIX draft standard. Command line options can cause these extensions
to print a warning  or to be rejected.  This  document describes the language
accepted by this processor. Extensions will be identified as such. 
<h3><a name='sect4' href='#toc4'>Options</a></h3>

<dl>

<dt>-h,
--help</dt>
<dd>Print the usage and exit. </dd>

<dt>-i, --interactive</dt>
<dd>Force interactive mode. </dd>

<dt>-l, --mathlib</dt>
<dd>Define
the standard math library. </dd>

<dt>-w, --warn</dt>
<dd>Give warnings for extensions to POSIX
<b>bc</b>. </dd>

<dt>-s, --standard</dt>
<dd>Process exactly the POSIX <b>bc</b> language. </dd>

<dt>-q, --quiet</dt>
<dd>Do not print
the normal GNU bc welcome. </dd>

<dt>-v, --version</dt>
<dd>Print the version number and copyright
and quit. </dd>
</dl>

<h3><a name='sect5' href='#toc5'>Numbers</a></h3>
The most basic element in <b>bc</b> is the number.  Numbers are
arbitrary precision numbers.  This precision is both in the integer part
and the fractional part.  All numbers are represented internally in decimal
and all computation is done in decimal.  (This version truncates results
from divide and multiply operations.)  There are two attributes of numbers,
the length and the scale.  The length is the total number of significant
decimal digits in a number and the scale is the total number of decimal
digits after the decimal point.  For example: <br>
<pre> .000001 has a length of 6 and scale of 6.
 1935.000 has a length of 7 and a scale of 3.
</pre>
<h3><a name='sect6' href='#toc6'>Variables</a></h3>
Numbers are stored in two types of variables, simple variables
and arrays.  Both simple variables and array variables are named.  Names
begin with a letter followed by any number of letters, digits and underscores.
 All letters must be lower case.  (Full alpha-numeric names are an extension.
In POSIX <b>bc</b> all names are a single lower case letter.)  The type of variable
is clear by the context because all array variable names will be followed
by brackets ([]). <p>
There are four special variables, <b>scale, ibase, obase,</b>
and <b>last</b>.  <b>scale</b> defines how some operations use digits after the decimal
point.  The default value of <b>scale</b> is 0. <b>ibase</b> and <b>obase</b> define the conversion
base for input and output numbers.  The default for both input and output
is base 10. <b>last</b> (an extension) is a variable that has the value of the
last printed number.  These will be discussed in further detail where appropriate.
 All of these variables may have values assigned to them as well as used
in expressions. 
<h3><a name='sect7' href='#toc7'>Comments</a></h3>
Comments in <b>bc</b> start with the characters <b>/*</b> and
end with the characters <b>*/</b>.  Comments may start anywhere and appear as a
single space in the input.  (This causes comments to delimit other input
items.  For example, a comment can not be found in the middle of a variable
name.)  Comments include any newlines (end of line) between the start and
the end of the comment. <p>
To support the use of scripts for <b>bc</b>, a single line
comment has been added as an extension.  A single line comment starts at
a <b>#</b> character and continues to the next end of the line.  The end of line
character is not part of the comment and is processed normally. 
<h3><a name='sect8' href='#toc8'>Expressions</a></h3>
The
numbers are manipulated by expressions and statements.  Since the language
was designed to be interactive, statements and expressions are executed
as soon as possible.  There is no "main" program.  Instead, code is executed
as it is encountered.  (Functions, discussed in detail later, are defined
when encountered.) <p>
A simple expression is just a constant. <b>bc</b> converts constants
into internal decimal numbers using the current input base, specified by
the variable <b>ibase</b>. (There is an exception in functions.) The legal values
of <b>ibase</b> are 2 through 16.  Assigning a value outside this range to <b>ibase</b>
will result in a value of 2 or 16.  Input numbers may contain the characters
0-9 and A-F. (Note: They must be capitals.  Lower case letters are variable
names.) Single digit numbers always have the value of the digit regardless
of the value of <b>ibase</b>. (i.e. A = 10.)  For multi-digit numbers, <b>bc</b> changes all
input digits greater or equal to ibase to the value of <b>ibase</b>-1.  This makes
the number <b>FFF</b> always be the largest 3 digit number of the input base. <p>
Full
expressions are similar to many other high level languages. Since there
is only one kind of number, there are no rules for mixing types.  Instead,
there are rules on the scale of expressions.  Every expression has a scale.
 This is derived from the scale of original numbers, the operation performed
and in many cases, the value of the variable <b>scale</b>. Legal values of the
variable <b>scale</b> are 0 to the maximum number representable by a C integer.
<p>
In the following descriptions of legal expressions, "expr" refers to a
complete expression and "var" refers to a simple or an array variable. A
simple variable is just a <blockquote><i>name</i> </blockquote>
and an array variable is specified as <blockquote><i>name</i>[<i>expr</i>]
</blockquote>
Unless specifically mentioned the scale of the result is the maximum scale
of the expressions involved. 
<dl>

<dt>- expr</dt>
<dd>The result is the negation of the expression.
</dd>

<dt>++ var</dt>
<dd>The variable is incremented by one and the new value is the result
of the expression. </dd>

<dt>-- var</dt>
<dd>The variable is decremented by one and the new value
is the result of the expression. </dd>

<dt>var ++</dt>
<dd> The result of the expression is
the value of<br>
 the variable and then the variable is incremented by one. </dd>

<dt>var --</dt>
<dd>The result
of the expression is the value of the variable and then the variable is
decremented by one. </dd>

<dt>expr + expr</dt>
<dd>The result of the expression is the sum of
the two expressions. </dd>

<dt>expr - expr</dt>
<dd>The result of the expression is the difference
of the two expressions. </dd>

<dt>expr * expr</dt>
<dd>The result of the expression is the product
of the two expressions. </dd>

<dt>expr / expr</dt>
<dd>The result of the expression is the quotient
of the two expressions. The scale of the result is the value of the variable
<b>scale</b>. </dd>

<dt>expr % expr</dt>
<dd>The result of the expression is the "remainder" and it
is computed in the following way.  To compute a%b, first a/b is computed
to <b>scale</b> digits.  That result is used to compute a-(a/b)*b to the scale of
the maximum of <b>scale</b>+scale(b) and scale(a).  If <b>scale</b> is set to zero and
both expressions are integers this expression is the integer remainder
function. </dd>

<dt>expr ^ expr</dt>
<dd>The result of the expression is the value of the first
raised to the second. The second expression must be an integer.  (If the
second expression is not an integer, a warning is generated and the expression
is truncated to get an integer value.)  The scale of the result is <b>scale</b>
if the exponent is negative.  If the exponent is positive the scale of the
result is the minimum of the scale of the first expression times the value
of the exponent and the maximum of <b>scale</b> and the scale of the first expression.
 (e.g. scale(a^b) = min(scale(a)*b, max( <b>scale,</b> scale(a))).)  It should be
noted that expr^0 will always return the value of 1. </dd>

<dt>( expr )</dt>
<dd>This alters
the standard precedence to force the evaluation of the expression. </dd>

<dt>var =
expr</dt>
<dd>The variable is assigned the value of the expression. </dd>

<dt>var &lt;op&gt;= expr</dt>
<dd>This
is equivalent to "var = var &lt;op&gt; expr" with the exception that the "var"
part is evaluated only once.  This can make a difference if "var" is an
array. </dd>
</dl>
<p>
 Relational expressions are a special kind of expression<br>
 that always evaluate to 0 or 1, 0 if the relation is false and 1 if the
relation is true.  These may appear in any legal expression. (POSIX bc requires
that relational expressions are used only in if, while, and for statements
and that only one relational test may be done in them.)  The relational
operators are 
<dl>

<dt>expr1 &lt; expr2</dt>
<dd>The result is 1 if expr1 is strictly less than
expr2. </dd>

<dt>expr1 &lt;= expr2</dt>
<dd>The result is 1 if expr1 is less than or equal to expr2.
</dd>

<dt>expr1 &gt; expr2</dt>
<dd>The result is 1 if expr1 is strictly greater than expr2. </dd>

<dt>expr1
&gt;= expr2</dt>
<dd>The result is 1 if expr1 is greater than or equal to expr2. </dd>

<dt>expr1
== expr2</dt>
<dd>The result is 1 if expr1 is equal to expr2. </dd>

<dt>expr1 != expr2</dt>
<dd>The result
is 1 if expr1 is not equal to expr2. </dd>
</dl>
<p>
Boolean operations are also legal. 
(POSIX <b>bc</b> does NOT have boolean operations). The result of all boolean operations
are 0 and 1 (for false and true) as in relational expressions.  The boolean
operators are: 
<dl>

<dt>!expr</dt>
<dd>The result is 1 if expr is 0. </dd>

<dt>expr &amp;&amp; expr</dt>
<dd>The result is
1 if both expressions are non-zero. </dd>

<dt>expr || expr</dt>
<dd>The result is 1 if either expression
is non-zero. </dd>
</dl>
<p>
The expression precedence is as follows: (lowest to highest)
<br>
<pre>|| operator, left associative
&amp;&amp; operator, left associative
! operator, nonassociative
Relational operators, left associative
Assignment operator, right associative
+ and - operators, left associative
*, / and % operators, left associative
^ operator, right associative
unary - operator, nonassociative
++ and -- operators, nonassociative
</pre><p>
This precedence was chosen so that POSIX compliant <b>bc</b> programs will run
correctly. This will cause the use of the relational and logical operators
to have some unusual behavior when used with assignment expressions.  Consider
the expression: <blockquote>a = 3 &lt; 5 </blockquote>
<p>
Most C programmers would assume this would assign
the result of "3 &lt; 5" (the value 1) to the variable "a".  What this does
in <b>bc</b> is assign the value 3 to the variable "a" and then compare 3 to 5.
 It is best to use parenthesis when using relational and logical operators
with the assignment operators. <p>
There are a few more special expressions
that are provided in <b>bc</b>. These have to do with user defined functions and
standard functions.  They all appear as "<a href='name.parameters.html'><i>name<b>(<i>parameters<b>)</b></i></b></i></a>
". See the section
on functions for user defined functions.  The standard functions are: 
<dl>

<dt>length
( expression )</dt>
<dd>The value of the length function is the number of significant
digits in the expression. </dd>

<dt>read ( )</dt>
<dd>The read function (an extension) will
read a number from the standard input, regardless of where the function
occurs.   Beware, this can cause problems with the mixing of data and program
in the standard input. The best use for this function is in a previously
written program that needs input from the user, but never allows program
code to be input from the user.  The value of the read function is the number
read from the standard input using the current value of the variable  <b>ibase</b>
for the conversion base. </dd>

<dt>scale ( expression )</dt>
<dd>The value of the scale function
is the number of digits after the decimal point in the expression. </dd>

<dt>sqrt
( expression )</dt>
<dd>The value of the sqrt function is the square root of the
expression.  If the expression is negative, a run time error is generated.
</dd>
</dl>

<h3><a name='sect9' href='#toc9'>Statements</a></h3>
Statements (as in most algebraic languages) provide the sequencing
of expression evaluation.  In <b>bc</b> statements are executed "as soon as possible."
 Execution happens when a newline in encountered and there is one or more
complete statements.  Due to this immediate execution, newlines are very
important in <b>bc</b>. In fact, both a semicolon and a newline are used as statement
separators.  An improperly placed newline will cause a syntax error.  Because
newlines are statement separators, it is possible to hide a newline by
using the backslash character.  The sequence "\&lt;nl&gt;", where &lt;nl&gt; is the newline
appears to <b>bc</b> as whitespace instead of a newline.  A statement list is a
series of statements separated by semicolons and newlines.  The following
is a list of <b>bc</b> statements and what they do: (Things enclosed in brackets
([]) are optional parts of the statement.) 
<dl>

<dt>expression</dt>
<dd>This statement does
one of two things.  If the expression starts with "&lt;variable&gt; &lt;assignment&gt; ...",
it is considered to be an assignment statement.  If the expression is not
an assignment statement, the expression is evaluated and printed to the
output.  After the number is printed, a newline is printed.  For example,
"a=1" is an assignment statement and "(a=1)" is an expression that has
an embedded assignment.  All numbers that are printed are printed in the
base specified by the variable <b>obase</b>. The legal values for <b> obase</b> are 2
through BC_BASE_MAX.  (See the section LIMITS.)  For bases 2 through 16,
the usual method of writing numbers is used.  For bases greater than 16,
<b>bc</b> uses a multi-character digit method of printing the numbers where each
higher base digit is printed as a base 10 number.  The multi-character digits
are separated by spaces. Each digit contains the number of characters required
to represent the base ten value of "obase-1".  Since numbers are of arbitrary
precision, some numbers may not be printable on a single output line. These
long numbers will be split across lines using the "\" as the last character
on a line.  The maximum number of characters printed per line is 70.  Due
to the interactive nature of <b>bc</b>, printing a number causes the side effect
of assigning the printed value to the special variable <b>last</b>. This allows
the user to recover the last value printed without having to retype the
expression that printed the number.  Assigning to <b>last</b> is legal and will
overwrite the last printed value with the assigned value.  The newly assigned
value will remain until the next number is printed or another value is
assigned to <b>last</b>.  (Some installations may allow the  use of a single period
(.) which is not part of a number as a short hand notation for for <b>last</b>.)
</dd>

<dt>string</dt>
<dd>The string is printed to the output.  Strings start with a double
quote character and contain all characters until the next double quote
character. All characters are take literally, including any newline.  No
newline character is printed after the string. </dd>

<dt><b>print</b> list</dt>
<dd>The print statement
(an extension) provides another method of output. The "list" is a list of
strings and expressions separated by commas. Each string or expression is
printed in the order of the list.  No terminating newline is printed.  Expressions
are evaluated and their value is printed and assigned to the variable <b>last</b>.
Strings in the print statement are printed to the output and may contain
special characters.  Special characters start with the backslash character
(\).  The special characters recognized by <b>bc</b> are "a" (alert or bell), "b"
(backspace), "f" (form feed), "n" (newline), "r" (carriage return), "q"
(double quote), "t" (tab), and "\" (backslash). Any other character following
the backslash will be ignored.   </dd>

<dt>{ statement_list }</dt>
<dd>This is the compound
statement.  It allows multiple statements to be grouped together for execution.
</dd>

<dt><b>if</b> ( expression ) statement1 [<b>else</b> statement2]</dt>
<dd>The if statement evaluates
the expression and executes statement1 or statement2 depending on the value
of the expression.  If the expression is non-zero, statement1 is executed.
 If statement2 is present and the value of the expression is 0, then statement2
is executed.  (The else clause is an extension.) </dd>

<dt><b>while</b> ( expression ) statement</dt>
<dd>The
while statement will execute the statement while the expression is non-zero.
 It evaluates the expression before each execution of the statement.   Termination
of the loop is caused by a zero expression value or the execution of a
break statement. </dd>

<dt><b>for</b> ( [expression1] ; [expression2] ; [expression3] ) statement</dt>
<dd>The
for statement controls repeated execution of the statement.   Expression1
is evaluated before the loop.  Expression2 is evaluated before each execution
of the statement.  If it is non-zero, the statement is evaluated.  If it is
zero, the loop is terminated.  After each execution of the statement, expression3
is evaluated before the reevaluation of expression2.  If expression1 or
expression3 are missing, nothing is evaluated at the point they would be
evaluated. If expression2 is missing, it is the same as substituting the
value 1 for expression2.  (The optional expressions are an extension. POSIX
<b>bc</b> requires all three expressions.) The following is equivalent code for
the for statement: <br>
<pre>expression1;
while (expression2) {
   statement;
   expression3;
}
</pre>
<dl>

<dt><b>break</b></dt>
<dd>This statement causes a forced exit of the most recent enclosing while
statement or for statement. </dd>

<dt><b>continue</b></dt>
<dd>The continue statement (an extension)
 causes the most recent enclosing for statement to start the next iteration.
</dd>

<dt><b>halt</b></dt>
<dd>The halt statement (an extension) is an executed statement that causes
the <b>bc</b> processor to quit only when it is executed.  For example, "if (0
== 1) halt" will not cause <b>bc</b> to terminate because the halt is not executed.
</dd>

<dt><b>return</b></dt>
<dd>Return the value 0 from a function.  (See the section on functions.)
</dd>

<dt><b>return</b> ( expression )</dt>
<dd>Return the value of the expression from a function.
 (See the section on  functions.)  As an extension, the parenthesis are
not required. </dd>
</dl>

<h3><a name='sect10' href='#toc10'>Pseudo Statements</a></h3>
These statements are not statements in the
traditional sense.  They are not executed statements.  Their function is
performed at "compile" time. 
<dl>

<dt><b>limits</b></dt>
<dd>Print the local limits enforced by the
local version of <b>bc</b>.  This is an extension. </dd>

<dt><b>quit</b></dt>
<dd>When the quit statement is
read, the <b>bc</b> processor is terminated, regardless of where the quit statement
is found.  For example, "if (0 == 1) quit" will cause <b>bc</b> to terminate. </dd>

<dt><b>warranty</b></dt>
<dd>Print
a longer warranty notice.  This is an extension. </dd>
</dl>

<h3><a name='sect11' href='#toc11'>Functions</a></h3>
Functions provide
a method of defining a computation that can be executed later.  Functions
in  <b>bc</b> always compute a value and return it to the caller.  Function definitions
are "dynamic" in the sense that a function is undefined until a definition
is encountered in the input.  That definition is then used until another
definition function for the same name is encountered.  The new definition
then replaces the older definition.  A function is defined as follows: <br>
<pre>define name ( parameters ) { newline
    auto_list   statement_list }
</pre>A function call is just an expression of the form "<a href='name.parameters.html'><i>name<b>(<i>parameters<b>)</b></i></b></i></a>
". <p>
Parameters
are numbers or arrays (an extension).  In the function definition, zero
or more parameters are defined by listing their names separated by commas.
 Numbers are only call by value parameters.  Arrays are only call by variable.
 Arrays are specified in the parameter definition by the notation "<i>name<b>[]</b></i>".
  In the function call, actual parameters are full expressions for number
parameters.  The same notation is used for passing arrays as for defining
array parameters.  The named array is passed by variable to the function.
 Since function definitions are dynamic, parameter numbers and types are
checked when a function is called.  Any mismatch in number or types of parameters
will cause a runtime error. A runtime error will also occur for the call
to an undefined function. <p>
The <i>auto_list</i> is an optional list of variables
that are for "local" use.  The syntax of the auto list (if present) is "<b>auto
<i>name</i></b>, ... ;".  (The semicolon is optional.)  Each <i>name</i> is the name of an auto
variable.  Arrays may be specified by using the same notation as used in
parameters.  These variables have their values pushed onto a stack at the
start of the function.  The variables are then initialized to zero and used
throughout the execution of the function.  At function exit, these variables
are popped so that the original value (at the time of the function call)
of these variables are restored.  The parameters are really auto variables
that are initialized to a value provided in the function call.  Auto variables
are different than traditional local variables because if function A calls
function B, B may access function A&rsquo;s auto variables by just using the same
name, unless function B has called them auto variables.  Due to the fact
that auto variables and parameters are pushed onto a stack, <b>bc</b> supports
recursive functions. <p>
The function body is a list of <b>bc</b> statements.  Again,
statements are separated by semicolons or newlines.  Return statements cause
the termination of a function and the return of a value.  There are two
versions of the return statement.  The first form, "<b>return</b>", returns the
value 0 to the calling expression.  The second form,  "<b>return ( <i>expression
<b>)</b></i></b>", computes the value of the expression and returns that value to the
calling expression.  There is an implied "<b>return (0)</b>" at the end of every
function.  This allows a function to terminate and return 0 without an explicit
return statement. <p>
Functions also change the usage of the variable <b>ibase</b>.
 All constants in the function body will be converted using the value of
<b>ibase</b> at the time of the function call.  Changes of <b>ibase</b> will be ignored
during the execution of the function except for the standard function <b>read</b>,
which will always use the current value of <b>ibase</b> for conversion of numbers.
<p>
As an extension, the format of the definition has been slightly relaxed.
The standard requires the opening brace be on the same line as the  <b>define</b>
keyword and all other parts must be on following lines. This version of
<b>bc</b> will allow any number of newlines before and after the opening brace
of the function.  For example, the following definitions are legal. <br>
<pre>CW
define d (n) { return (2*n); }
define d (n)
  { return (2*n); }

</pre>
<h3><a name='sect12' href='#toc12'>Math Library</a></h3>
If <b>bc</b> is invoked with the <b>-l</b> option, a math library is preloaded
and the default scale is set to 20.   The math functions will calculate
their results to the scale set at the time of their call.   The math library
defines the following functions: 
<dl>

<dt>s (<i>x</i>)</dt>
<dd>The sine of x, x is in radians. </dd>

<dt>c
(<i>x</i>)</dt>
<dd>The cosine of x, x is in radians. </dd>

<dt>a (<i>x</i>)</dt>
<dd>The arctangent of x, arctangent
returns radians. </dd>

<dt>l (<i>x</i>)</dt>
<dd>The natural logarithm of x. </dd>

<dt>e (<i>x</i>)</dt>
<dd>The exponential function
of raising e to the value x. </dd>

<dt>j (<i>n,x</i>)</dt>
<dd>The bessel function of integer order
n of x. </dd>
</dl>

<h3><a name='sect13' href='#toc13'>Examples</a></h3>
In /bin/sh,  the following will assign the value of "pi"
to the shell variable <b>pi</b>. <blockquote>CW pi=$(echo "scale=10; 4*<a href='a.1.html'>a(1)</a>
" | bc -l)  </blockquote>
<p>
The following
is the definition of the exponential function used in the math library.
 This function is written in POSIX <b>bc</b>. <br>
<pre>CW
scale = 20
/* Uses the fact that e^x = (e^(x/2))^2
   When x is small enough, we use the series:
     e^x = 1 + x + x^2/2! + x^3/3! + ...
*/
define e(x) {
  auto  a, d, e, f, i, m, v, z
  /* Check the sign of x. */
  if (x&lt;0) {
    m = 1
    x = -x
  } 
  /* Precondition x. */
  z = scale;
  scale = 4 + z + .44*x;
  while (x &gt; 1) {
    f += 1;
    x /= 2;
  }
  /* Initialize the variables. */
  v = 1+x
  a = x
  d = 1
  for (i=2; 1; i++) {
    e = (a *= x) / (d *= i)
    if (e == 0) {
      if (f&gt;0) while (f--)  v = v*v;
      scale = z
      if (m) return (1/v);
      return (v/1);
    }
    v += e
  }
}

</pre><p>
The following is code that uses the extended features of <b>bc</b> to implement
a simple program for calculating checkbook balances.  This program is best
kept in a file so that it can be used many times  without having to retype
it at every use. <br>
<pre>CW
scale=2
print "\nCheck book program!\n"
print "  Remember, deposits are negative transactions.\n"
print "  Exit by a 0 transaction.\n\n"
print "Initial balance? "; bal = read()
bal /= 1
print "\n"
while (1) {
  "current balance = "; bal
  "transaction? "; trans = read()
  if (trans == 0) break;
  bal -= trans
  bal /= 1
}
quit

</pre><p>
The following is the definition of the recursive factorial function. <br>
<pre>CW
define f (x) {
  if (x &lt;= 1) return (1);
  return (f(x-1) * x);
}

</pre>
<h3><a name='sect14' href='#toc14'>Readline and Libedit Options</a></h3>
GNU <b>bc</b> can be compiled (via a configure option)
to use the GNU <b>readline</b> input editor library or the BSD <b>libedit</b> library.
This allows the user to do editing of lines before sending them to <b>bc</b>. 
It also allows for a history of previous lines typed. When this option is
selected, <b>bc</b> has one more special variable. This special variable, <b>history</b>
is the number of lines of history retained.  For <b>readline</b>, a value of -1
means that an unlimited number of history lines are retained.  Setting the
value of <b>history</b> to a positive number restricts the number of history lines
to the number given.  The value of 0 disables the history feature.  The default
value is 100. For more information, read the user manuals for the GNU <b>readline</b>,
<b>history</b> and BSD <b>libedit</b> libraries.  One can not enable both <b>readline</b> and
<b>libedit</b> at the same time. 
<h3><a name='sect15' href='#toc15'>Differences</a></h3>
This version of  <b>bc</b> was implemented
from the POSIX P1003.2/D11 draft and contains several differences and extensions
relative to the draft and traditional implementations. It is not implemented
in the traditional way using <a href='dc.1.html'><i>dc(1)</a>
.</i> This version is a single process which
parses and runs a byte code translation of the program.  There is an "undocumented"
option (-c) that causes the program to output the byte code to the standard
output instead of running it.  It was mainly used for debugging the parser
and preparing the math library. <p>
A major source of differences is extensions,
where a feature is extended to add more functionality and additions, where
new features are added.  The following is the list of differences and extensions.

<dl>

<dt>LANG</dt>
<dd>This version does not conform to the POSIX standard in the processing
of the LANG environment variable and all environment variables starting
with LC_. </dd>

<dt>names</dt>
<dd>Traditional and POSIX <b>bc</b> have single letter names for functions,
variables and arrays.  They have been extended to be multi-character names
that start with a letter and may contain letters, numbers and the underscore
character. </dd>

<dt>Strings</dt>
<dd>Strings are not allowed to contain NUL characters.  POSIX
says all characters must be included in strings. </dd>

<dt>last</dt>
<dd>POSIX <b>bc</b> does not have
a <b>last</b> variable.  Some implementations of <b>bc</b> use the period (.) in a similar
way.   </dd>

<dt>comparisons</dt>
<dd>POSIX <b>bc</b> allows comparisons only in the if statement,
the while statement, and the second expression of the for statement.  Also,
only one relational operation is allowed in each of those statements. </dd>

<dt>if
statement, else clause</dt>
<dd>POSIX <b>bc</b> does not have an else clause. </dd>

<dt>for statement</dt>
<dd>POSIX
<b>bc</b> requires all expressions to be present in the for statement. </dd>

<dt>&amp;&amp;, ||, !</dt>
<dd>POSIX
<b>bc</b> does not have the logical operators. </dd>

<dt>read function</dt>
<dd>POSIX <b>bc</b> does not have
a read function. </dd>

<dt>print statement</dt>
<dd>POSIX <b>bc</b> does not have a print statement
. </dd>

<dt>continue statement</dt>
<dd>POSIX <b>bc</b> does not have a continue statement. </dd>

<dt>return statement</dt>
<dd>POSIX
<b>bc</b> requires parentheses around the return expression. </dd>

<dt>array parameters</dt>
<dd>POSIX
<b>bc</b> does not (currently) support array parameters in full. The POSIX grammar
allows for arrays in function definitions, but does not provide a method
to specify an array as an actual parameter.  (This is most likely an oversight
in the grammar.)  Traditional implementations of <b>bc</b> have only call by value
array parameters. </dd>

<dt>function format</dt>
<dd>POSIX <b>bc</b> requires the opening brace on
the same line as the  <b>define</b> key word and the <b>auto</b> statement on the next
line. </dd>

<dt>=+, =-, =*, =/, =%, =^</dt>
<dd>POSIX <b>bc</b> does not require these "old style" assignment
operators to be defined.  This version may allow these "old style" assignments.
 Use the limits statement to see if the installed version supports them.
 If it does support the "old style" assignment operators, the statement
"a =- 1" will decrement <b>a</b> by 1 instead of setting <b>a</b> to the value -1. </dd>

<dt>spaces
in numbers</dt>
<dd>Other implementations of <b>bc</b> allow spaces in numbers.  For example,
"x=1 3" would assign the value 13 to the variable x.  The same statement
would cause a syntax error in this version of <b>bc</b>. </dd>

<dt>errors and execution</dt>
<dd>This
implementation varies from other implementations in terms of what code
will be executed when syntax and other errors are found in the program.
 If a syntax error is found in a function definition, error recovery tries
to find the beginning of a statement and continue to parse the function.
 Once a syntax error is found in the function, the function will not be
callable and becomes undefined. Syntax errors in the interactive execution
code will invalidate the current execution block.  The execution block is
terminated by an end of line that appears after a complete sequence of
statements. For example,  <br>
<pre>a = 1
b = 2
</pre>has two execution blocks and <br>
<pre>{ a = 1
  b = 2 }
</pre>has one execution block.  Any runtime error will terminate the execution
of the current execution block.  A runtime warning will not terminate the
current execution block. 
<dl>

<dt>Interrupts</dt>
<dd>During an interactive session, the SIGINT
signal (usually generated by the control-C character from the terminal)
will cause execution of the current execution block to be interrupted. 
It will display a "runtime" error indicating which function was interrupted.
 After all runtime structures have been cleaned up, a message will be printed
to notify the user that <b>bc</b> is ready for more input.  All previously defined
functions remain defined and the value of all non-auto variables are the
value at the point of interruption.  All auto variables and function parameters
are removed during the clean up process.  During a non-interactive session,
the SIGINT signal will terminate the entire run of <b>bc</b>. </dd>
</dl>

<h3><a name='sect16' href='#toc16'>Limits</a></h3>
The following
are the limits currently in place for this  <b>bc</b> processor.  Some of them
may have been changed by an installation. Use the limits statement to see
the actual values. 
<dl>

<dt>BC_BASE_MAX</dt>
<dd>The maximum output base is currently set at
999.  The maximum input base is 16. </dd>

<dt>BC_DIM_MAX</dt>
<dd>This is currently an arbitrary
limit of 65535 as distributed.  Your installation may be different. </dd>

<dt>BC_SCALE_MAX</dt>
<dd>The
number of digits after the decimal point is limited to INT_MAX digits. Also,
the number of digits before the decimal point is limited to INT_MAX digits.
</dd>

<dt>BC_STRING_MAX</dt>
<dd>The limit on the number of characters in a string is INT_MAX
characters. </dd>

<dt>exponent</dt>
<dd>The value of the exponent in the raise operation (^)
is limited to LONG_MAX. </dd>

<dt>variable names</dt>
<dd>The current limit on the number of
unique names is 32767 for each of simple variables, arrays and functions.
</dd>
</dl>

<h2><a name='sect17' href='#toc17'>Environment Variables</a></h2>
The following environment variables are processed
by <b>bc</b>: 
<dl>

<dt>POSIXLY_CORRECT</dt>
<dd>This is the same as the <b>-s</b> option. </dd>

<dt>BC_ENV_ARGS</dt>
<dd>This
is another mechanism to get arguments to <b>bc</b>.  The format is the same as
the command line arguments.  These arguments are processed first, so any
files listed in the environent arguments are processed before any command
line argument files.  This allows the user to set up "standard" options
and files to be processed at every invocation of <b>bc</b>.  The files in the environment
variables would typically contain function definitions for functions the
user wants defined every time <b>bc</b> is run. </dd>

<dt>BC_LINE_LENGTH</dt>
<dd>This should be an
integer specifing the number of characters in an output line for numbers.
This includes the backslash and newline characters for long numbers. </dd>
</dl>

<h2><a name='sect18' href='#toc18'>Diagnostics</a></h2>
If
any file on the command line can not be opened, <b>bc</b> will report that the
file is unavailable and terminate.  Also, there are compile and run time
diagnostics that should be self-explanatory. 
<h2><a name='sect19' href='#toc19'>Bugs</a></h2>
Error recovery is not very
good yet. <p>
Email bug reports to <b>bug-bc@gnu.org</b>. Be sure to include the word
&lsquo;&lsquo;bc&rsquo;&rsquo; somewhere in the &lsquo;&lsquo;Subject:&rsquo;&rsquo; field. 
<h2><a name='sect20' href='#toc20'>Author</a></h2>
<br>
<pre>Philip A. Nelson
philnelson@acm.org
</pre>
<h2><a name='sect21' href='#toc21'>Acknowledgements</a></h2>
The author would like to thank Steve Sommars (Steve.Sommars@att.com)
for his extensive help in testing the implementation.  Many great suggestions
were given.  This is a much better product due to his involvement. <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Syntax</a></li>
<li><a name='toc2' href='#sect2'>Version</a></li>
<li><a name='toc3' href='#sect3'>Description</a></li>
<ul>
<li><a name='toc4' href='#sect4'>Options</a></li>
<li><a name='toc5' href='#sect5'>Numbers</a></li>
<li><a name='toc6' href='#sect6'>Variables</a></li>
<li><a name='toc7' href='#sect7'>Comments</a></li>
<li><a name='toc8' href='#sect8'>Expressions</a></li>
<li><a name='toc9' href='#sect9'>Statements</a></li>
<li><a name='toc10' href='#sect10'>Pseudo Statements</a></li>
<li><a name='toc11' href='#sect11'>Functions</a></li>
<li><a name='toc12' href='#sect12'>Math Library</a></li>
<li><a name='toc13' href='#sect13'>Examples</a></li>
<li><a name='toc14' href='#sect14'>Readline and Libedit Options</a></li>
<li><a name='toc15' href='#sect15'>Differences</a></li>
<li><a name='toc16' href='#sect16'>Limits</a></li>
</ul>
<li><a name='toc17' href='#sect17'>Environment Variables</a></li>
<li><a name='toc18' href='#sect18'>Diagnostics</a></li>
<li><a name='toc19' href='#sect19'>Bugs</a></li>
<li><a name='toc20' href='#sect20'>Author</a></li>
<li><a name='toc21' href='#sect21'>Acknowledgements</a></li>
</ul>
</body>
</html>
