 <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>RLE_GETRAW(3) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
 
<p> 
<h2><a name='sect0' href='#toc0'>Name</a></h2>
rle_getraw - Read run length encoded data from an RLE file. <br>
rle_freeraw - Free pixel storage allocated by rle_getraw. 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b></b> #include
&lt;rle.h&gt; <br>
<b></b> #include &lt;rle_raw.h&gt; <p>
<b></b> unsigned int rle_getraw( the_hdr, scanraw, nraw ) <br>
<b></b> rle_hdr * the_hdr; <br>
<b></b> rle_op ** scanraw; <br>
<b></b> int * nraw; <p>
<b></b> void rle_freeraw( the_hdr, scanraw, nraw ); <br>
<b></b> rle_hdr * the_hdr; <br>
<b></b> rle_op ** scanraw; <br>
<b></b> int * nraw; 
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<i>Rle_getraw</i> can be used to read information from
an RLE file in the "raw" form. 
<p> The <i>scanraw</i> argument is an array of pointers
to arrays of  <a href='rle_op.3.html'><i>rle_op</i>(3)</a>
 structures.  Each <i>rle_op</i> structure specifies a run
or sequence of pixel values.  The array <i>nraw</i> gives the number of  <i>rle_op</i>
structures for each channel.  I.e., <i>nraw[i]</i> is the length of the array pointed
to by <i>scanraw[i]</i>. <p>
Return value is the current scanline number.  Returns 32768
at EOF. <p>
Sufficient space must be allocated in the arrays of  <i>rle_op</i> structures
to hold the data read from the file.  A function, <a href='rle_raw_alloc.3.html'><i>rle_raw_alloc</i>(3)</a>
, is provided
to make this easier.  The storage required by any pixel sequences in the
input will be dynamically allocated by <i>rle_getraw</i>. 
<p> The pixel storage allocated
dynamically by <a href='rle_getraw.3.html'><i>rle_getraw</i>(3)</a>
 must be freed to avoid memory leaks.  This
is most easily accomplished by calling  <i>rle_freeraw</i>. The argument <i>scanraw</i>
points to an array of  <i>rle_op</i> structures, with <i>nraw</i> indicating the number
of structures in each channel.  All pixel data arrays will be freed by the
call to <i>rle_freeraw</i>.<i></i> 
<h2><a name='sect3' href='#toc3'>Example</a></h2>
The usual code looks something like <br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;rle_hdr in_hdr, out_hdr;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;rle_op **raw;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;int *nraw;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;while ( rle_getraw( &amp;in_hdr, raw, nraw ) != 32768 )
<tt> </tt>&nbsp;<tt> </tt>&nbsp;{
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* Process data. */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rle_putraw( &amp;out_hdr, raw, nraw );
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;rle_freeraw( &amp;in_hdr, raw, nraw );
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}
</pre>
<h2><a name='sect4' href='#toc4'>See Also</a></h2>
 <a href='rle_hdr.3.html'><i>rle_hdr</i>(3)</a>
, <a href='rle_op.3.html'><i>rle_op</i>(3)</a>
, <a href='rle_putraw.3.html'><i>rle_putraw</i>(3)</a>
, <a href='rle_raw_alloc.3.html'><i>rle_raw_alloc</i>(3)</a>
, <a href='rle_raw_free.3.html'><i>rle_raw_free</i>(3)</a>
,
<a href='rle_getrow.3.html'><i>rle_getrow</i>(3)</a>
, <a href='rle_getskip.3.html'><i>rle_getskip</i>(3)</a>
, <a href='librle.3.html'><i>librle</i>(3)</a>
, <a href='RLE.5.html'><i>RLE</i>(5)</a>
.  
<h2><a name='sect5' href='#toc5'>Author</a></h2>
Spencer W. Thomas
<br>

<p>University of Utah 
<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Example</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
<li><a name='toc5' href='#sect5'>Author</a></li>
</ul>
</body>
</html>
