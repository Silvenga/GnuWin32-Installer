  <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>"SGREP"(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>
 
<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p>  sgrep - search a file for a structured pattern 
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p>  <i>sgrep
</i> [<b>-aCcDdhilNnPqSsTtV</b>] [<b>-O</b> <i>filename</i>] [<b>-o</b> "<i>format</i>"] [<b>-p</b> <i>preprocessor</i>]  [<b>-e</b>]  <i>expression</i>
[<i>filename </i> ...]  <i>sgrep</i> [<b>-aCcDdhilNnPqSsTtV</b>] [<b>-O</b> <i>filename</i>]  [<b>-o</b> "<i>format</i>"] [ <b>-p</b>
<i>preprocessor</i>]  <b>-f</b> <i>filename</i> [<b>-e </b> <i>expression</i>]  [<i>filename</i> ...]   <i>sgrep </i> <b>-h</b> 
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p>
 <i>sgrep (structured grep)</i> is a tool for searching  <i>text files</i> and filtering
 <i>text streams</i> using structural criteria.  The data model of sgrep is based
on <i>regions</i>, which are non-empty substrings of text.  <i>Regions </i> are typically
occurrences of constant strings or  meaningful text elements,  which are
recognizable through some delimiting strings. Regions  can be arbitrarily
long, arbitrarily  overlapping, and arbitrarily nested.  <b>sgrep</b> uses patterns
called <i>region expressions</i> to express which regions of the input text are
output to standard output. The selection of regions  is based on mutual
  <i>containment and ordering conditions </i> of the regions,  expressed by the
region expression.  <i>Region expressions</i> are read by default first from file
<b>$HOME/.sgreprc,</b> or if it doesn&rsquo;t exist, from file <b>/usr/lib/sgreprc, </b> and
then from the command line. Different behavior can be specified through
command line options.  Input  <i>files </i> are processed one by one (i.e., regions
 cannot extend over file boundaries), except if the <b>-S</b> flag is given, in
which case <b>sgrep</b> takes the concatenation of the input  files as its input
text.  If no input files are  given, <b>sgrep</b> reads the standard input. Standard
input can also be specified as an input file by giving  hyphen &rsquo;-&rsquo; as a file
name.  The selected regions are output in increasing order of their start
positions.  If several output regions overlap, a minimal region that covers
them all  is output, by default, instead of outputting each of them separately.
   
<h2><a name='sect3' href='#toc3'>Options</a></h2>

<p>  
<dl>

<dt><b>-a</b></dt>
<dd>    Act as a filter: display the maching regions, possibly
formatted according to the output format,  interleaved with the rest of
the text. (See the description of option -o below.)  </dd>

<dt><b>-C </b></dt>
<dd>    Display copyright
notice. </dd>

<dt><b>-c </b></dt>
<dd>    Display only the count of the regions that match the expression.
</dd>

<dt><b>-D</b></dt>
<dd>    Display verbose progress output.  <b>NOTE:</b> This is used for debugging
purposes only and may not function in future versions of sgrep. </dd>

<dt><b>-d </b></dt>
<dd>    Display
each matching region once, even if the regions overlap or nest. </dd>

<dt><b>-e</b> <i>expression</i></dt>
<dd>
   Search the input text for occurrences of  <i>expression</i>. </dd>

<dt><b>-f</b> <i>file</i></dt>
<dd>    Read
the region expression from the named file. Filename <b>- </b> refers to stdin. </dd>

<dt><b>-h</b></dt>
<dd>
   Display a short help. </dd>

<dt><b>-i</b></dt>
<dd>    Ignore case distinctions in phrases. </dd>

<dt><b>-l</b></dt>
<dd>    Long
output format: precede each output region by a  line which indicates the
ordinal number of the region, the name of the file where the region starts,
the length of the region in bytes, the start and end positions of  the
region within the entire input text, the start position of the  region
within the file containing the start, and the end position  of the region
within the file containing the end. </dd>

<dt><b>-N</b></dt>
<dd>    Do not add a newline after the
last output region. </dd>

<dt><b>-n</b></dt>
<dd>    Suppress reading <b>$HOME/.sgreprc</b> or  <b>/usr/lib/sgreprc.</b>
</dd>

<dt><b>-O</b> file</dt>
<dd>    Read the output format from file. See the description of output
formats below. </dd>

<dt><b>-o</b> format</dt>
<dd>    Set the output format. The format is displayed
for each output region  with any occurrences of the following place holders
substituted: </dd>

<dt><b>%f</b></dt>
<dd>    name of the file containing the start of the region
</dd>

<dt><b>%s </b></dt>
<dd>    start position of the region </dd>

<dt><b>%e </b></dt>
<dd>    end position of the region </dd>

<dt><b>%l
</b></dt>
<dd>    length of the region in bytes (i.e., <b>%e-%s+1</b>)  </dd>

<dt><b>%i</b></dt>
<dd>    start position of
the region in the file where the region begins  </dd>

<dt><b>%j</b></dt>
<dd>    end position of the
region in the file where the region ends </dd>

<dt><b>%r</b></dt>
<dd>    text of the region. "%r"
is the default output format. </dd>

<dt><b>%n</b></dt>
<dd>    gets the ordinal number of the region
</dd>

<dt><b>-P</b></dt>
<dd> Display the (preprocessed) region expression without executing it. </dd>

<dt><b>-p</b> <i>preprocessor</i></dt>
<dd>
Apply  <i>preprocessor </i> to the region expression before evaluating it.  </dd>

<dt><b>-S</b></dt>
<dd> Stream
mode. With this option sgrep considers  it&rsquo;s input files as a continuous
stream, so that regions may extend across file boundaries.  <p>
<br>
<pre>    sgrep -S file_1 ... file_n
</pre> <p>

<p> is similar to  <p>
<br>
<pre>    cat file_1 ... file_n | sgrep
</pre> <p>

<p> except that the latter creates a temporary disk file of the input stream.
 Sgrep may use much more memory when run with the  <b>-S</b> option, since then
it cannot release its internal  region lists between processing each file.
</dd>

<dt><b>-s</b></dt>
<dd> Short output format (default): do not format the text of the  output
regions, and display overlapping parts of regions only once. </dd>

<dt><b>-T</b></dt>
<dd> Display statistics
about the execution. </dd>

<dt><b>-t</b></dt>
<dd> Display time usage. </dd>

<dt><b>-V</b></dt>
<dd> Display version information.
</dd>

<dt><b>--</b></dt>
<dd> No more options.  A list of options can be given also as the value of the
 environment variable <b>SGREPOPT</b>. </dd>
</dl>

<h2><a name='sect4' href='#toc4'>Syntax of Expressions</a></h2>

<p>   <p>
<br>
<pre>region_expr -&gt;   basic_expr 
               | operator_expr
operator_expr -&gt; region_expr [&rsquo;not&rsquo;] &rsquo;in&rsquo; basic_expr
               | region_expr [&rsquo;not&rsquo;] &rsquo;containing&rsquo; basic_expr
               | region_expr [&rsquo;not&rsquo;] &rsquo;equal&rsquo; basic_expr
               | region_expr &rsquo;or&rsquo; basic_expr
               | region_expr &rsquo;extracting&rsquo; basic_expr
               | region_expr &rsquo;..&rsquo; basic_expr
               | region_expr &rsquo;_.&rsquo; basic_expr
               | region_expr &rsquo;._&rsquo; basic_expr
               | region_expr &rsquo;__&rsquo; basic_expr
               | region_expr &rsquo;quote&rsquo; basic_expr
               | region_expr &rsquo;_quote&rsquo; basic_expr
               | region_expr &rsquo;quote_&rsquo; basic_expr
               | region_expr &rsquo;_quote_&rsquo; basic_expr
               | &rsquo;concat&rsquo; &rsquo;(&rsquo; region_expr &rsquo;)&rsquo;
               | &rsquo;inner&rsquo; &rsquo;(&rsquo; region_expr &rsquo;)&rsquo;
               | &rsquo;outer&rsquo; &rsquo;(&rsquo; region_expr &rsquo;)&rsquo;
               | &rsquo;join&rsquo; &rsquo;(&rsquo; integer &rsquo;,&rsquo; region_expr &rsquo;)&rsquo;
basic_expr -&gt;   phrase
              | &rsquo;start&rsquo;
              | &rsquo;end&rsquo;
              | &rsquo;chars&rsquo;
              | constant_list
              | &rsquo;(&rsquo; region_expr &rsquo;)&rsquo;
phrase -&gt; &rsquo;"&rsquo; char [ char ... ] &rsquo;"&rsquo;
constant_list -&gt; &rsquo;[&rsquo; &rsquo;]&rsquo; | &rsquo;[&rsquo; regions &rsquo;]&rsquo;
regions -&gt;   region 
           | region regions
region -&gt; &rsquo;(&rsquo; integer &rsquo;,&rsquo; integer &rsquo;)&rsquo; 
</pre> <p>
 Note that region expressions are left-associative. This means, for example,
that an expression   <p>
<br>
<pre>     &rsquo;"&lt;a&gt;".."&lt;/a&gt;" or "&lt;/b&gt;"&rsquo;
</pre> <p>

<p> evaluates to the regions starting with CR"&lt;a&gt;" and ending with CR"&lt;/a&gt;",
or comprising only the string CR"&lt;/b&gt;". In order to obtain the regions that
begin with CR"&lt;a&gt;" and end with either CR"&lt;/a&gt;" or CR"&lt;/b&gt;", one should indicate
the proper order of evaluation using parentheses:   <p>
<br>
<pre>     "&lt;a&gt;".. ("&lt;/a&gt;" or "&lt;/b&gt;")
</pre> <p>
  Expressions can also contain  <i>comments</i>, which start with &rsquo;#&rsquo; and extend
to the end of the line. However, a &rsquo;#&rsquo;-sign in a phrase does not begin a comment.
 
<h2><a name='sect5' href='#toc5'>Semantics of Expressions</a></h2>

<p>  The value of an expression is a set of regions
of input text that satisfy the expression.  Value <b>v(basic_expr)</b> of a basic
expression:  
<dl>

<dt><a href='v.phrase.html'><b>v(phrase)</a>
:= </b></dt>
<dd>    the set of regions of input text whose text
equals the text of the phrase. </dd>

<dt><b>v(&rsquo;start&rsquo;):=</b></dt>
<dd>    a set consisting of single-character
regions for the first position of each input file. If the -S option is given,
the value is a set containing a single region that comprises the first
character in the input stream. </dd>

<dt><b>v(&rsquo;end&rsquo;):=</b></dt>
<dd>    a set consisting of single-character
regions for the last position of each input file. If the -S option is given,
the value is a set containing a single region that comprises the last character
in the input stream. </dd>

<dt><b>v(&rsquo;chars&rsquo;):= </b></dt>
<dd>    a set consisting of all single-character
regions. </dd>

<dt><b>v([ ]):= </b></dt>
<dd>    an empty set. </dd>

<dt><b>v([(s_1,e_1) (s_1,e_2) ... (s_n,e_n)]):=
</b></dt>
<dd>    a set consisting of regions  <b>r_i </b> for each  <b>i = 1,...,n,</b> where the start
position of region  <b>r_i </b> is  <b>s_i </b> and its end position is  <b>e_i. </b> The positions
have to be nonnegative integers, and the regions have to be given in increasing
order of their start positions; regions with a common start positions have
to be given in increasing order of their  end positions. The positions are
counted from the first character of each input file, unless the -S option
is given, in which case the positions are counted starting from the beginning
of the input stream. The number of the first position in a file or a stream
is zero. </dd>

<dt><b>v(&rsquo;(&rsquo;region_expr&rsquo;)&rsquo;):= v(region_expr).</b></dt>
<dd>      Value <b>v(operator_expr)</b> of
operator expressions: </dd>

<dt><b>v(region_expr &rsquo;in&rsquo; basic_expr):=</b></dt>
<dd>    the set of the
regions in <b>v(region_expr) </b> that are contained in some region in <b>v(basic_expr)</b>.
A region <b>x</b> is contained in another region <b>y</b> if and only if the start position
of <b>x</b> is greater than the start position of <b>y</b> and the end position of <b>x</b>
is not greater than the end position of <b>y</b>, or the  end position of <b>x</b> is
smaller than the end position of <b>y</b> and the start position of <b>x</b> is not smaller
than the start position of <b>y</b>. </dd>

<dt><b>v(region_expr &rsquo;not&rsquo; &rsquo;in&rsquo; basic_expr):=</b></dt>
<dd>    the
set of the regions in <b>v(region_expr) </b> that are not contained in any region
in  <b>v(basic_expr).</b> </dd>

<dt><b>v(region_expr &rsquo;containing&rsquo; basic_expr):=</b></dt>
<dd>    the set of
the regions in  <b>v(region_expr) </b> that contain some region in  <b>v(basic_expr).</b>
</dd>

<dt><b>v(region_expr &rsquo;not&rsquo; &rsquo;containing&rsquo; basic_expr):=</b></dt>
<dd>    the set of the regions in
 <b>v(region_expr) </b> that do not contain any region in <b>v(basic_expr).</b> </dd>

<dt><b>v(region_expr
&rsquo;equal&rsquo; basic_expr):=</b></dt>
<dd>    The set of regions, which occur in both <b>v(region_expr)
</b> and <b>v(basic_expr).</b> </dd>

<dt><b>v(region_expr &rsquo;not equal&rsquo; basic_expr):=</b></dt>
<dd>    The set of
regions, which occur in <b>v(region_expr) </b> but do not occur in <b>v(basic_expr).</b>
</dd>

<dt><b>v(region_expr &rsquo;or&rsquo; basic_expr):=</b></dt>
<dd>    the set of the regions that appear in
<b>v(region_expr) </b> or in <b>v(basic_expr) </b> or in both. </dd>

<dt><b>v(region_expr &rsquo;extracting&rsquo;
basic_expr):=</b></dt>
<dd>    the set of the non-empty regions that are formed of the
 regions in <b>v(region_expr) </b> by extracting an overlap with any region in
<b>v(basic_expr).</b> For example, the value of    <p>
<br>
<pre>    &rsquo;[(1,4) (3,6) (7,9)] extracting [(2,5) (4,7)]&rsquo; 
</pre> <p>
 consists of the regions (1,1) and (8,9).  </dd>

<dt><b>v(region_expr &rsquo;..&rsquo; basic_expr):</b></dt>
<dd>
   The value of this expression consists of the regions that can be formed
by <i>pairing </i> regions from  <b>v(region_expr) </b> with regions from  <b>v(basic_expr).</b>
The pairing is defined as a generalization of the way how nested parentheses
are paired together "from inside out".  For this we need to be able to compare
the order of regions, which may be overlapping and nested. This ordering
is defined as follows.  Let  <b>x </b> and  <b>y </b> be two regions. We say that region
 <b>x </b> <i>precedes </i> region <b>y </b> if the end position of  <b>x </b> is smaller than the
start position of  <b>y.</b> We say that region  <b>x </b> is  <i>later </i> than region  <b>y </b>
if the end position of  <b>x </b> is greater than the end position of  <b>y, </b> or
if they end at the same position and the start of  <b>x </b> is greater than the
start of  <b>y. </b> Region  <b>x </b> is  <i>earlier </i> than region  <b>y </b> if the start position
of  <b>x </b> is smaller than the start position of  <b>y, </b> or if they start at the
same position and the end position of  <b>x </b> is less than the end position
of  <b>y.</b> Now a region  <b>x </b> from  <b>v(region_expr) </b> and a region  <b>y </b> from <b>v(basic_expr)
</b> are paired in expression  <b>v(region_expr &rsquo;..&rsquo; basic_expr) </b> if and only if 
    <b>x </b> precedes  <b>y,</b>     <b>x </b> is not paired with any region  from  <b>v(basic_expr)
</b> which is earlier than  <b>y,</b> and      <b>y </b> is not paired with any region from
<b>v(region_expr) </b> which is later than  <b>x. </b> 
<p> The pairing of regions  <b>x </b> and
 <b>y </b> forms a region that extends from the start position of  <b>x </b> to the end
position of  <b>y.</b> </dd>

<dt><b>v(region_expr &rsquo;._&rsquo; basic_expr):</b></dt>
<dd> The pairing of the regions
from <b>v(region_expr) </b> and the regions from  <b>v(basic_expr) </b> is defined similarly
to  <b>v(region_expr &rsquo;..&rsquo; basic_expr) above,</b> except that the pairing of regions
 <b>x </b> and  <b>y </b> now forms a region which extends from the start position of
 <b>x </b> to the position immediately preceding the start of  <b>y.</b> </dd>

<dt><b>v(region_expr
&rsquo;_.&rsquo; basic_expr):=</b></dt>
<dd> The pairing of the regions from  <b>v(region_expr) </b> and the
regions from  <b>v(basic_expr) </b> is defined similarly to  <b>v(region_expr &rsquo;..&rsquo; basic_expr)
above, except that</b> the pairing of regions  <b>x </b> and  <b>y </b> now forms a region
which extends from the position  immediately following the end position
of  <b>x </b> to the end position of  <b>y.</b> </dd>

<dt><b>v(region_expr &rsquo;__&rsquo; basic_expr):=</b></dt>
<dd> The pairing
of the regions from  <b>v(region_expr) </b> and the regions from  <b>v(basic_expr)
</b> is defined similarly to  <b>v(region_expr &rsquo;..&rsquo; basic_expr)</b> above, except that
now the pairing of regions  <b>x</b> and <b>y</b> forms a region which extends from the
text  position immediately following the end of  <b>x</b> to the text position
immediately preceding the start of  <b>y</b>. Possibly resulting empty regions
are excluded from the result.  </dd>

<dt><b>v(region_expr &rsquo;quote&rsquo; basic_expr):</b></dt>
<dd> The value
of this expression consists of  the regions that extend from the start
position of a "<i>left-quote region</i>" in  <b>v(region_expr)</b> to the end position
of a corresponding  "<i>right-quote region</i>" in <b>v(basic_expr)</b>. The regions in
the result are non-nesting and non-overlapping. The left-quote regions and
the right-quote regions are defined as follows:     The earliest region
(see above) in <b>v(region_expr)</b> is  a <i>possible left-quote region</i>.     For each
possible left-quote region <b>x</b>, the earliest region in <b>v(basic_expr)</b> preceeded
by <b>x</b> is its right-quote region.     For each  right-quote region <b>y</b> in <b>v(basic_expr)</b>,
the earliest region in <b>v(region_expr)</b> preceeded by <b>y</b> is a possible left-quote
region. 
<p> The below example query finds C-style non-nesting comments:  <p>
<br>
<pre>        "/*" quote "*/"
</pre> <p>
 The below example query finds strings between quotation marks:  <p>
<br>
<pre>        "\"" quote "\""
</pre> <p>

<p> (Notice the difference to expression <b>"\"" .. "\""</b>,  which would evaluate
to any substring of input text that starts with  a quotation mark and ends
with the next quotation mark.)  The variants <b>_quote</b>, <b>quote_</b> and <b>_quote_</b>
are analogical to the operators <b>_.</b>, <b>._</b> and <b>__</b>, in the sense that  the "quote
regions" originating from the expression on the side of the underscore
<b>_</b> are excluded from the result regions. (In the case of <b>_quote_</b> any possibly
resulting empty regions are excluded from the result.)  </dd>

<dt><b>v(&rsquo;concat&rsquo; &rsquo;(&rsquo; region_expr
&rsquo;)&rsquo; ):=</b></dt>
<dd> the set of the longest regions of input text that are covered by
the regions in <b>v(region_expr).</b> </dd>

<dt><b>v(&rsquo;inner&rsquo; &rsquo;(&rsquo; region_expr &rsquo;)&rsquo; ):=</b></dt>
<dd> the set of regions
in <b>v(region_expr) </b> that do not contain any other region in  <b>v(region_expr).</b>
Note that for any region expression <b>A</b>, the expression  <b>inner(A)</b> is equivalent
to <b>(A not containing A)</b>. </dd>

<dt><b>v(&rsquo;outer&rsquo; &rsquo;(&rsquo; region_expr &rsquo;)&rsquo; ):=</b></dt>
<dd> the set of regions
in  <b>v(region_expr) </b> that are not contained in any other region in  <b>v(region_expr).</b>
Note that for any region expression <b>A</b>, the expression <b>outer(A)</b> is equivalent
to <b>(A not in A)</b>.   </dd>

<dt><b>v(&rsquo;join&rsquo; &rsquo;(&rsquo; n &rsquo;,&rsquo; region_expr &rsquo;)&rsquo; ):</b></dt>
<dd> The value of this expression
is formed by  processing the regions of v(region_expr) in increasing order
of their start positions (and in increasing order of end positions for
regions with a common start). Each region  <b>r</b> produces a result region beginning
 at the start of r and extending to the end of the (n-1)th region after
r. The operation is useful only with non-nesting regions. Especially, when
applied to &rsquo;chars&rsquo;, it can be used to express nearness conditions. For example,
  <p>
<br>
<pre>    &rsquo;"/*" quote "*/" in join(10,chars)&rsquo; 
</pre> <p>
 selects comments  "/*  ... */" which are at most 10 characters long.   </dd>
</dl>

<h2><a name='sect6' href='#toc6'>Examples
of Region Expressions</a></h2>

<p>  Count the number of occurrences of string "sort"
in file eval.c:  <p>
<br>
<pre>    sgrep -c &rsquo;"sort"&rsquo; eval.c
</pre> <p>
 Show all blocks delimited by braces in file eval.c:  <p>
<br>
<pre>    sgrep &rsquo;"{" .. "}"&rsquo; eval.c
</pre> <p>
 Show the outermost blocks that contain "sort" or "nest":   <p>
<br>
<pre>    sgrep &rsquo;outer("{" .. "}" containing ("sort" or "nest"))&rsquo;\
            eval.c
</pre> <p>
 Show all lines containing "sort" but no "nest" in files with an extension
.c, preceded by the name of the file:   <p>
<br>
<pre>    sgrep -o "%f:%r" &rsquo;"\n" _. "\n" containing "sort" \
                      not containing "nest"&rsquo; *.c
</pre> <p>
 (Notice that this query would omit the first line, since it has no preceding
new-line character &rsquo;\n&rsquo;,  and also the last one, if not terminated by a new-line.
For a correct way to express text lines, see the definition of the LINE
macro below.)  Show the beginning of conditional statements, consisting
of "if" followed by a condition in parentheses, in files *.c. The query has
to disregard "if"s appearing within comments "/* ... */" or on compiler control
lines beginning with &rsquo;#&rsquo;:   <p>
<br>
<pre>    sgrep &rsquo;"if" not in ("/*" quote "*/" or ("\n#" .. "\n"))  \
                        .. ("(" ..  ")")&rsquo; *.c
</pre> <p>
 Show the if-statements containing string "access" in their condition part
appearing in the main function of the program in source files *.c:   <p>
<br>
<pre>    sgrep &rsquo;"if" not in ("/*" quote "*/" or ("\n#" .. "\n"))  \
             .. ("(" ..  ")") containing "access" \
                              in ("main(" .. ("{" .. "}")) \
            .. ("{" .. "}" or ";")&rsquo;  *.c
</pre> <p>
 We see that complicated conditions can become rather illegible. The use
of carefully designed  <i>macros </i> can make expressing queries much easier.
 For example, one could give the  below m4 macro processor definitions
in a file, say, c.macros:   <p>
<br>
<pre>    define(BLOCK,( "{" .. "}" ))
    define(COMMENT,( "/*" quote "*/" ))
    changecom(%)
    define(CTRLINE,( "#" in start or "\n#" 
                      _. ("\n" or end) ))
    define(IF_COND,( "if" not in (COMMENT or CTRLINE) 
                      .. ("(" .. ")")))
</pre> <p>
 Then the above query could be written more intuitively as   <p>
<br>
<pre>    sgrep -p m4 -f c.macros -e &rsquo;IF_COND containing "access"\
           in ( "main(" ..  BLOCK ) .. (BLOCK or  ";")&rsquo; *.c
</pre> <p>
 
<h2><a name='sect7' href='#toc7'>Optimization</a></h2>

<p>  <b>sgrep</b> performs common subexpression elimination on the
query expression, so that recurring sub-expressions are evaluated only once.
For example, in expression   <p>
<br>
<pre>    &rsquo;(" " or "\n" or "\t") .. (" " or "\n" or "\t")&rsquo;
</pre> <p>
 the sub-expression   <p>
<br>
<pre>    &rsquo;(" " or "\n" or "\t")&rsquo;
</pre> <p>
 is evaluated only one. 
<h2><a name='sect8' href='#toc8'>Diagnostics</a></h2>

<p>  Exit status is 0 if any matching regions
are found, 1 if none, 2  for syntax  errors  or  inaccessible files (even
if matching regions were found).  
<h2><a name='sect9' href='#toc9'>Environment</a></h2>

<p>  One&rsquo;s own default options
for sgrep can be given as a value of the environment variable <i>SGREPOPT</i>.
For example, executing   <p>
<br>
<pre>    setenv  SGREPOPT  &rsquo;-p m4 -o %r\n&rsquo;
</pre> <p>

<p> makes sgrep to apply m4 preprocessor to the expression and display each
output region as such followed by a line feed.   
<h2><a name='sect10' href='#toc10'>Files</a></h2>

<p>  <b>Sgrep</b> tries to read
the contents of the files  <i>$HOME/.sgreprc</i> and  <i>/usr/lib/sgreprc</i>. Generally
useful macro definitions may be placed in  these files. Using m4 (or some
other) macro processor, for example the following definitions could go
in one of these files:   <p>
<br>
<pre>    define(BLANK,( " " or "\t" or "\n"))
    define(LEND,( "\n" or end ))
    define(LINE,( start .. LEND or ("\n" _. LEND) ))
    define(NUMERAL,( "1" or "2" or "3" or "4" or "5" or
                     "6" or "7" or "8" or "9" or "0" ))
</pre> <p>
  
<h2><a name='sect11' href='#toc11'>Future Extensions</a></h2>

<p>      Regular expressions (The most important missing
feature)     Built-in macro preprocessor     More operations     Indexing
for large static texts        
<h2><a name='sect12' href='#toc12'>Authors</a></h2>

<p>  Jani Jaakkola and Pekka Kilpelainen,
University of Helsinki, Department of Computer Science, 1995.  
<h2><a name='sect13' href='#toc13'>Bugs</a></h2>

<p>  <b>Sgrep</b>
may use lots of memory, when evaluating complex queries on big files.  When
sgrep reads its input text from a pipe, it  copies it to a temporary file.
sgrep does not have regular expressions in search patters.  
<h2><a name='sect14' href='#toc14'>See Also</a></h2>

<p>  <a href='awk.1.html'><b>awk(1)</a>
,
<a href='ed.1.html'>ed(1)</a>
,  <a href='grep.1.html'>grep(1)</b></a>
  sgrep home page at CR<a href='http://www.cs.helsinki.fi/~jjaakkol/sgrep.html'>http://www.cs.helsinki.fi/~jjaakkol/sgrep.html</a>

  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Syntax of Expressions</a></li>
<li><a name='toc5' href='#sect5'>Semantics of Expressions</a></li>
<li><a name='toc6' href='#sect6'>Examples of Region Expressions</a></li>
<li><a name='toc7' href='#sect7'>Optimization</a></li>
<li><a name='toc8' href='#sect8'>Diagnostics</a></li>
<li><a name='toc9' href='#sect9'>Environment</a></li>
<li><a name='toc10' href='#sect10'>Files</a></li>
<li><a name='toc11' href='#sect11'>Future Extensions</a></li>
<li><a name='toc12' href='#sect12'>Authors</a></li>
<li><a name='toc13' href='#sect13'>Bugs</a></li>
<li><a name='toc14' href='#sect14'>See Also</a></li>
</ul>
</body>
</html>
