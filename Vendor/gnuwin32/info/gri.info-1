This is gri.info, produced by makeinfo version 4.8 from gri.texi.

INFO-DIR-SECTION Scientific Applications
START-INFO-DIR-ENTRY
* Gri: (gri).  Programming language for scientific illustration
END-INFO-DIR-ENTRY


File: gri.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Gri
***

Gri is an extensible plotting language designed for scientists.  It can
draw x-y plots, contour plots, and image plots, and has rudimentary
programming capabilities.  It is not mouse driven, nor gui-based;
rather, it is an interpreted scriping language.  Users regard it as an
analogue to the latex document formatting language: users gain
considerable power, at the price of a moderate learning curve.

   This manual describes Gri version 2.12.10 (c) 1991-2005, Dan Kelley
at email address dankelley@users.sourceforge.net

   Gri is released with the GNU Public License (*Note License::).

* Menu:

* Introduction::                What Gri is for
* Simple Example::              Introductory example
* Invoking Gri::                Running/viewing/printing Gri
* Getting More Control::        Controlling axes, text, color, etc.

* X-y Plots::                   Drawing x-y linegraphs/scattergraphs
* Contour Plots::               Drawing contour plots
* Images::                      Drawing black+white or color images

* Examples::                    Some real-world examples
* Handling Data::               Dealing with oddly-configured data
* Commands::                    All about the many Gri commands
* Programming::                 How to program in the Gri language
* Environment::                 Related tools
* Emacs Mode::                  Editing Gri code inside Emacs
* History::                     How Gri has changed over time
* Installation::                How to install Gri
* Bugs::                        Known bugs, and how to report more
* Test Suite::                  Series of test programs
* Gri in the Press::            Further reading
* Acknowledgments::             Many folks have helped me with Gri
* License::                     Gri is open-source!

Three indices
* Concept Index::               Detailed index
* Index of Commands::           Commands in Gri
* Index of Builtins::           Builtin variables


File: gri.info,  Node: Introduction,  Next: Simple Example,  Prev: Top,  Up: Top

1 Introduction
**************

*Gri is a programming language for drawing science-style graphs*.  It
is not mouse-driven, and it does not draw business-style graphs (e.g.
pie charts, three-dimensional graphs).  Gri has substantial power in
advanced applications.  It has been proven to be easy to learn; for
simple applications, the learning curve is less than an hour.  Many
users regard Gri as the plotting equivalent of the LaTeX document
preparation system.

   *Computers Gri works on:* unix computers of many types, plus
Microsoft Windows, and Macintosh OSX.  You'll find Gri pre-packaged for
various unixes, e.g. linux/debian, linux/redhat, and freeBSD.

   *Capabilities of Gri* are those scientists commonly want, since Gri
was written by a scientist.  It is not so useful for business people -
e.g., Gri draws xy graphs (*Note X-y Plots::), contour plots (*Note
Contour Plots::), and image plots (*Note Images::), but it will not
draw pie-charts unless you teach it how.  The list of capabilities of
Gri is similar to many packages, but unlike many of the other packages,
Gri gives you control over line widths, fonts, grayscales, etc.  (*Note
Getting More Control::), and it is a programming language of moderate
power.

   *The Gri drawing metaphor* is that of pen on paper.  The ink in the
pen is opaque.  An item drawn in white ink will erase a previously drawn
underlying object drawn in black ink.  For example, to draw a timeseries
curve in which the region between positive data values and the y=0 axis
is filled with black ink, you might use (`draw curve filled') to draw
the timeseries with black ink (the default color), blackening the area
between the curve and the lower axis.  Then you could load white ink
into the pen (using the `set graylevel 1' or `set graylevel white'
command) and white-out a box drawn between the zero line and the lower
axis.  Then you'd load black ink back into the pen (`set graylevel 0')
and draw the curve again, so that the negative part would appear again.

   *Input/output* in Gri may be interactive or non-interactive.  For
interactive use, type `gri' at the system commandline prompt.  For
non-interactive use, with Gri commands in a command-file called
`cmd.gri', type `gri cmd.gri'.

   *Gri output* is in the PostScript page description language.  The
output is therefore of high quality, device-independent, capable of
being inserted into popular text processors (e.g. LaTeX), and easily
displayed.

   *Online help:* the Gri command `help' makes Gri list the first words
of all known commands, along with a hint for getting further help.  To
get more information, type `help' followed by a command-name (e.g.
`help read').  There is also a tiny bit of information stored online
and categorized by topic.  Get this by typing for example `help -
strings' (*Note Online Help::).

   *Data analysis* in Gri is limited.  It has rudimentary data analysis
functions, such as regression, column manipulation, smoothing, etc, but
it is not intended as an integrated analysis/graphics package.

   *System calls* are an easy and important facet of Gri.  It is easy
to use operating system commands within Gri (*Note System::; *Note
Operating System::; *Note Get Env::).  This allows you to use familiar,
powerful tools, and keeps Gri simple.  Particularly useful is the
ability to read files through operating system filters (*Note Open::).

   *Programming Gri* is quite straightforward, and users familiar with
other programming languages find it easy.  If Gri lacks a drawing
method, you can add it fairly easily, since Gri has programming elements
such as `if' statements (*Note If Statements::), `while' loops (*Note
While::), facilities for interacting with the user (*Note Query::), and
mechanisms for storing numbers in "variables" (*Note Variables::), and
text strings in "synonyms" (*Note Synonyms::).  The Gri syntax can be
augmented easily (*Note Adding New Commands::), and these augmentations
can be stored in a startup file (*Note Resource File::), creating
personalized versions of Gri.

   *Manuals:* Gri has an online texinfo manual, a PostScript manual, a
WWW manual, a cookbook and several reference cards.  It also has
several discussion groups (*Note Discussion Group::).

   *Version Numbering Scheme* 

   When you launch Gri interactively (without naming a commandfile,
i.e. by just typing `gri' at the unix prompt), you'll see something like

      gri - scientific graphic program (version 2.12.10)
      GPL Copyright 2005 by Dan E. Kelley.

      Type `help' for an overview of Gri commands, or see the
      full manual at
          /usr/share/doc/gri-2.12.10/html/index.html
      and its text-only version in the 'gri' INFO node.

      Visit http://gri.sourceforge.net for updates and resources.
     gri:

The last line is a prompt, suggesting that you type in Gri commands.
You may type `quit' to get out of gri.

   The first line gives the version number.  You can also get this by
running Gri with the command `gri -v'.  Version numbers have three
numbers separated by periods.  The first number increments for major
changes, the second for smaller changes, the third for still smaller
changes.  The second number also indicates whether a copy is an
experimental version or a more reliable release version.  Experimental
versions have the second digit being an odd integer, while release
versions have this digit being even.


File: gri.info,  Node: Simple Example,  Next: Invoking Gri,  Prev: Introduction,  Up: Top

2 Simple Gri Program and How to Run it
**************************************

This chapter introduces Gri with a common example: an x-y graph.  The
example is discussed in detail later (*Note X-y Plots::).  The data
files and command files here and throughout the manual should be
available to you in a directory `.../gri/examples' on unix machines.

2.1 Gri Command file
====================

Here is a Gri command file to plot a linegraph of a set of (x,y) data,
stored as space-separated columns in a file called `example1.dat':

     # Example 1 -- Linegraph of data in separate file
     open example1.dat     # Open the data file
     read columns x y      # Read (x,y) columns
     draw curve            # Draw data curve
     draw title "Example 1"# Title above plot

The first line is a comment, as are all things following hash symbols
(`#').  (An exception to this rule is made within strings contained
within the double-quote character `"'.  This allows `sed' system
commands to work as expected; (*Note System::).)

   The other lines are Gri command lines; (*Note X-y Plots::) for more
explanation.

2.2 Data File
=============

The data file `example1.dat' looks like:

     0.05 12.5  # first point
     0.25 19    # second point
     0.5  15    # third point
     0.75 15    # ... you get the idea!
     0.95 13

Note that spaces (or tabs) separate numbers.  Any data line may have a
comment on it, just as any command line may.

2.3 Running The Command File
============================

Type `gri example1.gri' at the system prompt.  Gri will create a
PostScript file called `example1.ps'.  For details on running Gri see
*Note Invoking Gri::.

2.4 Output Graph
================

The output PostScript file is called `example1.ps'.

 [image src="./examples/example1.png" text="../../../gri-2.12.10-src/doc/examples/example1.gri
" ]

   To view Gri output, use your favorite PostScript previewer.

   Note that in the above example, Gri automatically chose reasonable
scales for the axes, based on the range of the data.  The next chapter
illustrates that Gri also gives you control over such things.


File: gri.info,  Node: Invoking Gri,  Next: Getting More Control,  Prev: Simple Example,  Up: Top

3 Invoking Gri
**************

3.1 Invoking Gri in a nutshell
==============================

First, the short story.  In 90 percent of cases, Gri is run as

     gri myscript

   where the file `myscript.gri' holds a script (list of Gri commands),
and Gri will create a PostScript file called `myscript.ps' with the
output.

   Some folks like to give the `.gri' suffix explicitly, so they would
invoke Gri as

     gri myscript.gri

instead.

   If you'd rather not have `myscript.ps' as the PostScript output file
name (let's say you prefer `graph1.ps') you'd do

     gri -output graph1.ps myscript.gri

   Few readers will need to know more than this.  But, for the rest, the
table in the next section gives full details on all the optional
arguments that Gri can handle.

3.2 Using Gri to draw things
============================

To draw things, invoke Gri as

     gri [OPTIONS] [CmdFile [optional_arguments]]

where the square brackets indicate that the enclosed items are
optional.  The `OPTIONS' item may consist of one or more of the
following (explained below):

     [-batch]
     [-b]
     [-chatty N]
     [-c      N]
     [-debug]
     [-d]
     [-directory_default]
     [-directory pathname]
     [-help]
     [-h]
     [-no_bounding_box]
     [-no_cmd_in_ps]
     [-no_startup_message]
     [-output PS_file_name]
     [-private]
     [-no_private]
     [-publication]
     [-p]
     [-superuser N]
     [-trace]
     [-t]
     [-yes]
     [-y]
     [-version]
     [-v]
     [-warn_offpage]
     [-no_warn_offpage]
   
   Here, the optional `optional_arguments' are a mechanism to customize
the action of the given Gri script from the commandline.  After Gri
processes standard arguments (e.g. `-t' for tracing), it puts the
remaining commandline arguments into a list.  This behavior is borrowed
from C and othe languages, so Gri borrows the name of the list as well:
it's called the "arg" list, and its elements are available with the RPN
operators named `argc' (*Note Solitary Operators::) and `argv' (*Note
Unary Operators::).

   For a note on usage within the Emacs gri-mode, see *Note Filename
arguments when running gri::.

   *Details of command-line options* 

   * `-batch' or `-b' Stops Gri from printing out prompts and hints.

   * `-chatty N' or `-c N' Make Gri print out various informative
     messages.  The numerical value gives a level of chattiness.  A
     value of 1, the default if the `-chatty' code is not supplied,
     tells Gri to keep you informed of some important things, like the
     success in gridding data for contouring.  Higher values make Gri
     tell you more:

     Information printed at various chatty levels:
        * *0* The bare minimum is printed.  Thus invoking Gri as `gri
          -c 0'...  will make it as quiet as can be.

        * *1 or higher* (the default) The full filenames of the
          commandfiles are displayed at startup time.

          `convert columns to grid' prints percentage of grid filled,
          as well as a suite of diagnostics, if you've let it calculate
          the region of influence automatically.  It also prints a
          warning of the time it expects to take, before starting the
          calculation.

          `convert grid to image' prints characteristics of image
          created, including amount of image clipped.

          `read grid data' reports number of data values it could not
          read (since they were nonnumeric).

          `draw symbol' reports number of data points not drawn because
          they were missing or outside clip region (if one exists).

        * *2 or higher* `draw contour' prints value of contour being
          drawn.

          `open "...|"' prints the command to be passed to the operating
          system as well as the name of the temporary file being
          created; also notifies user when the temporary file is
          destroyed.

          `show image' reports histograms in intensity bands of 8 units,
          instead of the default 16 units.

        * *3 or higher* `show image' reports histograms in intensity
          bands of 4 units, instead of the default 16 units.


   * `-debug' or `-d' Sets the built-in variable flag `..debug..' that
     you can use to isolate blocks of code.

   * `-directory_default' Reports directory where `gri.cmd' is expected
     to be found, either in the default location or the one specified
     by `-directory' commandline option.

   * `-directory pathname' Specifies the directory where Gri looks for
     the startup file `gri.cmd'.  (This file teaches Gri the standard
     commands; Gri will report an error and die if it cannot find this
     file.)  If this switch is not provided - and it is normally not -
     then Gri looks for `gri.cmd' in a standard system directory
     (sometimes, but not always, `/usr/local/share/gri/2.12.10') which
     was specified during the compilation of the Gri program itself.
     For more on how Gri looks for `gri.cmd', see the subsection below.

   * `-no_bounding_box' Make the so-called "bounding box" in the
     PostScript file be the full page.  The bounding box is used by
     some PostScript previewers to clip the image to just the drawn
     parts of the page, and is used by the `epsfbox' macro in `latex'
     to automatically determine the geometry of the graph for inclusion
     in text.  Normally the bounding box is calculated automatically,
     to enclose all the items drawn on the page.  But the box may also
     be set with the `set bounding box' command (*Note Set Bounding
     Box::).

   * `-no_cmd_in_ps' Prevent Gri from inserting the lines of the
     commandfile into the PostScript file as comments.  (These comments
     can be used by the `-creator' commandline option (see above), but
     they take up a little bit of space and users might sometimes want
     to get rid of them.)

   * `-no_warn_offpage' Do not warn if items are offpage.  (Contrast
     this with `-warn_offpage'.)

   * `-output PS_file_name' Specify the PostScript filename.  If this
     is not specified, the PostScript filename is derived from the name
     of the commandfile (e.g. `mygraph.gri' produces `mygraph.ps'), or,
     for interactive use, it will have a name like `gri-00.ps', or
     `gri-01.ps' if the former file exists, etc.

   * `-no_startup_message' Stops Gri from printing the startup message.

   * `-private' Prevents inserting any information about the user into
     the PostScript file (see `-no_private', next).  As of version
     2.12.10, this privacy option is assumed by default.

   * `-no_private' Instructs Gri to include comments in the PostScript
     file that identify the user, state the commandline arguments used
     in invoking Gri, and that list all the commands that were
     executed.  This information can be recovered by calling Gri on the
     PostScript file, with the `-creator' commandline argument.  Until
     version 2.12.10, the default was to include this information, but
     a change was made out of privacy concerns.

   * `-publication' or `-p' Sets the built-in variable
     `..publication..' to 1.  You may use this to distinguish between
     working plots and publication plots, as in this example:

          if !..publication..
            draw time stamp
            draw title "working version of plot"
          end if

   * `-superuser' (This option is included here only for completeness.
     It should only be used by developers (who will alter the code to
     print debugging information if `-superuser' is set in addition to
     `-debug').  An optional value can be inserted (e.g. `-superuser
     2') to set the debugging level (retrievable by the function
     superuser()) to indicated integer value.  Specifying the
     `-superuser' command-line option sets the built-in variable
     `..superuser..' to 1 or the specified value.)

     For flag meanings, see `superuser' command (*Note Superuser::).
     Using the question-mark symbol `?' instead of a flag number makes
     Gri print out the list of flags.

   * `-trace' or `-t' Makes Gri print out command lines as they are
     executed; this has the same effect as the `set trace' command.

   * `-version' or `-v' Display version information and exit
     successfully.

   * `-warn_offpage' Causes warnings to be issued for all items drawn
     far off a 8.5x11 inch page.  This is the default.  (Contrast with
     `-no_warn_offpage'.)

   * `-yes' or `-y' Bypasses all `query' commands, making Gri act as
     though the user typed a carriage-return (thus giving the default)
     for each `query'.

   * `-help' or `-h' Prints explanation of options.

   * `CommandFile' If a command file `CommandFile' is specified, then
     commands will be read from that file instead of the keyboard.  If
     the `chatty' level is 1 or larger, Gri prints the names of the
     commandfiles at startup time.  It is conventional but not
     necessary that the filename ends in `.gri'.  If the filename does
     end in `.gri', you may delete this suffix; Gri will assume it as
     implied.


   *Executable scripts.* If you don't need to supply commandline
options, you can put the following line as the first line in your Gri
program

     #!/usr/bin/gri

(or point to wherever Gri is located on your machine), and `chmod +x'
the file.  Then you can run Gri simply by naming the file.  There is no
particular advantage in this, except for saving the typing of a few
characters, but some folks like this.

   *How Gri locates the* `gri.cmd' *file*.  In a normal installation,
Gri finds the `gri.cmd' file all by itself.  However, developers and
some others may wish to control where Gri looks for this file.  The
rules below specify how Gri looks for `gri.cmd'.
_Case 1_
     If `-directory' was given on the commandline used to invoke Gri
     (e.g. `gri -directory /some/place mycommand_file.gri'), then Gri
     will use the `gri.cmd' in the named directory.  An error will
     result if `gri.cmd' is not found there.

_Case 2_
     If `-directory' was not given on the commandline, then Gri looks
     for `gri.cmd' in a location that was specified during compilation.
     If `gri.cmd' is found there, then it is used.  If it is not
     found, then Gri checks to see if an environment variable named
     `GRI_DIRECTORY_LIBRARY' is defined.  If so, then Gri takes this to
     be the name of a directory that contains the `gri.cmd' file.  If
     `gri.cmd' is not found there, an error results.

3.3 Extracting commandfile from a PostScript file
=================================================

     gri -creator PostScriptFile

*See also* `-no_cmd_in_ps'.

   The `-creator' flag makes gri examine the indicate PostScript file,
and produce a facsimile of the command file (or interactively-typed
commands) that created this PostScript file.  (This only works if the
Gri command that created the PostScript file used the `-no_private'
commandline argument.)


File: gri.info,  Node: Getting More Control,  Next: Simple Example Revisited,  Prev: Invoking Gri,  Up: Top

4 Controlling Axes, Fonts, Colors, etc
**************************************

Gri provides a great many things that you can control, if you want to.
An introduction to some of these things is presented in the sections
below.

* Menu:

* Simple Example Revisited::    Adding more details
* Axis Scaling::                Gri automatically scales and draws axes
* Log And Linear::              Selecting log/linar axes
* Length::                      Adjusting axis length
* Range::                       Adjusting axis range
* Labels::                      Adjusting labels on axes
* Position::                    Positioning the axes
* Fonts::                       Setting fonts
* Pen Color::                   Controlling Pen color


File: gri.info,  Node: Simple Example Revisited,  Next: Axis Scaling,  Prev: Getting More Control,  Up: Getting More Control

4.1 An example
==============

Below is a followup to the previous example, which names the x and the y
axes.

     # Fancier version of Example 1
     open example1.dat
     read columns x y
     set x name "Time, hours"
     set y name "U, m/s"
     draw curve

   The difference is that the x and y axes are named with a `set'
command.  There are many `set' commands, and they are all pretty
simple, e.g. `set x size 15' makes the x-axis be 15 centimeters long,
instead of the default of 10 centimeters.  Indeed, you can control
anything you want in gri, e.g. graph size, line width, fonts, etc etc.
Speaking of fonts, the `$\alpha$' type of latex formatting of Greek
letters is supported in a limited way.  Also, Gri handles ISO-Latin-1
encodings as well as the U.S. style.

   The example below illustrates a few more `set' commands.  This
example is intentionally complicated, being about a good example of the
level of complexity of many plots made by Gri.  Read the comments to see
what is being done, and consult the plot as you read the commandfile.

 [image src="./examples/example3.png" text="../../../gri-2.12.10-src/doc/examples/example3.gri
" ] 

     # Example 3 -- Controlling scales, etc
     #
     # Example of how to control axis scales, etc.  This example makes
     # two panels, plotting the same data in different ways.
     #
     #
     # ----- PANEL 1 ------------------------------------------------
     #
     # Set up the x axis.
     #
     # Make the x axis run from 0 to 1, with labelled tics each 0.25.
     set x axis 0   1   .25
     # Make the x-axis be 5 cm long; in other words, make the plot 5 cm wide.
     set x size 5
     # Put 2 cm of space between the left edge of the plot and the left
     # edge of the paper.
     set x margin 2
     # Give the x-axis the name "t" with subscript 0.
     set x name "$t_0$"
     #
     # Set up the y axis.
     #
     # Make the y axis run from 10 to 20, with labelled tics at intervals
     # of 5 and smaller, unlabelled tics, at intervals of 1.  Other
     # commands are similar to those for the x-axis.
     set y axis 10 20 5 1
     set y size 10
     set y margin 2
     set y name "F"
     #
     # Now, read our simple data set.
     open example1.dat
     read columns x y
     close
     #
     # Draw a curve connecting these (x,y) data.  Note that the axes, as
     # defined above, will be drawn automatically along with the curve.
     draw curve


     #
     # ----- PANEL 2 ------------------------------------------------
     #
     # OK, now for a more complicated version.  We'll keep the same data, but
     # redraw it in a new panel, to the right of the first graph.  So, the
     # first step is to increase the x margin.  The {rpn} command simply
     # creates a number which is the sum of the old x margin (stored in
     # the variable ..xmargin..) and the old plot width (stored in
     # the variable ..xsize..), plus an extra 1 cm
     set x margin {rpn ..xsize.. ..xmargin.. + 1 +}
     #
     # Set the line thickness for the curve to 1 point (0.3 mm) and the
     # axis line thickness to 0.2 points (0.1 mm).
     set line width 1.0              # points
     set line width axis 0.2         # points
     # Set the tics to be 1.5 mm.
     set tic size 0.15               # centimetres
     # Draw axes and frame, with axes offset from frame.  Some
     # people find this more attractive.
     set axes style offset
     draw axes 1
     # Now draw the actual curve.
     draw curve
     # Superimpose dots (diameter 1.5 mm) at the data.
     set symbol size 0.15
     draw symbol bullet
     #
     # All done.
     # Draw a title above the plot.
     set font size 20
     \label = "Example 3 -- scales, axes, etc"
     draw label "\label" at          \
         {rpn 8.5 2.54 * "\label" width - 2 /} \
         {rpn ..ytop.. yusertocm 2 +}\
         cm


File: gri.info,  Node: Axis Scaling,  Next: Log And Linear,  Prev: Simple Example Revisited,  Up: Getting More Control

4.2 Axis scaling
================

Gri normally assumes that you are plotting scientific graphs, and
therefore whenever it sees a command like `draw curve' or `draw
symbol', it draws an appropriate axis first.  You can turn this feature
off, by using `draw axes none' before the other `draw' command.

   Furthermore, Gri picks axis scales by itself, by scanning the (`x',
`y') columns.  If you don't like the scales Gri picks, you can override
them (*Note Range::).

   Gri normally draws axes labelled at left and bottom, and with an axis
frame with tics all around.  If you don't like this default axis style
you can specify other styles.  For example, if the commands `draw x
axis' and `draw y axis' are placed before the `draw curve' command, Gri
will realize you've already specified axes, and just draw them on the
left and bottom sides of the box, without completing the axis frame.

   For your general use, Gri stores the minimum and maximum x and y
values of the *axes* in the variables `..xleft..', `..xright..',
`..ybottom..', and `..ytop..'.  It also stores the increments used in
labelling these axes in the `..xinc..'  and `..yinc..' variables.

   To determine the minimum and maximum values of column data, you may
use the built-in RPN functions `min', `max', and `mean' (*Note
Manipulation of Columns etc::).

   Gri stores the last (x,y) pair on a curve (whether data or axis) in
the `..xlast..' and `..ylast..' variables

   Gri stores the axis sizes in `..xsize..' and `..ysize..'.  It stores
the space to the left of the plot in `..xmargin..' and the space below
the plot in `..ymargin..'.


File: gri.info,  Node: Log And Linear,  Next: Length,  Prev: Axis Scaling,  Up: Getting More Control

4.3 Logarithmic and linear axes
===============================

Axes are linear by default; to make logarithmic axes, use commands `set
x type log' and `set y type log'.


File: gri.info,  Node: Length,  Next: Range,  Prev: Log And Linear,  Up: Getting More Control

4.4 Axis Length
===============

The axes are normally 10 centimetres long.  To set the axis lengths (in
centimetres), use commands like `set x size 5' and `set y size 7'.
Some people like the ratio of axes to be in the so-called golden ratio
`(root(5)-1)/2'; to get that, you could do this: 

     set x size 15
     set y size {rpn ..xsize.. 5 0.5 power 1 - 2 / *}

   For maps, you'll want the plot scaled so that shapes retain their
aspect ratio.  To do this, do `set x size .cm.' and then do `resize y
for maps' (or vice versa).


File: gri.info,  Node: Range,  Next: Labels,  Prev: Length,  Up: Getting More Control

4.5 Axis Range
==============

To override axis ranges set by Gri, use `set x axis' and `set y axis'.
With these commands, you specify the range of the axes; you may also
set the interval for numbered tics, and an interval for unnumbered
tics.  The unnumbered tics must be at an interval that divides evenly
into the numbered tic interval, but the numbered tic interval need not
divide into the min/max range.  Thus, `set x axis 0 1.1 0.5' will
create an axis that will range from 0 to 1.1, with labelled tics at the
values 0, 0.5 and 1.


File: gri.info,  Node: Labels,  Next: Position,  Prev: Range,  Up: Getting More Control

4.6 Axis Name
=============

To set the name of the x axis, use `set x name "string"', and similarly
for the y-axis.  The default names are `x' and `y'.


File: gri.info,  Node: Position,  Next: Fonts,  Prev: Labels,  Up: Getting More Control

4.7 Axis location
=================

If you don't like the default position of axes (at left and bottom), you
may get Gri to draw axes anywhere you like, using commands like `draw y
axis at right' (so the y axis is at the right-hand end of the x range)
or `draw x axis at top' (so the x axis is at the top of the plot); you
may even specify an exact location, such as `draw x axis at 22.2'.

   Normally, the x axis is placed at the bottom end of the y axis, and
the y axis is placed at the left end of the x axis.  Some people prefer
a style in which the axes are positioned a small offset away from these
locations.  To get this effect, you may either position the axes
yourself, or simply use the `set axes style offset' command (*Note
Set::).  If you want this axis style for all their plots, put the line
`set axes style offset' in your `~/.grirc' startup file (*Note Resource
File::).


File: gri.info,  Node: Fonts,  Next: Pen Color,  Prev: Position,  Up: Getting More Control

4.8 Fonts
=========

Fonts are selected with `set font to' (*Note Set Font To::) and font
sizes are selected with `set font size' (*Note Set Font Size::).

   Much more about text, including how to draw mathematical symbols,
how to use subscripts and superscipts, how to write non-English
(accented) European text, etc, is discussed (*Note Text::).


File: gri.info,  Node: Pen Color,  Next: X-y Plots,  Prev: Fonts,  Up: Getting More Control

4.9 Colour of ink in pen
========================

The darkness of the "pen" used in drawing commands (for either lines or
for text) is set by `set graylevel .brightness.'.  A brightness value
of 0 corresponds to black ink, and a brightness value of 1 corresponds
to white ink.  Values outside this range are clipped to the nearer
endpoint.  Values inside this range choose a proportional graylevel in
between; for example, `set graylevel 0.5' gives a 50 percent gray tone.

   The graylevel applies to text as well as lines.  Often you'll want to
draw a gray line and a black label beside it, or you'll want to set a
graylevel temporarily.  Here's how to do it:

     # Save old graylevl, set, then reset to old
     .old_gray. = ..graylevel..
     set graylevel 0.5
     draw curve
     set graylevel 0
     draw label for last curve "TEST"
     set graylevel .old_gray.

   The color of the "pen" may be set to any value you can describe with
an RGB (red, green, blue) or HSB (hue, saturation, brightness)
specification, or a color name.  This pen color applies to everything,
even text.

The `set color \name' command

   Set the pen color to the indicated name.  There are two types of
names: hexadecimal-triplet names and English names.

   Hexadecimal-triplet names are of a form often used in web-pages.
They consist of exactly 6 characters, which are divided by Gri into
three sets of two characters, specifying the red component, the green
component, and the blue component of the color, respectively.  These
components are in hexadecimal notation, i.e. ranging from 00 to FF,
indicating values from 0 to 255.  For example,
     set color ACD4EF
   sets a pastel blue color, almost the color of a robin's egg.

   The English colors are written simply in the form
     set color blue
   where the color is from the following list.  (Gri requires that you
use the exact form shown, including the capitilization.)  The color
mixes are identical to those used in X11.

     NAME               RED    GREEN  BLUE
     "white"            1.000  1.000  1.000
     "LightGray"        0.827  0.827  0.827
     "darkslategray"    0.184  0.310  0.310
     "black"            0.000  0.000  0.000
     "red"              1.000  0.000  0.000
     "brown"            0.647  0.165  0.165
     "tan"              0.824  0.706  0.549
     "orange"           1.000  0.647  0.000
     "yellow"           1.000  1.000  0.000
     "green"            0.000  1.000  0.000
     "ForestGreen"      0.133  0.545  0.133
     "cyan"             0.000  1.000  1.000
     "blue"             0.000  0.000  1.000
     "skyblue"          0.529  0.808  0.922
     "magenta"          1.000  0.000  1.000

To get more colors than those provided in the above list, use the `read
colornames' command.

   You should do a test case for your printer to see which colors you
find most to your liking.  You'll want to pick colors that look
different from each other.  In some cases you might want to avoid
dithered colors, since they look too broken on really thin lines.  For
example, on my printer I like the following colors: `black', `red',
`yellow', `green', `cyan', and `magenta'.

The `set color rgb .red. .green. .blue.' command

   This command sets the color using the red-green-blue color model.  If
you are familiar with how colors add (e.g. red plus green yields
yellow), then you might like this, but most people find it easier to use
the `set color hsb ...' style described below.

   Set the individual color components as follows.  The numbers
`.red.', `.green.' and `.blue.' range from 0 (for no contribution of
that color component to the final color) to 1 (for maximal
contribution).  Values less than 0 are clipped to 0; values greater
than 1 are clipped to 1. EXAMPLES:

     set color rgb 0   0   0  # black
     set color rgb 1   1   1  # white
     set color rgb 1   0   0  # bright red
     set color rgb 0.5 0   0  # dark red
     set color rgb 0   1   0  # pure green
     set color rgb 1   1   0  # yellow: red + green

The `set color hsb .hue. .saturation. .brightness.' command

   In this color model, the color ("hue") is specified with a single
parameter.  Many people find this easier than using the corresponding
`rgb' command.

   Set the individual color components as follows.  The numbers
`.hue.', `.saturation.' and `.brightness.' range from 0 to 1.  The
color, represented by `.hue.', ranges from 0 for pure red, through 1/3
for pure green, and 2/3 for pure blue, and back to 1 again for pure
red.  (HINT: It is a good idea to limit the total range of hue you use
to 2/3, instead of 1; otherwise you'll get confused by (nearly)
repeated colors at the crossover.  For example, limit the hue to range
from 1/3 to 1, or 0 to 2/3.)  The purity of the color, represented by
`.saturation.', ranges from 0 (none of the hue is visible) to 1 (the
maximal amount is present).  Less saturated colours are like those you
would get from mixing black paint into colored paint.  The brightness
of the color, represented by `.brightness.', ranges from 0 (black) to 1
(maximal brightness).  Lowering brightness is like decreasing the
intensity of the light you shine on a painting.

   Hue, saturation, and brightness values are all clipped to the range
0 to 1.  EXAMPLES:

     set color hsb 0    1   1  # pure, bright red
     set color hsb 0    1 0.5  # half black, half red
     set color hsb .333 1   1  # pure, bright green


File: gri.info,  Node: X-y Plots,  Next: Linegraphs,  Prev: Pen Color,  Up: Top

5 X-Y Plots
***********

* Menu:

* Linegraphs::                  x-y graphs with data connected by line segments
* Scattergraphs::               x-y graphs with data indicated by symbols
* Formula Plots::


File: gri.info,  Node: Linegraphs,  Next: Scattergraphs,  Prev: X-y Plots,  Up: X-y Plots

5.1 Linegraphs
==============

The following Gri commands will draw a linegraph.  For the output graph
(*Note Getting More Control::).  

   This plots a simple linegraph:

     # Example 1 -- Linegraph using data in a separate file

     open example1.dat      # Open the data file
     read columns x y       # Read (x,y) columns
     draw curve             # Draw data curve
     draw title "Example 1" # Title above plot

   Here's what the command lines mean:

   * The first line is a comment.  Anything to the right of a hash-mark
     `#' is considered to be a comment.  (This symbol is also called a
     "pound".)

   * The second line is blank.  Gri ignores blank lines between
     commands.

   * `open example1.dat' tells Gri to open the indicated file (in the
     current directory) as an input data file.  You can specify files
     outside the current directory by using conventional unix-shell
     pathnames (e.g., `open ~/data/TS/section1/T_S.dat' or `open
     ../data/file.dat').  You can even use "synonyms" (*Note
     Synonyms::.) in filenames, as in `open \BASENAME.dat'.

   * `read columns x y' tells Gri to start reading columnar data, the
     first column being `x', the second `y'.  `x' and `y' are
     predefined names for whatever ends up on the horizontal and
     vertical axes.

     The number of data needn't be specified.  Gri reads columns until a
     blank line or end-of-file is found.  You can tell Gri how many
     lines to read with a command like `read columns 10 x y'.  Multiple
     datasets can reside within one file; provided that they are
     separated by a single blank line, Gri can access them by multiple
     `read' commands.

     Like C, Gri expects numbers to be separated by one or more spaces
     or tabs.  Commas are not allowed.  If the columns were reversed,
     the command would be `read columns y x'.  If there were an initial
     column of extraneous data, the command would be `read columns * x
     y', or `read columns x=2 y=3' (*Note Read Columns::).

   * `draw curve' tells Gri to draw a curve connecting the points in
     the `x' and `y' columns. A nice scale will be selected
     automatically.  (You can change this or any other plot
     characteristics easily, as you'll see later.)  

   * `draw title' tells Gri to write the indicated string centered
     above the plot. The title *must* be enclosed in quotes.  

   * `quit' tells Gri to exit.

   Gri will draw axes automatically, and pick its own scales.

   If you wish to draw several curves which cross each other, you should
try using `draw curve overlying' instead of `draw curve'.  This will
make it easier to distinguish the different curves.


File: gri.info,  Node: Scattergraphs,  Next: Formula Plots,  Prev: Linegraphs,  Up: X-y Plots

5.2 Scattergraphs
=================

This section contains two examples, the first being a fuller explanation
of all the bells and whistles, the second being a simple explanation of
how to get a very quick plot, given just a file containing a matrix of
grid data.

   To get a scattergraph with symbols at the data points, substitute
`draw symbol' for `draw curve'.  Both symbols and a curve result if
both `draw curve' and `draw symbols' are used.  See *Note Getting More
Control:: for an example.

   By default, the symbol used is an x.  To get another symbol, use a
command like `draw symbol 0' or `draw symbol plus'.

   To change the symbol size from the default of 0.2 cm use commands
like `set symbol size 0.1' to set to 1 mm (*Note Set Symbol Size::).

5.2.1 Coding data with symbols
------------------------------

To get different symbols for different data points, insert symbol codes
from the above list as a column along with the x-y data, and substitute
the command `read columns x y z', and then draw them with `draw
symbol'.  Gri will interpret the rounded-integer values of the `z'
columns as symbol codes.  Note that even if you've read in a z column
which you intend to represent symbols, it will be overridden if you
designate a specific symbol in your `draw symbols' command; thus `draw
symbol 0' puts a `+' at the data points whether or not you've read in a
symbol column.

5.2.2 Drawing a symbol legend
-----------------------------

The following example shows how you might write a symbol legend for a
plot.  The legend is drawn 1 cm to the right of the right-hand side of
the axes, with the bottom of the legend one quarter of the way up the
plot; *Note Draw Symbol Legend::.  The lines in the legend are
double-spaced vertically.  To change the location of the legend, alter
the `.legend_x. =' and `.legend_y. =' lines.  To change the spacing,
alter the `.legend_y. +=' line.

     set x axis -1 5 1
     set y axis -1 5 1
     read columns x y z
     0 0 0
     1 1 1
     2 2 2
     3 3 3

     draw symbol

     # Legend
     .leg_x. = {rpn ..xmargin.. ..xsize.. + 1 +}
     .leg_y. = {rpn ..ymargin.. ..ysize.. 4 / +}
     draw symbol legend 0 "Foo" at .leg_x. .leg_y. cm
     .leg_y. += {rpn "M" ascent 2 *}
     draw symbol legend 1 "Bar" at .leg_x. .leg_y. cm
     .leg_y. += {rpn "M" ascent 2 *}

5.2.3 Coding data with symbol colors
------------------------------------

To get different colors for different symbols, read a color code into
the z column, and do for example `draw symbol bullet color hue z'.  The
numerical color code ranges from 0 (red) through to 1, passing through
green at 1/3 and blue at 2/3.


File: gri.info,  Node: Formula Plots,  Next: Contour Plots,  Prev: Scattergraphs,  Up: X-y Plots

5.3 Formula Plots
=================

There are two methods for formula graphs.

  1. *Use the system yourself.* Do as in this example:

          open "awk 'BEGIN{for(i=0;i<3.141;i+=0.05)\
              {print(i,cos(i))}}' |"
          read columns x y
          close
          draw curve


  2. *Let Gri calculate things for you*

     The simplest is to let Gri calculate things for you with the
     `create columns from function' command (*Note Create::).  The
     command assumes that you have defined the synonym called
     `\function' which defines `y' in terms of `x'.

     Gri uses the program `awk' to create the columns, and cannot work
     without it.

     Here is an example of using `create columns from function':

          show "First 2 terms of perturbation expansion"
          set y axis name horizontal
          set y name "sea-level"
          set x name "$\omega$t"

          \b = "0.4" # perturbation parameter b=dH/H
          \xmin = "0"
          \xmax = "6.28"
          \xinc = "3.14 / 20"
          \function = "cos(x)"
          set x axis \xmin \xmax
          create columns from function
          draw curve
          draw title "SOLID LINE  \function"

          \function = "(cos(x)+\b/2*(1-cos(2*x)))"
          create columns from function
          set dash 1
          draw curve
          draw title "DASHED LINE \function"

          draw title "b = \b"

     Here's another example, in which the curve `y = 1/(\int + \sl*x)'
     is drawn through some data.  Note how `sprintf' is used to set
     `\xmin' and `\xmax' using the scales that Gri has determined in
     reading the data.

          open file.data
          read columns x y
          close
          draw symbol bullet
          \int = "-0.1235"
          \sl = "0.003685"
          sprintf \xmin "%f" ..xleft..
          sprintf \xmax "%f" ..xright..
          \function = "1/(\int + x * \sl)"
          create columns from function
          draw curve



File: gri.info,  Node: Contour Plots,  Next: Pre-gridded Data,  Prev: Formula Plots,  Up: Top

6 Contour Plots
***************

Contour plots can be done with either pregridded data or randomly
distributed (ie, ungridded) data.

* Menu:

* Pre-gridded Data::            Contouring f(x1, y1, x2, y2, ...)
* Ungridded Data::              Contouring f(x, y) where (x,y) are not on a grid


File: gri.info,  Node: Pre-gridded Data,  Next: Ungridded Data,  Prev: Contour Plots,  Up: Contour Plots

6.1 Pre-gridded Data
====================

This section presents two examples of contouring pre-gridded data, the
first example illustrating a boilerplate program to contour data stored
in a simple matrix form in a file, the second example illustrating a
case with more control of the details (e.g., a nonuniform grid).

6.1.1 Simple example
--------------------

This example was hardwired to know the size of the grid, etc.  Here's
an example which is more general, in that it determines the dimensions
of the grid data from using unix system commands.  Note that the grid is
set to run from 0 to 1 in both x and y; you'll most likely want to
change that after you see the initial plot, but this should get you
started.

     \file = "somefile.dat"
     \rows = system wc \file      | awk '{print $1}'
     \cols = system head -1 \file | awk '{print NF}'
     set x grid 0 1 /\cols
     set y grid 0 1 /\rows
     open \file
     read grid data \rows \cols
     close
     draw contour

6.1.2 Complicated example
-------------------------

To get a simple contour graph based on pre-gridded data, with full
control of axes, etc, do something like this: 

 [image src="./examples/example4.png" text="../../../gri-2.12.10-src/doc/examples/example4.gri
" ]

     # Example 4 -- Simple contour graph

     #
     # Read x-grid; blank-line means stop reading.
     read grid x
     0
     .2
     1

     # Note that the x-grid was irregular.  The y-grid
     # in this example is regular, so we can just set
     # it to range from 10 to 20, incrementing by 2.5.
     set y grid 10 20 2.5
     # Thus we now have a grid 3 wide and 5 high.  Let's
     # read the actual data now.
     read grid data
     1 2 3
     2 3 4
     3 4 5
     4 5 6
     5 6 7

     # Now draw contours (automatically set; we could
     # have done `draw contour 2' to draw contour for
     # value 2 or `draw contour 1 10 2' to draw contours
     # ranging from 1 to 10 with an increment of 2.)
     draw contour
     draw title "Example 4"

   Here several new things have been introduced.

   First, you've got to define a grid in xy space.  This example uses a
non-uniform x-grid, and reads it in from the commandfile.  In this form,
the blank line is essential; it tells Gri that the end of data has been
located; if you like, you can specify the number of lines to read, as in
`read grid x 3'.

   The y-grid for this example is uniform, however, so it may be
specified with the `set y grid' command.  It obtains values (10, 12.5,
15, 17.5, 20).  The `set x|y grid' commands accept negative increments.
Furthermore, it is possible to specify the number of steps, rather than
the increment size, by putting `/' before the third number; thus `set x
grid 0 1 /5' and `set x grid 0 1 0.2' are equivalent.

   Having defined a grid, it is time to read in the gridded data.  Here
this is done with the `read grid data' command.  Since Gri already knows
the grid dimensions, it will read the data appropriately.  You could
also have told it (`read grid data 3 5').

   The first dataline is the top of the y-grid.  In other words, the
data appear in the file just as they would on the graph, assuming that
the x-grid and y-grid both increase.

   Sometimes you want to read in the transpose of a matrix.  Gri lets
you do that.  If the `bycolumns' keyword is present at the end of the
`read grid' command, the first dataline will contain the first
*column*, of the data.

   If you have an extraneous column of data to the left of your data
matrix, do `read grid data * 2 3'

   Now Gri has the grid in its head.  We tell it to draw some contours
with the `draw contour' command.   As the comments in the example show,
the contour values will be selected automatically, but you can alter
that.


File: gri.info,  Node: Ungridded Data,  Next: Images,  Prev: Pre-gridded Data,  Up: Contour Plots

6.2 Ungridded data
==================

When you have f=f(x,y) points at random x and y, you must cast them onto
a grid to contour them.  This is a difficult problem.  There are many
ways to grid data, and all have both good and bad features.  You should
try various methods, and various settings of the parameters of the
methods.  If you have a favorite gridding method that you prefer, you
should probably pre-grid the data yourself.  If not, Gri can do it for
you.  Gri has two methods for doing this, the "boxcar" method and the
"objective analysis" method.  Each method puts holes in the grid
wherever there are too few data to map to grid points, unless you
specifically ask to fill in the whole grid.

   The next two sections show first an example, then a discussion of the
methods and how to use them.

6.2.1 Example
-------------

This example uses data taken from Figure 5 of S. E.  Koch and M.
DesJardins and P. J. Kocin, 1983.  "An interactive Barnes objective map
anlaysis scheme for use with satellite and conventional data,", J.
Climate Appl.  Met., vol 22, p. 1487-1503.  Readers should compare
Figures 5 and 6 of that paper to the results shown here.

 [image src="./examples/example5.png" text="../../../gri-2.12.10-src/doc/examples/example5.gri
" ] 

     # Example 5 - Contouring ungridded data, from figure
     # 5 of Koch et al., 1983, J. Climate Appl. Met.,
     # volume 22, pages 1487-1503.
     open example5.dat
     read columns x y z
     close
     set x size 12
     set x axis 0 12 2
     set y size 10
     set y axis 0 10 2
     draw axes
     set line width symbol 0.2
     set symbol size 0.2
     draw symbol bullet
     set font size 8
     draw values
     set x grid 0 12 0.25
     set y grid 0 10 0.25

     # Use default method (Barnes)
     convert columns to grid

     set font size 10
     draw contour 0 40 2
     set font size 12
     draw title "Example 5 -- wind (Fig5 Koch et al, 1983)"

6.2.2 Discussion of Methods
---------------------------

The various commands for converting columns to a grid are given in
(*Note Convert Columns To Grid::).  Generally, the Barnes method is
best.


File: gri.info,  Node: Images,  Next: Reading and Creating Image Data,  Prev: Ungridded Data,  Up: Top

7 Image Plots
*************

Gri can read in images stored in various formats.  It can also create
image data internally, by converting gridded data, which is quite handy
in some contouring applications.

   Note: if your diagram is to be reproduced by a journal, it is
unlikely that the reproduction will be able to distinguish between any
two graylevels which differ by less than 0.2.  Also, graylevels less
than 0.2 may appear as pure black, while those of 0.8 or more may
appear as pure white.  These guidelines are as specified by American
Geophysical Union (publishers of J. Geophysical Res.), as of 1998.

* Menu:

* Reading and Creating Image Data:: Reading image, and creating from grid data
* Image PostScript Output::     How the image is embedded in the PostScript
* Example Image::               How to plot a satellite image


File: gri.info,  Node: Reading and Creating Image Data,  Next: Image PostScript Output,  Prev: Images,  Up: Images

7.1 Reading and Creating Image Data
===================================

Gri can do black and white image plots, such as satellite images.  There
are several ways to create image data in Gri
   * Create images from gridded data using `convert grid to image'.  For
     examples see *Note Grayscale Images::), *Note Combination::, and
     *Note Contouring::.

   * Read raw ascii image data files.  Use `read grid'.

   * Read PGM (portable graymap) ascii files.  (That is, a file with
     magic characters `P1' or `P3' at the start.)  Use the `read image
     pgm' command, for a file opened in ascii mode with `open filename'.

   * Read raw binary data, with or without headers.  Use `read image',
     after skipping any header bytes using the `skip' command, for a
     file opened in binary mode with `open filename binary'.

   * Read a Sun "rasterfile" file (but only in uncompressed form).  Use
     `read image rasterfile' for a file opened in binary mode with
     `open filename binary'.

   * Read a PGM (portable graymap) binary file.  (A file with magic
     characters `P2' or `P4' at the start.)  Use the `read image pgm'
     for a file opened in binary mode with `open filename binary'.

   * Aside: Images can be converted to grids (for contouring) using
     `convert image to grid' (*Note Convert::).

   Once the image is created, its grayscale/colorscale may be
manipulated with the commands `set image grayscale' and `set image
colorscale', which permit linear and histogram-equalized blendings over
the grayscale or color range, or with `read image grayscale' and `read
image colorscale', which permit reading in the grayscale or color
values individually, one for each of the 256 pixel values.

   It is important to understand the structure of image data.  Gri works
only with 8-bit image data.  This means that a given pixel of the image
may have only one of 256 possible values.  The example below uses a
satellite image of surface temperature.  The suppliers of the data
dictate that pixel value 0 corresponds to a temperature of 5C, and a
pixel value of 255 corresponds to 30.5C, so the resolution is 0.1C per
pixel value.  This resolution will be apparent if the output of the
example below is previewed on a grayscale/color monitor -- notice the
quantization in the palette.  This resolution issue is not very
important with satellite images, since you have to use what you are
given by the suppliers of the data.  However, the issue is very
important when you are converting grid data to images.  When Gri
converts grid data to image data, it neccessarily discards information,
because the grid data have resolution to about 6 digits, whereas the
image data have only 8-bit (2-3 digit) resolution.  The `set image
range' commands determines the range of this 8-bit resolution in terms
of user units.  All other things being equal, it would be preferable to
use the smallest range consistent with the range of your data.  If your
grid data ranged from 0 to 1, say, you might `set image range 0 1'.
This would give a resolution in the image of 1/255 in the user units.
But, when Gri converts the grid into an image, it will *clip* all data
outside the indicated range.  In this case, any data greater than 1 in
the grid would translate to *exactly* 1 in the image.  Naturally there
is a tradeoff between having a range large enough to encompass any data
in the grid, and a range small enough to yield adequate resolution.  In
most cases, 8-bit resolution will be adequate, but it is good to be
aware of the limitations.  One should always `draw image palette', and
check it on a color monitor for bandedness, which is a sign of
resolution problems.


File: gri.info,  Node: Image PostScript Output,  Next: Example Image,  Prev: Reading and Creating Image Data,  Up: Images

7.2 About The PostScript Output
===============================

Programmers Note: Gri inserts some special comments in the PostScript
file, to help programmers extract the image data; to extract the
information, you'll have to understand how PostScript handles images.
Gri inserts a single comment line before a line ending in the token
`im':

     %BEGIN_IMAGE
     170.70 170.70 534.86 534.86 128 128 im
   The first four numbers are the (x,y) locations of the lower-left and
upper-right corners of the image, in units of points on the page (72
points = 1 inch).  The fifth and sixth numbers are the width of the
image and the height of the image.  The keyword `im' is always present
on this line.  Gri inserts the following comment line at the end of the
image data

     %END_IMAGE


File: gri.info,  Node: Example Image,  Next: Examples,  Prev: Image PostScript Output,  Up: Images

7.3 Example (Satellite image)
=============================

Here's an example that will plot different types of images, depending on
your answers to `query' questions.  The file called `\filename' is the
data file, in binary format with one byte (`unsigned char' in C) for
each pixel, stored with the northwest pixel first, and the pixel to the
east of that next. The file called `\mask' is in the same format, and
the numbers are 0 if the point is over the sea and 1 if over land.  The
mask file is used in computing the histograms, which is done if
`\histo' is 1.

   The file in this example covers 128 * 128 pixels over the Gulf of
Maine. The numbers in `\filename' correspond to surface temperatures
according to the equation

     T = 5 + 0.1 * pixel_value

which explains the following lines in the command file:

     \0val = "5"             # 0 in image
     \255val = "30.5"        # 255 in image

   Depending on `\histo', the graymap will be linear or
histogram-enhanced. The histogram method consists of dividing the
cumulative histogram for the values in the image up into 256 levels,
and assigning a graylevel to each.  This has the effect of creating
maximal contrast in all ranges of graylevel. It points up features
really well, but it is a nonlinear mapping, so it is not good for
telling you where gradients are strong or weak.

   Examples are shown for linear mapping and histogram mapping.  

 [image src="./examples/example6.png" text="../../../gri-2.12.10-src/doc/examples/example6.gri
" ]

 [image src="./examples/example6histogram.png" text="../../../gri-2.12.10-src/doc/examples/example6histogram.gri
" ] 

     # Example 6 -- Plot IR image of Gulf of Maine
     # Define characteristics of norda images
     # Note that the pixel to temperature conversion formula is
     #
     #   Temperature = 5C + pixel_value / 10
     #
     # where pixel_value ranges from 0 to 255.  Thus, a pixel value of 0
     # corresponds to a temperature of 5C, and 255 corresponds to 30.5C;
     # this is why the limits \0val and \255val, for use by the `set image
     # range' command, take on these values.
     \0val = "5"                     # 0 in image
     \255val = "30.5"                # 255 in image
     .rows. = 128
     .cols. = 128
     .pixel_width. = 2
     .km. = {rpn .cols. .pixel_width. *}

     # get filenames
     query \filename "Name image file" ("example6image.dat")
     query \maskname "Name mask  file" ("example6mask.dat")

     # get data, then mask, each in 8-bit image format
     open \filename 8bit
     set image range \0val \255val
     read image .rows. .cols. box 0 0 .km. .km.
     close
     open \maskname 8bit
     read image mask .rows. .cols.
     close

     # find out what grayscale method to use
     query \histo "Do histogram enhancement? (yes|no)" ("no")
     query \minT  "T/deg for white on page?          " ("10")
     query \maxT  "T/deg for black on page?          " ("15")
     \incT = "1"

     # set up scales.
     set x size 12.8
     set y size 12.8
     set x name "km"
     set y name "km"
     set x axis 0 .km. 32
     set y axis 0 .km. 32

     # plot image, grayscale, and histogram
     if {"\histo" == "yes"}
         set image grayscale using histogram black \maxT white \minT
     else
         set image grayscale black \maxT white \minT
     end if
     draw image
     draw image palette left \minT right \maxT increment \incT
     draw image histogram
     if {"\histo" == "yes"}
         draw title "Example 6: grayscale histogram enhanced"
     else
         draw title "Example 6: grayscale linear \minT to \maxT"
     end if


File: gri.info,  Node: Examples,  Next: Box Plots,  Prev: Example Image,  Up: Top

8 Real-world examples
*********************

The example files in this manual should be available to you directly,
having been installed with Gri; if not, ask your system manager to check
the FTP site.

   Additionally, I've collected a few real life examples here.  Other
sources are the Gri cookbook, available at
`http://gri.sourceforge.net/gri-cookbook/index.html'.

* Menu:

* Box Plots::                   Tukey box plots, which show histograms
* Contouring::                  sample contour plot
* Grayscale Images::            create and plot image, from gridded data
* Combination::                 image and contour combination plot
* Fancy::                       fancy plot with lots of tricks
* Legend::                      plot with annotated curves and legend
* Polygons::                    read geometry, then draw polygon
* TS Diagram::                  temperature-salinity diagrams
* PDF Diagram::                 probability-density function
* Running Means::               skyline plot of running means
* Finite Element Model Mesh::   plotting mesh of FEM-type model
* Handling Data::               samples of handling data


File: gri.info,  Node: Box Plots,  Next: Contouring,  Prev: Examples,  Up: Examples

8.1 Box plots
=============

Box plots were invented by Tukey for eda (exploratory data analysis).
They show nonparametric statistics.  The centre of the box is the
median.  The box edges show the first quartile (q1) and the third
quartile (q3).  The distance from q3 to q1 is called the inter-quartile
range.  The whiskers (lines with crosses on them) extend to the furthest
points still within 1.5 inter-quartile ranges of q1 and q3.  Beyond the
whiskers, all outliers are shown, in open circles up to a distance of 3
inter-quartile ranges beyond q1 and q3, and in closed circles beyond
that.  Below is an example that uses a "new command" to define each box
plot (*Note Adding New Commands::).

 [image src="./examples/example7.png" text="../../../gri-2.12.10-src/doc/examples/example7.gri
" ]

     # Example 7 -- Box plots of mixing efficiency vs density ratio (meddy)

     `Draw y boxplot from \file at .x.'
     Draw a y boxplot for data in given file, at given
     value of x.
     {
         open \.word4.
         read columns * y
         close
         draw y box plot at \.word6.
     }
     if !..publication..
         draw time stamp
     end if
     set x axis 1 3 1 0.1
     set x name "Density Ratio, $R_\rho$"
     set x margin 4
     set y axis -2 1 1
     #
     # Must fool gri into not drawing the axes, because the y data
     # are already in logspace.
     draw axes none
     Draw y boxplot from example7a.dat at 1.3
     Draw y boxplot from example7b.dat at 1.4
     Draw y boxplot from example7c.dat at 1.5
     Draw y boxplot from example7d.dat at 1.6
     Draw y boxplot from example7e.dat at 1.7
     Draw y boxplot from example7f.dat at 1.8
     Draw y boxplot from example7g.dat at 1.9
     delete y scale
     set y name "Efficiency, $\Gamma$"
     set y type log
     set y axis 0.01 10 1
     draw axes
     draw title "Example 7 -- Box plot"


File: gri.info,  Node: Contouring,  Next: Grayscale Images,  Prev: Box Plots,  Up: Examples

8.2 Contouring
==============

This example plots a section of dT/drho vs x and rho (actually, sigma-t,
as the label indicates).  The contours are unlabelled; I'm only
interested in the zero crossings.

   There are some other useful tricks in this example, such as calling
`awk' and `wc' from the unix system.

   (In the plot shown, all `query' questions were answered with
carriage return, yielding the defaults; the `-p' flag was specified on
execution, so the time stamp was not drawn.)

 [image src="./examples/example8.png" text="../../../gri-2.12.10-src/doc/examples/example8.gri
" ]

     # Example 8 -- Plot T=T(x,rho) section of eubex data

     `Initialize Parameters'
     {
         \FILE_DATA = "example8a.dat" # T vs rho
         \FILE_LOCN = "example8b.dat" # section distances
         set missing value -99.0
         #
         # Following values from ~/eubex/processing/to_rho_bins/do_rho_inter
         \RHO_MIN = "28.1"
         \RHO_MAX = "27.5"
         \RHO_INC = "-0.002"
         \NY = "301"
         \xmin = "350"
         \xmax = "0"
         \xinc = "-100"
         \ymin = "28.1"
         \ymax = "27.8"
         \yinc = "-0.1"
         \zmin = "0"
         \zmax = "2.5"
     }
     `Initialize Axes'
     /*
     Set up axes
     */
     {
         set x name "km"
         set x size 10
         set x axis \xmin \xmax \xinc
         set y name "$\sigma_T$"
         set y size 5
         set y axis name horizontal
         set y axis \ymin \ymax \yinc
         set y format "%.1f"
     }
     `Initialize Files'
     {
         query \data "Data file?   " ("\FILE_DATA")
         query \locn "Station locn?" ("\FILE_LOCN")
     }
     `Read Data'
     {
         # Read x-locations
         system awk '{print $2}' < \locn > TMP
         system wc TMP | awk '{print $1}' > NUM
         open NUM
         read .gridx_number.
         close
         system rm NUM
         open TMP
         read grid x .gridx_number.
         close
         system rm TMP
         # Create y-locations
         set y grid \RHO_MIN \RHO_MAX \RHO_INC
         #
         # Read data
         open \data
         read grid data \NY .gridx_number.
         close
     }
     `Plot Contours'
     {
         set graylevel .contour_graylevel.
         set clip on
         set line width 0.5
         draw contour -3 3 0.25 unlabelled
         #
         # wide line at 0 degrees
         set line width 2
         draw contour 0 unlabelled
     }
     `Plot Image And Maybe Contours'
     {
         \imagefile = "image"
         set image range \zmin \zmax
         convert grid to image box \xmin  \ymin \xmax \ymax
         query \dohisto "Do histogram scaling? (yes|no)" ("yes")
         \incs = "no"
         if {"\dohisto" == "yes"}
     	set image grayscale using histogram
         else
     	\zinc = "0.25"
     	query \incs "In linear scaling, band at an increment of \zinc?" ("yes")
     	if {"\incs" == "yes"}
     	    set image grayscale black \zmin white \zmax increment \zinc
     	else
     	    set image grayscale black \zmin white \zmax
     	end if
         end if
         write image rasterfile to \imagefile
         show "wrote image rasterfile `\imagefile '"
         draw image
         draw image palette
         query \do_contours "Do contours as well (yes|no)" ("yes")
         if {"\do_contours" == "yes"}
     	Plot Contours
         end if
         draw title "Example 8 -- \data black=\zmin white=\zmax"
         if {"\dohisto" == "yes"}
     	draw title "Histogram enhanced grayscales"
         else
     	if {"\incs" == "yes"}
     	    draw title "Grayscale banded at intervals of \zinc"
     	end if
         end if
     }
     Initialize Parameters
     Initialize Axes
     Initialize Files
     Read Data
     query \doimage "Draw image (yes|no)" ("no")
     if {"\doimage" == "yes"}
         .contour_graylevel. = 1	# white contours
         Plot Image And Maybe Contours
     else
         .contour_graylevel. = 0	# black contours
         Plot Contours
         draw title "Example 8"
     end if


File: gri.info,  Node: Grayscale Images,  Next: Combination,  Prev: Contouring,  Up: Examples

8.3 Image created from coarsely gridded data
============================================

This example reads gridded ascii station data (`Read Data'), creates an
interpolated image (`convert grid ...'), and then plots the image.

   There are some other useful tricks in this example, such as calling
`awk' and `wc' from the unix system.

   (In the plot shown, all `query' questions were answered with
carriage return, yielding the defaults; the `-p' flag was specified on
execution, so the time stamp was not drawn.)  

 [image src="./examples/example9.png" text="../../../gri-2.12.10-src/doc/examples/example9.gri
" ]

     # Example 9 -- Plot dTdrho-rho section

     `Initialize Parameters'
     {
         \FILE_DATA = "example9a.dat" # T vs rho
         \FILE_LOCN = "example9b.dat" # section distances
         #
         # Following values from ~/eubex/processing/to_rho_bins/do_rho_inter
         \RHO_MIN = "28.1"
         \RHO_MAX = "27.5"
         \RHO_INC = "-0.002"
         \NY = "301"
         set missing value -99.0
         \xmin = "350"
         \xmax = "0"
         \xinc = "-100"
         \ymin = "28.1"
         \ymax = "27.8"
         \yinc = "-0.1"
         \zmin = "-10"		# black
         \zmax = "0"			# white
     }
     `Initialize Axes'
     Set up axes.
     {
         set x name "km"
         set x size 10
         set x axis \xmin \xmax \xinc
         set y size 5
         set y name "$\sigma_T$"
         set y axis name horizontal
         set y axis \ymin \ymax \yinc
         set y format %.1lf
         draw axes none
     }
     `Initialize Files'
     {
         query \data "Data file?   " ("\FILE_DATA")
         query \locn "Station locn?" ("\FILE_LOCN")
     }
     `Read Data'
     {
         # Read x-locations
         system awk '{print $2}' < \locn > TMP
         system wc TMP | awk '{print $1}' > NUM
         open NUM
         read .gridx_number.
         close
         system rm NUM
         open TMP
         read grid x .gridx_number.
         close
         system rm TMP
         # Create y-locations
         set y grid \RHO_MIN \RHO_MAX \RHO_INC
         #
         # Read data
         open \data
         read grid data \NY .gridx_number.
         close
     }
     Initialize Parameters
     Initialize Axes
     Initialize Files
     Read Data
     set image range \zmin \zmax
     set image colorscale hsb 0 1 1 \zmin   hsb .6 1 1 \zmax
     convert grid to image box \xmin  \ymin \xmax \ymax
     #
     # Draw the image, then draw the axes.  Note that the image has
     # extends beyond the axes frame, so we will turn clipping
     # on before drawing it, to make a clean picture.
     set clip postscript on
     draw image
     set clip postscript off
     draw axes

     #
     # All done.
     draw title "Example 9"
     if {"\dohisto" == "yes"}
         draw title "Histogram enhanced grayscales"
     end if


File: gri.info,  Node: Combination,  Next: Fancy,  Prev: Grayscale Images,  Up: Examples

8.4 Combination of image and contour
====================================

The following example reads gridded data and creates an image as in the
previous example, but also superimposes unlabelled white contour lines.

   (In the plot shown, all `query' questions were answered with
carriage return, yielding the defaults; the `-p' flag was specified on
execution, so the time stamp was not drawn.)  

 [image src="./examples/example10.png" text="../../../gri-2.12.10-src/doc/examples/example10.gri
" ]

     # Example 10 -- Draw image plot of flushing of dye out of cove
     if !..publication..
         draw time stamp
     end if
     \file = "example10.dat"
     query \contours "Superimpose contours? (yes|no)" ("yes")
     query \file     "Input file name               " ("\file")
     open \file
     read line \header
     read \D
     read .nx.
     read .ny.
     set x name "distance along cove"
     set y name "time"
     set x grid 0 1 /.nx.
     set x axis 0 1 0.5 0.1
     set y grid 0 .ny. / .ny.
     set y axis 0 .ny.
     read grid data * * .ny. .nx.
     set image range 0 20
     set image grayscale black 20 white 0 increment 5
     convert grid to image
     draw image
     if {"\contours" == "yes"}
         set graylevel 1.0
         draw contour 0 20 1 unlabelled
         set graylevel 0.0
     end if
     draw axes
     draw image palette left -1 right 21 increment 5
     draw title "Example 10 -- file=\file header=`\header'"

     # Example 10color -- Draw color image plot

     # Test various colorscales.
     # INSTRUCTIONS: Uncomment one of the following '\scale = ' statements

     # CASE 1: From black at high values to white at low values
     #\scale = "rgb 0 0 0 20.0 rgb 1 1 1  0.0 increment 5"

     # CASE 2: From skyblue at 20 to tan for 0; traverse RGB space
     #         See also case 5, which names the colors.
     #\scale = "rgb 0.529 0.808 0.922 20.0 rgb 0.824 0.706 0.549 0.0 increment 5"

     # CASE 3: From skyblue at 20 to tan for 0; traverse HSB space
     #         Is it just me, or is this uglier than case 2?
     #\scale = "hsb 0.548 0.426 0.922 20.0 hsb 0.095 0.334 0.824 0.0 increment 5"

     # CASE 4: Use a spectrum; traverse HSB space
     #\scale = "hsb 0 1 1 20.0 hsb 0.6666 1 1  0.0 increment 5"

     # CASE 5: From skyblue to tan, traversing RGB space (by default)
     #         (Compare case 2, which uses similar endpoints, with
     #         colors specified with RGB values, and larger increment.)
     #\scale = "skyblue 20.0 tan 0.0 increment 2"

     # CASE 6: From skyblue to tan, traversing RGB space (by default)
     #         Compare 2 and 5; note this has continuous increment
     #\scale = "skyblue 20.0 tan 0.0"

     # CASE 7: From blue to brown
     \scale = "blue 20.0 brown 0.0 increment 2.5"

     open example10.dat
     read line \header
     read \D
     read .nx.
     read .ny.
     set x name "distance along cove"
     set y name "time"
     set x grid 0 1 /.nx.
     set x axis 0 1 0.5 0.1
     set y grid 0 .ny. / .ny.
     set y axis 0 .ny.
     read grid data * * .ny. .nx.
     set image range 0 20
     convert grid to image
     set image colorscale \scale
     draw image

     # Draw contours in white ink
     set graylevel 1.0
     draw contour 0 20 1 unlabelled
     set graylevel 0.0

     draw axes                               # redraw in case whited out
     draw image palette left -1 right 21 increment 5
     set font size 9

     # Title tells what method used
     draw title "Used `draw image colorscale \scale'"


File: gri.info,  Node: Fancy,  Next: Legend,  Prev: Combination,  Up: Examples

8.5 Fancy x-y linegraph
=======================

The following code shows a fancy plot with lots of bells and whistles.  

 [image src="./examples/example11.png" text="../../../gri-2.12.10-src/doc/examples/example11.gri
" ]

     # Example 11 -- Fancy plot
     # Pen sizes, etc.
     #
     .thin. = 0.5                    # for whole data set
     .thick. = 2                     # for bravo time period
     .gray_for_guiding_lines. = 0.75 # for guiding lines
     .tmin. = 1964                   # time axis
     .tmax. = 1974
     .tinc. = 5
     .tincinc. = 1
     .missing_value. = -9
     \file = "./example11.dat"
     #
     # Guiding lines to draw on both panels.
     #
     .1xl. = 1962
     .1yb. = -3
     .1xr. = 1968
     .1yt. = 3
     .1slope. = {rpn .1yt. .1yb. - .1xr. .1xl. - /}
     .1intercept. = {rpn .1yb. .1slope. .1xl. * -}
     .2xl. = 1966.4
     .2yb. = 3
     .2xr. = 1980
     .2yt. = -1
     .2slope. = {rpn .2yt. .2yb. - .2xr. .2xl. - /}
     .2intercept. = {rpn .2yb. .2slope. .2xl. * -}
     #
     # PANEL 1: Bravo time period.
     #
     set x margin 3
     set x size 15
     set y margin 3
     set y size 5
     # Draw border big enough for this and next panel.
     draw border box {rpn ..xmargin.. 2 -} \
         {rpn ..ymargin.. 2 -} \
         {rpn ..xmargin.. ..xsize.. + 2 +} \
         {rpn ..ymargin.. ..ysize.. 2 * 3 + + 2 +} \
         0.2 0.75
     set missing value .missing_value.
     set ignore error eof
     set x name "Year"
     set x axis .tmin. .tmax. .tinc. .tincinc.
     set y name "Area / 10$^5$km$^2$"
     set y axis -3 3 1
     draw axes
     #
     # Draw index lines 1 and 2.
     #
     # Upward sloped line.
     set line width .thin.
     set graylevel .gray_for_guiding_lines.
     if {rpn .1intercept. ..xright.. .1slope. * + ..ytop.. <}
         draw line from              \
             ..xleft..               \
             {rpn .1intercept. ..xleft.. .1slope. * +} \
             to                      \
             {rpn ..ytop.. .1intercept. - .1slope. /} \
             ..ytop..
     else
         draw line from              \
             ..xleft..               \
             {rpn .1intercept. ..xleft.. .1slope. * +} \
             to                      \
             ..xright..              \
             {rpn .1intercept. ..xright.. .1slope. * +}
     end if
     set graylevel 0
     #
     # Downward sloped line.
     set line width .thin.
     set graylevel .gray_for_guiding_lines.
     if {rpn .2intercept. ..xleft.. .2slope. * + ..ytop.. <}
         draw line from              \
             {rpn ..ytop.. .2intercept. - .2slope. /} \
             ..ytop..                \
             to                      \
             ..xright..              \
             {rpn .2intercept. ..xright.. .2slope. * +}
     else
         draw line from              \
             ..xleft..               \
             {rpn .2intercept. ..xleft.. .2slope. * +} \
             to                      \
             ..xright..              \
             {rpn .2intercept. ..xright.. .2slope. * +}
     end if
     set graylevel 0
     #
     # Finally, draw the data curve on top, after first
     # whiting out a background.
     set input data window x .tmin. .tmax.
     open \file
     read columns x y
     close
     y /= 1e5
     set line width ..linewidthaxis..
     draw zero line
     set line width {rpn .thick. 3 *}
     set graylevel 1
     draw curve
     set graylevel 0
     set line width .thick.
     draw curve

     #
     # PANEL 2: Longer timescale.
     #
     delete x scale
     set x margin bigger 5
     set x size 10
     set x name ""
     set y name ""
     set y margin bigger {rpn ..ysize.. 3 +}
     #
     # Draw long data set in thin pen.
     set input data window x off
     open \file
     read columns x y
     close
     y /= 1e5
     #
     # Draw guiding lines, axes, etc.
     set x axis 1952 1980 5 1
     draw axes frame
     set line width .thin.
     set graylevel .gray_for_guiding_lines.
     draw line from .1xl. .1yb. to .1xr. .1yt.
     draw line from .2xl. .2yb. to .2xr. .2yt.
     set graylevel 0
     set line width ..linewidthaxis..
     draw zero line


     draw x axis at bottom
     .old. = ..fontsize..
     set font size 0
     draw y axis at left
     set font size .old.
     delete .old.
     #
     # Draw full curve (first whiting out region around it).
     set line width {rpn .thin. 4 *}
     set graylevel 1
     draw curve
     set graylevel 0
     set line width .thin.
     draw curve
     #
     # Draw bravo time period (first whiting out region around it).
     set input data window x .tmin. .tmax.
     open \file
     read columns x y
     close
     y /= 1e5
     set line width {rpn .thick. 3 *}
     set graylevel 1
     draw curve
     set graylevel 0
     set line width .thick.
     draw curve
     #
     # Done
     set font size 20
     \label = "Example 11 (Arctic ice anomaly)"
     draw label "\label" at          \
         {rpn 8.5 2.54 * "\label" width - 2 /} \
         {rpn ..ytop.. yusertocm 0.7 +} \
         cm
     if !..publication..
         draw time stamp
     end if


File: gri.info,  Node: Legend,  Next: Polygons,  Prev: Fancy,  Up: Examples

8.6 Legends and annotated lines
===============================

The following example shows how to handle annotated curves and legends.

 [image src="./examples/example12.png" text="../../../gri-2.12.10-src/doc/examples/example12.gri
" ]

     # Example 12 -- Linegraph with key inside plot
     set font size 10                # points (1in = 72pt)
     set x size 10                   # cm
     set y size 10                   # cm
     set x name "Height"
     set y name "Total Energy"

     # Following axis setups not necessary; will autoscale if you
     # remove these.
     set x margin 3
     set x axis 800 960 20
     set y margin 3
     set y axis -0.4 1 0.2

     # Read data.  Format is columns (x, y1, y2, y3, y4)
     open example12.dat
     read columns x y
     draw curve
     draw label for last curve "1"

     rewind
     set line width {rpn ..linewidth.. 1.5 *}
     read columns x * y
     draw curve
     draw label for last curve "2"

     rewind
     set line width {rpn ..linewidth.. 1.5 *}
     read columns x * * y
     draw curve
     draw label for last curve "3"

     rewind
     set line width {rpn ..linewidth.. 1.5 *}
     read columns x * * * y
     draw curve
     draw label for last curve "4"

     # Draw the key.
     # NOTES:
     # (1) This key is inside the plot; its location was chosen
     #     after looking at the data.  To put the key in a different
     #     location, alter the .key_topleft_x. and .key_topleft_y.
     #     variables.  For example, you could put the key to the
     #     right of the plot by changing the next line to:
     #     `.key_topleft_x. = {rpn ..xsize.. 0.5 +}'
     # (2) The variable .dy_inc. is the spacing between lines in
     #     the key.  It should be OK even if you change the
     #     font size above.
     .key_topleft_x. = 0.5           # cm right of left axis
     .key_topleft_y. = 0.5           # cm below top axis
     .dy_inc. = {rpn ..fontsize.. pttocm 1.5 *}

     draw label "1 = Model 1A" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm

     .key_topleft_y. += .dy_inc.
     draw label "2 = Model 2A" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm

     .key_topleft_y. += .dy_inc.
     draw label "3 = Model 1B" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm

     .key_topleft_y. += .dy_inc.
     draw label "4 = Model 2B" at    \
         {rpn ..xleft.. xusertocm .key_topleft_x. +} \
         {rpn ..ytop.. yusertocm .key_topleft_y. -} cm

     draw title "Example 12 -- Total heating vs height of boundary layer"


File: gri.info,  Node: Polygons,  Next: TS Diagram,  Prev: Legend,  Up: Examples

8.7 Drawing gray polygons
=========================

The following example shows how to draw polygons of a graylevel that is
read in.  It also draws a bullet (within the polygon).  See the help
lines at the start.

     `Draw Polygon And Bullet'
     Draw a polygon of a given graylevel, with a bullet
     (black dot) at an indicated location.  The polygon
     coordinates are read in by this command, as are
     the graylevel and the location of the bullet.

     Variables used:
       .black.
       .white.

     Input data read:

     line   1:
       A code (which is ignored) and a graylevel
       to draw the polygon with. The value for this
       graylevel ranges from .black. (which codes
       to black ink on the paper) to .white.
       (which codes to blank paper).

     line   2:
       An (x,y) location for the bullet.

     line   3:
       Skipped.

     line 4-n:
       Locations of vertices of polygon, ended with a blank line.
     {
       read .code. .graylevel. # Read line 1
       read .x. .y.            # Read line 2
       skip                    # Skip line 3
       read columns x y        # Read a polygon
       # Adjust .graylevel. to range between 0
       # (for black ink) and 1 (for white paper),
       # then set graylevel and draw polygon.
       .graylevel. = {rpn .graylevel. \
           .black. - .white. .black. - /}
       set graylevel .graylevel.
       draw curve filled
       # Draw black bullet
       set graylevel 0
       draw symbol bullet at .x. .y.
       # Clean up local storage.
       delete .code.
       delete .graylevel.
       delete .x.
       delete .y.
     }


File: gri.info,  Node: TS Diagram,  Next: PDF Diagram,  Prev: Polygons,  Up: Examples

8.8 Temperature-Salinity Diagram
================================

Here is how you might draw an oceanographic "TS" (temperature salinity)
diagram: 

 [image src="./examples/example13.png" text="../../../gri-2.12.10-src/doc/examples/example13.gri
" ]

     # Example 13 -- TS diagram, with isopycnals
     #
     # Draw Axes
     set line width axis 0.25
     set line width 0.75
     .tic_size. = 0.1                # cm
     set symbol size 0.03
     .isopycnal_fontsize. = 8        # for isopycnal labels
     .axes_fontsize. = 10            # for axes
     set font size .axes_fontsize.
     set x margin 2
     set x size 10
     set y margin 2
     set y size 10
     .Smin. = 33.4
     .Smax. = 35.0
     .Sinc. = 0.5
     .Sincinc. = 0.1
     .thetamin. = -2.0
     .thetamax. = 11.0
     .thetainc. = 1.0
     .thetaincinc. = 1.0
     set tic size .tic_size.
     set x name "Salinity / PSU"
     set y name "Potential Temperature / $\circ$C"
     set x axis .Smin. .Smax. .Sinc. .Sincinc.
     set y axis .thetamin. .thetamax. .thetainc. .thetaincinc.
     set axes style offset
     draw axes 1
     set clip on
     .old. = ..fontsize..
     set font size .isopycnal_fontsize.
     draw isopycnal 26.00
     draw isopycnal 26.50 unlabelled
     draw isopycnal 27.00
     draw isopycnal 27.50 unlabelled
     draw isopycnal 28.00
     draw isopycnal 28.50 unlabelled
     draw isopycnal 29.00
     set clip off
     set font size .old.
     #
     # Draw the data.
     open example13.dat
     read columns x y
     draw symbol bullet
     set font size ..
     draw title "Example 13 -- TS diagram, with isopycnals"


File: gri.info,  Node: PDF Diagram,  Next: Running Means,  Prev: TS Diagram,  Up: Examples

8.9 Probability Density Function Diagram
========================================

A common application is to draw the probability density function for
(x,y) data.  Gri has no builtin facility to do this, but the following
example shows how to create the gridded PDF data using a call to the
`perl' system command.  The gridded data thus generated are contoured,
creating a PDF diagram.  As the comments in the program state, the
first call to Perl is specific to a particular dataset, and can be
ignored on first reading; it just creates the file `tmp-xy.\.pid.'.

     # Draw prob-density-function TS diagram for Bravo data

     # This first call to perl is specific to the
     # particular (weird) dataset.  All that matters
     # is that a file of (x,y) data is created, and
     # stored in the file called `tmp-xy.\.pid.'
     system perl <<"EOF"
     #
     # Slurp in x[], y[] data
     $dir = "/users/dek/kelley/Labrador/bravo/data";
     $Sfile = "$dir/S_25db_1day";
     $Tfile = "$dir/T_25db_1day";
     open(S, "$Sfile") || die "Can't open input $Sfile";
     open(T, "$Tfile") || die "Can't open input $Tfile";
     open(ST, ">tmp-xy.\.pid.")
         || die "Can't open tmp-xy.\.pid.";
     $day = 5;
     $year = 1964;
     while(<S>) {
         @S = split;
         $_ = <T>;
         @T = split;
         if (240 < $day && $day < 360) {
             for ($i = 0; $i < $#S; $i++) { #all depths
                 print ST "$S[$i] $T[$i]\n";
             }
         }
         $day += 1;
         if ($day > 365) {
             $year++;
             $day = 0;
         }
         if ($year > 1967) { last; }
     }
     EOF

     #
     # Create 2D PDF for (x,y) data in file \infile
     # storing the results in \outfile.  X ranges
     # between the indicated limits, with the indicated
     # binsize, as does y.  The synonyms defined
     # on the next 4 lines are the only input this
     # perlscript needs; the perlscript itself is
     # quite general.  For details of what it does,
     # particularly the scaling of the PDF, see
     # the perl comments.
     \xmin = "33.5"; \xmax = "35.5"; \xinc = "0.05";
     \ymin = "-2.0"; \ymax = "11.0"; \yinc = "0.25";
     \infile = "tmp-xy.\.pid."
     \outfile = "tmp-grid.\.pid."
     system perl <<"EOF"
     #
     # Prepare 2 dimensional probability-density-function
     # dataset for contouring by Gri.  This reads (x,y)
     # data from a file called $infile (defined below)
     # and creates an output file called $outfile
     # (also defined below) containing the
     # x-grid, the y-grid, and then the grid data,
     # suitable for reading/contouring by the Gri
     # commands
     #       open tmp-grid.\.pid.
     #       read .number_of_data.
     #       read grid x
     #       read grid y
     #       read grid data
     #       draw contour
     #
     # The values in the output grid are defined so
     # that they sum to the reciprocal of the
     # product of the x binsize and y binsize (see
     # definition of $factor below).
     #
     $xmin = \xmin; $xmax = \xmax; $xinc = \xinc;
     $ymin = \ymin; $ymax = \ymax; $yinc = \yinc;
     $infile = "\infile";
     $outfile = "\outfile";
     #
     # Slurp in the x[], y[] data, storing
     # the total number of data in $n.
     open(IN,  "$infile")   || die "Can't open infile";
     open(OUT, ">$outfile") || die "Can't open outfile";
     $n = 0;
     while(<IN>) {
         ($x[$n], $y[$n]) = split;
         $n++;
     }
     #
     # Zero out matrix (stored in a linear array scanned
     # as one reads a book).
     $cols = int(1 + ($xmax - $xmin) / $xinc);
     $rows = int(1 + ($ymax - $ymin) / $yinc);
     for ($y = $ymax; $y > $ymin; $y -= $yinc) {
         for ($x = $xmin; $x < $xmax; $x += $xinc) {
             $l = int(($x - $xmin) / $xinc
                 + $cols * int(($y - $ymin) / $yinc));
             $sum[$l] = 0;
         }
     }
     #
     # Cumulate (x,y) data into the matrix
     $inside = 0;
     for ($i = 0; $i < $n; $i++) {
         if ($ymin <= $y[$i] && $y[$i] <= $ymax
             && $xmin <= $x[$i] && $x[$i] <= $xmax) {
             $l = int(($x[$i] - $xmin) / $xinc
                 + $cols * int(($y[$i] - $ymin) / $yinc));
             $sum[$l]++;
             $inside++;
         } else {
             print STDERR "($y[$i], $x[$i]) clipped\n";
         }
     }
     #
     # Print number of points (to allow renormalization
     # if the user wishes)
     print OUT "$inside\n";
     #
     # Print x grid, y grid, then grid itself
     for ($x = $xmin; $x < $xmax; $x += $xinc) {
         printf OUT "%lg\n", $x;
     }
     print OUT "\n";
     for ($y = $ymax; $y > $ymin; $y -= $yinc) {
         printf OUT "%lg\n", $y;
     }
     print OUT "\n";
     #
     # The $factor variable scales the PDF.
     $factor = 1 / $xinc / $yinc / $inside;
     for ($y = $ymax; $y > $ymin; $y -= $yinc) {
         for ($x = $xmin; $x < $xmax; $x += $xinc) {
             $l = int(($x - $xmin) / $xinc
                 + $cols * int(($y - $ymin) / $yinc));
             printf OUT "%lg ", $factor * $sum[$l];
         }
         print OUT "\n";
     }
     EOF

     # Axes
     set x margin 3
     set x margin 6
     set x name "Salinity [PSU]"
     set y name "Potential Temperature [$\circ$C]"
     set x axis 34.5 34.8 0.1
     set y axis 5 9 1
     draw axes

     # PDF
     open tmp-grid.\.pid.
     read .number_of_data.
     read grid x
     read grid y
     read grid data
     .smooth. = 0

     # Contours.  Use clipping, since the axes are
     # zooming in on part of the PDF.
     set font size 8
     set contour label position centered
     set clip postscript on
     set line width rapidograph 4x0
     draw contour 0.2 2.2 0.4 unlabelled
     set line width rapidograph 0
     draw contour 0.4 2.4 0.4
     set clip postscript off
     end if


File: gri.info,  Node: Running Means,  Next: Finite Element Model Mesh,  Prev: PDF Diagram,  Up: Examples

8.10 Running-Mean Skyline Diagram
=================================

Timeseries data are often cast into running means; e.g. a temperature
record might be cast into monthly mean values.  The following example
shows how to use a perl script to accomplish this easily, producing a
graph with both the raw data (bullets) and the running mean (a skyline
plot).

     `Bin with  x .min. .max. .inc. \in_file \out_file'

     Creates \out_file from \in_file.  In each of these
     files, column 1 represents x and column 2 represents
     y.  The \out_file file contains the average values
     of y in x bands of width .inc., centred at .min.,
     (.min.+.inc.), up to .max, and with missing values
     inserted in bands with no x-data in \in_file.
     Each x-band is represented in \out_file by a
     plateau in y, and adjacent bands with
     non-missing data are connnected by vertical
     lines; the effect is a skyline plot of the
     banded means.  Sample application: plot
     monthly means of a variable.
     {
         if {rpn \.words. 8 !=}
             show "ERROR: `\.proper_usage.' called without"
             show " giving all parameters"
             quit 1
         end if
         system perl <<"EOF"
         $min = \.word3.;
         $max = \.word4.;
         $inc = \.word5.;
         open(IN,   "\.word6.")
             || die "`\.proper_usage': no \\in_file";
         open(OUT, ">\.word7.")
             || die "`\.proper_usage': no \\out_file";

         $n = ($max - $min) / $inc;
         #
         # Set up bins.
         for($i = 0; $i <= $n; $i++) {
            $xx[$i] = 0;
            $yy[$i] = 0;
            $nn[$i] = 0;
         }
         while(<IN>) {
             ($x, $y) = split(' ');
             $i = int(0.5 + ($x - $min) / $inc);
             $i =      0 if $i <      0;
             $i = $n - 1 if $i > $n - 1;
             $xx[$i] += $x;
             $yy[$i] += $y;
             $nn[$i]++;
         }
         for($i = 0; $i <= $n; $i++) {
             if ($nn[$i] > 0) {
                 $xx[$i] /= $nn[$i];
                 $yy[$i] /= $nn[$i];
                 $xleft  = $min + $inc * ($i - 0.5);
                 $xright = $min + $inc * ($i + 0.5);
                 #
                 # If datum to left non-missing,
                 # just draw vertical line
                 # down to the last yy value.
                 if ($i > 0 && $nn[$i - 1] > 0) {
                     print OUT "$xleft $yy[$i - 1]\n";
                 } else {
                     print OUT "$xleft \.missingvalue.\n"
                 }
                 print OUT "$xleft  $yy[$i]\n";
                 print OUT "$xright $yy[$i]\n";
             }
         }
     EOF
     }

     # Bin into months
     Bin with x 1964 1974 {rpn 1 12 /} \
         timeseries.dat tmp.dat
     open tmp.dat
     read columns x y
     close
     draw curve                      # skyline of means
     open timeseries.dat
     read columns x y
     close
     draw symbol bullet              # data
     system rm -f tmp.dat            # clean up


File: gri.info,  Node: Finite Element Model Mesh,  Next: Handling Data,  Prev: Running Means,  Up: Examples

8.11 Finite Element Model mesh
==============================

Finite Element Models (used in fluid mechanics) employ non-rectangular
meshes, and plotting these meshes requires a few intermediate steps.
Consider the common case of triangular elements.  Suppose two data files
exist describing the mesh, the first, `model.nodes' say, consists of a
description of the x-y coordinates of the nodes (vertices) of the
triangles.  The second, `model.elements' say, consists of a description
of which triplet of nodes defines each triangle in the mesh.  Here,
from a sample application, is a node file called `model.nodes':

     1	1	1
     2	2	1
     3	1	2
     4	3	1.5
     5	2	2
     6	1.5	3
   Here is the corresponding file of the elements, called
`model.elements'

     1	1	2	3
     2	2	5	3
     3	2	4	5
     4	3	5	6

In each of these files, the first column is a reference number.  Thus,
`model.elements' indicates that the first triangle is defined by the
nodes numbered `1', `2' and `3' as defined in `model.nodes'.  More
specifically, the triangle is defined by vertices at (x,y) locations
(1,1), (2,1), and (1,2).

   A Gri program, named `FEM.gri', to draw the nodes is the following.

     set missing value -99.99
     # Create data using perl-script ...
     system FEM.pl model.nodes model.elements > tmp
     # ... then plot it ...
     open tmp
     read columns x y
     close
     draw curve
     # ... and, finally, clean up the temporary file
     system rm tmp

The work of interpreting the data files is done by the perlscript that
follows, named `FEM.pl'

     #!/usr/bin/perl -w
     $missing = -99.99;              # missing value
     $node_file = $ARGV[0];
     $element_file = $ARGV[1];
     open (NODE, $node_file)
         or die "Cannot open '$node_file' file";
     open (ELEM, $element_file)
         or die "Cannot open '$element_file' file";

     # Read in node information, creating arrays
     # named $node_x[] and $node_y[]. Check that
     # the first column (the index) makes sense.
     $max_node = 1;
     while(<NODE>) {
         ($index, $node_x[$max_node], $node_y[$max_node])
             = split;
         die "Node mismatch at index=$index"
             if ($index != $max_node);
         $max_node++;
     }

     # Read in triangle elements, into arrays
     # $a[], $b[], and $c[].  Check that the
     # first column (the index) makes sense.
     $max_elem = 1;
     while(<ELEM>) {
         ($index, $a[$max_elem], $b[$max_elem], $c[$max_elem])
             = split;
         die "Element mismatch at index=$index"
             if ($index != $max_elem);
         $max_elem++;
     }

     # Print out triangles suitable for plotting in gri.
     for ($i = 1; $i < $max_elem; $i++) {
         print $node_x[$a[$i]], " ", $node_y[$a[$i]], "\n";
         print $node_x[$b[$i]], " ", $node_y[$b[$i]], "\n";
         print $node_x[$c[$i]], " ", $node_y[$c[$i]], "\n";
         # Repeat first, to close the triangle.
         print $node_x[$a[$i]], " ", $node_y[$a[$i]], "\n";
         print $missing, " ", $missing, "\n";
     }


File: gri.info,  Node: Handling Data,  Next: Handling Headers,  Prev: Finite Element Model Mesh,  Up: Examples

8.12 Handling Data
==================

* Menu:

* Handling Headers::            How to skip or read header lines
* Ignoring Columns::            Ignoring columns that are not of interest
* Column Algebra::              How to do algebra on columns
* Combining Columns::           Combining columns from separate files
* Plotting Several Columns::    Plotting several y-columns vs one x-column


File: gri.info,  Node: Handling Headers,  Next: Ignoring Columns,  Prev: Handling Data,  Up: Handling Data

8.12.1 Handling headers
-----------------------

Case 1 - known number of header lines.  This is easy.  If you know that
the file has, say, 10 header lines, you can just do this:

     open file
     skip 10
     read columns x y
     ...

   Case 2 - header itself indicates number of header lines.  Quite
often the first line of a file will indicate the number of header
lines.  For example, suppose the first line contains a single number,
indicating the number of header lines to follow:

     open file
     read .skip.
     skip .skip.
     read columns x y
     ...

   Case 3 - header lines marked by a textual key.  Sometimes header
lines are indicated by a textual key, for example, the characters
`HEADER' at the start of the line in the file.  The easy way to skip
such a header is to use a system command.  Depending on your
familiarity with the operating system (here presumed to be Unix), you
might choose to use Grep, Awk, or Perl.  Here are examples:

     open "grep -v '^HEADER' file |"

   For more on the `|' mechanism, see *Note Open::.  The Grep command
prints lines which do not match the indicated string (because of the
`-v' switch), and the `^' character stands for the start of the line
(*Note Grep::).  Thus all lines with the key word at the *start* of the
line are skiped.

   Case 4 - reading and using information in header.  Consider a
dataset in which the first line gives the time of observation, followed
by a list of observations.  This might be, for example, an indication
of the data taken from a weather balloon released at a particular time
from a fixed location, with the main data being air temperature as a
function of elevation of the balloon.  The time indication might be,
for instance, the hour number.  One might need to know the time to
print a label on the diagram.  You could do that by:

     open file
     read .time.
     read columns x y
     draw curve
     sprintf \label "Time of observation is %f hour" .time.
     draw title "\label"

where the `sprintf' command has been used to change the numerical time
indication into a synonym that can be inserted into a quoted string for
drawing the title of the diagram (*Note Sprintf::).  Here the time has
been assumed to be a decimal hour.  You might also have three numbers on
the line, perhaps a day, an hour and a minute.  Then you could do
something like

     open file
     read .d. .h. .m.
     read columns x y
     draw curve
     sprintf \label "Obs. %.0f:%.0f, day %.0f" .h. .m. .d.
     draw title "\label"

Here the `%.0f' code is used to ensure no numbers will be written after
the decimal point.  Naturally, you could convert this to a decimal day,
by e.g.

     ...
     .dday. = {rpn .day. .hour. 24 / .min. 24 / 60 /}
     sprintf \label "Decimal day is %.4f" .dday.
     ...

(Some of you might know how many minutes in a day, but I'm silly so I
kept the extra mathematical step - nothing is lost by being
straightforward!)


File: gri.info,  Node: Ignoring Columns,  Next: Column Algebra,  Prev: Handling Headers,  Up: Handling Data

8.12.2 Ignoring columns that are not of interest
------------------------------------------------

Quite often a dataset will have many columns, of which only a couple are
of interest to you.  Consider for example oceanographic data which has
columns storing, in order, these variables: (1) depth in water column,
(2) "in situ" temperature, (3) "potential" temperature, (4) salinity,
(5) conductivity, (6) density, (7) sigma-theta, (8) sound speed, and
(9) oxygen concentration.  But you might only be interested in plotting
a graph of salinity on the x-axis and depth on the y-axis.  Here are
several ways to do this:

     open file
     read columns y * * x
     draw curve

where the `*' is a place-keeper to indicate to skip that column.  For a
large number of columns, or as an aesthetic choice, you might prefer to
write this a

     open file
     read columns y=1 x=4
     draw curve

   Many users would just as soon not bother with this syntax, preferring
instead to use system tools with which they are more familiar.  So a
Gawk user might write

     open "gawk '{print($1, $4)}' file |"
     read columns y x
     draw curve

For more on the Gawk command see *Note Awk::.


File: gri.info,  Node: Column Algebra,  Next: Combining Columns,  Prev: Ignoring Columns,  Up: Handling Data

8.12.3 Algebra on column data
-----------------------------

Suppose the file contains (x,y), but you wish to plot 2y times x.  You
could do the doubling of y within Gri, as

     open file
     read columns x y
     y *= 2
     draw curve

or you could use a system tool, e.g. gawk, as in this example (*Note
Awk::).

     open "gawk '{print($1,2*$2)}' file|"
     read columns x y
     draw curve

   The latter is preferable in the sense that it is more powerful.  The
reason for this is that Gri allows you to manipulate the x and y
columns, using so-called RPN mathematics (*Note rpn Mathematics::), but
you cannot blend the columns.  For example, you cannot easily form the
ratio y/x in Gri.  (Actually, you can, by looping through your data and
doing the calculation index by index, but if you knew that already you
wouldn't need to be reading this section!)  Such blending is trivial in
the operating system, though, as in the following Gawk example (*Note
Awk::).

     open "gawk 'print {($1, $2/$1)}' file |"
     read columns x y
     draw curve


File: gri.info,  Node: Combining Columns,  Next: Plotting Several Columns,  Prev: Column Algebra,  Up: Handling Data

8.12.4 Combining columns from different files
---------------------------------------------

Suppose you want to plot a column (`y', say) from one file versus a
second column (`x') from a second data file.  The easy way is to use a
system command to create a new file, for example the Unix command
`paste' - but of course you don't want to clutter your filesystem with
such files, so you should do this withing Gri:

     open "paste file1 file2 |"
     read columns x y
     draw curve


File: gri.info,  Node: Plotting Several Columns,  Next: Commands,  Prev: Combining Columns,  Up: Handling Data

8.12.5 Plotting several y-columns versus on x-column
----------------------------------------------------

Sometimes you'll have a datafile with the first column being x, and the
other columns being various things to plot versus x.  For example, you
might have the data

     1  8 11  9
     2 22 21 20
     3 11 10  9
     4 20 15 10

in a file called `test.dat'.  Let's say the x-column is time, and the
y-columns are the readings from three temperature sensors.  The
following illustrates how you might plot these data.  If you think the
new-command which starts this script is useful, just insert it in your
`~/.grirc' file and you can just use it without re-defining it each
time.  This will give Gri a command called `draw curves'.

     `draw curves \xname \y1name ...'
     Draw multiple y columns versus an x column.  Assumes
     that the datafile is open, and that x is in the first
     column, with the y values in one or more following
     columns.

     The number of columns is figured out from the options,
     as is the name of the x-axis, and the labels to be
     used on each of the y curves.
     {
       # NB. the 3 below lets us skip the words 'draw'
       # and 'curves', and the name of the x-column.
       .num_of_y_columns. = {rpn wordc 3 -}
       if {rpn .num_of_y_columns. 1 >}
         show "ERROR: `draw curves' needs at least 1 y column!"
         quit
       end if

       set x name {rpn 2 wordv}
       set y name ""

       # Loop through the columns.
       .col. = 0
       while {rpn .num_of_y_columns. .col. <}
         # The x-values will be in column 1, with y-values
         # in columns 2, 3, ..., of the file.
         .ycol. = {rpn .col. 2 +}
         rewind
         read columns x=1 y=.ycol.
         # At this point, you may want to change line thickness,
         # thickness, color, dash-type, etc.  For illustration,
         # let's set dash type to the column number.
         set dash .col.
         draw curve
         draw label for last curve {rpn .col. 3 + wordv}
         .col. += 1
       end while
     }

     open test.dat
     draw curves time y1 y2 y3


File: gri.info,  Node: Commands,  Next: Overview Of Gri Commands,  Prev: Plotting Several Columns,  Up: Top

9 List of Commands in the Gri Language
**************************************

* Menu:

* Overview Of Gri Commands::    General classification of commands
* Command Syntax::              Syntax of the commands
* List Of Gri Commands::


File: gri.info,  Node: Overview Of Gri Commands,  Next: Command Syntax,  Prev: Commands,  Up: Commands

9.1 Overview of Gri Commands
============================

The Gri commands may be divided roughly into a few categories, as
indicated in the following list.

   * *Working with files*: Commands are `open', `close', `skip',
     `read', and `rewind'.

   * *Controlling parameters of the drawn material*: Various `set'
     commands control values of parameters, like size of plot,
     linewidth, font, etc.

   * *Drawing things*: Various `draw' commands let you draw data, axes,
     etc.

   * *Interacting with the user*: The `query' command gets instructions
     from the user.  The `show' command displays messages to user.

   * *Controlling program flow*: The `if' statement controls optional
     execution of commands (*Note If Statements::).  The `while'
     statement allows loops.

   * *Moving around in directories*: The `pwd', `cd' and `ls' commands
     do the usual unix things.

   * *Using the operating system* The `system' command passes
     instructions to the operating system; the output may be saved into
     a synonym by using `\syn = system ...'.  The `get env' command
     determines the value of any unix environment variables the system
     has defined.  For more discussion (*Note Operating System::).

   * *Statistical operations*: Some very limited capabilities exist;
     for example, `regress' does linear regression.

   * *Mathematical operations*: Simple mathematical manipulation of
     column, grid, and image data is provided.  Also, wherever Gri
     expects a number, it will accept a reverse-polish expression; for
     example, `set x size 10' could also be written `set x size {rpn 20
     2 /}'.  For details (*Note Mathematics::).


File: gri.info,  Node: Command Syntax,  Next: List Of Gri Commands,  Prev: Overview Of Gri Commands,  Up: Commands

9.2 Command syntax
==================

The syntax description is enclosed within angled single quotes, optional
items are enclosed in square brackets, multiword items are enclosed in
curly braces, and vertical bars separate different legitimate choices.
For example, the documentation item for the command for drawing contours

     `draw contour \
         [.value. |  \
           {.min. .max. .inc. [.inc_unlabelled.]}] \
         [unlabelled]'

indicates that following are legal:

     draw contour                   # gri selects levels
     draw contour unlabelled        # " but unlabelled
     draw contour 10                # single contour line
     draw contour 10 unlabelled     # " but unlabelled
     draw contour 0 100 10          # contours at z=0,1,
     draw contour 0 10 1 unlabelled # " but unlabelled
     # contours at 0, 0.1, ... labelled at 0, 1
     draw contour 0 10 1 0.1

Note that items enclosed in braces must appear in their entirety; for
example,

     draw contour 0 10              # WRONG; missing .inc.

which might look similar `draw contour .min. .max. .inc.' to you, looks
like garbage to Gri.  Gri will recognize it as an attempt at the `draw
contour' command (because the first 2 words match the syntax) but it
will then get confused, spit out an error message, and quit.


File: gri.info,  Node: List Of Gri Commands,  Next: Assert,  Prev: Command Syntax,  Up: Commands

9.3 List of all Gri commands
============================

Commands are listed below in the order in which they are defined in the
`gri.cmd' file (*Note Invoking Gri::).  What you see here is similar
to, but not identical to, the text of the online help.  Gri usually
accepts both American and English spellings (As an example of spelling
latitude, Gri accepts `grey' anywhere the manual says `gray', and
`colour' for `color'.)

* Menu:

* Assert::                      Assert something to be true (for debugging)
* Cd::                          Change directory
* Close::                       Close a file
* Convert::                     Convert various data types
* Create::                      Create columns from specified function
* Debug::                       Set to debugging mode
* Delete::                      Delete various data structures
* Differentiate::               Differentiate things
* Draw::                        Draw various things
* End Group::                   End a group
* Expecting::                   Make Gri warn of incompatibilites
* Filter::                      Filter (smooth) various data structures
* Flip::                        Flip or transpose grid or image
* Get Env::                     Get a unix environment variable
* Group::                       Start a group of drawn objects
* Heal::                        Interpolate across missing values
* Help::                        Give on-line help
* If::                          If and if/else statements
* Ignore::                      Ignore some of data recently read in
* Input::                       Input PostScript file into output file
* Insert::                      Run another command file
* Interpolate::                 Interpolate grid data to new x/y grid
* List::                        List source of a gri command
* Ls::                          List files in current directory
* Mask::                        Mask the image
* New::                         Get space for new variable or synonym
* Newpage::                     Start a new page
* New Postscript File::         Start a new PostScript file
* Open::                        Open a data file
* Postscript::                  Insert a line into the PostScript file
* Pwd::                         Print working directory
* Query::                       Get user input
* Quit::                        Exit from gri
* Read::                        Read something
* Regress::                     Do linear regressions on columnar data
* Reorder::                     Reorder columns
* Rescale::                     Re-determine scales for x/y axes
* Resize::                      Resize plot width/height for maps
* Return::                      Return early from command or insert file
* Rewind::                      Rewind data file to beginning
* Rpnfunction::                 Define an rpn function
* Set::                         Set various preference flags, etc
* Show::                        Show values of various things
* Skip::                        Skip some lines in data file
* Sleep::                       Sleep for a while
* Smooth::                      Smooth data
* Source::                      Run another command file
* Sprintf::                     Print variable values into a synonym
* State::                       Save or restore the graphics state
* Superuser::                   Enable some programmers debugging commands
* System::                      Performing system commands within gri
* Unlink::                      Delete file
* While::                       Loop over some code while a condition is true
* Write::                       Write data to a file


File: gri.info,  Node: Assert,  Next: Cd,  Prev: List Of Gri Commands,  Up: List Of Gri Commands

9.3.1 `assert'
--------------

     `assert .condition. ["message"]

The condition may be a variable, a synonym, or an RPN expression.  If
this condition is true (i.e. evaluates to a non-zero number), do
nothing.  If the condition is false, the program will terminate with an
error condition (in unix, it will terminate with a non-zero exit code).

   Before termination, a message will be printed, the form of which
depends on the optional `"message"' string.

   If no `"message"' string is given, the the printed message will
indicate the name of the command-file and the line at which the assert
command was encountered.

   If a `"message"' string is given, and if it ends in a newline
(`"\\n"'), then this string is printed.

   If a `"message"' string is given, and if it does not end in `"\\n"',
then the string is printed along with an indication of the location in
the command-file.

   (Perl users will recognize this as being patterned on the `"die"'
command.)


File: gri.info,  Node: Cd,  Next: Close,  Prev: Assert,  Up: List Of Gri Commands

9.3.2 `cd'
----------

     `cd [\pathname]'

If a pathname specified, change to that directory.  Normal unix
filenames are used, as in the C-shell convention.  For example, the
commands `cd ~/src' and `cd $HOME/src' are equivalent.  You may specify
relative pathnames as in `cd ../sister_directory'.

   If no \pathname directory path is specified, go to the home
directory, exactly as `cd ~' and `cd $HOME' do.


File: gri.info,  Node: Close,  Next: Convert,  Prev: Cd,  Up: List Of Gri Commands

9.3.3 `close'
-------------

     `close [\filename]'

If no filename is specified, close the most recently opened data-file;
otherwise close the indicated file.


File: gri.info,  Node: Convert,  Next: Convert Columns To Grid,  Prev: Close,  Up: List Of Gri Commands

9.3.4 The `convert' commands
----------------------------

* Menu:

* Convert Columns To Grid::      Create grid from (x,y,f) data
* Convert Columns To Spline::    Create spline (x',y') from (x,y) data
* Convert Grid To Columns::      Create (x,y,f) data from grid
* Convert Grid To Image::        Create an image from grid data
* Convert Image To Grid::        Create a grid from image data


File: gri.info,  Node: Convert Columns To Grid,  Next: Convert Columns To Spline,  Prev: Convert,  Up: Convert

9.3.4.1 `convert columns to grid'
.................................

Various forms exist:

     `convert columns to grid OPTIONS'

where the `OPTIONS' may be omitted or selected from this list:

     `neighbor'
     `boxcar    [.xr. .yr. [.n. .e.]]'
     `objective [.xr. .yr. [.n. .e.]]'
     `barnes    [.xr. .yr. .gamma. .iter.]'

For more discussion on the methods see *Note Ungridded Data::.

   All these commands "grid" columnar (x,y,z) data.  That is, they fill
up a grid based on some form of interpolation of the possibly
randomly-spaced columnar data.  There are many methods in existence for
doing this, and Gri implements several of them as alternatives.

   The grid will have been defined by commands such as `set x grid',
`set y grid', `read grid x' and `read grid y'.  As of version 2.1.9,
Gri does not require a grid to have been pre-defined; it will create a
regular 20 by 20 grid, spanning the range of x and y data, as a
default.  This is a good starting point in many cases.

_`neighbor' method_
     Very fast but very limited.

_`boxcar' method_
     Slower but a lot better.  Still, this can produce noisy contours
     if the data are not densely and uniformly ditributed through
     domain.

_`objective' method_
     Somewhat slower than `boxcar', but produces better fields since the
     averaging function is smooth.

_`barnes' method_
     Somewhat slower than `objective', but only by a constant factor
     (that is, independent of number of data).  This produces by far
     the best results, since the smoothing function has variable
     spatial scale.  This is the default method if no method is
     supplied.

   All except the `neighbor' method may take optional arguments to
define the x and y scales of the smoothing function (called `.xr.' and
`.yr.').  (The barnes method has two other optional arguments - see
below.)  If you do not supply these arguments, Gri will make a
reasonable choice and inform you of its decision.  Many users find that
it is best to `convert columns to grid' with no additional parameters
as a first step, to get advice on values to use for the optional
parameters.

   The default `.xr.' and `.yr.' are calculated by determining the span
in x and in y directions, and dividing each by the square root of the
number of data points.  These numbers are then multiplied by the square
root of 2.  The method is as proposed by S. E. Koch and M.  DesJardins
and P. J. Kocin, 1983.  "An interactive Barnes objective map anlaysis
scheme for use with satellite and conventional data,", J. Climate Appl.
Met., vol 22, p. 1487-1503.

   If `.xr.' and `.yr.' were supplied but negative, then Gri interprets
this as an instruction to modify the default values, described in last
paragraph, by multiplying by the absolute values of the negative
numbers given, instead of muliplying by square root of 2.

   If the `chatty' option is turned on then Gri will print out the
values of (dx,dy) that it has calculated; this gives you some guidance
for supplying your own values of `(.xr.,.yr.)' if you choose to supply
them yourself.  It is also a good idea to let these parameters be a
guide for your grid spacing; for example, Koch et al., 1983, suggest
using grid spacing of 0.3 to 0.5 times (dx,dy).

   And now, the details ...

   * *"Neighbor" method* The `convert columns to grid neighbor' method
     is useful for (x,y,z) data which are already gridded (i.e., for
     which x and y take only values which lie on the grid), or nearly
     gridded.  The (x,y,z) data are scanned from start to finish. For
     each data point, the nearest grid point is found.  Nearness is
     measured as Cartesian distance, with scale factor given by the
     distance between the first and second grid points.  In other
     words, distance is given by D=sqrt(dx*dx+dy*dy) where dx is ratio
     of distance from data point to nearest grid point, in x-units,
     divided by the difference between the first two elements of the
     x-grid, and dy is similarly defined.  Once the grid point nearest
     the data point is determined, Gri adds the z-value to a list of
     possible values to store in the grid.  Once the entire data set
     has been scanned, Gri then goes back to each grid point, and
     chooses the z-value of the data point that was nearest to the grid
     point - that is, it stores the z value of the (x,y,z) data triplet
     which has minimal D value.  Note that this scheme is independent
     of the order of the data within the columns.

     The `neighbor' method is useful when the data are already
     pre-gridded, meaning that the (x,y,z) triplets have x and y values
     which are already aligned with the grid.  *Computational cost:* For
     `P' data points, `X' x-grid points, and `Y' y-grid points, the
     method calculation cost is proportional to `P*[log2(X)+log2(Y)]'
     where `log2' is logarithm base 2.  As discussed below, this is
     often several orders of magnitude lower than the other methods of
     gridding.

   * *"Objective" method* In the `objective' method, a smoothing
     technique known as objective mapping is applied.  It is
     essentially a variable-size smoothing filter of approximately
     Gaussian shape (it is method "two" of Levy and Brown [1986 J.
     Geophysical Res. vol 91, p 5153-5158]) The parameters `.xr.' and
     `.yr.' give the width of the filter.

     With the optional additional parameters `.n.' and `.e.' are
     specified, then grid values will be assigned the missing value if
     there are fewer than `.n.' (x,y,f) data in the neighborhood of the
     gridpoint, even after enlarging the neighborhood by widening and
     heightening by root(2) up to `.e.' times.  (The enlargement is only
     done if fewer than `.n.' points are found.)  If these parameters
     are not specified in the command, then values `.n.'=5 and `.e.'=1
     are assumed.  The special case where `.e.' is negative tells Gri
     to *always* fill in each grid point, by extending the neighborhood
     to enclose the entire dataset if necessary.

     *Computational cost:* For `P' data points, `X' x-grid points, and
     `Y' y-grid points, the method calculation cost is proportional to
     `P*X*Y'.  Given that `X' and `Y' are determined by the requirement
     for smoothness of contours and the size of the graph, they are
     more or less fixed for all applications.  They are often in the
     range of 20 or so - on 10 cm wide graph, this yields a contour
     footprint of 1/2 cm, which is often small enough to yield smooth
     contours.  Therefore, the computational cost scales linearly with
     the number of data points.  Compared to the "neighborhood" method,
     this is more costly by a factor of `X*Y/log_2(X)/log_2(Y)' which is
     normally in the range from 20 to 50.

   * *"Boxcar" method* In the `boxcar' method, the grid points are
     derived from simple averages calculated in rectangles `.xr.' wide
     and `.yr.' tall, centred on the gridpoints.  The `.n.' and `.e.'
     parameters have similar meanings as in the "objective" method.

     *Computational cost:* Roughly same as `objective' method described
     above.

   * *"Barnes" method* This is the default scheme.

     The Barnes algorithm is applied.  If no parameters are specified,
     `.xr.' and `.yr.' are determined as above, with `.gamma.' set to
     0.5, and `.iter.' set to 2 so that two iterations are done.  On
     successive iterations, the smoothing lengthscales `.xr' and `.yr'
     are each reduced by multiplying by the square root of `.gamma.'.
     Smaller `.gamma.' values yield better resolution of small-scale
     features on successive iterations.  Koch et al., 1983, recommend
     using a `.gamma.' value in the range 0.2 to 1, with two iterations.

     Provided that all the grid points are close enough to at least some
     column data, the entire grid is filled.  But if `.xr.' and `.yr.'
     are too small, the weighting function can fall to zero, since it
     is exponential in the sum of the squares of the x-distance/`.xr.'
     and the y-distance/`.yr.'; in that case missing values result at
     those grid points.  On a 32 bit computer, the weighting function
     will fall to zero when x-distance/`.xr.'  and y-distance/`.yr.'
     are less than about 15 to 20.

     If weights have been read in (*Note Read Columns::), then these
     values are applied in addition to the distance-based weighting.
     (The normalization means that weights for two data points of e.g.
     1 and 2 will yield the same result as if the weights had been
     given as 10 and 20.)

     The computational cost at each iteration scales as `P*X*Y)'.  This
     is comparable to that of the "objective" and "boxcar" methods.
     Since normally two iterations are done, "barnes" is about double
     the cost of these methods.  (Note: versions prior to 2.1.8 were
     much slower for large datasets, being proportional to `P*P'.)

     References: (1) Section 3.6 in Roger Daley, 1991, "Atmospheric data
     analysis," Cambridge Press, New York. (2) S. E. Koch and M.
     DesJardins and P. J. Kocin, 1983.  "An interactive Barnes
     objective map anlaysis scheme for use with satellite and
     conventional data,", J. Climate Appl.  Met., vol 22, p. 1487-1503.

   The Barnes algorithm is as follows:

   The gridded field is estimated iteratively.  Successive iterations
retain largescale features from previous iterations, while adding
details at smaller scales.

   The first estimate of the gridded field, here denoted `G_(ij)^0'
(the superscript indicating the order of the iteration) is given by a
weighted sum of the input data, with `z_k' denoting the k-th `z' value.

                  sum_1^n W_(ijk)^0 z_k
     G_(ij)^(0) = ----------------------
                    sum_1^n W_(ijk)0
   where the notation `sum_1^n' means to sum the elements for the `k'
index ranging from 1 to `n'.

   The weights `W_(ijk)^0' are defined in terms of a Guassian function
decaying with distance from observation point to grid point:

                    (   (x_k - X_i)^2       (y_k - Y_j)^2  )
     W_(ijk)^0 = exp(-  --------------  -  --------------- )
                    (      L_x^2                L_y^2      )

Here `L_x' and `L_y' are lengths which define the smallest `(x,y)'
scales over which the gridded field will have significant variations
(for details of the spectral response see Koch et al. 1983).

   Note: if the user has supplied weights then these are applied in
addition to the distance-based weights.  That is, `w_i W_(ijk)' is used
instead of `W_(ijk)'.

   The second iteration derives a grid `G_(ij)^1' in terms of the first
grid `G_(ij)^0' and "analysis values" `f_k^0' calculated at the
`(x_k,y_k)' using a formula analogous to that above.  (Interpolation
based on the first estimate of the grid `G_(ij)^0' can also be used to
calculate `f_k^0', with equivalent results for a grid of sufficiently
fine mesh.)  In this iteration, however, the weighted average is based
on the difference between the data and the gridded field, so that no
further adjustment of the gridded field is done in regions where it is
already close to through the observed values.  The second estimate of
the gridded field is given by

                            sum_1^n W_(ijk)^1 (f_k - f_k^0)
     G_(ij)^1 = G_(ij)^0 +  -------------------------------
                                   sum_1^n W_(ijk)^1

where the weights `w_{ik,1}' are defined by analogy with `W_{ik}^0'
except that `L_x' and `L_y' are replaced by `gamma^{1/2}L_x' and
`gamma^{1/2}L_y'.  The nondimensional parameter `gamma' (`0<gamma<1')
controls the degree to which the focus is improved on the second
iteration.  Just as the weighting function forced the gridded field to
be smooth over scales smaller than `L_x' and `L_y' on the first
iteration, so it forces the second estimate of the gridded field to be
smooth over the smaller scales `gamma^{1/2}L_x' and `gamma^{1/2}L_y'.

   The first iteration yields a gridded field which represents the
observations over scales larger than `(L_x,L_y)', while successive
iterations fill in details at smaller scales, without greatly modifying
the larger scale field.

   In principle, the iterative process may be continued an arbitrary
number of times, each time reducing the scale of variation in the
gridded field by the factor `gamma^{1/2}'.  Koch et al. 1983 suggest
that there is little utility in performing more than two iterations,
providing an appropriate choice of the focussing parameter `gamma' has
been made.  Thus the gridding procedure defines a gridded field based
on three tunable parameters: `(L_x,L_y,gamma)'.


File: gri.info,  Node: Convert Columns To Spline,  Next: Convert Grid To Columns,  Prev: Convert Columns To Grid,  Up: Convert

9.3.4.2 `convert columns to spline'
...................................

     `convert columns to spline \
         [.gamma.] \
         [.xmin. .xmax. .xinc.]'

   Fit a normal or taut interpolating spline, y=y(x), through the (x,y)
data.  Then subsample this spline to get a new set of (x,y) data.  If
the spline x-values, `.xmin.', etc, are not specified, the spline
ranges from the smallest x-value with legitimate data to the largest
one, with 200 steps in between.

   The parameter `.gamma.' determines the type of spline used.  If
`.gamma.' is not specified, or is given as zero, a standard
interpolating spline is used.  A knot appears at each x location, with
cubic polynomials spanning the space between the knots.  If `.gamma.'
lies between 0 and 6, a taut spline is used; this tends to have fewer
wiggles than a normal spline.  If `.gamma.'  lies in the range 0 to 3,
a taut spline is used, with the possible insertion of knots between
interior x pairs.  The value 2.5 is used commonly.  If `.gamma.' lies
in the range 3 to 6, extra knots are permitted in the x pairs at the
ends of the domain.  A value of 5.5 is used commonly.

   *Reference* Chapter 16 of Carl de Boar, 1987. "A Practical Guide to
Splines" Springer-Verlag.

     read columns x y  # function is y=x^2
     0 0
     1 1
     2 4
     3 9
     4 16

     set symbol size 0.2
     draw symbol bullet
     convert columns to spline
     draw curve


File: gri.info,  Node: Convert Grid To Columns,  Next: Convert Grid To Image,  Prev: Convert Columns To Spline,  Up: Convert

9.3.4.3 `convert grid to columns'
.................................

     `convert grid to columns'

Create column data from grid data.  Each non-missing gridpoint is
translated into a single (x,y,z) triplet.  If column data already exist,
then they are first erased.  This command is useful in changing the grid
configuration, perhaps from a non-uniform grid to a uniform grid.  In
the following example, a new grid with x=(0, 0.05, 0.1, ..., 0.1) and
y=(10, 11, ..., 20) is created.  The default gridding method (`convert
columns to grid') is used here, but of course one is free to adjust the
method as usual.

     # ... read/create grid
     convert grid to columns
     delete grid
     set x grid  0  1 0.05
     set y grid 10 20 1
     convert columns to grid


File: gri.info,  Node: Convert Grid To Image,  Next: Convert Image To Grid,  Prev: Convert Grid To Columns,  Up: Convert

9.3.4.4 `convert grid to image'
...............................

     `convert grid to image [size .width. .height.] \
         [box .xleft. .ybottom. .xright. .ytop.]'

With no options specified, convert grid to a 128x128 image, using an
image range as previously set by `set image range'.

   Interpolation method: The interpolation scheme is the same used for
contouring.  Image points that lie outside the grid domain are
considered missing.  For points within the grid, the first step is to
locate the patch of the grid upon which the pixel lies.  Then the 4
neighboring grid points are examined, and one of the following cases
holds.
  1. If 3 or more of them are missing, the pixel is considered missing.

  2. If just one of the neighboring grid points is missing, then the
     image pixel value is determined by bilinear interpolation on the
     remaining 3 non-missing grid points.  (This amounts to fitting a
     plane to three measurements of height.)

  3. If all 4 of the grid points are non-missing, then the rectangle
     defined by the grid patch is subdivided into four triangles.  The
     triangles are defined by the two diagonal lines joining opposite
     corners of the rectangle.  An "image point" is constructed at the
     center of the grid patch, with f(x,y) value taken to be the
     average of the values of the four neighbors.  This value is taken
     to be the value at the common vertex of the four triangles, and
     then bilinear interpolation is used to calculate the image pixel
     value.

   With the `size' options `.width.' and `.height.' specified, they set
the number of rectanglular patches in the image.

   With the `box' options specified, they set the bounding box for the
image.  If `box' is not given, the image spans the same bounding box as
the grid as set by `set x grid' and `set y grid'.

   Normally, missing values in the grid become white in the image, but
this can be changed using the `set image missing value color to'...
command.


File: gri.info,  Node: Convert Image To Grid,  Next: Create,  Prev: Convert Grid To Image,  Up: Convert

9.3.4.5 `convert image to grid'
...............................

     `convert image to grid'

Convert image to grid, using current graylevel/colorlevel mapping.  For
example, if one had a linear mapping of pixel values 0->255 into the
user values 10->20, as in

     set image range 10 20
     set image grayscale black 10 white 20

then the output grid will be of value 10 where the pixel value is 0,
etc.  If the image is in color, the grid values will represent the
result of mapping the colors to grayscale in the standard way (Foley and
VanDam, 1984). [BUG: as of 1.063, the colorscale is ignored completely,
and I'm not sure what happens.] The image data are interpolated onto the
grid using a nearest-neighbor substitution.  This command insists that
the image x/y grids have already been defined.


File: gri.info,  Node: Create,  Next: Create Columns From Function,  Prev: Convert Image To Grid,  Up: List Of Gri Commands

9.3.5 The `create' commands
---------------------------

* Menu:

* Create Columns From Function:: prepare to draw a function
* Create Image Grayscale::       prepare to draw banded image


File: gri.info,  Node: Create Columns From Function,  Next: Create Image Grayscale,  Prev: Create,  Up: Create

9.3.5.1 `create columns from function'
......................................

     `create columns from function'

Plot a function of x which is defined in synonym \function.

     ENVIRONMENT
     \function = function to plot.
     \xmin     = minimum x value
     \xmax     = maximum x value
     \xinc     = increment in x values

     EXAMPLE
     \function = "cos(x)"
     \xmin     = "0"
     \xmax     = "2 * 3.14"
     \xinc     = "0.1"
     create columns from function
     draw curve

NOTE: This only works on machines which have the `awk' command
available at the commandline.  This means most unix machines and some
vax machines.


File: gri.info,  Node: Create Image Grayscale,  Next: Debug,  Prev: Create Columns From Function,  Up: Create

9.3.5.2 `create image grayscale'
................................

     `create image grayscale banded .band.'

Make a banded grayscale with in units of .band. pixel values each.
Thus, pixel values 0 to (.band. - 1) on the image will map to 0, while
values from .band. to (2 * .band. - 1) will map to .band., etc.  For
example, .band. = 2 gives grayscale = (0 0 2 2 4 4 6 6 ... 252 252 254
254).


File: gri.info,  Node: Debug,  Next: Delete,  Prev: Create Image Grayscale,  Up: List Of Gri Commands

9.3.6 `debug'
-------------

     `debug [.n.]|[clipped values in draw commands]|off'

With no optional parameters, sets the value of `..debug..' to 1.
(Normally, `..debug..' is 0.)  You may use `..debug..' in `if'
statements, etc.  Note that `..debug..' is also set to 1 when gri is
invoked with the commandline switch `-d'.

   With `.n.' specified, `..debug..' is set to `.n.'; a value of zero
for `.n.' turns debugging off, while 1 turns it on.  Higher values may
be used for deeper debugging, if you choose:

     if {rpn ..debug.. 2 <}
       # Code to do if ..debug.. is greater than 2.
     end if

Note that you can assign to `..debug..' as you can to any other
variable; `debug .n.' is equivalent to `..debug.. = .n.'.

   With the `clipped' option, Gri prints any clipped data encountered
during any `draw ...' commands, EXCEPT in the case of `postscript'
clipping, where no check is possible.  (Note that `..debug..' is not
affected.)

   All these forms of debugging are cancelled by `debug off'.


File: gri.info,  Node: Delete,  Next: Differentiate,  Prev: Debug,  Up: List Of Gri Commands

9.3.7 `delete'
--------------

     `delete .variable.|\synonym [.variable.|\synonym [...]]'
     `delete columns [where missing]'
     `delete columns [randomly .fraction.]'
     `delete grid'
     `delete [x|y] scale'

Delete some item or characteristic.

   * `delete .variable.' Delete definition of variable `.variable.',
     making it undefined.  Any number of variables or synonyms may be
     specified on one line.

   * `delete \synonym' Delete definition of synonym `\synonym', making
     it undefined.  Any number of variables or synonyms may be
     specified on one line.

   * `delete \@alias' Delete the item named by the alias (*Note Alias
     Synonyms::).

   * `delete' with an `&' item Delete the item in the calling program.

   * `delete columns' Delete column data.

   * `delete columns where missing' Completely delete all column data
     for which any one of x, y, etc is missing.

   * `delete columns randomly .fraction.' Randomly select fraction
     `.fraction.'  of the non-missing column data, and designate them
     as being missing.

   * `delete grid' Delete grid data.

   * `delete scale' Delete scales for both x and y, so next `read
     columns' will set it.

   * `delete x scale' Delete scales for x, so next `read columns' will
     set it.

   * `delete y scale' Delete scales for y, so next `read columns' will
     set it.


File: gri.info,  Node: Differentiate,  Next: Draw,  Prev: Delete,  Up: List Of Gri Commands

9.3.8 `differentiate'
---------------------

     `differentiate {x|y wrt index|y|x} | {grid wrt x|y}'

Differentiate column data or grid data.  Only the `x' and `y' columns
may be differentiated.  They may be differentiated either with respect
to ("wrt") the index (forming a first difference) or with respect to
the other column.  The derivative is done with the backwards-difference
algorithm.  Grid data may differentiated with respect to `x' direction
or `y' direction.  Grid differentiation is done with a centred
difference, with endpoints being assigned the derivative of the
neighboring interior point (so that the second derivative is zero at
the edges of the grid).


File: gri.info,  Node: Draw,  Next: Draw Arc,  Prev: Differentiate,  Up: List Of Gri Commands

9.3.9 The `draw' commands
-------------------------

Draw commands do actual drawing on the page.  You can draw axes,
lineplots, symbols, contours, images, and text.

   *NOTE* Gri likes drawings to have axes, so if a `draw' command is
executed before any axes have been drawn, Gri will draw axes after it
draws the item.  (You can get drawings without axes by preceding any
other `draw' commands with the command `draw axes none'.)  Many users
have been surprised by the results of this rule.  For example, if you
do `set graylevel 0.5' before `draw curve', you'll find that the axes
are drawn in gray also.  To avoid this, make sure to do `draw axes'
before you modify the graylevel.)

* Menu:

* Draw Arc::                    Draw an arc segment
* Draw Arrow::                  Draw single arrow
* Draw Arrows::                 Draw many arrows (using columns)
* Draw Axes If Needed::         Draw axes if haven't done so yet
* Draw Axes::                   Draw axes
* Draw Border Box::             Draw border around plot
* Draw Box::                    Draw a box, possibly filled
* Draw Circle::                 Draw a circle
* Draw Contour::                Draw contour(s)
* Draw Curve::                  Draw a curve of y(x) column data
* Draw Essay::                  Draw text, adjusting position for each line
* Draw Gri Logo::               Draw a Gri logo
* Draw Grid::                   Draw the location of grid points
* Draw Image Histogram::        Draw histogram of values in image
* Draw Image Palette::          Draw palette used in image plots
* Draw Image::                  Draw image
* Draw Isopycnal::              Draw isopycnal line on TS plot
* Draw Isospice::               Draw iso-spice line on TS plot
* Draw Label Boxed::            Draw a label in a box
* Draw Label Whiteunder::       Draw a label with white ink under it
* Draw Label For Last Curve::   What it says
* Draw Label::                  Draw text somewhere
* Draw Line From::              Draw line segment
* Draw Line Legend::            Draw legend displaying line types
* Draw Lines::                  Draw sequence of parallel lines
* Draw Patches::                Draw grayscale patches showing z(x,y)
* Draw Polygon::                Draw a polygon
* Draw Regression Line::        Draw line from regression between x and y
* Draw Symbol At::              Draw a symbol at a point
* Draw Symbol Legend::          Draw a symbol and a string describing it
* Draw Symbol::                 Draw symbols at (x,y), or at a point
* Draw Time Stamp::             Draw a timestamp at top of plot
* Draw Title::                  Draw a title for plot
* Draw Values::                 Draw numbers beside z(x,y)
* Draw X Axis::                 Draw the x axis
* Draw X Box Plot::             Draw box plots showing x spread
* Draw Y Axis::                 Draw the y axis
* Draw Y Box Plot::             Draw box plots showing y spread
* Draw Zero Line::              Draw y=0 or x=0


File: gri.info,  Node: Draw Arc,  Next: Draw Arrow,  Prev: Draw,  Up: Draw

9.3.9.1 The `draw arc' command
..............................

     `draw arc [filled] .xc_cm. .yc_cm. .r_cm. .angle_1. .angle_2.'

   Draw an "arc", that is, a portion of a circle.  The center of the
circle is at the coordinate (`.xc_cm.', `.yc_cm.'), and the circle
radius is `.r_cm.', all three quantities being in cm on the page, _not_
in user-units.  The arc starts at angle `.angle_1.', measured in
degrees counterclockwise from a horizontal line, and extends to angle
`.angle_2.', in the same units.

   If the keyword `filled' is present, the arc is filled with the
current color.  Otherwise it is drawn with the current "curve"
linewidth *Note Set Line Width::.


File: gri.info,  Node: Draw Arrow,  Next: Draw Arrows,  Prev: Draw Arc,  Up: Draw

9.3.9.2 `draw arrow'
....................

     draw arrow from .x0. .y0. to .x1. .y1. [cm]

   With no optional parameters, draw an arrow from (`.x0.', `.y0.') to
(`.x1.', `.y1.'), where coordinates are in user units.  The arrow head
will be at (`.x1.', `.y1.'), and its size is as set by most recent call
to `set arrow size'.  With the `cm' keyword present, the coordinates
are in centimetres on the page.  NOTE: This will not cause auto-drawing
of axes.


File: gri.info,  Node: Draw Arrows,  Next: Draw Axes If Needed,  Prev: Draw Arrow,  Up: Draw

9.3.9.3 `draw arrows'
.....................

     `draw arrows'

Draw a vector field consisting of arrows emanating from the coordinates
stored in the (x, y) columns.  The lengths and orientations of the
arrows are stored in the (u, v) columns, and the scale for the (u,v)
columns is set by `set u scale' and `set v scale'.  *See also* (1) To
set arrow size, use `set arrow size'.  (2) To get a single arrow, use
`draw arrow'.


File: gri.info,  Node: Draw Axes If Needed,  Next: Draw Axes,  Prev: Draw Arrows,  Up: Draw

9.3.9.4 `draw axes if needed'
.............................

     `draw axes if needed'

Draw axes frame if required.  Used within gri commands that auto-draw
axes.  NOTE: this should only be done by developers.


File: gri.info,  Node: Draw Axes,  Next: Draw Border Box,  Prev: Draw Axes If Needed,  Up: Draw

9.3.9.5 `draw axes'
...................

     `draw axes [.style.|frame|none]'

With no style (`.style.') specified, draw x-y axes frame labelled at
left and bottom. The value of `.style.' determines the style of axes:
   * `.style. = 0' Draw x-y axes frame labelled at left and bottom.
     Since this is the default, it's best to leave it out altogether to
     make your code easier to understand.

   * `.style. = 1' Draw axes without tics at top and right

   * `.style. = 2' Draw axes frame with no tics or labels; same as
     `draw axes frame'

   With the keyword `frame' specified, draw axes frame with no tics or
labels (just like `.style.' = 2, but preferable because it makes for
code that is easier to read and understand).

   With the keyword `none' specified, prevent Gri from automatically
drawing axes when drawing curves.

   Note: `set axes style' can also be used to set axes properties, and
then simply using `draw axes', or letting axes be auto-drawn, will
result in the desired effect (*Note Set Axes Style::).  However, if the
`draw axes' command explicitly asks for a particular style, then it
over-rides the style set by `Set Axes Style'.


File: gri.info,  Node: Draw Border Box,  Next: Draw Box,  Prev: Draw Axes,  Up: Draw

9.3.9.6 `draw border box'
.........................

     `draw border box .xleft. .ybottom. .xright. .ytop. \
         .width_cm. .brightness.'

Draw gray box, as decoration or alignment key for pastup. The box, with
outer lower left corner at (`.xleft.', `.ybottom.') and outer upper
right corner at (`.xright'., `.ytop.') - both coordinates being in
centimetres on the page - is drawn with thickness `.width_cm.' and with
graylevel `.brightness.' (0 for black; 1 for white).  The gray line is
drawn inside the box.  After drawing the gray line, a thin black line
is drawn along the outside edge.

   If the geometry is not specified with `.xleft.' and the other
parameters, then a reasonable margin is used around the present axes
area, and the defaults (`.border.' = 0.2, `.brightness.' = 0.75) are
used.

   NOTE: This command does not cause auto-drawing of axes.


File: gri.info,  Node: Draw Box,  Next: Draw Circle,  Prev: Draw Border Box,  Up: Draw

9.3.9.7 `draw box'
..................

     `draw box filled .xleft. .ybottom. .xright. .ytop. [cm|pt]'

Draw filled box spanning indicated range, with lower-left corner at
(`.xleft.', `.ybottom.') and upper-right corner at (`.xright.',
`.ytop.').  The corners are specified in user coordinates, unless the
optional `cm' or `pt' keyword is present, in which case they are in
centimetres or points on the page.  An error will result if you specify
user coordinates but they aren't defined yet.

   No checking is done on the rectangle; for example, there is no
requirement that `.xleft.' be to the left of `.xright.' in your
coordinate system.

   NOTE: if the box is specified in user units, this command will cause
auto-drawing of axes, but not if the box is specified in `cm' or `pt'
units

     `draw box .xleft. .ybottom. .xright. .ytop. [cm|pt]'

Draw box spanning indicated range, with lower-left corner at
(`.xleft.', `.ybottom.)' and upper-right corner at (`.xright.',
`.ytop.').

   The corners are specified in user coordinates, unless the optional
`cm' or `pt' keyword is present, in which case they are in centimetres
or points on the page.  An error will result if you specify user
coordinates but they aren't defined yet.

   No checking is done on the rectangle; for example, there is no
requirement that `.xleft.' be to the left of `.xright.' in your
coordinate system.


File: gri.info,  Node: Draw Circle,  Next: Draw Contour,  Prev: Draw Box,  Up: Draw

9.3.9.8 `draw circle'
.....................

     draw circle with radius .r_cm. at .x_cm. .y_cm.

Draw circle of specified radius (in cm) at the specified location (in
cm on the page).


File: gri.info,  Node: Draw Contour,  Next: Draw Curve,  Prev: Draw Circle,  Up: Draw

9.3.9.9 `draw contour'
......................

     `draw contour [{.value. \
       [unlabelled | {labelled "\label"}]} \
       | {.min. .max. .inc. \
         [.inc_unlabelled.] [unlabelled]}]'

This command draws contours based on the "grid" data previously read in
by a `read grid data' command or created by gridding column data with a
`create grid from columns' command.  If the grid data don't exist, or
if the x and y locations of the grid points do not exist (see `set x
grid', `set y grid', etc), Gri will complain.

   With no optional parameters, draw labelled contours at an interval
that is picked automatically based on the range of the data.

   With a single numerical value (`.value.'), draw the indicated
contour.  With the addition of `labelled "\label"', put the indicated
label instead of a numeric label.  This can be useful for using
scientific notation instead of computer notation for exponents, e.g.
`draw contour 1e-5 labelled "10$^{-5}$"'.

   With (`.min.', `.max.' and `.inc.') given, draw contours for z(x,y)
= `.min.', z(x,y) = `.min. + .inc.', z(x,y) = `.min. + 2*.inc.', ...,
z(x,y) = `.max.'

   With the additional value `.inc_unlabelled.' specified, extra
unlabelled contours are drawn at this finer interval.

   With the optional parameter `unlabelled' at the end of any form of
this command (except the `labelled "\label"' variation, of course), Gri
will not label the contour(s).

   *Hint:* It can be effective to draw contours at a certain interval
with labels, and a thicker pen, e.g.

     set line width rapidograph 3x0
     draw contour -2 5 1 0.25
     set line width rapidograph 1
     draw contour -2 5 1

   Interpolation method: The interpolation scheme is the same used for
converting grid-values to image values (*Note Convert Grid To Image::).

   *See also* `set contour labels'


File: gri.info,  Node: Draw Curve,  Next: Draw Essay,  Prev: Draw Contour,  Up: Draw

9.3.9.10 `draw curve'
.....................

Several forms exist.

     `draw curve'

Draws a curve connecting the points (x,y), which have been read in by a
command like `read columns x y'.  Line segments are drawn between all
(x,y) points, except: (1) no line segments are drawn to any missing
data (see `set missing value'), and (2) if clipping is turned on (see
`set clip on'), no line segments are drawn outside the clipping region.
*See also* `draw curve overlying'

     `draw curve overlying'

Like `draw curve', except that before drawing, the area underneath the
curve (+/- one linewidth) is whited out.  This clarifies graphs where
curves overlie other curves or the axes.  *See also* `draw curve'.

     `draw curve filled [to {.y. y}|{.x. x}]'

The form `draw curve filled ...' draws filled curves.  If the `to
.value.' is not specified, fill the region defined by the x-y points
using the current paint colour (see `set graylevel').  To complete the
shape, an extra line is drawn between the first and last points.

   The form `draw curve filled to .y. y' fills the region between y(x)
and y = `.y.'; do not connect the first and last points as in the case
where `to .yvalue.' is not specified.

   The form `draw curve filled to .x. x' fills the region between x(y)
and x = `.x.'


File: gri.info,  Node: Draw Essay,  Next: Draw Gri Logo,  Prev: Draw Curve,  Up: Draw

9.3.9.11 `draw essay'
.....................

     `draw essay "text"|reset'

Draw indicated text on the page.  Succeeding calls draw text further and
further down the page, starting at the top.

   The current font size is used; to alter this, use `set font size'
before `draw essay'.

   When `reset' is present instead of text, the drawing position is
reset to the top of the page.  Use this after a `new page' command to
ensure that the next text lines will appear at the top of the page as
expected.  EXAMPLE:

     set font size 2 cm
     draw essay "Line 1, at top of page"
     draw essay "Line 2, below top line"


File: gri.info,  Node: Draw Gri Logo,  Next: Draw Grid,  Prev: Draw Essay,  Up: Draw

9.3.9.12 `draw gri logo'
........................

     `draw gri logo .x_cm. .y_cm. .height_cm. .style. \fgcolor \bgcolor'

Draw a Gri logo at given location with given style and colors.  The
lower-left corner of the logo will be `.x_cm.' centimeters from the
left-hand side of the page and `.y_cm.' centimeters from the bottom of
the page.  The logo will be `.height_cm.' centimeters tall.  The
textual parameters `\fgcolor' and `\bgcolor' give the foreground and
background colors, respectively, and these are used in styles as noted
in the table below

     .style.    style
     =======    ===================
        0       stroke curve
        1       fill with color \fgcolor, no background
        2       fill with color \fgcolor it in tight box of color \bgcolor
        3       as 2 but in square box
        4       draw in \fgcolor on top of shifted copy in \bgcolor

   An example is given below

     draw gri logo 1 1 3 4 blue green


File: gri.info,  Node: Draw Grid,  Next: Draw Image Histogram,  Prev: Draw Gri Logo,  Up: Draw

9.3.9.13 `draw grid'
....................

     `draw grid'

Draw plus-signs at locations where grid data are non-missing.


File: gri.info,  Node: Draw Image Histogram,  Next: Draw Image Palette,  Prev: Draw Grid,  Up: Draw

9.3.9.14 `draw image histogram'
...............................

     `draw image histogram \
       [box .llx_cm. .lly_cm. .urx_cm. .ury_cm.]'

With no optional parameters, draw histogram of all unmasked parts of the
image, placing it above the current top of the plot.

   When the `box' options are present, they specify the box (in
centimetre coordinates on the page) in which the histogram plot is to be
done.


File: gri.info,  Node: Draw Image Palette,  Next: Draw Image,  Prev: Draw Image Histogram,  Up: Draw

9.3.9.15 `draw image palette'
.............................

     `draw image palette
        [axisleft|axisright|axistop|axisbottom]
        [left .left. right .right. [increment .inc.]]
        [box .xleft_cm. .ybottom_cm. .xright_cm. .ytop_cm.]'

With no optional parameters, draw palette for image, placed above the
current top showing values ranging from `.min_value.' to `.max_value.'
as given in `set image range'.

   Optional keywords (`axisleft', etc) control the orientation of the
palette, the default being `axisbottom'.

   The optional parameters `.left.' and `.right.' may be used to
specify the range to be drawn in the palette.  If the additional
optional parameter `.inc.' is present, it specifies the interval
between tics on the scale; if not present, the tics are at increments of
2 * (`.right.' - `.left'.).  (If `.inc.'  has the wrong sign, it will
be corrected without warning.)

   When the optional `box' parameters are present, they prescribe the
bounding box to contain the palette.  The units are centimetres on the
page.  If these parameters are not present, the box will be drawn above
the image plot.

   *Hint* It is a good idea to make the palette range `.left.' to
`.right.' extend a little beyond the range of full white and full
black, since otherwise neither pure white nor pure black will appear in
the colorbar.  For example

     set image grayscale black 0 white 1 increment 0.1
     draw image palette left -0.1 right 1.1 increment 0.1

   *Hint* Continuous-tone images with superimposed contours are often
effective.  To get the contour lines drawn on the image palette, do
something like this

     draw image
     .left.   = 0
     .right.  = 9
     .inc.    = 1
     .space.  = 3
     .height. = 1
     draw image palette left .left. \
       right .right. \
       increment .inc. \
       box \
         ..xmargin.. \
         {rpn ..ymargin.. ..ysize.. + .space. + } \
         {rpn ..xmargin.. ..xsize.. +} \
         {rpn ..ymargin.. ..ysize.. + .space. + .height. + }
     draw contour .left. .right. .inc. unlabelled

     .c. = .left.
     while {rpn .right. .c. <= }
       .c_cm. = {rpn .c. .left. - \
        .right. .left. - / \
         ..xsize.. * ..xmargin.. +}
       draw line from \
         .c_cm. \
         {rpn ..ymargin.. ..ysize.. + .space. + }\
         to \
         .c_cm. \
         {rpn ..ymargin.. ..ysize.. + .space. + .height. +} \
         cm
       .c. += 1
     end while


File: gri.info,  Node: Draw Image,  Next: Draw Isopycnal,  Prev: Draw Image Palette,  Up: Draw

9.3.9.16 `draw image'
.....................

     `draw image'

Draw black/white image made by `convert grid to image' or by `read
image'.


File: gri.info,  Node: Draw Isopycnal,  Next: Draw Isospice,  Prev: Draw Image,  Up: Draw

9.3.9.17 `draw isopycnal'
.........................

     `draw isopycnal \
        [unlabelled] .density. [.P_sigma. [.P_theta.]]'

   Draw isopycnal curve for a temperature-salinity diagram.  This curve
is the locus of temperature and salinity values which yield seawater of
the indicated density, at the indicated pressure.  The UNESCO equation
of state is used.

   For the results to make sense, the x-axis should be salinity and the
y-axis should be either in-situ temperature or potential temperature.

   The `.density.' unit is kg/m^3.  If the supplied value exceeds 100
then it will be taken to indicate the actual density; otherwise it will
be taken to indicate density minus 1000 kg/m^3.  (The deciding value of
100 kg/m^3 was chosen since water never has this density; the more
intuitive value of 1000 kg/m^3 would be inappropriate since water can
have that density at some temperatures.)  Thus, 1020 and 20 each
correspond to an actual density of 1020 kg/m^3.

   The reference pressure for density, `.P_sigma.', is in decibars
(roughly corresponding to meters of water depth).  If no value is
supplied, a pressure of 0 dbar (i.e. atmospheric pressure) is used.

   The reference pressure for theta, `.P_theta.', is in decibars, and
defaults to zero (i.e. atmospheric pressure) if not supplied.  This
option is used if the y-axis is potential temperature referenced to a
pressure other than the surface.  Normally the potential temperature is,
however, referenced to the surface, so that specifying a value for
`.P_theta.' is uncommon.

   By default, labels will be drawn on the isopycnal curve; this may be
prevented by supplying the keyword `unlabelled'.  If labels are drawn,
they will be of order 1000, or of order 10 to 30, according to the
value of `.density.' supplied (see above).  The label format defaults
to "%g" in the C-language format notation, and may be controlled by
`set contour format'.  The label position may be controlled by `set
contour label position' command (bug: only non-centered style works).
Setting label position is useful if labels collide with data points.
Labels are drawn in the whiteunder mode, so they can white-out data
below.  For this reason it is common to draw data points after drawing
isopycnals.

   If the y-axis is in-situ temperature, the command should be called
without specifying `.P_sigma.', or, equivalently, with `.P_sigma.' = 0.
That is, the resultant curve will correspond to the (S,T) solution to
the equation

     .density. = RHO(S, T, 0)

where `RHO=RHO(S,T,p)' is the UNESCO equation of state for seawater.
This is a curve of constant sigma_T.

   If the y-axis is potential temperature referenced to the surface,
`.P_theta.' should not be specified, or should be specified to be zero.
The resultant curve corresponds to a constant value of potential
density referenced to pressure `.P_sigma.', i.e. the (S,theta) solution
to the equation

     .density. = RHO(S, theta, .P_sigma.)

For example, with `.P_sigma.=0' (the default), the result is a curve of
constant sigma_theta.

   If the y-axis is potential temperature referenced to some pressure
other than that at the surface, `.P_theta.' should be supplied.  The
resultant curve will be the (S,theta) solution to the equation

     .density. = RHO(S, T', .P_sigma.)

where

     T'=THETA(S, theta, .P_theta., .P_sigma.)

where `THETA=THETA(S,T,P,Pref)' is the UNESCO formula for potential
temperature of a water-parcel moved to a reference pressure of `Pref'.
Note that `theta', potential temperature referenced to pressure
`.P_theta.', is the variable assumed to exist on the y-axis.


File: gri.info,  Node: Draw Isospice,  Next: Draw Label Boxed,  Prev: Draw Isopycnal,  Up: Draw

9.3.9.18 `draw isospice'
........................

     `draw isospice .spice. [unlabelled]'

Draw an iso-spice line for a "TS" diagram, using (S, T) data stored in
files in a subdirectory named `iso-spice0' in a directory named by the
unix environment variable `GRI_EOS_DIR'.  You must set this environment
variable yourself, in the normal unix way.  If `GRI_EOS_DIR' is not
defined, Gri looks in the directory `/data/po/ocean/EOS/iso0'; of
course, this will work only for people on the same machine as the
author.

   Only certain iso-spice lines are stored in these files, so only
certain values of `.spice.' are allowed.  They are 21.75, 22.00, 22.25,
..., 30.75.  You must supply `.density.' in exactly this format (with 2
decimal places), or else Gri will not find the appropriate TS file, and
will give a "can't open file" error.  NB: isopycnals ranging from about
23.00 to 26.00 cross a TS diagram spanning 34<S<36 and 0<T<10.

   The line is labelled at the right with the density value, unless the
`unlabelled' option is given.

   Clipping should be on when drawing iso-spice lines.  A warning will
be given if the isospice line does not intersect the clipping region.

   EXAMPLE

     set clip on
     draw isospice line 27.00
     draw isospice line 27.50 unlabelled


File: gri.info,  Node: Draw Label Boxed,  Next: Draw Label Whiteunder,  Prev: Draw Isospice,  Up: Draw

9.3.9.19 `draw label'
.....................

     `draw label boxed "string" at .xleft. .ybottom. [cm]'

Draw boxed label for plot, located with lower-left corner at indicated
(x,y) position (specified in user units or in cm on the page).  The
current font size and pen color are used.  The geometry derives from the
current font size, with the label being centered within the box.


File: gri.info,  Node: Draw Label Whiteunder,  Next: Draw Label For Last Curve,  Prev: Draw Label Boxed,  Up: Draw

9.3.9.20 `draw label whiteunder'
................................

     `draw label whiteunder "\string" at .xleft. .ybottom. [cm]'

Draw label for plot, located with lower-left corner at indicated (x,y)
position (specified in user units or in cm on the page).  Whiteout is
used to clean up the area under the label.  BUGS: Cannot handle angled
text; doesn't check for super/subscripts.


File: gri.info,  Node: Draw Label For Last Curve,  Next: Draw Label,  Prev: Draw Label Whiteunder,  Up: Draw

9.3.9.21 `draw label for last curve'
....................................

     `draw label for last curve "label"'

Draw a label for the last curve drawn, using the `..xlast..' and
`..ylast..' built-in variables.


File: gri.info,  Node: Draw Label,  Next: Draw Line From,  Prev: Draw Label For Last Curve,  Up: Draw

9.3.9.22 `draw label'
.....................

     `draw label "\string" [centered|rightjustified] \
         at .x. .y. [cm|pt] \
         [rotated .deg.]'

With no optional parameters, draw string at given location in USER
units.

   With the `cm' or `pt' keyword is present, the location is in
centimetres or points on the page.

   With the `rotated' keyword present, the angle in degrees from the
horizontal, measured positive in the counterclockwise direction, is
given.

   With the keyword `centered' present, the text is centered at the
given location; similarly the keyword `rightjustified' makes the text
end at the given location.


File: gri.info,  Node: Draw Line From,  Next: Draw Line Legend,  Prev: Draw Label,  Up: Draw

9.3.9.23 `draw line from ... to'
................................

     `draw line from .x0. .y0. to .x1. .y1. [cm|pt]'

With no optional parameters, draw a line from (`.x0.', `.y0.')  to
(`.x1.', `.y1'.), where coordinates are in user units.  With the `cm'
or `pt' keyword present, the coordinates are in centimetres or points
on the page.  NOTE: This will not cause auto-drawing of axes.


File: gri.info,  Node: Draw Line Legend,  Next: Draw Lines,  Prev: Draw Line From,  Up: Draw

9.3.9.24 `draw line legend'
...........................

     `draw line legend "label" at .x. .y. [cm] [length .cm.]'

Draw a legend identifying the current line type with the given label.  A
short horizontal line is drawn starting at the location (`.x.', `.y.'),
which may be specified in centimetres or, the default, in user
coordinates.  The line length is normally 1 cm, but this length can be
set by the last option.  The indicated label string is drawn 0.25 cm to
the right of the line.

   *See also* `draw symbol legend ...'.

   EXAMPLE (of keeping track of the desired location for the legend)

     .offset. = 1                    # cm to offset legends
     # ... get salinity data
     set line width 0.25
     draw curve
     draw line legend "Salinity" at .x. .y.
     # ... get temperature data
     set line width 1.0
     set dash 0.45 0.05
     draw curve
     .y. += .offset.
     draw line legend "Temperature" at .x. .y.


File: gri.info,  Node: Draw Lines,  Next: Draw Patches,  Prev: Draw Line Legend,  Up: Draw

9.3.9.25 `draw lines'
.....................

     `draw lines {vertically .left. .right. .inc.} | \
         {horizontally .bottom. .top. .inc.}'

Draw several lines, either vertically or horizontally.  This can be
useful in drawing gridlines for axes, etc.  The following example shows
how to draw thin gray lines extending from the labelled tics on the x
axis (ie, at 0, 0.1, 0.2, ... 1):

     set x axis 0 1 0.1 0.05
     set y axis 10 20 10
     draw axes
     set graylevel 0.75
     set line width 0.5
     draw lines vertically 0 1 0.1
     set graylevel 0


File: gri.info,  Node: Draw Patches,  Next: Draw Polygon,  Prev: Draw Lines,  Up: Draw

9.3.9.26 `draw patches'
.......................

     `draw patches .width. .height. [cm]'

With the optional `cm' keyword not present, draw column data z(x,y) as
gray patches according to the grayscale as set by most recent `set
image grayscale'.  The patches are aligned along the horizontal, and
have the indicated size in user units.

   With the optional keyword `cm' is present, the patch size is
specified in centimetres.


File: gri.info,  Node: Draw Polygon,  Next: Draw Regression Line,  Prev: Draw Patches,  Up: Draw

9.3.9.27 `draw polygon'
.......................

     `draw polygon [filled] .x0. .y0. .x1. .y1. [other pairs] [user|cm|pt]'

Draw a polygon connecting the indicated points, specified in user
units.  The last point is joined to the first by a line segment.  At
least two points must be specified.  If the `filled' keyword is
present, the polygon is filled with the current pen color.  If no unit
is given, user units are used.


File: gri.info,  Node: Draw Regression Line,  Next: Draw Symbol At,  Prev: Draw Polygon,  Up: Draw

9.3.9.28 `draw regression line'
...............................

     `draw regression line [clipped]'

Fit and draw a regression line to column data, of the form  `y =
..coeff0.. + ..coeff1.. * x', exporting `..coeff0..', `..coeff0_sig..',
`..coeff1..'  and `..coeff1_sig..'  as global variables (*Note
Regress::).

Normally, the line is not clipped to the axes frame, but it will be if
the keyword `clipped' is given.

HINT: to label the plot you might do the following:

     sprintf \label "y = %f + %f * x. R$^2$=%f" \
       ..coeff0.. ..coeff1.. ..R2..
     draw title "The linear fit is \label"


File: gri.info,  Node: Draw Symbol At,  Next: Draw Symbol Legend,  Prev: Draw Regression Line,  Up: Draw

9.3.9.29 `draw symbol ... at'
.............................

     `draw symbol .code.|\name at .x. .y. [cm|pt]'

Draw a symbol at given (single) location.  The location is normally in
user coordinates; it will be in centimetres on the page if the optional
`cm' or `pt' keyword is given.

   With the optional numerical/name code specified, then the symbol of
that number or name is drawn at each (x,y) datum, whether or not a
z-column exists.  The numerical/name codes are:

      # name                description
     -- ----                -----------
      0 plus                +
      1 times               x
      2 box                 box
      3 circ                circle
      4 diamond             diamond
      5 triangleup          triangle with base at bottom
      6 triangleright       triangle with base at left
      7 triangledown        triangle with base at top
      8 triangleleft        triangle with base at right
      9 asterisk            *
     10 star                star of David
     11 filledbox           filled box
     12 bullet              filled circle
     13 filleddiamond       filled diamond
     14 filledtriangleup    filled triangleup
     15 filledtriangleright filled triangleright
     16 filledtriangledown  filled triangledown
     17 filledtriangleleft  filled triangleleft


File: gri.info,  Node: Draw Symbol Legend,  Next: Draw Symbol,  Prev: Draw Symbol At,  Up: Draw

9.3.9.30 `draw symbol legend'
.............................

     `draw symbol legend \symbol_name "label" \
         at .x. .y. [cm]'

Draw indicated symbol at indicated location, with the indicated label
beside it.  The label is drawn one M-space to the right of the symbol,
vertically centered on the indicated `.y.' location.


File: gri.info,  Node: Draw Symbol,  Next: Draw Time Stamp,  Prev: Draw Symbol Legend,  Up: Draw

9.3.9.31 `draw symbol'
......................

     `draw symbol [[.code.|\name]    \
         | [graylevel z]             \
           [color [hue z|.h.]        \
                  [brightness .b.]   \
                  [saturation .s.]]]'

With no optional parameters, draw symbols at the (x,y) data.  If a
z-column has been read with `read columns', then its value codes the
symbol to draw, according to the table below.  (The value of z is first
rounded to the nearest integer.)  If no z-column has been read, the
symbol X is drawn at each datum.

   With the optional numerical/name code specified, then the symbol of
that number or name is drawn at each (x,y) datum, whether or not a
z-column exists.  The numerical/name codes are:

      # name                description
     -- ----                -----------
      0 plus                +
      1 times               x
      2 box                 box
      3 circ                circle
      4 diamond             diamond
      5 triangleup          triangle with base at bottom
      6 triangleright       triangle with base at left
      7 triangledown        triangle with base at top
      8 triangleleft        triangle with base at right
      9 asterisk            *
     10 star                star of David
     11 filledbox           filled box
     12 bullet              filled circle
     13 filleddiamond       filled diamond
     14 filledtriangleup    filled triangleup
     15 filledtriangleright filled triangleright
     16 filledtriangledown  filled triangledown
     17 filledtriangleleft  filled triangleleft

   With the optional `graylevel z' fields specified, the graylevel is
given by the `z' column (0=black, 1=white).

   With the optional `color' field specified, the color is specified,
either directly in the command (the `hue .h.' form) or in the z column.
For more information on color, refer to the `set color hsb ...'
command.

   Examples: both `draw symbol bullet color' and `draw symbol bullet
color hue z' draw bullets whose hue is given by the value in the z
column.  The hue (or the color, in other words) blends smoothly across
the spectrum as the numerical value ranges from 0 to 1.  The value
0yields red, 1/3 yields green, 2/3 yields blue, etc.  If the
`brightness' and the `saturation' are not specified, they both default
to the value 1, which yields pure, bright colors.

   Example: draw all in green dots `draw symbol bullet color hue 0.333
brightness 1 saturation 1'

   Example: display spectrum of dots

     set symbol size 0.3
     open "awk 'END{ \
         for(c=0;c<1;c+=1/40) \
             print(c,c,c)}' | "
     read columns x y z
     close
     draw symbol bullet color hue z


File: gri.info,  Node: Draw Time Stamp,  Next: Draw Title,  Prev: Draw Symbol,  Up: Draw

9.3.9.32 `draw time stamp'
..........................

     `draw time stamp \
         [fontsize .points. \
             [at .x_cm. .y_cm. cm \
                 [with angle .deg.]]]'

Draw the command-file name, PostScript file name, and time, at the top
of graph.  Normally, the timestamp is drawn at the top of the page, in a
fontsize of 10 points.  But the user can specify the fontsize, and
additionally the location (in cm) and additionally the angle measured in
degrees anticlockwise from the horizontal.

   NOTE: If you want to have the plot drawn in landscape mode, ensure
that `set page landscape' precedes `draw time stamp.'


File: gri.info,  Node: Draw Title,  Next: Draw Values,  Prev: Draw Time Stamp,  Up: Draw

9.3.9.33 `draw title'
.....................

     `draw title "\string"'

Draw the indicated string above the plot.


File: gri.info,  Node: Draw Values,  Next: Draw X Axis,  Prev: Draw Title,  Up: Draw

9.3.9.34 `draw values'
......................

     draw values                 \
         [.dx. .dy.]             \
         [\format]               \
         [separation .xcm. .ycm.]

Draw values of `z' column, at corresponding (`x', `y') locations.  If
the `separation' keyword is present, the distance between successive
points is checked, and points are skipped unless the x and y
separations exceed the indicated distances.

   * `draw values' Draw the values of `z(x,y)', positioned 1/2 M-space
     to the right of `(x,y)' and vertically centred on `y'.  The values
     are written in a good general format known as `%lg', in C
     terminology.

   * `draw values %.2f' Draw values of `z(x,y)' positioned as described
     above, but using the indicated format string.  This format string
     specifies that 2 numbers be used after the decimal place, and that
     floating point should be used.  See any C manual for format codes.

   * `draw values .dx. .dy.' Print values of `z(x,y)' at indicated
     offset vector (`.dx.',`.dy.'), measured in centimeters, from the
     values of `(x,y)' at which the data are defined.

   * `draw values .dx. .dy. %.3f' Print values of `z(x,y)' at indicated
     distance from `(x,y)', indicated format.


File: gri.info,  Node: Draw X Axis,  Next: Draw X Box Plot,  Prev: Draw Values,  Up: Draw

9.3.9.35 `draw x axis'
......................

     draw x axis [at bottom|top|{.y. [cm]} [lower|upper]]

Draw an x axis, optionally at a specified location and of a specified
style.
   * `draw x axis' Draw a lower x axis (ie, one with the numbers below
     the line) at the bottom of the box defined by `set y axis'.

   * `draw x axis at bottom' Draw a lower x axis (ie, one with the
     numbers below the line) at the bottom of the box defined by `set y
     axis'.

   * `draw x axis at top' Draw an upper x axis (ie, one with the
     numbers above the line) at the top of the box defined by `set y
     axis' (or above any existing stacked x axes there)

   * `draw x axis at .y.' Draw a lower x axis at indicated value of
     `.y.'.

   * `draw x axis at .y. upper' Draw an upper x axis at indicated value
     of .y.


File: gri.info,  Node: Draw X Box Plot,  Next: Draw Y Axis,  Prev: Draw X Axis,  Up: Draw

9.3.9.36 `draw x box plot'
..........................

     draw x box plot at .y. [size .cm.]

Draw Tukey box plots (which give a summary of histogram properties).
Box plots were invented by Tukey for eda (exploratory data analysis).
The centre of the box is the median.  The box edges show the first
quartile (q1) and the third quartile (q3).  The distance from q3 to q1
is called the inter-quartile range.  The whiskers (i.e., the lines with
crosses at the end) extend from q1 and q3 to the furthest data points
which are still within a distance of 1.5 inter-quartile ranges from q1
and q3.  Beyond the whiskers, all outliers are shown: open circles are
used for data within a distance of 3 inter-quartile ranges beyond q1 and
q3, and in closed circles beyond that.

   * `draw x box plot at .y.' Draw Tukey's box plot, spreading in the x
     direction, centered at y=`.y.' and of default width 0.5 cm.

   * `draw x box plot at .y. size .cm.' Draw Tukey's box plot,
     spreading in the x direction, centered at y=`.y.' and of width
     `.cm.' centimetres.


File: gri.info,  Node: Draw Y Axis,  Next: Draw Y Box Plot,  Prev: Draw X Box Plot,  Up: Draw

9.3.9.37 `draw y axis'
......................

     draw y axis [at left|right|{.x. cm} [left|right]]

Draw a y axis, optionally at a specified location and of a specified
style.

   * `draw y axis' Draw a left-hand-side y axis (ie, one with the
     numbers to the left of the line) at left of box defined by `set x
     axis'

   * `draw y axis at left' Draw a left-hand-side y axis (ie, one with
     the numbers to the left of the line) at left of box defined by
     `set x axis'.

   * `draw y axis at right' Draw a right-hand-side y axis (ie, one with
     the numbers to the right of the line) at right of box defined by
     `set x axis'.

   * `draw y axis at .x.' Draw a left-hand-side y axis (ie, one with
     the numbers to the left of the line) at indicated value of `.x.'

   * `draw y axis at .x. right' Draw a right-hand-side y axis (ie, one
     with the numbers to the right of the line) at indicated value of
     `.x.'


File: gri.info,  Node: Draw Y Box Plot,  Next: Draw Zero Line,  Prev: Draw Y Axis,  Up: Draw

9.3.9.38 `draw y box plot'
..........................

     draw y box plot at .x. [size .cm]

Draw Tukey box plots (which give summary of histogram properties).
   * `draw y box plot at .x.' Draw Tukey's box plot, spreading in the y
     direction, centered at x=`.x.' and of default width 0.5 cm.

   * `draw y box plot at .x. size .cm.' Draw Tukey's box plot,
     spreading in the y direction, centered at x=`.x.' and of width
     `.cm.' centimetres.


File: gri.info,  Node: Draw Zero Line,  Next: End Group,  Prev: Draw Y Box Plot,  Up: Draw

9.3.9.39 `draw zero line'
.........................

     draw zero line [horizontally|vertically]

Draw lines corresponding to x=0 or y=0.
   * `draw zero line' Draw line y=0 if it is within axes.

   * `draw zero line horizontally' Draw line y=0 if it is within axes.

   * `draw zero line vertically' Draw line x=0 if it is within axes.


File: gri.info,  Node: End Group,  Next: Expecting,  Prev: Draw Zero Line,  Up: List Of Gri Commands

9.3.9.40 `end grouip'
.....................

     end group

_Command not implemented yet.  Syntax may change._


File: gri.info,  Node: Expecting,  Next: Filter,  Prev: End Group,  Up: List Of Gri Commands

9.3.10 `expecting'
------------------

     expecting version a.b
     expecting version a.b.c

Show a list of incompatibilites that have been introduced since the
named version.  This command can make your commandfiles more reliable
against changes to Gri.

   There are two forms of the version number.  Modern versions use the
triplet form, e.g.  `expecting version 2.8.7', but prior to October
1996 the version numbers were written in decimal form, so that you
would write `expecting version 1.069' for example.


File: gri.info,  Node: Filter,  Next: Flip,  Prev: Expecting,  Up: List Of Gri Commands

9.3.11 `filter'
---------------

   * `filter column x|y|z|u|v|weight recursively a[0] a[1] ... b[0]
     b[1] ...' Filter indicated column, using a two-pass recursive
     filter.  The first pass runs from the start to the end, while the
     second pass runs from the end to the start; in this way, the phase
     shift inherent in this type of filter is removed entirely.  The
     coefficients are used in the following formula (demonstrated on
     the `x' column):

          x_new[i] = b[0] * x[i] \
            + b[1] * x[i-1] \
            + b[2] * x[i-2] \
            + ... \
            - a[1] * x_new[i-1] \
            - a[2] * x_new[i-2] \
            - ...

     Thus, for example, setting `a[i]' = 0 results in a simple
     backwards-looking moving-average filter applied in two passes.
     The real power of this type of filter, however, comes when
     non-zero `a[i]' coefficients are given, thus adding recursion
     (i.e., `x_new[i]' depends on `x_new[i-...]').  See any standard
     reference on digital filters for an explanation.  You might find
     that the Matlab command `butter' an easy way to design filter
     coefficients.  Here are some examples:

          # Filter x column with simple 2-point moving
          # average.  (This slurs into a 3-point moving
          # average, in effect, since the filter is run
          # forwards and then backwards.)
          filter column x recursively 0 0 0.5 0.5

          # Use filter designed with the Matlab
          # command butter(2,0.1), which creates a
          # 2nd order lowpass butterworth filter
          # with a cutoff frequency of 0.1
          # (in units which have a frequency
          # of 1 corresponding to one-half the
          # sampling rate).
          filter column x recursively \
              1     -1.561  0.6414 \
              0.0201 0.0402 0.0201

   * `filter grid rows|columns recursively a[0] a[1] ... b[0] b[1] ...'
     Apply recursive filter (see `filter column ... recursively' for
     meaning of this filter operation) to the individual rows or
     columns of the grid data.  For example, the command `filter grid
     columns recursively 0 0 0.5 0.5' applies a 2-point moving average
     filter across the columns, smoothing the grid in the x-direction.

   * `filter image highpass' Remove low-wavenumber components from
     image (ie, sharpen edges).  Do this by subtracting a Laplacian
     smoothed version of the image.

   * `filter image lowpass' Remove high-wavenumber components from
     image (ie, smooth shapes).  Do this by Laplacian smoothing.

   *See also* *Note Smooth::.


File: gri.info,  Node: Flip,  Next: Get Env,  Prev: Filter,  Up: List Of Gri Commands

9.3.12 `flip'
-------------

     `flip grid|image x|y'

Flip grid or image by relecting it about a horizontal or vertical
centerline.
   * `flip grid x' Flip grid so right-hand side becomes left-hand side.

   * `flip grid y' Flip grid so bottom side becomes top side.

   * `flip image x' Flip image so right-hand side becomes left-hand
     side.

   * `flip image y' Flip image so bottom side becomes top side.


File: gri.info,  Node: Get Env,  Next: Group,  Prev: Flip,  Up: List Of Gri Commands

9.3.13 `get env'
----------------

     `get env \result \environment_variable'

Get the value of an "environment variable" from the unix operating
system, and store the result in the indicated synonym.  This makes most
sense on unix systems (hence the name, patterned after the unix command
`getenv').  This command can be useful in making gri programs resistant
to changes in data-file locations.  Suppose, for example, there is a
file called `data', normally in a local directory called `Bravo'.  The
line `open Bravo/data' will fail if the Bravo directory is moved.  But
if the name of the datafile is stored in an unix environment variable,
`DIR_BRAVO' say, then the gri program will work no matter where the
Bravo data are moved, so long as an appropriate environment variable is
modified when the data are moved.  Example:

     get env \dir DIR_BRAVO
     if {rpn "\dir" "" ==}
         show "Cannot determine location of the Bravo data,"
         show "which should be stored in the environment"
         show "variable DIR_BRAVO.  You should"
         show "do something like"
         show "export DIR_BRAVO='/data/Bravo/'"
         show "in your ~/.environment file"
         quit
     end if
     open \dir/data
     ...


File: gri.info,  Node: Group,  Next: Heal,  Prev: Get Env,  Up: List Of Gri Commands

9.3.14 `group'
--------------

     `group ["\name"]'

_Command not implemented yet.  Syntax may change._


File: gri.info,  Node: Heal,  Next: Help,  Prev: Group,  Up: List Of Gri Commands

9.3.15 `heal'
-------------

     heal columns|{columns along x|y}
The `heal' command heals over gaps in either columnar or gridded data.
This is done by linear interpolation across the missing-value gaps.

   * `heal columns' Fill in missing values in x, y, z, ... columns, by
     linear interpolation to neighboring valid data.  All gaps in the
     data will get replaced by a linear function of index which matches
     the data at the indices just before and just after the gap.  For
     example, if the y data were like

          111
          3
          -9
          -9
          -9
          7
          333

     where `-9' is the missing-value code, then they would get replace
     by

          111
          3
          4
          5
          6
          7
          333

     Notes: (1) This is done *independently* for all existing columns.
     (2) Gaps at the start and end of the columns are not filled in.

   * `heal grid along x' Scan in the x direction, filling in missing
     values by linear interpolation.  Since this uses the the x-grid,
     you must first have done `read grid x' or `set x grid'.

   * `heal grid along y' Scan in the y direction, filling in missing
     values by linear interpolation.  Since this uses the the y-grid,
     you must first have done `read grid y' or `set y grid'.


File: gri.info,  Node: Help,  Next: If,  Prev: Heal,  Up: List Of Gri Commands

9.3.16 `help'
-------------

     `help [*|command_name|{- topic}]'

Give help on a command or topic.
   * `help' Print a general help message.

   * `help *' Prints complete help info.

   * `help command_name' Prints help on the command whose name begins
     with the string `command_name'.  The string may be several words
     long; e.g.  `help set' or `help set x axis'.

   * `help - topic_name' The minus sign tells Gri that the string to
     follow it is a topic, not a command.  Topics Gri knows about are
     listed by the one-word `help' request.


File: gri.info,  Node: If,  Next: Ignore,  Prev: Help,  Up: List Of Gri Commands

9.3.17 `if'
-----------

(*See also* *Note If Statements::.)

     `if {[!] .flag.}|\flag|{{"string1" == "string2"}}'

Control program flow.  The `if' block is ended with a line containing
`end if'.  Optional `else' and `else if' blocks are allowed.  Note that
rpn expressions are allowed, and a special form of string comparison is
allowed, as in the examples below.

     if .flag.
       # List of Gri commands to be done if .flag. is 1.
       # This list may extend across any number of lines.
     end if

If the variable `.flag.' is not equal to 0, do the code between the
`if' line and the `end if' line.

     if .flag.
       # Commands done if .flag. is 1
     else
       # Commands done if .flag. is 0
     end if

If the variable `.flag.' is not equal to 0, do the code between the
`if' line and the `else' line.  If `.flag.' is equal to 0, do the code
between the `else' line and the `end if' line.

     if ! .flag.
       # Commands done if .flag. is 0
     end if

If the variable `.flag.' is equal to 0, do the code between the `if'
line and the `end if' line.

     if {rpn .flag. 10 <}
       # Commands done if 10 is less than .flag.
     end if

If the variable `.flag.' is greater than 10, do the code between the
`if' line and the `end if' line.

     if \smooth
       # Commands done if \smooth is 1
     else
       # Commands done if \smooth is 0
     end if

If the number stored in the synonym `\smooth' is not equal to 0, do the
code between the `if' line and the `else' line.  If the synonym stores
a representation of a number not equal to zero, do the `else' part.  If
the synonym contains text that does not decode to a number, generate
error message.

     if {"\item" == "Temperature"}
       # Commands done if the synonym \item is equal to the
       # indicated text string.
     end if

If the synonym `\item' has the value `Temperature' stored in it, do the
indicated code.

     if {rpn "\item" "Temperature" ==}
       # Commands done if the synonym \item
       # equals indicated text string.
     end if

As above, but using the `rpn' calculator (*Note rpn Mathematics::).

     if {rpn "\item" "Temperature" !=}
       # ...
     end if

As above, but do the indicated code if `\item' is *not* equal to
`Temperature'.


File: gri.info,  Node: Ignore,  Next: Input,  Prev: If,  Up: List Of Gri Commands

9.3.18 `ignore'
---------------

     `ignore last .n.'

Ignores last `.n.' lines read by `read columns'.


File: gri.info,  Node: Input,  Next: Insert,  Prev: Ignore,  Up: List Of Gri Commands

9.3.19 `input'
--------------

     `input \ps_filename \
       [.xcm. .ycm. \
         [.xmag. .ymag. \
           [.rot_deg.]]]'

Input the named PostScript file directly into the Gri output PostScript
file.  (If the filename has punctuation, insert it in double quotes,
e.g. `input "../thefile"'.)  If no options are specified, the file is
input at normal scale, with normal margins.  (Aside to PostScript
programmers: the named file is sandwiched between `gsave' and
`grestore' commands.)  If `.xcm.' and `.ycm.' are specified, then the
origin is moved to the named location first.  If, in addition, `.xmag.'
and `.ymag.' are specified, then these are used as scale factors after
translation.  Finally, if `.rot_deg.' is specified in addition, then
the indicated counterclockwise rotation is applied after translation
and scaling.  Hint: if the results look wrong, the first thing to do is
to think carefully about the order of the (translation, scaling,
rotation) operations.


File: gri.info,  Node: Insert,  Next: Interpolate,  Prev: Input,  Up: List Of Gri Commands

9.3.20 `insert'
---------------

     `insert \filename'

Perform the commands in the indicated file.

   If the file name is absolute (i.e. starts with `.', or with `/' or
with `~') then an error results if the file is not present (or cannot
be read by this user).

   However, if the file name starts with a normal letter, Gri will try
harder to locate the file.  If it is not in the local directory, and if
a `set path to "PATH" for commands' has been done, then Gri will search
the colon-separated directories for the file (*Note Set Path To::).

   If you don't want path-searching done, use the `source' command
instead (*Note Source::).


File: gri.info,  Node: Interpolate,  Next: List,  Prev: Insert,  Up: List Of Gri Commands

9.3.21 `interpolate'
--------------------

     interpolate x grid to .left. .right. .inc.|{/.cols.}'
     interpolate y grid to .bottom. .top. .inc.|{/.rows.}'

Transform grid by interpolating between existing grid data, according to
a new x or y grid specified in the manner of `set x grid' and `set y
grid'.  Note that the new grid is neccessarily regular, while the first
grid needn't have been.  The data of the new grid are constructed by
interpolation, using the same interpolation algorithm as the `convert
grid to image' command.


File: gri.info,  Node: List,  Next: Ls,  Prev: Interpolate,  Up: List Of Gri Commands

9.3.22 `list'
-------------

     `list \command-syntax'

List the source of a gri command.  Often this is just the name of a C
function internal to gri (try `list list' for an example), but when the
command is written in the gri programming language the source will be
more understandable (try `list set panel').


File: gri.info,  Node: Ls,  Next: Mask,  Prev: List,  Up: List Of Gri Commands

9.3.23 `ls'
-----------

     `ls [\file_specification]'

List files in current directory.  (The current directory can be printed
by the gri command `pwd' and can be set by the gri command `cd'.)  `ls
\file_specification' lists files in current directory which match the
file specification.  Normal unix file specification options are
understood.


File: gri.info,  Node: Mask,  Next: New,  Prev: Ls,  Up: List Of Gri Commands

9.3.24 `mask'
-------------

     `mask the image [to {uservalue .u.}|{imagevalue .i.}]'

Examine both the image and the mask pixel by pixel.  For any pixels
which have a mask value of 1 (which indicates an invalid region of the
image), change the image value.  If no `to' phrase is present, change
the image value to 0 in pixel units.  If the `to uservalue .u.' phrase
is present, change the pixel to hold the imagevalue that corresponds to
this uservalue (see `set image range' command for a discussion of this
correspondance).  If the `to imagevalue .i.' phrase is present, change
the pixel to hold that imagevalue (in range 0 to 255 inclusive for
8-bit images).


File: gri.info,  Node: New,  Next: Newpage,  Prev: Mask,  Up: List Of Gri Commands

9.3.25 `new'
------------

     new .variable_name. | \synonym_name \
        [.variable_name. | \synonym_name \
        [...]]

`new' sets aside storage for new version of the named variable(s)
and/or synonym(s).  Any number of variables and synonyms may be
specified.  If a given variable/synonym already exists, this will create
a new version of it, and future assignments will be stored in this new
version *without* affecting the pre-existing version.  If the
variable/synonym is `delete'ed, the new version is deleted, making the
old, unaltered, version accessible again.

   This command is used mostly for temporary use, to prevent clashing
with existing values.  Suppose you want to change the font size inside
a new command or an if block.  Then you might do the following, where
the variable `.tmp.' is used to store the old font size.  Note that the
use of the `new/delete' statements prevents the assignment to the local
version of the variable `.tmp.' from affecting the value known outside
the `if' block, if in fact `.tmp.' happened to exist outside the block.

     set font size 10
     draw label "This is in fontsize 10" at 10 2 cm
     if .want_title.
       new .tmp.
       .tmp. = ..fontsize..
       set font size 22
       draw label "This is 22 font" at 10 5 cm
       set font size .tmp.
       delete .tmp.
     end if
     draw label "This is 10 font" at 10 8 cm

   *Special case*: for local synonyms (e.g. `\.word1.', etc.), the
`new' operator checks to see whether the synonym is standing for an
"ampersand" argument, signalling a changeable argument that is a
variable or a synonym.  In such a case, `new' creates a new instance of
the item in the calling context.  The test suite has examples (*Note
Test Suite::).


File: gri.info,  Node: Newpage,  Next: New Postscript File,  Prev: New,  Up: List Of Gri Commands

9.3.26 `new page'
-----------------

     `new page'

Finish the present page, and start a new page.  All settings (of
linewidth, axes, landscape/portrait, etc) are retained on the new page.
Among these settings is the flag that tells gri whether you need axes
plotted along with your data.


File: gri.info,  Node: New Postscript File,  Next: Open,  Prev: Newpage,  Up: List Of Gri Commands

9.3.27 `new postscript file'
----------------------------

     `new postscript file "name"'

Finish the present Postscript file, and start a new page with the given
name.  All settings (of linewidth, axes, landscape/portrait, etc.) and
data are retained on the new file.


File: gri.info,  Node: Open,  Next: Opening Simple Files,  Prev: New Postscript File,  Up: List Of Gri Commands

9.3.28 `open'
-------------

There are two styles of `open' command.  In the first style, a simple
file is to be opened.  In the second style a unix-like "pipe" is
opened, i.e. Gri will read the output of a system command instead of a
file.

* Menu:

* Opening Simple Files::
* Opening Pipes::
* Opening URLs::


File: gri.info,  Node: Opening Simple Files,  Next: Ascii Files,  Prev: Open,  Up: Open

9.3.28.1 Opening simple files
.............................

* Menu:

* Ascii Files::
* Binary Files::
* NetCDF Files::


File: gri.info,  Node: Ascii Files,  Next: Binary Files,  Prev: Opening Simple Files,  Up: Opening Simple Files

   Ascii Files Most applications involve ascii files, and these are
very easy to handle in Gri.  For example given a data file named
`foo.dat', just use the command

     open foo.dat

and then you can read the data using various commands.  Thus a complete
program might be

     open foo.dat
     read columns x y
     draw curve

   If a filename contains blanks or punctuation symbols, you must put
it in double quotes (`"'), e.g.

     open "foo bar.dat"

   Indeed, Gri accepts double-quotes on any `open' command and some
folks use it on all commands, as a matter of habit.

   Gri can handle compressed files appropriately, e.g.

     open foo.data.gz

so that there is no need to uncompress data for use with Gri.

   Gri is quite persistant in looking for your file, and if a given
file is not found, it will then check to see if a compressed version is
available, and use that instead.  Thus

     open foo.dat

will look for a file named `foo.dat.gz' if `foo.dat' is not available.
(Only files compressed with the GNU `gzip' utility are handled.)

   If the `open' command was successful in opening the file, it will
set the value of the synonym `\.return_value.' to the full pathname of
the file.  Thus, if `open a.dat' is done in directory `/home/gri', then
`\.return_value.' will equal the string `/home/gri/a.dat'.


File: gri.info,  Node: Binary Files,  Next: NetCDF Files,  Prev: Ascii Files,  Up: Opening Simple Files

   Binary Files Like most computer programs, Gri has some trouble with
binary files.  One big issue is the so-called "endian" character of the
computer.  Some computers store multi-byte values with the most
significant bytes first, while others store them with the most
significant bytes last.  The problem is that nothing is stored in data
files to indicate which convention was employed.  For this reason, a
version of Gri compiled on a so-called "big-endian" computer will
misinterpret multi-byte values that were created on a so-called
"little-endian" computer.  Many folks in the scientific community have
converted to using the NetCDF format (see next section) for precisely
this reason, since this format is independent of the endian character
of the computer.

   Presuming an appropriate endian character, however, reading is
straightforward.  A command of the form

     open foo.dat binary

tells Gri that the data are stored in a binary format.  With the above
syntax, Gri expects images to be in `unsigned char' (8 bits), while
other data, such as columns and grids, are expected to be in 32-bit
format (suitable for reading into a so-called "float" variable in the C
programming language).

   You may also specify the format directly, as in the following
examples; Gri then interprets all data as being in the indicated format
and then converts to the internal format before using the data.

     open \filename binary uchar
     open \filename binary 8bit
     open \filename binary int
     open \filename binary float
     open \filename binary double
     open \filename binary 16bit

   As with ascii files, Gri will automatically uncompress any files that
are compressed, and if it fails to find a given filename, it will try to
open a compressed version of it (i.e. one with a `.gz' suffix).


File: gri.info,  Node: NetCDF Files,  Next: Opening Pipes,  Prev: Binary Files,  Up: Opening Simple Files

   NetCDF Files The NetCDF format provides the best of both worlds.  It
is binary, so that data are relatively compact, and may be read very
quickly.  (Reading ascii data is time-consuming in C++, the language in
which Gri is written.)  But it does not suffer the endian problem
problem of normal binary files (see previous section), since
information about the endian character is stored in the file itself,
and Gri uses this information to decode the data without difficulty,
regardless of the endian characteristics of the computer on which Gri
is running and of the computer that created the data.

   For more information on netCDF format, see

   `http://www.unidata.ucar.edu/packages/netcdf/index.html'

   The syntax of opening NetCDF files is as below

     open foo.nc netCDF

and the syntax for reading such files is described in sections on the
various `read' commands (see e.g. *Note Read Columns::).


File: gri.info,  Node: Opening Pipes,  Next: Opening URLs,  Prev: NetCDF Files,  Up: Open

9.3.28.2 Opening pipes
......................

Sometimes it makes sense to get Gri to work with the results of another
command in the OS.  Gri handles this by creating a so-called "pipe",
thus reading the output from the other command.  (Readers familiar with
the unix OS will know what pipes are all about, and especially why they
are a good thing.  Other readers might wish to skip this section.)

   Suppose we wish to plot an x-y plot using just the first few lines
of a datafile named `foo.dat'.  Unix users will know that a good way to
see the first few lines of such a file would be to type the command
`head foo.dat'.  They also know that these lines could be provided to a
second unix command, named `do_foo' say, by the command `head foo.dat |
do_foo'.  This uses a so-called "pipe", designated by the vertical line
(called a pipe symbol below).

   Gri can read the output from system commands by using a syntax in
which the (quoted) system command ends in a pipe symbol, e.g.

     open "head foo.dat |"

as in the example above.

   *Aside*: When pipe-open commands are used, Gri creates a temporary
file (often located in `/usr/tmp', but that varies with machine).  This
is automatically cleaned up when Gri completes executation, but if Gri
dies (or is interrupted) before it finishes, you'll be left with an
extra file in this temporary-storage directory.  It's up to you to clean
that directory up from time to time.

   Some common examples of pipe-open commands are given below.

  1. *Comma-separated values* are common in files created by, or
     intended for, spreadsheets.  Since Gri expects data elements to be
     separated by blanks (or tabs), you'll have to convert the commas
     into blanks.  There are many ways to do that using pipes, e.g.
     `sed' system utility, e.g.

          open "sed -e 's/,/ /g' foo.dat |"

     Other unix facilities, such as `tr' will also work, of course.  If
     the file has headers, you'll want to remove them also.  This can
     be done with the `skip' command (*Note Skip::) but you could also
     do it at the open stage, e.g. to remove the first two lines, use

          open "sed -e 's/,/ /g' foo.dat | tail +2 |"

  2. *Manipulating column data* is done by e.g.

          open "cat foo.dat | awk '{$1, $2 * 22}' |"

     where `awk' has been used to multiply the second column in the file
     named `foo.dat' by 22.

  3. *Time-based and geographical data* are sometimes encountered.  For
     an example, suppose that longitude/latitude (i.e. x/y) data are
     stored in Hour.minutesecond format, e.g. 12.2133 means hour 12,
     minute 21, second 33.  Gri doesn't read HMS format, but gawk can
     be told to:

          open "cat datafile.HMS |        \
              awk '{                      \
              split($1, hms, \".\");      \
              h = hms[1];                 \
              m = int(hms[2] / 100);      \
              s = hms[2] - 100 * m;       \
              x = h + m / 60 + s / 3600;  \
              split($2, hms, \".\");      \
              h = hms[1];                 \
              m = int(hms[2] / 100);      \
              s = hms[2] - 100 * m;       \
              y = h + m / 60 + s / 3600;  \
              print(x,y)                  \
              }' | "
              read columns x y

  4. *Timeseries data* are often stored in formats that blend letters
     and numbers.  For one thing, using letters (e.g. `aug') removes an
     ambiguity in numerically-based data.  (Example: 02/03/2000 means
     one thing to an American and another thing in the rest of the
     world.  However, everybody agrees on what 2000-Feb-03 means.)
     Suppose, for example, that we have data in a format such as

          Tue_Jul_25_11:07:51 0.62
          Tue_Jul_25_11:22:51 0.59
          Tue_Jul_25_11:37:51 0.56

     (stored in a file called `foo.dat' say) and we want a graph of the
     y-variable (0.62, 0.59, 0.56) versus x-variable, time expressed
     say as seconds in the day.  Then here is how that could be done:

          open "cat foo.dat |\
              sed -e 's/_/ /g' -e 's/:/ /g' |\
              awk '{print ($4*3600+$5*60+$6, $7)}' |"
          read columns x y
          draw curve

     Note that the actual day information is skipped in this example;
     seasoned `awk' users could easily fill in the code to handle
     datasets spanning several days.


File: gri.info,  Node: Opening URLs,  Next: Postscript,  Prev: Opening Pipes,  Up: Open

9.3.28.3 Opening URLs
.....................

Gri can open a URL, _if_ you have the `wget' program on your machine.
(`wget' is available from the GNU website
`http://www.gnu.org/software/wget/'.)

   The URL must be enclosed in quotes (since otherwise, Gri will
interpret the `//' sequence as indicating an old way of denoting
comments).  For example,
     open "http://gri.sourceforge.net/gridoc/examples/example1.dat"
     read columns x y
     show columns

   If you don't have `wget' installed on your machine, the above won't
work, but you can always use another fetching program, with a system
call, as in the following:
     \url = "http://gri.sourceforge.net/gridoc/html/examples/example1.dat"
     open "lynx -dump \url |"
     read columns x y
     draw curve


File: gri.info,  Node: Postscript,  Next: Pwd,  Prev: Opening URLs,  Up: List Of Gri Commands

9.3.29 `postscript'
-------------------

     `postscript \string'

Write the indicated string to the PostScript output file, after
substitution of synonyms if there are any.  Example:

     \a = "45"  # angle
     \w = "8.5" # page width
     postscript gsave \w 72 mul 0 translate \a rotate
     # ... other code to do stuff
     postscript grestore

   Here is how to draw an image palette vertically instead of
horizontally:

     \X = "3"	# cm
     \Y = "10"	# cm
     \a = "90"       # degrees counterclockwise
     postscript gsave \X 28.35 mul \Y 28.35 mul translate \a rotate
     # Palette is at user's origin
     draw image palette box 0 0 10 1
     postscript grestore

   NOTE: the `postscript' command is *very* dangerous, and should
normally only be used by developers.  Most of the code concerning this
is in the file `doline.cc'; look for the string `postscriptCmd' to find
the relevant code.


File: gri.info,  Node: Pwd,  Next: Query,  Prev: Postscript,  Up: List Of Gri Commands

9.3.30 `pwd'
------------

     `pwd'

Print current directory (which can be set by `cd').


File: gri.info,  Node: Query,  Next: Quit,  Prev: Pwd,  Up: List Of Gri Commands

9.3.31 `query'
--------------

     `query \synonym|.variable. \
       ["\prompt" ["\default"|.default.]]'

Ask the user for the value of a variable (number) or synonym (text
string).  Gri recognizes the type of the item being asked for, either a
variable or synonym, by the presence of a dot or backslash in the second
word of the command line.  If a prompt string is given (in quotes), then
this string is shown to the user.  If a default is given (in
parentheses), then it will be displayed also, and if the user types
carriage-return, then that item will be assigned to the variable or
synonym.  If the default has more than one item, then Gri considers this
a restrictive list of possibilities, and will demand that the answer be
in that list, going into an infinite query loop until an item from the
list (or carriage-return, meaning take first item) is found.  The items
in the list are to be separated by spaces, not commas or any other
non-whitespace characters.

   NOTE: The `-y' command-line option bypasses all query commands,
fooling Gri into thinking that the user typed a carriage-return to all
questions.  Thus the defaults, if they exist, are selected.


File: gri.info,  Node: Quit,  Next: Read,  Prev: Query,  Up: List Of Gri Commands

9.3.32 `quit'
-------------

     `quit [.exit_status.]'

Exits the gri program.  If an exit status (`.exit_status.') is
specified, then Gri returns this value, rounded to the nearest integer,
as the "exit status" (a concept meaningful mostly in the unix
environment, where it designates an error).


File: gri.info,  Node: Read,  Next: Read Colornames,  Prev: Quit,  Up: List Of Gri Commands

9.3.33 The `read' commands
--------------------------

There are several varieties of `read' command.  Those commands used for
reading numerical information (e.g. `read columns') are able to decode
variables and synonyms as well as simple numbers.

* Menu:

* Read Colornames::             Read colornames
* Read Columns::                Read (x,y,...) columnar data
* Read Grid::                   Read grid for contouring
* Read Image Colorscale::       Read colormap for color image
* Read Image Grayscale::        Read colormap for gray image
* Read Image Mask::             Read mask for image
* Read Image::                  Read image
* Read From::                   Change which open file looked at
* Read Synonym or Variable::    Read individual synonym or variable
* Read Line::                   Read whole line


File: gri.info,  Node: Read Colornames,  Next: Read Columns,  Prev: Read,  Up: Read

9.3.33.1 `read colornames'
..........................

     `read colornames from RGB "\filename"'

Read colornames from named file, which is in the X11 format.  This
format has 4 or more columns, the first three giving the red, green and
blue values in the range 0 to 255, and the last columns giving the
colorname (which may have more than one word).  You can create colors
yourself or read an X11 color file.  In many cases you will want to
`read colornames from RGB "/usr/lib/X11/rgb.txt"'.  Full filenames must
be used; the '~' syntax is not permitted.  Once you have read in a
colorname table, the named colors may be used as builtin colors (*Note
Set Color::).  To view the colors available on your particular system,
use the Unix command `xcolors' or `excolors'; to see the RGB values of
all colors on your X11 system, use the `showrgb' unix command..  To
view the names and RGB values of the colors Gri knows, including
builtin ones and ones from `read colornames', use `show colornames'.

   This command is akin to `set colorname' (*Note Set Colorname::),
except that the latter uses the Gri notation of color constituents being
in the range from 0 to 1, whereas for `read colornames' uses an X11
database, so that the color constitutents range from 0 to 255.


File: gri.info,  Node: Read Columns,  Next: Read Grid,  Prev: Read Colornames,  Up: Read

9.3.33.2 `read columns'
.......................

     `read columns ...'

   Read numbers into columns.  These columns have predefined meanings
and names.  For example, `read columns x y' instructs Gri to read data
into columns called `x' and `y'; it is these data that Gri will use if
you tell it to `draw curve'.  Other columns are: `z', used for
contouring a function `z=z(x,y)'; `weight', used for weighting data
points; `u' and `v', used for arrow (vector) plots.

   If the keyword `appending' is given as the last word on the `read
columns' line, then the new data will be appended to any existing
columnar data; otherwise they will overwrite any existing data.

   As a special case, if the `x' column is not indicated (e.g. `read
columns y') then Gri creates x-values automatically, in the sequence 0,
1, 2, etc.

   * `read columns x y' Read `x' in column 1, `y' in column 2 until
     blank-line found.  Only the first two numbers on each line will be
     read; any extra numbers (or words) on the line will be ignored.

   * `read columns * y * * x' Read `x' in column 5, `y' in column 2.
     The `*' character is a spacer.  It instructs Gri to skip the
     first, third, and fourth words on the data line.  These words need
     not be numbers.  This example illustrates a general mechanism of
     using the `*' character to skip over unwanted items in the data
     file.  Note that there is no need to supply `*' characters for
     trailing extraneous words; Gri will skip them anywary.  Finally,
     note that any order of `x' and `y' (and the other columns; see
     below) is allowed.

   * `read columns y=2 x=5' or `read columns x=5 y=2' As above; read
     `x' in column 5 and `y' in column 2.  The column number may be
     specified in this manner for all the named column variables.  No
     spaces are allowed before or after the `=' sign.  The first column
     is called column 1.  Whether this format is used or the `*' format
     is a matter of choice, except that numbered format also permits
     using a given number to fill several variables (for example `read
     columns x=1 y=2 u=1 v=2').

   * `read columns x="netCDF_name" ...' If the file is a `netCDF' file,
     opened by e.g. `open myfile.nc netCDF', then the `netCDF' variables
     for the columns, e.g.

          open latlon.nc netCDF
          read columns x="longitude" y="latitude"

     Note: the data *must* be stored as the `netCDF' "float" type.

     For more information on netCDF format, see

     `http://www.unidata.ucar.edu/packages/netcdf/index.html'

   * `read columns * y z * x' Read `x' in column 5, `y' in column 2,
     and `z' in column 3.  The `z' column is used for contouring.

   * `read columns x y u v' Read `x' and `y' in first two columns, and
     the "arrow" data `u' and `v' as third and fourth columns.

   * `read columns .rows. x y' Read `.rows.' rows of column data.

   Sometimes you'll have `x' in one file and `y' in another.  In that
case, use the operating system or an editor to put the columns in one
file.  In unix, the easy way is

     open "paste file_with_x file_with_y |"
     read columns x y

   NOTE FOR BINARY FILES: For ascii files, Gri will proceed to a new
line after it has read the items requested; it skips any words
appearing on the data line after the last object of interest.  Thus
`read columns x y' will read the first two columns and ignore any other
columns that might be present.  But for binary files, Gri has no way of
knowing how to "skip" to the next line (see `skip' command), so you
will have to flesh out the `read columns' command with as many spacers
as are present in your data.  For example, if you have four numbers in
each data record and want to interpret the first two as `x' and `y',
you would use `read columns x y * *' to read the data.

   RETURN VALUE: Sets `\.return_value' to `N rows N non-missing N
inside-clip-region'


File: gri.info,  Node: Read Grid,  Next: Read Image Colorscale,  Prev: Read Columns,  Up: Read

9.3.33.3 `read grid'
....................

`read grid' commands read grid characteristics.  (The "grid" is the
object that is contoured.)

   For normal ascii or binary files, the commands to read the grid's
x-locations, y-locations and data are:

     `read grid x [.rows.]'
     `read grid y [.rows.]'
     `read grid data [spacers] \
       [.rows. .cols.] [spacers] [bycolumns]'

   For `netCDF' files, the commands are as follows (note that it is not
possible to specify the number of data to read, nor to read the grid by
columns).

     `read grid x = "variable_name"'
     `read grid y = "variable_name"'
     `read grid data = "variable_name"'

The ordering of the y-grid data is the same as if they were read from a
normal file: the first number is considered to be at the top of the
plot.

   For more information on netCDF format, see

   `http://www.unidata.ucar.edu/packages/netcdf/index.html'

   Details of the non-netCDF commands:
   * `read grid x [.cols.]' Read the `x' locations of the grid points,
     one number per line.  If `.cols.' is supplied, then that many
     values will be read; otherwise, reading will stop at end-of-file
     or blank-line.

   * `read grid y [.rows.]' As above, but for y grid;  `.rows.' is the
     number of rows.  The first number to be read corresponds to the
     location of the *top* edge of the grid.  Thus, if you were to view
     the column of numbers with a text editor, they would be oriented
     the same way as the corresponding elements will appear on the page.

   * `read grid data [.rows. .cols.]' Read data for a grid having
     `.rows.' and `.cols.' columns.  (If `.rows.' and `.cols.' are not
     supplied, but the grid already exists, then those pre-existing
     values are used.  If they are specified here, then they are
     checked for consistency with the pre-existing values if they
     exist.) Gri will read `.rows.' lines, each containing `.cols.'
     numbers.  (Extra information in the file can be skipped; see
     discussion of the `*' keyword below.)  Gri will interpret the
     first line it reads as the grid data corresponding to a value of y
     equal to `y[.rows.]'.  Thus, file should be arranged like this:

          f(x[1], y[.rows.])  ...  f(x[.cols.], y[.rows.])
                  .
                  .
                  .
          f(x[1], y[3])       ...  f(x[.cols], y[3])
          f(x[1], y[2])       ...  f(x[.cols], y[2])
          f(x[1], y[1])       ...  f(x[.cols], y[1])

   * `read grid data [.rows. .cols.] bycolumns' As above, but the
     `bycolumns' keyword tells Gri to read the data one column at a
     time, instead of one row at a time.  Each line is expected to
     contain `.rows.' numbers (as opposed to `.cols.' numbers, as in
     the format where the `bycolumns' keyword is not present).  (Extra
     information in the file can be skipped; see discussion of the `*'
     keyword below).  The first line of the data file contains the
     first column of the gridded data, corresponding to x equal to
     `x[1]').  The file should look like this:

          f(x[1], y[1])     ...     f(x[1], y[.cols.])
          f(x[2], y[1])     ...     f(x[2], y[.cols.])
          f(x[3], y[1])     ...     f(x[3], y[.cols.])
                  .
                  .
                  .
          f(x[.rows.],y[1]) ...  f(x[.rows.], y[.cols.])

   * `read grid data * * [.rows. .cols.]' As `read grid data .rows.
     .cols.' except that the first two words on each line are skipped.
     As usual, trailing extraneous numbers are also skipped.

   *See also* `set x grid', `set y grid'

RETURN VALUE: 

   `read grid x' sets `\.return_value' to `N cols'

   `read grid y' sets `\.return_value' to `N rows'

   `read grid data' sets `\.return_value' to `N rows N cols'


File: gri.info,  Node: Read Image Colorscale,  Next: Read Image Grayscale,  Prev: Read Grid,  Up: Read

9.3.33.4 `read image colorscale'
................................

     `read image colorscale [rgb|hsb]'

Read colorscale for image, from 256 lines each containing values for
Red, Green, and Blue (or Hue, Saturation and Brightness), separated by
whitespace.  The values are expected to be in the range 0 to 1, and are
clipped to these limits if not.

   For hints on how to create such an input file, *Note Read Image
Grayscale::.  If the example given there has the following code instead,

     open "awk 'BEGIN {               \
          for(i=0;i<256;i++) {        \
            print((i - 50)/50, 1, 1)  \
          }                           \
        }' |"
     read image colorscale hsb

then a linear full-color spectrum running from red at 10C to magenta at
15C is achieved.


File: gri.info,  Node: Read Image Grayscale,  Next: Read Image Mask,  Prev: Read Image Colorscale,  Up: Read

9.3.33.5 `read image grayscale'
...............................

     `read image grayscale'

Read grayscale for an image, from 256 lines each containing a single
value.  The values are expected to be in the range 0 to 1, and are
clipped to these limits if not.  For 8-bit images, Gri multiplies these
values by 255, and uses this list for the grayscale mapping.  Such a
list is created by `write image grayscale'.

   As an example, consider the code fragment (*Note Images::).

     set image range 5 30.5
     set image grayscale black 10 white 15

is equivalent to

     set image range 5 30.5
     open "awk 'BEGIN {\
       for(i=0;i<256;i++) {\
         print(1-(i-50)/50)\
       } \
     }' |"
     read image grayscale
     close

because the image formula is

     Temperature = 5C + 0.1C * pixelvalue
   where the pixelvalue ranges from 0 to 255.  Therefore, a temperature
of 10C is a pixelvalue of 50, and 15C is 100.  To get a grayscale
ranging between these values, therefore, we create a linear function
which maps the 50th pixelvalue into grayvalue 1, and the 100th
pixelvalue into grayvalue 0.  That is what the awk line does; to see
the actual numbers, you could insert the line `write image grayscale to
TMP' and look at the file `TMP' (bear in mind that Gri will clip the
values to the range 0 to 1).

   Sometimes you will have a file, say named `map.dat', with RGB
numbers in the range 0-255, rather than 0-1 as Gri requires.  To read
them, use the operating system to convert the numbers for you (*Note
Open::).

     open "cat map.dat \
       | awk '{print(($1+$2+$3)/3/255)}' |"
     read image grayscale
     close


File: gri.info,  Node: Read Image Mask,  Next: Read Image,  Prev: Read Image Grayscale,  Up: Read

9.3.33.6 `read image mask'
..........................

     `read image mask rasterfile|{.rows. .cols.}'

Read image mask.  The mask is associated with the image read in by the
`read image' command in the following way.  When computing image
histograms, Gri ignores any pixels in the image for which the
corresponding pixel in the mask is set to `1'.

   * `read image mask rasterfile' The image size is specified in the
     rasterfile file itself, so it is not specified.

   * `read image mask .rows. .cols.' The file must contain
     `.rows.*.cols.' binary data.  Pixel order is the same as for
     images.


File: gri.info,  Node: Read Image,  Next: Read From,  Prev: Read Image Mask,  Up: Read

9.3.33.7 `read image'
.....................

There are several types of `read image' commands, depending on the file
format.  If the file is "raw", with no embedded information about
things like the width and height, then we need to specify everything, as
in the first format given below.  The other formats make use of the
header information in, e.g. PGM files.

   *Headerless images*

     `read image .rows. .cols. \
       [box .xleft. .ybottom. .xright. .ytop.] \
       [bycolumns]'

With no options specified (`read image .rows. .cols.'), read binary
data defining an `image'.  The image range must have previously have
been set by `set image range'.  The data are as written by "unsigned
char" format in C.

   When the `box' option is specified, the geometry of the image, in
user coordinates, is specified in terms of the cartesian coordinates of
the lower-left corner (`.xleft.', `.ybottom.') and upper-right corner
(`.xright.', `.ytop.').  If the `box' option is not specified, this
geometry can be specified with either `read x grid' or `set x grid',
plus either `read y grid' or `set y grid'.

   With the `bycolumns' keyword present, the image is read sweeping
from top-to-bottom, then left-to-right, instead of the usual order.

   *Sun rasterfile images*

     `read image rasterfile [box .xleft. .ybottom. .xright. .ytop.]'

Read image in Sun rasterfile format.  Image geometry is inferred from
the header, so `.rows.' and `.cols' parameters are not given.

   *PGM images*

     `read image pgm [box .xleft. .ybottom. .xright. .ytop.]'

Read image in PGM (Portable Gray Map) format.  Image geometry is
inferred from the header, so `.rows.' and `.cols' parameters are not
given.  Both ascii and binary PGM formats are supported (that is, files
with magic characters of P2 and P5).

   *NOTE* that there are many image formats and Gri doesn't try to deal
with them all.  The idea is to use another program to convert images to
a file format that Gri understands.  In the future Gri may support PNG
and other popular formats, especially in the Linux versions, for which
libraries exist to ease the input.


File: gri.info,  Node: Read From,  Next: Read Synonym or Variable,  Prev: Read Image,  Up: Read

9.3.33.8 `read from \filename'
..............................

     `read from \filename'

Cause future `read' commands to read from the indicated file.  If that
file is not open, an error message will result.  Use `read from
\filename' to shuffle reading among several open files.

   Gri can look up filenames for `read from' in terms of their full
pathnames or their local pathnames.  Thus, a local file called `a.dat'
in the directory `/home/gri' can be referred to by `read from a.dat' or
by `read from /home/gri/a.dat', which comes in handy if you need to
work with two files of the same name, in other directories.  However,
since Gri has the ability to search for files in a "path" (*Note Set
Path To::), you may not have specified an exact path name; this is why
the `open' command provides a return value which names the full
pathname (*Note Opening Simple Files::).


File: gri.info,  Node: Read Synonym or Variable,  Next: Read Line,  Prev: Read From,  Up: Read

9.3.33.9 `read' synonym/variable
................................

     `read [* [*...]] \synonym|.variable. [\synonym|.variable. [...]]}'

Read one or more items from the next line of the input file.  These
items may be synonyms or variables.  The token `*' indicates that the
word in the datafile should be skipped.  As usual, the datafile may be
embedded in the commandfile, providing the last data line is blank.

   Normally one would use synonyms for words, and variables for numbers.
The items are separated by one or more "whitespace" characters (e.g.
space or TAB).  Thus, if a file contained the line

     Temperature 10.3

then the line

     read \var_name .var_value.

would have the same result as

     \var_name = "Temperature"
     .var_value. = 10.3

   This command ignores any trailing items on the line.  That is, the
next `read' command will start on the next line of the file.  In a
sense then, you get just one shot at analysing the input line in your
datafile.  If you need flexibility, you may wish to read the *whole*
contents of the line into a synonym, which may be done using the `read
line' command instead, to read it in as a string.  (*Note Read Line::).

   If the input file is in the netCDF format, the indicated item will
be read.  For example, `read \time:_MissingValue' reads the missing
value for the variable called `time'.  This conveniently allows your
data file to dictate axes names, units, missing values, etc.  Example:

     # Plot profile of TU81N (age-corrected tritium)
     open profile.nc netCDF
     read columns x="TU81N" y="z"
     read \{z:_FillValue}		# assume same for all
     read \{z:long_name}
     read \{z:units}
     read \{TU81N:long_name}
     read \{TU81N:units}
     close
     set missing value \{z:_FillValue}
     set x name "\{TU81N:long_name} (\{TU81N:units)}"
     set y name "\{z:long_name} (\{z:units)}"
     set y axis decreasing
     draw curve

   For more information on netCDF format, see
`http://www.unidata.ucar.edu/packages/netcdf/index.html'


File: gri.info,  Node: Read Line,  Next: Regress,  Prev: Read Synonym or Variable,  Up: Read

9.3.33.10 `read line'
.....................

     `read line \synonym'

Read the next line of the datafile (or commandfile), trim off a trailing
comment if there is one, and then store the next line of datafile into
the named synonym.


File: gri.info,  Node: Regress,  Next: Reorder,  Prev: Read Line,  Up: List Of Gri Commands

9.3.34 `regress'
----------------

     `regress {y vs x [linear]}|{x vs y [linear]}'

Perform linear regression of `y' as a function of `x' or `x' as a
function of `y'.

   * `regress y vs x' Linear regression of y vs x.  Several quantities
     are reported and also saved into builtin variables.  The intercept
     is defined as `..coeff0..', its 95 percent confidence limit is
     defined as `..coeff0_sig..'.  Thus the confidence range is
     `..coeff0..-..coeff0_sig..' to `..coeff0..+..coeff0_sig..'.
     Similarly the slope and confidence limit are stored in `..coeff1..'
     and `..coeff1_sig..'

     The squared correlation coefficient is stored in `..R2..'.

     *Historical note* prior to version 2.1.15, a different meaning was
     attached to `..coeff0_sig..' and `..coeff1_sig..'; they used be
     defined as standard errors, without having been multiplied by the
     appropriate student-t coefficient.

   * `regress x vs y' Linear regression of x vs y; for notation see
     above.

   * `regress y vs x linear' Linear regression of y vs x; for notation
     see above.

   * `regress x vs y linear' Linear regression of x vs y; for notation
     see above.


File: gri.info,  Node: Reorder,  Next: Rescale,  Prev: Regress,  Up: List Of Gri Commands

9.3.35 `reorder'
----------------

     `reorder columns randomly \
       |{ascending in x|y|z} \
       |{descending in x|y|z}'

Reorder the columns in various ways.

   In the `randomly' style, the column data are shuffled randomly by
index, retaining the correspondance between a given x and y.  This is
useful with `draw symbol' using colored dots - it prevents the
overpainting of one dot on another from biasing the color field to
values that happened to occur near the end of the column data.  If you
prefer the overpainting to be done in random order, use this command to
reorder the columns randomly.  The random number is selected using the
system `rand' call, with the seed being provided by the PID (process
ID) of the job.

   The `ascending' and `descending' styles do what you'd expect.


File: gri.info,  Node: Rescale,  Next: Resize,  Prev: Reorder,  Up: List Of Gri Commands

9.3.36 `rescale'
----------------

     `rescale'

Re-determine the scales for the x and y axes.  Typically used after a
column math operation, when you want the new data to be auto-scaled.
(Note: normally, if the axes have already been drawn, Gri won't rescale
automatically just because you modify the column data.  This is designed
so that you can add offsets to curves, etc, while staying in saved axes.
But if the axes have not been drawn yet when you modify the column data,
then Gri will automatically rescale the axes it is planning to draw.)


File: gri.info,  Node: Resize,  Next: Return,  Prev: Rescale,  Up: List Of Gri Commands

9.3.37 `resize'
---------------

     `resize {x for maps}|{y for maps}'

Resize the axes frame region in such a way that geographical objects
appear in correct proportions.  This assumes that y is degrees latitude
and x is degrees longitude.

   * `resize x for maps' Resize the plot width for maps, assuming that
     x represents longitude and y represents latitude.  Before using
     this, you must have defined scales for both x and y, and a size
     for y (ie, you must have done `set x axis ...', `set y axis ...'
     and `set y size'); this command sets the x size, thus eliminating
     `set x size.' The result is that, at the central latitude (y), a
     centimetre on the page will correspond to an equal distance on the
     earth, in both the north-south and east-west directions.

   * `resize y for maps' Resize the plot height for maps, assuming that
     x represents longitude and y represents latitude.  Before using
     this, you must have defined scales for both x and y, and a size
     for x (ie, you must have done `set x axis ...', `set y axis ...'
     and `set x size'); this command sets the y size, thus eliminating
     `set y size.' The result is that, at the central latitude (y), a
     centimetre on the page will correspond to an equal distance on the
     earth, in both the north-south and east-west directions.

     *See also* `resize x for maps'.


File: gri.info,  Node: Return,  Next: Rewind,  Prev: Resize,  Up: List Of Gri Commands

9.3.38 `return'
---------------

     `return'

Return early from a user-defined function or an `insert' file.  Or, in
the main gri program, do the same thing as `quit'.


File: gri.info,  Node: Rewind,  Next: Rpnfunction,  Prev: Return,  Up: List Of Gri Commands

9.3.39 `rewind'
---------------

     `rewind \filename'

Rewind a data-file to the beginning.  If no filename is given, this is
done for the currently active file; otherwise the named file is rewound.


File: gri.info,  Node: Rpnfunction,  Next: Set,  Prev: Rewind,  Up: List Of Gri Commands

9.3.40 `rpnfunction'
--------------------

     `rpnfunction name replacement-words'

Create a new keyword for use in rpn expressions.  Inside any RPN
expression which follows this line, the word `name' will be substituted
with the indicated replacement words.

   For example, the following shows the definition and use of a
function which computes the sine of twice an angle, by multiplying
whatever is on the stack by `2', and then taking the sine of the result.

     rpnfunction sin2 2 * sin
     show "expect the number 1 to follow: " {rpn 45 sin2}

   The replacement words will have any synonyms in them translated
first, unless they start with an underscore followed by a double
backslash.  Similarly, variables are substituted unless they start with
an underscore.  These exceptions are to allow the use of the `defined'
operator (*Note rpn Mathematics::).

   Note: The mathematical constants `e' and `pi' are stored using
`rpnfunctions'.  Also, two `rpnfunctions' are provided for finding the
slope and intercept of a line joining two points, e.g.  

     # Expect answers 1 and 10 ...
     show "slope=" {rpn 0 1 1 11 linear_slope}
     show "inter=" {rpn 0 1 1 11 linear_intercept}

   These are useful in `set grid missing above .intercept. .slope.' and
`set z missing above .intercept. .slope.'.


File: gri.info,  Node: Set,  Next: Set Axes Style,  Prev: Rpnfunction,  Up: List Of Gri Commands

9.3.41 The `set' commands
-------------------------

Set various flags and parameters which Gri will use in later commands.

* Menu:

* Set Axes Style::              Set type of axes
* Set Arrow Size::              Set size for arrow heads
* Set Arrow Type::              Set type of arrow heads
* Set Beep::                    Set error beeping on or off
* Set Bounding Box::            Set PostScript bounding box
* Set Clip::                    Set clipping region
* Set Color::                   Set color of pen
* Set Colorname::               Create a color name
* Set Contour Format::          Set format for numbers on contours
* Set Contour Label For::       Set existence of contour labels
* Set Contour Label Position::  Set spacing of contour labels
* Set Contour Labels::          Control various things about contour lables
* Set Dash::                    Set style of dashed lines
* Set Environment::             (Developer cmd)
* Set Error Action::            Set error behavior
* Set Flag::                    Set flag to control Gri (developer cmd)
* Set Font Color::              Set color of pen used for text
* Set Font Encoding::           Set font encoding vector
* Set Font Size::               Set size of text
* Set Font To::                 Set font for text
* Set Graylevel::               Set graylevel of pen
* Set Grid Missing::            Set missing region of grid
* Set Ignore Initial Newline::  Set to ignore initial blank line
* Set Ignore Error Eof::        Set ability to tolerate EOF on files
* Set Image Colorscale::        Set colorscale mapping for image
* Set Image Grayscale::         Set grayscale mapping for image
* Set Image Missing Value Color::  Set missing value color in image
* Set Image Range::             Set range of data that image can hold
* Set Input Data Window::       Set data window for reading columns
* Set Input Data Separator::    Set separator between data items
* Set Line Cap::                Set line end (cap) type
* Set Line Join::               Set method for intersections of line segments
* Set Line Width::              Set width of lines
* Set Missing Value::           Set "missing" value
* Set Page Size::               Set page size
* Set Page::                    Set page style
* Set Panel::                   Establish geometry for a panel of multipanel plot
* Set Panels::                  Prepare for multipanel plot
* Set Path To::                 Set search-path for data or command files
* Set Postscript Filename::     Set name of PostScript file
* Set Symbol Size::             Set size of symbols
* Set Tic Size::                Set size of tics on axes
* Set Trace::                   Set printout of statements as executed
* Set Transparency::            Set transparency of the pen
* Set U Scale::                 Set scale for u (i.e. x) component of arrows
* Set V Scale::                 Set scale for v (i.e. y) component of arrows
* Set X Axis::                  Set range of x axis
* Set X Format::                Set format for numbers on x axis
* Set X Grid::                  Set x mesh of contour grid
* Set X Margin::                Set margin to left of x axis
* Set X Name::                  Set name of x axis
* Set X Size::                  Set length of x axis
* Set X Type::                  Set type of x axis (log/linear)
* Set Y Axis::                  Set range of y axis
* Set Y Format::                Set format for numbers on y axis
* Set Y Grid::                  Set y mesh of contour grid
* Set Y Margin::                Set margin below y axis
* Set Y Name::                  Set name of y axis
* Set Y Size::                  Set length of y axis
* Set Y Type::                  Set type of y axis (log/linear)
* Set Z Missing::               Set missing region of z column


File: gri.info,  Node: Set Axes Style,  Next: Set Arrow Size,  Prev: Set,  Up: Set

9.3.41.1 `set axes style'
.........................

     set axes style .style.     \
       | {offset [.dist_cm.]} \
       | rectangular|none|default

Tell Gri how you want the axes to look, when they are drawn later.

   * `set axes style 0' Set axes to be rectangular, with an x-y axis
     frame labelled at the left and bottom and tic marks on all axes.

   * `set axes style 1' As style `0', but only put tics on the lower
     and left axes.

   * `set axes style 2' As style `0' but without labels or tics on any
     axis, i.e. just an axis frame.

   * `set axes style offset [.dist_cm.]' Set axes so that the actual x
     and y axes will be drawn with a space separating them from the
     data area.  The space, if not set by the `.distance_cm.' option,
     will be equal to the current tic size (see `set tic size').  This
     command can be used together with any other `set axes style'
     command.  It applies to both the `draw axes' command and with any
     `draw x|y axis' command in which the axis location is not
     explicitly given.

   * `set axes style rectangular' Set axes to be rectangular, with an
     x-y axes frame labelled at the left and bottom.

   * `set axes style none' Tell gri not to bother drawing axes before
     drawing curves, etc.

   * `set axes style default' Same as `set axes style 0', and with
     `offset' turned off.


File: gri.info,  Node: Set Arrow Size,  Next: Set Arrow Type,  Prev: Set Axes Style,  Up: Set

9.3.41.2 `set arrow size'
.........................

     `set arrow size .size.           \
       | {as .num. percent of length} \
       | default'

Set the arrowsize (which is stored in the builtin variable
`..arrowsize..').

   * `set arrow size .size.' Set the arrow size (ie, half-width of the
     arrowhead) to `.size.' centimetres.

   * `set arrow size as .num. percent of length' Set the arrow size to
     be the indicated percentage of arrow length, as in "HWP" in the
     singles ads.  (As a flag to this, `..arrowsize..' is set to the
     negative of the fractional size measured in percent.)

   * `set arrow size default' Set the arrow size to the default of 0.2
     cm.


File: gri.info,  Node: Set Arrow Type,  Next: Set Beep,  Prev: Set Arrow Size,  Up: Set

9.3.41.3 `set arrow type'
.........................

     set arrow type .which.

   Set type of arrow, according to the value of `.which.', rounded to
the nearest integer.  A rounded `.which.' value of 0 yields the default
arrows, drawn with three line strokes.  Value 1 yields outlined arrows,
sometimes used on definition sketches.  Value 2 yields filled,
swept-back arrow heads.

   This command uses the "line join" parameters that are presently
active (*Note Set Line Join::).  So, by default, the arrow ends are
rounded (because the default line-join parameter is 1).  To get pointy
ends, first set the line join parameter to 0.


File: gri.info,  Node: Set Beep,  Next: Set Bounding Box,  Prev: Set Arrow Type,  Up: Set

9.3.41.4 `set beep'
...................

     `set beep on|off'

The command `set beep on' makes gri beep on errors and `query'.  `set
beep off' (the default) turns this beeping off.


File: gri.info,  Node: Set Bounding Box,  Next: Set Clip,  Prev: Set Beep,  Up: Set

9.3.41.5 `set bounding box'
...........................

     `set bounding box .xleft. .ybottom. .xright. .ytop. [pt|cm]'

Set the PostScript bounding box for the graph to the indicated values.
The bounding box is used by some programs to determine the region of the
page on which marks have been made.  For example, LaTeX uses the
bounding box to decide how to position figures in documents.

   Normally, the bounding box is computed automatically unless the
`-no_bounding_box' commandline option has been specified; (*Note
Invoking Gri::).  But if `set bounding box' is done, the automatically
computed value is ignored and the given box is used instead.  Use this
if Gri makes mistakes in its automatic selection of bounding box.

   The coordinates of the bounding box may be specified in (1) user
coordinates, as defined *at the moment* the command is executed, or (2)
in points on the page, measured from an origin at the lower-left (72
point per inch), or (3) in centimeters on the page.  Which coordinate
system is used depends on the last keyword - use `pt' for points, `cm'
for centimeters, and nothing at all for user-units.

   The most common use is in points, since that is how many other
application packages, e.g. LaTeX and dvips, specify the bounding box.

   If the box is specified in the user units, the user units in effect
*at the moment* of executing the `set bounding box' command are used.
This must be born in mind if the coordinate system is changing during
the execution of the program, e.g.  if margins are changing or the x
and y axes are changing.  For this reason it often makes sense to put
this command at the end of the commandfile.


File: gri.info,  Node: Set Clip,  Next: Set Color,  Prev: Set Bounding Box,  Up: Set

9.3.41.6 `set clip'
...................

     `set clip [postscript] \
       {on [.xleft. .xright. .ybottom. .ytop.]} \
       {to curve} \
       | off'

Control clipping of following drawing commands.  Note that the commands
have two styles, one of which includes the keyword `postscript'.
PostScript clipping does a cleaner job, but it results in larger file
sizes.  _Important_ if you are using `postscript' clipping, then you be
_sure_ to turn it off using `set clip postscript off', instead of `set
clip off'; otherwise Gri will get mixed up.

   * `set clip on' Don't plot data outside axes.

   * `set clip postscript on' As above, but Postscript clipping.

   * `set clip on .xleft. .xright. .ybottom. .ytop.' Don't plot data
     outside indicated box.

   * `set clip postscript on .xleft. .xright. .ybottom. .ytop.' As
     above, but Postscript clipping.

   * `set clip off' Plot all data, whether inside the axes or not.

   * `set clip postscript off' As above, but Postscript clipping.

   * `set clip to curve' set clip to the curve, as would be drawn by a
     `draw curve filled' command, i.e. to the polygon constructed by
     running along the xy points, in order, followed by a final segment
     from the last point back to the first point.  This is a
     "postscript" clip, as explained in the next item.

   * `set clip postscript to curve' As above, but Postscript clipping.

          draw axes
          set clip postscript on 10 20 0 1
          draw curve
          set clip postscript off

   * `set clip postscript off' Turn PostScript clipping off.  *See
     also* `set input data window'.  


File: gri.info,  Node: Set Color,  Next: Set Colorname,  Prev: Set Clip,  Up: Set

9.3.41.7 `set color'
....................

     `set color \name               | \
         {rgb .red. .green. .blue.} | \
     {hsb .hue. .saturation. .brightness.}'

Set the color of the "pen" used for drawing lines and text.  Normally
lines and text are drawn in the same color, but the text color can be
specified independently if desired (*Note Set Font Color::).  This
might be useful to get contour lines of one color and labels of
another.  The spelling `colour' is also accepted.

   In the `set color \name' style, set the drawing color to the
indicated name, either from the builtin list (`white', `LightGray',
`darkslategray', `black', `red', `brown', `tan', `orange', `yellow',
`green', `ForestGreen', `cyan', `blue', `skyblue', `magenta'), or from
a list created by `read colornames'.  In the latter case, if the
colorname has more than one word in it, use quotes, e.g. `set color
"ghost white"'.

   In the `set color rgb ...' style, set the individual color
components as indicated.  The numbers `.red.', `.green.' and `.blue.'
range from 0 (for no contribution of that color component to the final
color) to 1 (for maximal contribution).  Values less than 0 are clipped
to 0; values greater than 1 are clipped to 1.  EXAMPLES:

     set color rgb 0   0   0 # black
     set color rgb 1   1   1 # white
     set color rgb 1   0   0 # bright red
     set color rgb 0.5 0   0 # dark red (only 50 percent)
     set color rgb 0   1   0 # pure green
     set color rgb 1   1   0 # yellow: red + green

   In the `set color hsb ...' style, set the individual color
components as indicated.  The numbers `.hue.', `.saturation.' and
`.brightness.' range from 0 to 1.  The color, represented by .hue.,
ranges from 0 for pure red, through 1/3 for pure green, and 2/3 for
pure blue, and back to 1 again for pure red. The purity of the color,
represented by .saturation., ranges from 0 (none of the hue is visible)
to 1 (the maximal amount is present).  The brightness of the color,
represented by `.brightness.', ranges from 0 (black) to 1 (maximal
brigntness).  Values less than 0 are clipped to 0; values greater than
1 are clipped to 1.  EXAMPLES:

     set color hsb 0    1   1 # pure, bright red
     set color hsb 0    1 0.5 # half black, half red
     set color hsb .333 1   1 # pure, bright green


File: gri.info,  Node: Set Colorname,  Next: Set Contour Format,  Prev: Set Color,  Up: Set

9.3.41.8 `set colorname'
........................

     `set colorname \name {rgb .red. .green. .blue.} \
                        | {hsb .hue. .saturation. .brightness.}'

Create a colorname with the indicated color.  The color components range
from 0 to 1, and will be clipped to these values if they are outside
this range.  EXAMPLE (borrowing a color from `/usr/lib/X11/rgb.txt'):

     set colorname peachpuff rgb 1 {rpn 218 255 / }  {rpn 185 255 / }
     draw box filled 2 2 3 3 cm

   This command is akin to `read colornames' (*Note Read Colornames::),
except that the latter uses an X11 database, so the color constituents
range from 0 to 255, whereas for `set colorname' they range from 0 to 1.


File: gri.info,  Node: Set Contour Format,  Next: Set Contour Label For,  Prev: Set Colorname,  Up: Set

9.3.41.9 `set contour format'
.............................

     `set contour format \style|default'

Normally, Gri draws the numeric labels of contours using a format code
called `%g' in the "C" language.  You may specify any other "long"
format using this command.  For example, `set contour format %.1f'
tells Gri to use one decimal place in the numbers, and also to prefer
the "float" notation to the exponential notation.  `set contour format
default' resets to the default `%f' format.  You may use quotes around
the format if you need to, to make the item be a single word (e.g. `set
contour format "%.1f m/s"').


File: gri.info,  Node: Set Contour Label For,  Next: Set Contour Label Position,  Prev: Set Contour Format,  Up: Set

9.3.41.10 `set contour label for'
.................................

     `set contour label for lines exceeding .x. cm'

Make it so contour lines shorter than `.x.' centimeters will not be
labelled.


File: gri.info,  Node: Set Contour Label Position,  Next: Set Contour Labels,  Prev: Set Contour Label For,  Up: Set

9.3.41.11 `set contour label position'
......................................

     `set contour label position \
       {.start_cm. .between_cm.} \
       | centered \
       | default'

By default, contour labels are drawn at the location 1 cm into the
contour curve, measured from the startpoint of the contour (e.g., for
contours crossing the axes frames, the label will be 1 cm from the
frame), and then at a uniform distance along the contour.  By default,
this uniform distance is the average dimension of the plotting area
inside the axes.  If `.start_cm.' and `.between_cm.' are specified, the
first label is drawn at a distance `.start_cm.' from the start of the
contour, and thereafter at a separation of `.between_cm.'.

   If the `centered' option is used, then the contour labels are
centered along the length of the line.


File: gri.info,  Node: Set Contour Labels,  Next: Set Dash,  Prev: Set Contour Label Position,  Up: Set

9.3.41.12 `set contour labels'
..............................

     set contour labels rotated \
       | horizontal \
       | whiteunder \
       | nowhiteunder

The first two options control whether contour labels are rotated to line
up with the contour lines, or whether they are horizontal (the default).

   The second two options control whether the region under contour
labels is whited out before drawing the label.  The default is
`whiteunder', which has the visual effect of the label having been
drawn on a piece of paper and then pasted on.  This can look jarring
when the material under the contour is an image.  When `nowhiteunder'
is specified, the contour line is broken to make space for the text,
but no whiting out is done.


File: gri.info,  Node: Set Dash,  Next: Set Environment,  Prev: Set Contour Labels,  Up: Set

9.3.41.13 `set dash'
....................

     `set dash [.n.|{.dash_cm. .blank_cm. ...}|off]'

Control dash-style for following `draw curve' and `draw line' commands.

   * `set dash' Set to dashed line (0.4cm dashes, 0.1cm blanks).

   * `set dash .n.' Set to indicated pre-defined dashed line, according
     to table:

          .n. dash/cm blank/cm
           0        -        -   ... (Solid line)
           1      0.2      0.1
           2      0.4      0.1
           3      0.6      0.1
           4      0.8      0.1
           5      1.0      0.1
          10      w        w
          11      w        2w
          12      w        3w
          13      w        4w
          14      w        5w
          15      w        6w

     Where `w' is written, it indicates the current linewidth.  Thus,
     types 10 through 15 give square-dotted lines.

   * `set dash .dash_cm. .blank_cm. .dash_cm. .blank_cm. ...' Set to
     indicated dashed line.  The series of lengths `.dash_cm.' and
     `.blank_cm.' give the lengths of dash and blank portions (measured
     in centimeters).  Any number of dash/blank lengths may be given.
     For example, `set dash 0.5 0.1 0.1 0.1' looks good.

   * `set dash off' Turn dashing off, setting to a solid line.


File: gri.info,  Node: Set Environment,  Next: Set Error Action,  Prev: Set Dash,  Up: Set

9.3.41.14 `set environment'
...........................

     `set environment'

Set environment (graylevel, axis length, etc) so that following plotting
commands will make use of anything set by either a `set' command or by
direct manipulation of builtin variables like `..xsize..', etc.  NOTE:
this should *only* be done by developers.


File: gri.info,  Node: Set Error Action,  Next: Set Flag,  Prev: Set Environment,  Up: Set

9.3.41.15 `set error'
.....................

     `set error action to core dump'

Make Gri dump core when any error is found, to facilitate debugging.


File: gri.info,  Node: Set Flag,  Next: Set Font Color,  Prev: Set Error Action,  Up: Set

9.3.41.16 `set flag'
....................

     `set flag \name [off]'

Set the indicated flag to YES.  The name of the flag is contained in a
single word, e.g. `set flag dan_28sep_test'.  The action of the flags
may change with time and is undocumented.  This command is provided to
enable selected users (e.g., the developer himself) to use test
features of Gri before they are frozen into a fixed syntax and action.
The keyword `off' turns the indicated flag off.  NOTE: this should
*only* be done by developers.

     FLAG         DATE     ACTION

     jinyu1       29sep94  'convert columns to grid'
                            outputs (x,y,z,z_predicted)

     emulate_gre   9jun97  'E' format on axes yields
                           scientific notation

     kelley1      17jun97  for kelley only - quit contour
                           trace if hit nonlegit

     kelley2      17jun97  for kelley only: print
                           info while contour tracing


File: gri.info,  Node: Set Font Color,  Next: Set Font Encoding,  Prev: Set Flag,  Up: Set

9.3.41.17 `set font color'
..........................

     set font color \name           | \
         {rgb .red. .green. .blue.} | \
     {hsb .hue. .saturation. .brightness.}

The syntax is the same as `set color', except that this applies to text
only.  By default, text is drawn in the same color as lines, so text
color is changed as line color is changed (e.g. by using the `set
color' or `set graylevel' commands)).  However, once `set font color'
is used in a Gri program, the font thereafter maintains a separate
color from the lines.


File: gri.info,  Node: Set Font Encoding,  Next: Set Font Size,  Prev: Set Font Color,  Up: Set

9.3.41.18 `set font encoding'
.............................

     set font encoding PostscriptStandard | isolatin1

Permits one to control the so-called "font encoding" used in text.  The
default font encoding is ISO-Latin-1, which is best for English and
other European languages.  To learn how to enter accents in a text
editor, and for a brief overview of font encodings, (*Note Non-English
Text::).

   If the so-called "Postscript Standard" font encoding is required,
this command permits changing the encoding.

   Note: few users will ever need this command.  If you don't even know
what "font encoding" is about, ignore this command!


File: gri.info,  Node: Set Font Size,  Next: Set Font To,  Prev: Set Font Encoding,  Up: Set

9.3.41.19 `set font size'
.........................

     `set font size {.size. [cm]}|default'

Set the size of the font for drawing of text.

   * `set font size .size.' Set font size to `.size.' points.  (A point
     is 1/72 of an inch, or 1/28 of a centimetre.)

   * `set font size .size. cm' Set font size to `.size.' centimetres.

   * `set font size default' Set font size to default = 12 pts.

   If your figure is to be reproduced by a journal, you should check
with them about the range of font size they need.  This will, of course,
depend on whether your figure is reduced or enlarged during
reproduction.  For example, American Geophysical Union (publishers of
J. Geophysical Res.) recommends that one use fonts no smaller than 8
points.  They also recommend that the range in fontsize in a given
figure not exceed 2.


File: gri.info,  Node: Set Font To,  Next: Set Graylevel,  Prev: Set Font Size,  Up: Set

9.3.41.20 `set font to'
.......................

     `set font to \fontname'

Set font to named style.  Note that the backslash is *not* to be
written, but here merely means that this word has several alternatives.
For example, one might say `set font to Courier'.  The allowed
fontnames are: `Courier', a typewriter font (and the only monospaced
font in Gri); `Helvetica' (the default), a sans-serif font commonly
used in drafting scientific graphs; `HelveticaBold', a bold version of
Helvetica; `Times' (also called `TimesRoman'), a font used in most
newspapers; `TimesBold', a bold version of Times; `Palatino' (also
called `PalatinoRoman'), similar to Times; `Symbol', included for
completeness, is a mathematical font in which "a" becomes $\alpha$ of
the math mode, etc.  For reference on these fonts see any book on
PostScript.  The default font is `Helvetica'.


File: gri.info,  Node: Set Graylevel,  Next: Set Grid Missing,  Prev: Set Font To,  Up: Set

9.3.41.21 `set graylevel'
.........................

     `set graylevel .brightness.|white|black'

Set graylevel for lines to indicated numerical value between 0=black and
1=white, or to the named color.

   Note: if your diagram is to be reproduced by a journal, it is
unlikely that the reproduction will be able to distinguish between any
two graylevels which differ by less than 0.2.  Also, graylevels less
than 0.2 may appear as pure black, while those of 0.8 or more may
appear as pure white.  These guidelines are as specified by American
Geophysical Union (publishers of J. Geophysical Res.), as of 1998.


File: gri.info,  Node: Set Grid Missing,  Next: Set Ignore Initial Newline,  Prev: Set Graylevel,  Up: Set

9.3.41.22 `set grid missing'
............................

General format is

     `set grid missing \
       {above|below .intercept. .slope} \
       | {inside curve}'

The style

     `set grid missing above|below .intercept. .slope'

sets grid to missing value for all points above/below the line defined
by y = .intercept. + .slope. * x

   The style

     `set grid missing inside curve'

sets the grid to the missing value throughout an area described by the
curve last read in with `read columns'.  This is useful for e.g.
excluding land areas while contouring ocean properties.  The curve may
contain several "islands," each tracing (clockwise) a region inside of
which the grid is to considered missing.  If the first point in an
island doesn't match the last, then an imaginary line is assumed which
connects them.  Multiple islands may be separated by missing-value
codes.

   *See also* `Set Z Missing'.


File: gri.info,  Node: Set Ignore Initial Newline,  Next: Set Ignore Error Eof,  Prev: Set Grid Missing,  Up: Set

9.3.41.23 `set ignore initial newline'
......................................

     `set ignore initial newline [off]'

Make Gri ignore a newline if it occurs as the first character of the
next data file.  This is used for files made by FORTRAN programs on
VAX/VMS computers.


File: gri.info,  Node: Set Ignore Error Eof,  Next: Set Image Colorscale,  Prev: Set Ignore Initial Newline,  Up: Set

9.3.41.24 `set ignore error eof'
................................

     `set ignore error eof'

Stop Gri from considering that to encounter an end of file in future
`read' commands consitutes an error; Gri will simply warn about future
EOFs.


File: gri.info,  Node: Set Image Colorscale,  Next: Set Image Grayscale,  Prev: Set Ignore Error Eof,  Up: Set

9.3.41.25 `set image colorscale'
................................

     set image colorscale hsb .h. .s. .b. .im_value. \
         hsb .h. .s. .b. .im_value. [increment .im_value.]
     set image colorscale rgb .r. .g. .b. .im_value. \
         rgb .r. .g. .b. .im_value. [increment .im_value.]
     set image colorscale \
       \name .im_value. \
       \name .im_value. \
       [increment .im_value.]

Set colorscale mapping for image, using HSB (hue, saturation,
brightness) specification, RGB (red, green, blue) color specification,
or named colors.  The image range must previously have been set by `set
image range', so that the `.im_value.' values will have meaning.  Two
pairs of (color, image-value) are given, and possibly an increment.
Normally the colors are smoothly blended between the endpoints, but if
an increment is supplied, the colors are quantized.  The HSB method
allows creation of spectral palettes, while the other two methods
create simple blending between the two endpoints.

   EG: To get a spectrum ranging between pure red (H=0) for image value
of -10.0, and pure blue (H=2/3) for image value of 10.0, do this:

     set image colorscale hsb 0 1 1 -10 hsb .666 1 1 10

   EG: To get a scale running from pure red (at image-value 10.0) into
pure blue (at image-value 25.1), but with the colors blending
intuitively in between (i.e., blending as paint might), use `rgb' color
specification, as follows:

     set image colorscale rgb 1 0 0 10 rgb  0 0 1 25.1

   EG: To get a quantized blend between the X11 colors `skyblue' at
image value of 0 and `tan' at image value of 20, and with steps at
image values incrementing by 5, do this:

     set image colorscale skyblue 0 tan 20 increment 5

Note that the traversal is through RGB space, so it is intuitive, not
spectral.  See `set color' for a list of X11 colors known to Gri.

   See also `read image colorscale' (*Note Read Image Colorscale::).


File: gri.info,  Node: Set Image Grayscale,  Next: Set Image Missing Value Color,  Prev: Set Image Colorscale,  Up: Set

9.3.41.26 `set image grayscale'
...............................

     `set image grayscale using histogram \
       [black .bl. white .wh.]'

     `set image grayscale \
       [black .bl. white .wh. [increment .inc.]]'

Set up a grayscale mapping for images.  The image range must have
previously have been set by `set image range'.

     `set image grayscale using histogram [black .bl. white .wh.]'

Create a grayscale mapping using linearized cumulative histogram
enhancement.  The image range must have previously have been set by
`set image range'.

   This creates maximal contrast in each range of graylevels, and is
useful for tracing subtle features between different images (for
example, it makes it easier to trace fronts between successive satellite
images).  The entire histogram is expanded, from the smallest value in
the image to the largest.

   With no options specified, the histogram is done from 0 in the image
to 255 in the image.  If the black/white options are specified, the
histogram is done between these values.

     `set image grayscale \
       [black .bl. white .wh. [increment .inc.]]'

With no optional parameters, create a grayscale mapping for the current
image, scaling it from black for the mininum value in the image to white
for the maximum value.  The image range must have previously have been
set by `set image range'.

   The optional parameters `.wh.' and `.bl.' specify the values to be
drawn in white and black in the image, with smooth linear blending in
between.

   Normally the blending from white to black is smooth (linear), but if
the additional optional parameter `.inc.' is specified, the blending is
quantized, jumping to darker values at (`.wh.' + `.inc.'), (`.wh.' + 2*
`.inc.'), etc.  (The sign of `.inc.' will be altered, if necessary, to
ensure that (`.wh.' + `.inc.') is between `.wh.' and `.inc.'.)  The
colour switches to pure white at the value `.wh.', and remains pure
white everywhere on the "white" side of this value.  Similarly, the
transition to pure black occurs at the value `.bl.'.  In other words,
neither pure white nor pure black is present inside the interval from
`.wh.' to `.bl.'.  Therefore, when using the `draw image palette'
command, you might want to extend the range by one increment so as to
get an example of both pure white and pure black.

     .w. = 0
     .b. = 1
     .i. = 0.2
     set image grayscale white .w. black .b. increment .i.
     draw image palette left \
       {rpn .w. .i. -} \
       right {rpn .b. .i. +} \
       increment .i.


File: gri.info,  Node: Set Image Missing Value Color,  Next: Set Image Range,  Prev: Set Image Grayscale,  Up: Set

9.3.41.27 `set image missing value color'
.........................................

     set image missing value color to white|black|\
         {graylevel .brightness.}|{rgb .r. .g. .b.}

Set the color of "missing" pixels (white by default).  The image range
must have previously have been set by `set image range'.  Pixels with
missing values can result from creating images from grids which have
missing values; see the `convert grid to image' command.  The
`.brightness.' parameter in the `graylevel' style ranges from 0 for
black to 1 for white.  The `rgb' parameters allow setting to full color.


File: gri.info,  Node: Set Image Range,  Next: Set Input Data Window,  Prev: Set Image Missing Value Color,  Up: Set

9.3.41.28 `set image range'
...........................

     set image range .0value. .255value.

Specify maximum possible range of values that images can hold, in user
units.  Gri needs to know this because it stores images in a limited
format capable of holding only 256 distinct values.  Unlike some other
programs, Gri encourages (forces) the user to specify things in terms of
user-units, not image-units.  This has the advantage of working
regardless of the number of bits per pixel.  Thus, for example, `set
image grayscale', `set image colorscale', `draw image grayscale', etc,
all use *user* units.

   When an image is created by `convert grid to image', values outside
the range spanned by `.0value.' and `.255value.' are clipped.  (There
is no need, however, for `.0value.' to be less than `.255value.'.)
This clipping discards information, so make sure the range you give is
larger than the range of data in the grid.

   EXAMPLE: consider a satellite image in which an internal value of 0
is meant to correspond to 0 degrees Celsius, and an internal value of
255 corresponds to 25.5 degrees.  (This is a common scale.)  Then the
Gri command `set image range 0 25.5' would establish the required
range.  If this range were combined with a linear grayscale mapping (see
`set image grayscale'), the resultant granularity in the internal
representation of the user values would be (25.5-0)/255 or 0.1 degrees
Celsius; temperature variations from pixel to pixel which were less than
0.1 degrees would be lost.

   All other image commands *require* that the range has been set.
Thus, all these commands fail unless `set image range' has been done:
`draw image', `draw image palette', `read image', `convert grid to
image', `set image grayscale', and `set image colorscale'.

   NOTE: If a range already exists when `set image range' is used, then
the settings are altered.  Thoughtless usage can therefore lead to
confusing results.  (The situation is like setting an axis scale,
plotting a curve with no axes, then altering the scale and plotting the
new axes.  It is legal but not necessarily smart.)


File: gri.info,  Node: Set Input Data Window,  Next: Set Input Data Separator,  Prev: Set Image Range,  Up: Set

9.3.41.29 `set input data window'
.................................

     `set input data window x|y {.min. .max.}|off'

Create a data window for following `read' statements.

   * `set input data window x .min. .max.' For future reading commands,
     ignore all data with x less than `.min.' or x greater than `.max.'
     The data not in the interval will not be read in at all.  This
     will hold until `set data window x off' is done, in which case all
     data will be read in.

   * `set input data window x off' Return to normal conditions, in
     which all data are read in.

   * `set input data window y .min. .max.' Analgous to command for x.

   * `set input data window y off' Analagous to command for x.

   EXAMPLE: To set the input data window as the current x axis plus a
border of 5 centimetres to left and right, do the following:

     set input data window x \
       {rpn ..xleft..  xusertocm 5 - xcmtouser} \
       {rpn ..xright.. xusertocm 5 + xcmtouser}

   *See also* `set clip' 


File: gri.info,  Node: Set Input Data Separator,  Next: Set Line Cap,  Prev: Set Input Data Window,  Up: Set

9.3.41.30 `set input data separator'
....................................

     `set input data separator TAB|default'

Set the separator between data items.  The `default' method is to
assume that data items are separated by one or more spaces or tabs, and
also to ignore any spaces or tabs at the start of a data line.

   In the `TAB' method the data are assumed to be separated by a SINGLE
tab character.  (Multiple tabs will result in null values being
assigned to items - almost certainly not what you want!)  Also, initial
spaces and tabs on lines are NOT skipped.

   Use the `TAB' method only after thinking carefully about the above,
since the assignment of null values is problematic.


File: gri.info,  Node: Set Line Cap,  Next: Set Line Join,  Prev: Set Input Data Separator,  Up: Set

9.3.41.31 `set line cap'
........................

     `set line cap .type.'

Set the type of ends (caps) of lines.  Use `.type.' of value 0 for
square ends, cut off precisely at the end of line, or 1 for round ends
which overhang half the line width, or 2 for square ends which overhang
half the line width.  The selected style is used for the ends of line
segments, as well as at corners.  In PostScript parlance, therefore,
this command sets both the linecap and the linejoin parameters.

   This command only applies to lines drawn with `draw curve', `draw
line' and `draw polygon'.  Axes are always drawn with a line cap of 0.


File: gri.info,  Node: Set Line Join,  Next: Set Line Width,  Prev: Set Line Cap,  Up: Set

9.3.41.32 `set line join'
.........................

     `set line join .type.'

Set the type of intersection of lines.  Use `.type.' of value 0 for
mitered joins (pointy ends that may extend beyond the data points), a
value of 1 for rounded ends (the default), or a value of 2 for bevelled
(squared-off) ends.  See the `setlinejoin' command in any text on the
PostScript language for more information.

   This command only applies to lines drawn with `draw curve', `draw
line' and `draw polygon'.  Axes are always drawn with a line join of 0.


File: gri.info,  Node: Set Line Width,  Next: Set Missing Value,  Prev: Set Line Join,  Up: Set

9.3.41.33 `set line width'
..........................

     `set line width \
       [axis|symbol|all] \
       .width_pt. \
       | {rapidograph \name} \
       | default'

Set the width of lines used to draw curves (default), axes, symbols, or
all of the above.  The width may be set to a value specified in points
(conversion: 72 pt = 1 inch), to a named rapidograph width, or to the
default value.  The initial default values are: 0.709pt (or rapidograph
3x0) for curves; 0.369pt (or rapidograph 6x0) for axes; 0.369pt (or
rapidograph 6x0) for symbols.  (To learn more about standard pen
widths, see the ISO 9175-1 documents.)

   If your figure is to be reproduced by a journal, you should check
with them about the range of line thicknesses they recommend.  This
will, of course, depend on whether your figure is reduced or enlarged
during reproduction.  For example, American Geophysical Union
(publishers of J. Geophysical Res.) recommends that one use line
thicknesses no less than 0.5 points and no more than 4 points.

   The rapidograph settings match the standard set of widths used in
technical fountain pens.  The table below gives width names along with
the width in points and centimetres, as given in the specifications
supplied with Rapidograph technical fountain pens.  Names marked by the
symbol `*' are in sequence increasing by the factor root(2).  Texts on
technical drawing often suggest using linewidths in the ratio of 2 or
root(2).  On many printers, the variation in width from root(2) increase
is too subtle to see, so the factor-of-2 rule may be preferable.  To get
sizes in a sequence doubling in width, pick from the list (`6x0',
`3x0', `1', `3.5' `7').  To get a sequence increasing in width by
root(2), pick from the list (`6x0', `4x0', `3x0', `0', `1', `2.5',
`3.5', `6', `7').  The eye can distinguish curves with linewidths
differing by a factor of root(2) if the image is of high quality, but a
factor of 2 is usually better.  Similarly, for overhead projections and
projected slides, one would do well to use linewidths differing by a
factor of 4.

   This is the list of `rapidograph' linewidths:

       Name      pt    cm
       ====    =====  =====
     *  6x0    0.369  0.013
     *  4x0    0.510  0.018
     *  3x0    0.709  0.025
         00    0.850  0.03
     *    0    0.992  0.035
     *    1    1.417  0.05
          2    1.701  0.06
     *    2.5  1.984  0.07
          3    2.268  0.08
     *    3.5  2.835  0.1
          4    3.402  0.12
     *    6    3.969  0.14
     *    7    5.669  0.2


File: gri.info,  Node: Set Missing Value,  Next: Set Page Size,  Prev: Set Line Width,  Up: Set

9.3.41.34 `set missing value'
.............................

     `set missing value .value.|none'

If a numerical value is given, set the missing-value code to that
value, and also store this value in the builtin variable
`..missingvalue..' and the builtin synonym `\.missingvalue..' also.
After this command, Gri will ignore any data that are within 0.1
percent of this value.  (This feature is commonly used in geophysical
data.)

   If `none' is given, turn off this feature.

   The default is that the feature is turned off.


File: gri.info,  Node: Set Page Size,  Next: Set Page,  Prev: Set Missing Value,  Up: Set

9.3.41.35 `set page size'
.........................

     `set page size letter|legal|folio|tabloid|A0|A1|A2|A3|A4|A5'

Set the page dimension, as indicated below.
_letter_
     American "letter" size: 8.5 x 11 inches

_legal_
     American "legal" size: 8.5 x 14 inches

_folio_
     American "folio" size: 8.5 x 13 inches

_tabloid_
     American "tabloid" size: 11 x 17 inches

_A5_
     Metric size: 14.8 x 21.0 cm

_A4_
     Metric size: 21.0 x 29.7 cm

_A3_
     Metric size: 29.7 x 42.0 cm

_A2_
     Metric size: 42.0 x 59.4 cm

_A1_
     Metric size: 59.4 x 84.1 cm

_A0_
     Metric size: 84.1 x 118.9 cm

   The effect is to possibly alter the PostScript "bounding box."  If
all the drawn material fits within the indicated page, then the bounding
box is not altered.  (In other words, Gri will still keep the bounding
box tight on the drawn items.)

   However, if any drawn item extends beyond the indicated size, it will
be clipped to the boundary.


File: gri.info,  Node: Set Page,  Next: Set Panel,  Prev: Set Page Size,  Up: Set

9.3.41.36 `set page'
....................

     `set page portrait \
       | landscape \
       | {factor .mag.} \
       | {translate .xcm. .ycm.}'

Control orientation or scaling of what is drawn on the paper.

   * `set page portrait' Print graph normally (default).

   * `set page landscape' Print graph sideways.

   * `set page factor .mag.' Scale everything to be drawn on the paper
     by the indicated magnification factor.  This *must* be called
     before any drawing commands.

   * `set page translate .xcm. .ycm.' Translate everything to be drawn
     on the paper by the indicated x/y distances.  This *must* be
     called before any drawing commands.

   *Note*: The order of the factor/translate commands matters, so you
may need to experiment.  For example,

     set page translate 2 1
     set page factor 0.5

moves anything that would have been drawn at the lower-left corner of
the paper onto the point 2cm from the left side and 1cm from the bottom
side of the paper, and then applies the multiplication factor.
Reversing the order gives quite different results.  PostScript gurus
should note that the following two commands are inserted into the
PostScript file:

     56.900000 28.450000 translate
     0.500000 0.500000 scale


File: gri.info,  Node: Set Panel,  Next: Set Panels,  Prev: Set Page,  Up: Set

9.3.41.37 `set panel'
.....................

     set panel .row. .col.

Establish the geometry for the panel in the indicated row and column;
that is, select which defined panel to draw into.  The bottom row has
`.row.' = 1, and the leftmost column has `.col.' = 1.  This must be
used only after defining the panel layout using `Panels .row. .col.
.dx_cm. .dy_cm.'.


File: gri.info,  Node: Set Panels,  Next: Set Path To,  Prev: Set Panel,  Up: Set

9.3.41.38 `set panels'
......................

     set panels .rows. .cols. [.dx_cm. .dy_cm.]

Set up for multipanel plots, with spacing `.dx_cm.' between the columns
and `.dy_cm.' between the rows.  If the spacings are not supplied, 2cm
is used.  The panels fill the rectangle which would otherwise contain
the single axis frame, as set by `set x size' and `set x margin', etc.

   The global variables `.panel_dx.', `.panel_dy.', `.panel_xmargin.',
`.panel_ymargin.', `.panel_xsize.', and `.panel_ysize' are created, to
be used by later calls to `set panel'.

   EXAMPLE

     # Draw 2 panels across, 3 up the page.

     # The Panel interiors will be in region cornered
     # by (2,2), (12,22) cm
     set x margin 2
     set y margin 2
     set x size 10
     set y size 20
     set panels 2 3

     # Create dummy scale
     set x axis 0 1
     set y axis 0 1

     # Draw blank axes
     et panel 1 1
     raw axes
     set panel 1 2
     draw axes
     set panel 1 3
     draw axes
     set panel 2 1
     draw axes
     set panel 2 2
     draw axes
     set panel 2 3
     draw axes

   *See also* `set panel .row. .col.'


File: gri.info,  Node: Set Path To,  Next: Set Postscript Filename,  Prev: Set Panels,  Up: Set

9.3.41.39 `set path'
....................

     set path to "\path"|default for data|commands

Set the directory path that `open' will search for data files, or that
`insert' will search for command files.  This search will _not_ be done
if the filename starts with a `/', `~', or `.' character.

   The path is formatted in a colon-separated manner, following the
normal Unix convention, and searching is from left to right.  For
example, the path `".:/usr/lib/gri"' tells Gri to search for the file
first in the local directory (named `.'), and if it is not found there,
to look next in the directory named `/usr/lib/gri'.

   The indicated path is stored in either `\.path_data.' or
`\.path_commands.', as appropriate.  At startup time, each of these
paths is set to `"."', the current directory, and this value is reset
if the `default' keyword is provided to this command.

   If you need to know where the file was eventually found, save the
`\.return_value.' just after the `open' command was executed.  For
example, the following defines the synonym `\uk', which is the full
pathname of the file containing some sort of data about Great Britain.

     set path to "/atlases/world:/atlases/northern_hemisphere" for data
     open britain.dat        # we don't know where file is ...
     \gb = "\.return_value." # ... until now!

     # Can later do command such as
     #    read from \gb
     # or
     #    rewind \gb
     # to work with this particular file, even if
     # there is another file open that also is
     # named "britain.dat".


File: gri.info,  Node: Set Postscript Filename,  Next: Set Symbol Size,  Prev: Set Path To,  Up: Set

9.3.41.40 `set postscript filename'
...................................

     `set postscript filename "\name"'

Set name of PostScript file, over-riding the present name.


File: gri.info,  Node: Set Symbol Size,  Next: Set Tic Size,  Prev: Set Postscript Filename,  Up: Set

9.3.41.41 `set symbol size'
...........................

     `set symbol size .diameter_cm.|default'

Control the diameter of symbols drawn by `draw symbol' command.

   * `set symbol size .diameter_cm.' Make symbol size be
     `.diameter_cm.' centimeters in diameter.

   * `set symbol size default' Set to default diameter of 0.1 cm.


File: gri.info,  Node: Set Tic Size,  Next: Set Trace,  Prev: Set Symbol Size,  Up: Set

9.3.41.42 `set tic size'
........................

     `set tic size .size.|default'

Control size of tics on axes.
   * `set tic size .size.' Set tic size to `.size.' centimetres.

   * `set tic size default' Set tic size to default of 0.2 cm.

   * `set tics in|out' Make axis tics point inward or outward.  The
     default is outward.


File: gri.info,  Node: Set Trace,  Next: Set Transparency,  Prev: Set Tic Size,  Up: Set

9.3.41.43 `set trace'
.....................

     `set trace [on|off]'

Control printing of command lines as they are processed.

   * `set trace' Make Gri print command lines as they are processed.

   * `set trace on' Same as `set trace'.

   * `set trace off' Prevent printing command lines (default).


File: gri.info,  Node: Set Transparency,  Next: Set U Scale,  Prev: Set Trace,  Up: Set

9.3.41.44 `set transparency'
............................

     `set transparency .transparency.'

Set the transparency of drawn items, 0 for opaque and 1 for invisibly
faint.  _This command is provisional, as of summer 2004, and this part
of the documentation needs to be fleshed out so users can build
intuition on transparency.  For example, a quick quiz: what color do
you think comes from drawing red on top of yellow, or on top of blue?  _


File: gri.info,  Node: Set U Scale,  Next: Set V Scale,  Prev: Set Transparency,  Up: Set

9.3.41.45 `set u scale'
.......................

     `set u scale .cm_per_unit.|{as x}'

Set scale for x-component of arrows.

   * `set u scale .cm_per_unit.' Set scale for `u' component of arrows.

   * `set u scale as x' Set scale for u component of arrows to be the
     same as the x-scale.  Equivalent to `set u scale as {rpn ..xsize..
     ..xright.. ..xleft.. - /}'.

   NOTE: this only works if the x-scale is LINEAR (see `set x type').


File: gri.info,  Node: Set V Scale,  Next: Set X Axis,  Prev: Set U Scale,  Up: Set

9.3.41.46 `set v scale'
.......................

     `set v scale .cm_per_unit.|{as y}'

Set scale for y-component of arrows.

   * `set v scale .cm_per_unit.' Set scale for `v' component of arrows.

   * `set v scale as y' Set scale for v component of arrows to be the
     same as the y-scale.  Equivalent to `set v scale as {rpn ..ysize..
     ..ytop.. ..ybottom.. - /}'.

   NOTE: this only works if the y-scale is LINEAR (see `set y type').


File: gri.info,  Node: Set X Axis,  Next: Set X Format,  Prev: Set V Scale,  Up: Set

9.3.41.47 `set x axis'
......................

     `set x axis top'
     `set x axis bottom'
     `set x axis increasing'
     `set x axis decreasing'
     `set x axis unknown'
     `set x axis .left. .right. [.incBig. [.incSml.]]'
     `set x axis labels [add] .position_1. "label_1" [.position_2. "label_2" [...]]'
     `set x axis labels automatic'

Control various things about the x axis.

   * `set x axis top' Make next x-axis to be drawn have labels above
     the axis.

   * `set x axis bottom' Make next x-axis to be drawn have labels below
     the axis.

   * `set x axis increasing' Make next x-axis to be drawn have numeric
     labels increasing to the right.  This applies only if autoscaling
     is done; otherwise, the supplied values (`.left. .right. [.incBig.
     [.incSml.]]') are used.

   * `set x axis decreasing' Make next x-axis to be drawn have numeric
     labels decreasing to the right.  This applies only if autoscaling
     is done; otherwise, the supplied values (`.left. .right. [.incBig.
     [.incSml.]]') are used.

   * `set x axis unknown' Make Gri forget any existing scale for the x
     axis, whether set by another `set x axis' command or
     automatically, during reading of data.  This is essentially a
     synonym for `delete x scale'.

   * `set x axis .left. .right.' Make x-axis range from `.left.' to
     `.right.'

   * `set x axis .left. .right. .incBig.' Make x-axis range from
     `.left.' to `.right.', with labelled increments at `.incBig.'
     Note: In the case of log axes, and provided that `set x type log'
     has been called previously, the `.incBig.' parameter has a
     different meaning: it is the interval, in decades, between
     numbered labels; the default is 1.

   * `set x axis .left .right. .incBig. .incSml.' Make x-axis range
     from `.left.' to `.right.', with labelled increments at
     `.incBig.', and small tics at `.incSml.'  NOTE: if the axis is
     logarithmic, the value of `.incSml.' takes on a special meaning:
     if it is positive then small tics are put at values 2, 3, 4, etc.
     between the decades, but if `.incSml.' is negative then no such
     small tics are used.

   * `set x axis labels .position. "label" [.position. "label" [...]]' Override
     the automatic labelling at axis tics, and instead put the
     indicated labels at the indicated x values.  For example, a
     day-of-week axis can be created by the code:

          set x axis 0 7 1
          set x axis labels 0.5 "Mon" 1.5 "Tue" 2.5 "Wed" \
                            3.5 "Thu" 4.5 "Fri" 5.5 "Sat" \
                            6.5 "Sun"

     The command replaces any existing labels, unless the `add' keyword
     is present, in which case the new label information is appended to
     any existing information.

   * `set x axis labels automatic' Return to automatically-generated
     axis labels, undoing the command of the previous item.



File: gri.info,  Node: Set X Format,  Next: Set X Grid,  Prev: Set X Axis,  Up: Set

9.3.41.48 `set x format'
........................

     `set x format \format|default|off

Set format for numbers on x axis.  The format is specified in the manner
of the "C" programming language.  The C formats (i.e., `%f', `%e' and
`%g') are permitted.  For example, `set x format %.1f' tells Gri to use
1 decimal place, and to prefer the "float" notation to the exponential
notation.  The form `set x format off' tells Gri not to write numbers
on the axis.  To get spaces in your format, enclose the format string in
double-quotes, e.g., you might use `set x format "%.0f$\circ$ W"' for a
map, or `set x format "%f "' to make the numbers appear to the left of
their normal location.

   The default format is `%lg'.


File: gri.info,  Node: Set X Grid,  Next: Set X Margin,  Prev: Set X Format,  Up: Set

9.3.41.49 `set x grid'
......................

     `set x grid .left. .right. .inc.|{/.cols.}'

Create x-grid for contour or image.  If a grid already exists, an error
will be declared; the way to interpolate from an existing grid to a new
one is with the `interpolate x grid' command.

   * `set x grid .left. .right. .inc.' Create x-grid ranging from the
     value `.left.' at the left to `.right.' at the right, stepping by
     an increment of `.inc.'.

   * `set x grid .left. .right. /.cols.' Create x-grid with `.cols.'
     points, ranging from the value `.left.' at the left to `.right.'
     at the right.


File: gri.info,  Node: Set X Margin,  Next: Set X Name,  Prev: Set X Grid,  Up: Set

9.3.41.50 `set x margin'
........................

     `set x margin {[bigger|smaller] .size.}|default'

Control x margin, that is, the space between the left-hand side of the
page and the left-hand side of the plotting area.  (Note that axis
labels are drawn inside the margin; the margin extends to the axis line,
not to the labels.)

   * `set x margin .size.' Set left margin to `.size.' cm.  It is
     permissible to have negative margins, with the expected effect.

   * `set x margin bigger .size.' Increases left margin by `.size.' cm.

   * `set x margin smaller .size.' Decreases left margin by `.size.' cm.

   * `set x margin default' Set left margin to default = 6 cm.


File: gri.info,  Node: Set X Name,  Next: Set X Size,  Prev: Set X Margin,  Up: Set

9.3.41.51 `set x name'
......................

     `set x name "\name"|default'

Set name of x-axis to the indicated string.  An empty string (`set x
name ""') causes the x axis to be unlabelled.  The `default' is `"x"'.


File: gri.info,  Node: Set X Size,  Next: Set X Type,  Prev: Set X Name,  Up: Set

9.3.41.52 `set x size'
......................

     `set x size .width_cm.|default'

Set the width of the plotting area.  This does not include axis labels,
only the interior part of the plot.

   * `set x size .width_cm.' Set width of x-axis in centimeters.

   * `set x size default' Set width of x-axis to default = 10 cm.


File: gri.info,  Node: Set X Type,  Next: Set Y Axis,  Prev: Set X Size,  Up: Set

9.3.41.53 `set x type'
......................

     set x type linear|log|{map E|W|N|S}

Control transformation function mapping user units to centimetres on the
page.

   * `set x type linear' Set to linear axis.

   * `set x type log' Set to log axis.  To avoid clashes in the linear
     to log transform, this command should precede the creation of an
     axis scale, either explicitly through the `set x axis .left.
     .right. ...' command or implicitly through the `read columns'
     command.

   * `set x type map E|W|N|S' Set to be a map.  This means that whole
     numbers on the axis will have a degree sign written after them
     (and then the letter `E', etc) and that numbers which are
     multiples of 1/60 will be written in degree-minute format, and
     that similarly numbers which are divisible by 1/3600 will be in
     degree-minute-second format.  If none of these things apply, the
     axis labels will be written in decimal degrees.  Note that this
     command overrides any format set by `set x format'.

     BUG: this only has an effect if the axis is not already of type
     `log'.


File: gri.info,  Node: Set Y Axis,  Next: Set Y Format,  Prev: Set X Type,  Up: Set

9.3.41.54 `set y axis'
......................

     `set y axis left'
     `set y axis right'
     `set y axis increasing'
     `set y axis decreasing'
     `set y axis .bottom. .top. [.incBig. [.incSml.]]'
     `set y axis labels [add] .position_1. "label_1" [.position_2. "label_2" [...]]'
     `set y axis labels automatic'

Control various things about the y axis.

   * `set y axis name horizontal' Make y-axis name be horizontal.

   * `set y axis name vertical' Make y-axis name be vertical (default).

   * `set y axis left' Make next y-axis to be drawn have labels to the
     left of the axis.

   * `set y axis right' Make next y-axis to be drawn have labels to the
     right of the axis.

   * `set y axis increasing' Make next y-axis to be drawn have numeric
     labels increasing up the page.  This applies only if autoscaling
     is done; otherwise, the supplied values (`.left. .right. [.incBig.
     [.incSml.]]') are used.

   * `set y axis decreasing' Make next y-axis to be drawn have numeric
     labels decreasing up the page.  This applies only if autoscaling
     is done; otherwise, the supplied values (`.left. .right. [.incBig.
     [.incSml.]]') are used.

   * `set y axis unknown' Make Gri forget any existing scale for the y
     axis, whether set by another `set y axis' command or
     automatically, during reading of data.  This is essentially a
     synonym for `delete y scale'.

   * `set y axis .bottom. .top.' Make y-axis range from `.bottom.' to
     `.top.'

   * `set y axis .bottom. .top. .incBig.' Make y-axis range from
     `.bottom.' to `.top.', with labelled increments at `.incBig.'

   * `set y axis .bottom. .top. .incBig. .incSml.' Make y-axis range
     from `.bottom.' to `.top.', with labelled increments at
     `.incBig.', and small tics at `.incSml.'  NOTE: if the axis is
     logarithmic, the value of `.incSml.' takes on a special meaning:
     if it is positive then small tics are put at values 2, 3, 4, etc.
     between the decades, but if `.incSml.' is negative then no such
     small tics are used.

   * `set y axis labels .position. "label" [.position. "label" [...]]'
     Override the automatic labelling at axis tics, and instead put the
     indicated labels at the indicated y values.  For example, a
     physical-condition axis can be created by the code:

          set y axis 0 1 0.5
          set y axis labels 0.25 "Weak" 0.75 "Strong"

     The command replaces any existing labels, unless the `add' keyword
     is present, in which case the new label information is appended to
     any existing information.

   * `set y axis labels automatic' Return to automatically-generated
     axis labels, undoing the command of the previous item.

   * `set y axis name vertical' Cause future y axes to be drawn with
     the name aligned vertically (the default).

   * `set y axis name horizontal' Cause future y axes to be drawn with
     the name aligned horizontally.



File: gri.info,  Node: Set Y Format,  Next: Set Y Grid,  Prev: Set Y Axis,  Up: Set

9.3.41.55 `set y format'
........................

     `set y format \format|default|off'

Set format for numbers on y axis.  The format is specified in the manner
of the "C" programming language.  The C formats (i.e., `%f', `%e' and
`%lg') are permitted.  For example, `set y format %.1f' tells Gri to
use 1 decimal place, and to prefer the "float" notation to the
exponential notation.  The form `set y format off' tells Gri not to
write numbers on the axis.  To get spaces in your format, enclose the
format string in double-quotes, e.g., you might use `set y format
"%.0f$\circ$ N"' for a map, or `set y format "%f"' to make the numbers
appear to the right of their normal location.

   The default format is `%lg'.


File: gri.info,  Node: Set Y Grid,  Next: Set Y Margin,  Prev: Set Y Format,  Up: Set

9.3.41.56 `set y grid'
......................

     `set y grid .bottom. .top. .inc.|{/.rows.}'

Create y-grid for contour or image.  If a grid already exists, an error
will be declared; the way to interpolate from an existing grid to a new
one is with the `interpolate x grid' command.

   * `set y grid .bottom. .top. .inc.' Create y-grid ranging from the
     value `.bottom.' at the bottom to `.top.' at the top, stepping by
     an increment of `.inc.'.

   * `set y grid .bottom. .top. /.rows.' Create y-grid with `.rows.'
     points, ranging from the value `.bottom.' at the bottom to `.top.'
     at the top.


File: gri.info,  Node: Set Y Margin,  Next: Set Y Name,  Prev: Set Y Grid,  Up: Set

9.3.41.57 `set y margin'
........................

     `set y margin {[bigger|smaller] .size.}|default'

Control y margin, that is, the space between the bottom side of the page
and the bottom of the plotting area.  (Note that axis labels are drawn
inside the margin; the margin extends to the axis line, not to the
labels.)

   * `set y margin .size.' Set bottom margin to `.size.' centimeters.
     It is permissible to have negative margins, with the expected
     effect.

   * `set y margin bigger .size.' Increases bottom margin by `.size.'
     centimeters.

   * `set y margin smaller .size.' Decreases bottom margin by `.size.'
     centimeters.

   * `set y margin default' Set bottom margin to default = 6 cm.


File: gri.info,  Node: Set Y Name,  Next: Set Y Size,  Prev: Set Y Margin,  Up: Set

9.3.41.58 `set y name'
......................

     `set y name "\name"|default'

Set name of y-axis to the indicated string.  An empty string (`set y
name ""') causes the x axis to be unlabelled.  The `default' is `"y"'.


File: gri.info,  Node: Set Y Size,  Next: Set Y Type,  Prev: Set Y Name,  Up: Set

9.3.41.59 `set y size'
......................

     `set y size .height_cm.|default'

Set the width of the plotting area.  This does not include axis labels,
only the interior part of the plot.

   * `set y size .height_cm.' Set height of y-axis in centimeters.

   * `set y size default' Set width of y-axis to default = 10 cm.


File: gri.info,  Node: Set Y Type,  Next: Set Z Missing,  Prev: Set Y Size,  Up: Set

9.3.41.60 `set y type'
......................

     set y type linear|log|{map N|S|E|W}

Control transformation function mapping user units to centimetres on the
page.

   * `set y type linear' Set to linear axis.

   * `set y type log' Set to log axis.  To avoid clashes in the linear
     to log transform, this command should precede the creation of an
     axis scale, either explicitly through the `set y axis .left.
     .right. ...' command or implicitly through the `read columns'
     command.

   * `set y type map N|S|E|W' Set to be a map.  This means that whole
     numbers on the axis will have a degree sign written after them
     (and then the letter `N', etc), and that numbers which are
     multiples of 1/60 will be written in degree-minute format, and
     that similarly numbers which are divisible by 1/3600 will be in
     degree-minute-second format.  If none of these things apply, the
     axis labels will be written in decimal degrees.  Note that this
     command overrides any format set by `set y format'.

     BUG: this only has an effect if the axis is not already of type
     `log'.


File: gri.info,  Node: Set Z Missing,  Next: Show,  Prev: Set Y Type,  Up: Set

9.3.41.61 `set z missing'
.........................

     set z missing above|below .intercept. .slope.

Set `z' column to be missing whenever the associated `y' and `x'
columns are above/below the line defined by y = .intercept. + .slope. *
x

