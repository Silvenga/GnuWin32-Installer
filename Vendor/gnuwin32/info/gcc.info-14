This is doc/gcc.info, produced by makeinfo version 4.0 from
doc/gcc.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* gcc: (gcc).                  The GNU Compiler Collection.
END-INFO-DIR-ENTRY
   This file documents the use and the internals of the GNU compiler.


   Published by the Free Software Foundation
59 Temple Place - Suite 330
Boston, MA 02111-1307 USA


   Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001 Free Software Foundation, Inc.


   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding Free
Software", the Front-Cover texts being (a) (see below), and with the
Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.


File: gcc.info,  Node: Executing code before main,  Next: Type encoding,  Prev: Objective C,  Up: Objective C

`+load': Executing code before main
===================================

   The GNU Objective-C runtime provides a way that allows you to execute
code before the execution of the program enters the `main' function.
The code is executed on a per-class and a per-category basis, through a
special class method `+load'.

   This facility is very useful if you want to initialize global
variables which can be accessed by the program directly, without
sending a message to the class first. The usual way to initialize
global variables, in the `+initialize' method, might not be useful
because `+initialize' is only called when the first message is sent to a
class object, which in some cases could be too late.

   Suppose for example you have a `FileStream' class that declares
`Stdin', `Stdout' and `Stderr' as global variables, like below:


     FileStream *Stdin = nil;
     FileStream *Stdout = nil;
     FileStream *Stderr = nil;
     
     @implementation FileStream
     
     + (void)initialize
     {
         Stdin = [[FileStream new] initWithFd:0];
         Stdout = [[FileStream new] initWithFd:1];
         Stderr = [[FileStream new] initWithFd:2];
     }
     
     /* Other methods here */
     @end

   In this example, the initialization of `Stdin', `Stdout' and
`Stderr' in `+initialize' occurs too late. The programmer can send a
message to one of these objects before the variables are actually
initialized, thus sending messages to the `nil' object. The
`+initialize' method which actually initializes the global variables is
not invoked until the first message is sent to the class object. The
solution would require these variables to be initialized just before
entering `main'.

   The correct solution of the above problem is to use the `+load'
method instead of `+initialize':


     @implementation FileStream
     
     + (void)load
     {
         Stdin = [[FileStream new] initWithFd:0];
         Stdout = [[FileStream new] initWithFd:1];
         Stderr = [[FileStream new] initWithFd:2];
     }
     
     /* Other methods here */
     @end

   The `+load' is a method that is not overridden by categories. If a
class and a category of it both implement `+load', both methods are
invoked.  This allows some additional initializations to be performed in
a category.

   This mechanism is not intended to be a replacement for `+initialize'.
You should be aware of its limitations when you decide to use it
instead of `+initialize'.

* Menu:

* What you can and what you cannot do in +load::


File: gcc.info,  Node: What you can and what you cannot do in +load,  Prev: Executing code before main,  Up: Executing code before main

What you can and what you cannot do in `+load'
----------------------------------------------

   The `+load' implementation in the GNU runtime guarantees you the
following things:

   * you can write whatever C code you like;

   * you can send messages to Objective-C constant strings (`@"this is a
     constant string"');

   * you can allocate and send messages to objects whose class is
     implemented in the same file;

   * the `+load' implementation of all super classes of a class are
     executed before the `+load' of that class is executed;

   * the `+load' implementation of a class is executed before the
     `+load' implementation of any category.


   In particular, the following things, even if they can work in a
particular case, are not guaranteed:

   * allocation of or sending messages to arbitrary objects;

   * allocation of or sending messages to objects whose classes have a
     category implemented in the same file;


   You should make no assumptions about receiving `+load' in sibling
classes when you write `+load' of a class. The order in which sibling
classes receive `+load' is not guaranteed.

   The order in which `+load' and `+initialize' are called could be
problematic if this matters. If you don't allocate objects inside
`+load', it is guaranteed that `+load' is called before `+initialize'.
If you create an object inside `+load' the `+initialize' method of
object's class is invoked even if `+load' was not invoked. Note if you
explicitly call `+load' on a class, `+initialize' will be called first.
To avoid possible problems try to implement only one of these methods.

   The `+load' method is also invoked when a bundle is dynamically
loaded into your running program. This happens automatically without any
intervening operation from you. When you write bundles and you need to
write `+load' you can safely create and send messages to objects whose
classes already exist in the running program. The same restrictions as
above apply to classes defined in bundle.


File: gcc.info,  Node: Type encoding,  Next: Garbage Collection,  Prev: Executing code before main,  Up: Objective C

Type encoding
=============

   The Objective-C compiler generates type encodings for all the types.
These type encodings are used at runtime to find out information about
selectors and methods and about objects and classes.

   The types are encoded in the following way:

`char'             `c'
`unsigned char'    `C'
`short'            `s'
`unsigned short'   `S'
`int'              `i'
`unsigned int'     `I'
`long'             `l'
`unsigned long'    `L'
`long long'        `q'
`unsigned long     `Q'
long'              
`float'            `f'
`double'           `d'
`void'             `v'
`id'               `@'
`Class'            `#'
`SEL'              `:'
`char*'            `*'
unknown type       `?'
bit-fields         `b' followed by the starting position of the
                   bit-field, the type of the bit-field and the size of
                   the bit-field (the bit-fields encoding was changed
                   from the NeXT's compiler encoding, see below)

   The encoding of bit-fields has changed to allow bit-fields to be
properly handled by the runtime functions that compute sizes and
alignments of types that contain bit-fields. The previous encoding
contained only the size of the bit-field. Using only this information
it is not possible to reliably compute the size occupied by the
bit-field. This is very important in the presence of the Boehm's
garbage collector because the objects are allocated using the typed
memory facility available in this collector. The typed memory
allocation requires information about where the pointers are located
inside the object.

   The position in the bit-field is the position, counting in bits, of
the bit closest to the beginning of the structure.

   The non-atomic types are encoded as follows:

pointers       `^' followed by the pointed type.
arrays         `[' followed by the number of elements in the array
               followed by the type of the elements followed by `]'
structures     `{' followed by the name of the structure (or `?' if the
               structure is unnamed), the `=' sign, the type of the
               members and by `}'
unions         `(' followed by the name of the structure (or `?' if the
               union is unnamed), the `=' sign, the type of the members
               followed by `)'

   Here are some types and their encodings, as they are generated by the
compiler on a i386 machine:


Objective-C type   Compiler encoding
     int a[10];    `[10i]'
     struct {      `{?=i[3f]b128i3b131i2c}'
       int i;      
       float f[3]; 
       int a:3;    
       int b:2;    
       char c;     
     }             


   In addition to the types the compiler also encodes the type
specifiers. The table below describes the encoding of the current
Objective-C type specifiers:


Specifier          Encoding
`const'            `r'
`in'               `n'
`inout'            `N'
`out'              `o'
`bycopy'           `O'
`oneway'           `V'


   The type specifiers are encoded just before the type. Unlike types
however, the type specifiers are only encoded when they appear in method
argument types.


File: gcc.info,  Node: Garbage Collection,  Next: Constant string objects,  Prev: Type encoding,  Up: Objective C

Garbage Collection
==================

   Support for a new memory management policy has been added by using a
powerful conservative garbage collector, known as the
Boehm-Demers-Weiser conservative garbage collector. It is available from
`http://www.hpl.hp.com/personal/Hans_Boehm/gc/'.

   To enable the support for it you have to configure the compiler
using an additional argument, `--enable-objc-gc'. You need to have
garbage collector installed before building the compiler. This will
build an additional runtime library which has several enhancements to
support the garbage collector. The new library has a new name,
`libobjc_gc.a' to not conflict with the non-garbage-collected library.

   When the garbage collector is used, the objects are allocated using
the so-called typed memory allocation mechanism available in the
Boehm-Demers-Weiser collector. This mode requires precise information on
where pointers are located inside objects. This information is computed
once per class, immediately after the class has been initialized.

   There is a new runtime function `class_ivar_set_gcinvisible()' which
can be used to declare a so-called "weak pointer" reference. Such a
pointer is basically hidden for the garbage collector; this can be
useful in certain situations, especially when you want to keep track of
the allocated objects, yet allow them to be collected. This kind of
pointers can only be members of objects, you cannot declare a global
pointer as a weak reference. Every type which is a pointer type can be
declared a weak pointer, including `id', `Class' and `SEL'.

   Here is an example of how to use this feature. Suppose you want to
implement a class whose instances hold a weak pointer reference; the
following class does this:


     @interface WeakPointer : Object
     {
         const void* weakPointer;
     }
     
     - initWithPointer:(const void*)p;
     - (const void*)weakPointer;
     @end
     
     
     @implementation WeakPointer
     
     + (void)initialize
     {
       class_ivar_set_gcinvisible (self, "weakPointer", YES);
     }
     
     - initWithPointer:(const void*)p
     {
       weakPointer = p;
       return self;
     }
     
     - (const void*)weakPointer
     {
       return weakPointer;
     }
     
     @end

   Weak pointers are supported through a new type character specifier
represented by the `!' character. The `class_ivar_set_gcinvisible()'
function adds or removes this specifier to the string type description
of the instance variable named as argument.


File: gcc.info,  Node: Constant string objects,  Next: compatibility_alias,  Prev: Garbage Collection,  Up: Objective C

Constant string objects
=======================

   GNU Objective-C provides constant string objects that are generated
directly by the compiler. You declare a constant string object by
prefixing a C constant string with the character `@':

       id myString = @"this is a constant string object";

   The constant string objects are usually instances of the
`NXConstantString' class which is provided by the GNU Objective-C
runtime. To get the definition of this class you must include the
`objc/NXConstStr.h' header file.

   User defined libraries may want to implement their own constant
string class. To be able to support them, the GNU Objective-C compiler
provides a new command line options
`-fconstant-string-class=CLASS-NAME'.  The provided class should adhere
to a strict structure, the same as `NXConstantString''s structure:


     @interface NXConstantString : Object
     {
       char *c_string;
       unsigned int len;
     }
     @end

   User class libraries may choose to inherit the customized constant
string class from a different class than `Object'. There is no
requirement in the methods the constant string class has to implement.

   When a file is compiled with the `-fconstant-string-class' option,
all the constant string objects will be instances of the class specified
as argument to this option. It is possible to have multiple compilation
units referring to different constant string classes, neither the
compiler nor the linker impose any restrictions in doing this.


File: gcc.info,  Node: compatibility_alias,  Prev: Constant string objects,  Up: Objective C

compatibility_alias
===================

   This is a feature of the Objective-C compiler rather than of the
runtime, anyway since it is documented nowhere and its existence was
forgotten, we are documenting it here.

   The keyword `@compatibility_alias' allows you to define a class name
as equivalent to another class name.  For example:

     @compatibility_alias WOApplication GSWApplication;

   tells the compiler that each time it encounters `WOApplication' as a
class name, it should replace it with `GSWApplication' (that is,
`WOApplication' is just an alias for `GSWApplication').

   There are some constraints on how this can be used--

   * `WOApplication' (the alias) must not be an existing class;

   * `GSWApplication' (the real class) must be an existing class.



File: gcc.info,  Node: Gcov,  Next: Trouble,  Prev: Objective C,  Up: Top

`gcov': a Test Coverage Program
*******************************

   `gcov' is a tool you can use in conjunction with GNU CC to test code
coverage in your programs.

   This chapter describes version 1.5 of `gcov'.

* Menu:

* Gcov Intro::         	        Introduction to gcov.
* Invoking Gcov::       	How to use gcov.
* Gcov and Optimization::       Using gcov with GCC optimization.
* Gcov Data Files::             The files used by gcov.


File: gcc.info,  Node: Gcov Intro,  Next: Invoking Gcov,  Up: Gcov

Introduction to `gcov'
======================

   `gcov' is a test coverage program.  Use it in concert with GNU CC to
analyze your programs to help create more efficient, faster running
code.  You can use `gcov' as a profiling tool to help discover where
your optimization efforts will best affect your code.  You can also use
`gcov' along with the other profiling tool, `gprof', to assess which
parts of your code use the greatest amount of computing time.

   Profiling tools help you analyze your code's performance.  Using a
profiler such as `gcov' or `gprof', you can find out some basic
performance statistics, such as:

   * how often each line of code executes

   * what lines of code are actually executed

   * how much computing time each section of code uses

   Once you know these things about how your code works when compiled,
you can look at each module to see which modules should be optimized.
`gcov' helps you determine where to work on optimization.

   Software developers also use coverage testing in concert with
testsuites, to make sure software is actually good enough for a release.
Testsuites can verify that a program works as expected; a coverage
program tests to see how much of the program is exercised by the
testsuite.  Developers can then determine what kinds of test cases need
to be added to the testsuites to create both better testing and a better
final product.

   You should compile your code without optimization if you plan to use
`gcov' because the optimization, by combining some lines of code into
one function, may not give you as much information as you need to look
for `hot spots' where the code is using a great deal of computer time.
Likewise, because `gcov' accumulates statistics by line (at the lowest
resolution), it works best with a programming style that places only
one statement on each line.  If you use complicated macros that expand
to loops or to other control structures, the statistics are less
helpful--they only report on the line where the macro call appears.  If
your complex macros behave like functions, you can replace them with
inline functions to solve this problem.

   `gcov' creates a logfile called `SOURCEFILE.gcov' which indicates
how many times each line of a source file `SOURCEFILE.c' has executed.
You can use these logfiles along with `gprof' to aid in fine-tuning the
performance of your programs.  `gprof' gives timing information you can
use along with the information you get from `gcov'.

   `gcov' works only on code compiled with GNU CC.  It is not
compatible with any other profiling or test coverage mechanism.


File: gcc.info,  Node: Invoking Gcov,  Next: Gcov and Optimization,  Prev: Gcov Intro,  Up: Gcov

Invoking gcov
=============

     gcov [-b] [-c] [-v] [-n] [-l] [-f] [-o directory] SOURCEFILE

`-b'
     Write branch frequencies to the output file, and write branch
     summary info to the standard output.  This option allows you to
     see how often each branch in your program was taken.

`-c'
     Write branch frequencies as the number of branches taken, rather
     than the percentage of branches taken.

`-v'
     Display the `gcov' version number (on the standard error stream).

`-n'
     Do not create the `gcov' output file.

`-l'
     Create long file names for included source files.  For example, if
     the header file `x.h' contains code, and was included in the file
     `a.c', then running `gcov' on the file `a.c' will produce an
     output file called `a.c.x.h.gcov' instead of `x.h.gcov'.  This can
     be useful if `x.h' is included in multiple source files.

`-f'
     Output summaries for each function in addition to the file level
     summary.

`-o'
     The directory where the object files live.  Gcov will search for
     `.bb', `.bbg', and `.da' files in this directory.

   When using `gcov', you must first compile your program with two
special GNU CC options: `-fprofile-arcs -ftest-coverage'.  This tells
the compiler to generate additional information needed by gcov
(basically a flow graph of the program) and also includes additional
code in the object files for generating the extra profiling information
needed by gcov.  These additional files are placed in the directory
where the source code is located.

   Running the program will cause profile output to be generated.  For
each source file compiled with `-fprofile-arcs', an accompanying `.da'
file will be placed in the source directory.

   Running `gcov' with your program's source file names as arguments
will now produce a listing of the code along with frequency of execution
for each line.  For example, if your program is called `tmp.c', this is
what you see when you use the basic `gcov' facility:

     $ gcc -fprofile-arcs -ftest-coverage tmp.c
     $ a.out
     $ gcov tmp.c
      87.50% of 8 source lines executed in file tmp.c
     Creating tmp.c.gcov.

   The file `tmp.c.gcov' contains output from `gcov'.  Here is a sample:

                     main()
                     {
                1      int i, total;
     
                1      total = 0;
     
               11      for (i = 0; i < 10; i++)
               10        total += i;
     
                1      if (total != 45)
           ######        printf ("Failure\n");
                       else
                1        printf ("Success\n");
                1    }

   When you use the `-b' option, your output looks like this:

     $ gcov -b tmp.c
      87.50% of 8 source lines executed in file tmp.c
      80.00% of 5 branches executed in file tmp.c
      80.00% of 5 branches taken at least once in file tmp.c
      50.00% of 2 calls executed in file tmp.c
     Creating tmp.c.gcov.

   Here is a sample of a resulting `tmp.c.gcov' file:

                     main()
                     {
                1      int i, total;
     
                1      total = 0;
     
               11      for (i = 0; i < 10; i++)
     branch 0 taken = 91%
     branch 1 taken = 100%
     branch 2 taken = 100%
               10        total += i;
     
                1      if (total != 45)
     branch 0 taken = 100%
           ######        printf ("Failure\n");
     call 0 never executed
     branch 1 never executed
                       else
                1        printf ("Success\n");
     call 0 returns = 100%
                1    }

   For each basic block, a line is printed after the last line of the
basic block describing the branch or call that ends the basic block.
There can be multiple branches and calls listed for a single source
line if there are multiple basic blocks that end on that line.  In this
case, the branches and calls are each given a number.  There is no
simple way to map these branches and calls back to source constructs.
In general, though, the lowest numbered branch or call will correspond
to the leftmost construct on the source line.

   For a branch, if it was executed at least once, then a percentage
indicating the number of times the branch was taken divided by the
number of times the branch was executed will be printed.  Otherwise, the
message "never executed" is printed.

   For a call, if it was executed at least once, then a percentage
indicating the number of times the call returned divided by the number
of times the call was executed will be printed.  This will usually be
100%, but may be less for functions call `exit' or `longjmp', and thus
may not return every time they are called.

   The execution counts are cumulative.  If the example program were
executed again without removing the `.da' file, the count for the
number of times each line in the source was executed would be added to
the results of the previous run(s).  This is potentially useful in
several ways.  For example, it could be used to accumulate data over a
number of program runs as part of a test verification suite, or to
provide more accurate long-term information over a large number of
program runs.

   The data in the `.da' files is saved immediately before the program
exits.  For each source file compiled with `-fprofile-arcs', the
profiling code first attempts to read in an existing `.da' file; if the
file doesn't match the executable (differing number of basic block
counts) it will ignore the contents of the file.  It then adds in the
new execution counts and finally writes the data to the file.


File: gcc.info,  Node: Gcov and Optimization,  Next: Gcov Data Files,  Prev: Invoking Gcov,  Up: Gcov

Using `gcov' with GCC Optimization
==================================

   If you plan to use `gcov' to help optimize your code, you must first
compile your program with two special GNU CC options: `-fprofile-arcs
-ftest-coverage'.  Aside from that, you can use any other GNU CC
options; but if you want to prove that every single line in your
program was executed, you should not compile with optimization at the
same time.  On some machines the optimizer can eliminate some simple
code lines by combining them with other lines.  For example, code like
this:

     if (a != b)
       c = 1;
     else
       c = 0;

can be compiled into one instruction on some machines.  In this case,
there is no way for `gcov' to calculate separate execution counts for
each line because there isn't separate code for each line.  Hence the
`gcov' output looks like this if you compiled the program with
optimization:

           100  if (a != b)
           100    c = 1;
           100  else
           100    c = 0;

   The output shows that this block of code, combined by optimization,
executed 100 times.  In one sense this result is correct, because there
was only one instruction representing all four of these lines.  However,
the output does not indicate how many times the result was 0 and how
many times the result was 1.


File: gcc.info,  Node: Gcov Data Files,  Prev: Gcov and Optimization,  Up: Gcov

Brief description of `gcov' data files
======================================

   `gcov' uses three files for doing profiling.  The names of these
files are derived from the original _source_ file by substituting the
file suffix with either `.bb', `.bbg', or `.da'.  All of these files
are placed in the same directory as the source file, and contain data
stored in a platform-independent method.

   The `.bb' and `.bbg' files are generated when the source file is
compiled with the GNU CC `-ftest-coverage' option.  The `.bb' file
contains a list of source files (including headers), functions within
those files, and line numbers corresponding to each basic block in the
source file.

   The `.bb' file format consists of several lists of 4-byte integers
which correspond to the line numbers of each basic block in the file.
Each list is terminated by a line number of 0.  A line number of -1 is
used to designate that the source file name (padded to a 4-byte
boundary and followed by another -1) follows.  In addition, a line
number of -2 is used to designate that the name of a function (also
padded to a 4-byte boundary and followed by a -2) follows.

   The `.bbg' file is used to reconstruct the program flow graph for
the source file.  It contains a list of the program flow arcs (possible
branches taken from one basic block to another) for each function which,
in combination with the `.bb' file, enables gcov to reconstruct the
program flow.

   In the `.bbg' file, the format is:
             number of basic blocks for function #0 (4-byte number)
             total number of arcs for function #0 (4-byte number)
             count of arcs in basic block #0 (4-byte number)
             destination basic block of arc #0 (4-byte number)
             flag bits (4-byte number)
             destination basic block of arc #1 (4-byte number)
             flag bits (4-byte number)
             ...
             destination basic block of arc #N (4-byte number)
             flag bits (4-byte number)
             count of arcs in basic block #1 (4-byte number)
             destination basic block of arc #0 (4-byte number)
             flag bits (4-byte number)
             ...

   A -1 (stored as a 4-byte number) is used to separate each function's
list of basic blocks, and to verify that the file has been read
correctly.

   The `.da' file is generated when a program containing object files
built with the GNU CC `-fprofile-arcs' option is executed.  A separate
`.da' file is created for each source file compiled with this option,
and the name of the `.da' file is stored as an absolute pathname in the
resulting object file.  This path name is derived from the source file
name by substituting a `.da' suffix.

   The format of the `.da' file is fairly simple.  The first 8-byte
number is the number of counts in the file, followed by the counts
(stored as 8-byte numbers).  Each count corresponds to the number of
times each arc in the program is executed.  The counts are cumulative;
each time the program is executed, it attempts to combine the existing
`.da' files with the new counts for this invocation of the program.  It
ignores the contents of any `.da' files whose number of arcs doesn't
correspond to the current program, and merely overwrites them instead.

   All three of these files use the functions in `gcov-io.h' to store
integers; the functions in this header provide a machine-independent
mechanism for storing and retrieving data from a stream.


File: gcc.info,  Node: Trouble,  Next: Bugs,  Prev: Gcov,  Up: Top

Known Causes of Trouble with GCC
********************************

   This section describes known problems that affect users of GCC.  Most
of these are not GCC bugs per se--if they were, we would fix them.  But
the result for a user may be like the result of a bug.

   Some of these problems are due to bugs in other software, some are
missing features that are too much work to add, and some are places
where people's opinions differ as to what is best.

* Menu:

* Actual Bugs::		      Bugs we will fix later.
* Cross-Compiler Problems::   Common problems of cross compiling with GCC.
* Interoperation::      Problems using GCC with other compilers,
			   and with certain linkers, assemblers and debuggers.
* External Bugs::	Problems compiling certain programs.
* Incompatibilities::   GCC is incompatible with traditional C.
* Fixed Headers::       GNU C uses corrected versions of system header files.
                           This is necessary, but doesn't always work smoothly.
* Standard Libraries::  GNU C uses the system C library, which might not be
                           compliant with the ISO C standard.
* Disappointments::     Regrettable things we can't change, but not quite bugs.
* C++ Misunderstandings::     Common misunderstandings with GNU C++.
* Protoize Caveats::    Things to watch out for when using `protoize'.
* Non-bugs::		Things we think are right, but some others disagree.
* Warnings and Errors:: Which problems in your code get warnings,
                         and which get errors.


File: gcc.info,  Node: Actual Bugs,  Next: Cross-Compiler Problems,  Up: Trouble

Actual Bugs We Haven't Fixed Yet
================================

   * The `fixincludes' script interacts badly with automounters; if the
     directory of system header files is automounted, it tends to be
     unmounted while `fixincludes' is running.  This would seem to be a
     bug in the automounter.  We don't know any good way to work around
     it.

   * The `fixproto' script will sometimes add prototypes for the
     `sigsetjmp' and `siglongjmp' functions that reference the
     `jmp_buf' type before that type is defined.  To work around this,
     edit the offending file and place the typedef in front of the
     prototypes.

   * When `-pedantic-errors' is specified, GCC will incorrectly give an
     error message when a function name is specified in an expression
     involving the comma operator.


File: gcc.info,  Node: Cross-Compiler Problems,  Next: Interoperation,  Prev: Actual Bugs,  Up: Trouble

Cross-Compiler Problems
=======================

   You may run into problems with cross compilation on certain machines,
for several reasons.

   * Cross compilation can run into trouble for certain machines because
     some target machines' assemblers require floating point numbers to
     be written as _integer_ constants in certain contexts.

     The compiler writes these integer constants by examining the
     floating point value as an integer and printing that integer,
     because this is simple to write and independent of the details of
     the floating point representation.  But this does not work if the
     compiler is running on a different machine with an incompatible
     floating point format, or even a different byte-ordering.

     In addition, correct constant folding of floating point values
     requires representing them in the target machine's format.  (The C
     standard does not quite require this, but in practice it is the
     only way to win.)

     It is now possible to overcome these problems by defining macros
     such as `REAL_VALUE_TYPE'.  But doing so is a substantial amount of
     work for each target machine.  *Note Cross-compilation::.

   * At present, the program `mips-tfile' which adds debug support to
     object files on MIPS systems does not work in a cross compile
     environment.


File: gcc.info,  Node: Interoperation,  Next: External Bugs,  Prev: Cross-Compiler Problems,  Up: Trouble

Interoperation
==============

   This section lists various difficulties encountered in using GNU C or
GNU C++ together with other compilers or with the assemblers, linkers,
libraries and debuggers on certain systems.

   * Objective C does not work on the RS/6000.

   * GNU C++ does not do name mangling in the same way as other C++
     compilers.  This means that object files compiled with one compiler
     cannot be used with another.

     This effect is intentional, to protect you from more subtle
     problems.  Compilers differ as to many internal details of C++
     implementation, including: how class instances are laid out, how
     multiple inheritance is implemented, and how virtual function
     calls are handled.  If the name encoding were made the same, your
     programs would link against libraries provided from other
     compilers--but the programs would then crash when run.
     Incompatible libraries are then detected at link time, rather than
     at run time.

   * Older GDB versions sometimes fail to read the output of GCC version
     2.  If you have trouble, get GDB version 4.4 or later.

   * DBX rejects some files produced by GCC, though it accepts similar
     constructs in output from PCC.  Until someone can supply a coherent
     description of what is valid DBX input and what is not, there is
     nothing I can do about these problems.  You are on your own.

   * The GNU assembler (GAS) does not support PIC.  To generate PIC
     code, you must use some other assembler, such as `/bin/as'.

   * On some BSD systems, including some versions of Ultrix, use of
     profiling causes static variable destructors (currently used only
     in C++) not to be run.

   * Use of `-I/usr/include' may cause trouble.

     Many systems come with header files that won't work with GCC unless
     corrected by `fixincludes'.  The corrected header files go in a new
     directory; GCC searches this directory before `/usr/include'.  If
     you use `-I/usr/include', this tells GCC to search `/usr/include'
     earlier on, before the corrected headers.  The result is that you
     get the uncorrected header files.

     Instead, you should use these options (when compiling C programs):

          -I/usr/local/lib/gcc-lib/TARGET/VERSION/include -I/usr/include

     For C++ programs, GCC also uses a special directory that defines
     C++ interfaces to standard C subroutines.  This directory is meant
     to be searched _before_ other standard include directories, so
     that it takes precedence.  If you are compiling C++ programs and
     specifying include directories explicitly, use this option first,
     then the two options above:

          -I/usr/local/lib/g++-include

   * On some SGI systems, when you use `-lgl_s' as an option, it gets
     translated magically to `-lgl_s -lX11_s -lc_s'.  Naturally, this
     does not happen when you use GCC.  You must specify all three
     options explicitly.

   * On a Sparc, GCC aligns all values of type `double' on an 8-byte
     boundary, and it expects every `double' to be so aligned.  The Sun
     compiler usually gives `double' values 8-byte alignment, with one
     exception: function arguments of type `double' may not be aligned.

     As a result, if a function compiled with Sun CC takes the address
     of an argument of type `double' and passes this pointer of type
     `double *' to a function compiled with GCC, dereferencing the
     pointer may cause a fatal signal.

     One way to solve this problem is to compile your entire program
     with GNU CC.  Another solution is to modify the function that is
     compiled with Sun CC to copy the argument into a local variable;
     local variables are always properly aligned.  A third solution is
     to modify the function that uses the pointer to dereference it via
     the following function `access_double' instead of directly with
     `*':

          inline double
          access_double (double *unaligned_ptr)
          {
            union d2i { double d; int i[2]; };
          
            union d2i *p = (union d2i *) unaligned_ptr;
            union d2i u;
          
            u.i[0] = p->i[0];
            u.i[1] = p->i[1];
          
            return u.d;
          }

     Storing into the pointer can be done likewise with the same union.

   * On Solaris, the `malloc' function in the `libmalloc.a' library may
     allocate memory that is only 4 byte aligned.  Since GCC on the
     Sparc assumes that doubles are 8 byte aligned, this may result in a
     fatal signal if doubles are stored in memory allocated by the
     `libmalloc.a' library.

     The solution is to not use the `libmalloc.a' library.  Use instead
     `malloc' and related functions from `libc.a'; they do not have
     this problem.

   * Sun forgot to include a static version of `libdl.a' with some
     versions of SunOS (mainly 4.1).  This results in undefined symbols
     when linking static binaries (that is, if you use `-static').  If
     you see undefined symbols `_dlclose', `_dlsym' or `_dlopen' when
     linking, compile and link against the file `mit/util/misc/dlsym.c'
     from the MIT version of X windows.

   * The 128-bit long double format that the Sparc port supports
     currently works by using the architecturally defined quad-word
     floating point instructions.  Since there is no hardware that
     supports these instructions they must be emulated by the operating
     system.  Long doubles do not work in Sun OS versions 4.0.3 and
     earlier, because the kernel emulator uses an obsolete and
     incompatible format.  Long doubles do not work in Sun OS version
     4.1.1 due to a problem in a Sun library.  Long doubles do work on
     Sun OS versions 4.1.2 and higher, but GCC does not enable them by
     default.  Long doubles appear to work in Sun OS 5.x (Solaris 2.x).

   * On HP-UX version 9.01 on the HP PA, the HP compiler `cc' does not
     compile GCC correctly.  We do not yet know why.  However, GCC
     compiled on earlier HP-UX versions works properly on HP-UX 9.01
     and can compile itself properly on 9.01.

   * On the HP PA machine, ADB sometimes fails to work on functions
     compiled with GCC.  Specifically, it fails to work on functions
     that use `alloca' or variable-size arrays.  This is because GCC
     doesn't generate HP-UX unwind descriptors for such functions.  It
     may even be impossible to generate them.

   * Debugging (`-g') is not supported on the HP PA machine, unless you
     use the preliminary GNU tools (*note Installation::).

   * Taking the address of a label may generate errors from the HP-UX
     PA assembler.  GAS for the PA does not have this problem.

   * Using floating point parameters for indirect calls to static
     functions will not work when using the HP assembler.  There simply
     is no way for GCC to specify what registers hold arguments for
     static functions when using the HP assembler.  GAS for the PA does
     not have this problem.

   * In extremely rare cases involving some very large functions you may
     receive errors from the HP linker complaining about an out of
     bounds unconditional branch offset.  This used to occur more often
     in previous versions of GCC, but is now exceptionally rare.  If
     you should run into it, you can work around by making your
     function smaller.

   * GCC compiled code sometimes emits warnings from the HP-UX
     assembler of the form:

          (warning) Use of GR3 when
            frame >= 8192 may cause conflict.

     These warnings are harmless and can be safely ignored.

   * The current version of the assembler (`/bin/as') for the RS/6000
     has certain problems that prevent the `-g' option in GCC from
     working.  Note that `Makefile.in' uses `-g' by default when
     compiling `libgcc2.c'.

     IBM has produced a fixed version of the assembler.  The upgraded
     assembler unfortunately was not included in any of the AIX 3.2
     update PTF releases (3.2.2, 3.2.3, or 3.2.3e).  Users of AIX 3.1
     should request PTF U403044 from IBM and users of AIX 3.2 should
     request PTF U416277.  See the file `README.RS6000' for more
     details on these updates.

     You can test for the presence of a fixed assembler by using the
     command

          as -u < /dev/null

     If the command exits normally, the assembler fix already is
     installed.  If the assembler complains that `-u' is an unknown
     flag, you need to order the fix.

   * On the IBM RS/6000, compiling code of the form

          extern int foo;
          
          ... foo ...
          
          static int foo;

     will cause the linker to report an undefined symbol `foo'.
     Although this behavior differs from most other systems, it is not a
     bug because redefining an `extern' variable as `static' is
     undefined in ISO C.

   * AIX on the RS/6000 provides support (NLS) for environments outside
     of the United States.  Compilers and assemblers use NLS to support
     locale-specific representations of various objects including
     floating-point numbers (`.' vs `,' for separating decimal
     fractions).  There have been problems reported where the library
     linked with GCC does not produce the same floating-point formats
     that the assembler accepts.  If you have this problem, set the
     `LANG' environment variable to `C' or `En_US'.

   * Even if you specify `-fdollars-in-identifiers', you cannot
     successfully use `$' in identifiers on the RS/6000 due to a
     restriction in the IBM assembler.  GAS supports these identifiers.

   * On the RS/6000, XLC version 1.3.0.0 will miscompile `jump.c'.  XLC
     version 1.3.0.1 or later fixes this problem.  You can obtain
     XLC-1.3.0.2 by requesting PTF 421749 from IBM.

   * There is an assembler bug in versions of DG/UX prior to 5.4.2.01
     that occurs when the `fldcr' instruction is used.  GCC uses
     `fldcr' on the 88100 to serialize volatile memory references.  Use
     the option `-mno-serialize-volatile' if your version of the
     assembler has this bug.

   * On VMS, GAS versions 1.38.1 and earlier may cause spurious warning
     messages from the linker.  These warning messages complain of
     mismatched psect attributes.  You can ignore them.  *Note VMS
     Install::.

   * On NewsOS version 3, if you include both of the files `stddef.h'
     and `sys/types.h', you get an error because there are two typedefs
     of `size_t'.  You should change `sys/types.h' by adding these
     lines around the definition of `size_t':

          #ifndef _SIZE_T
          #define _SIZE_T
          ACTUAL-TYPEDEF-HERE
          #endif

   * On the Alliant, the system's own convention for returning
     structures and unions is unusual, and is not compatible with GCC
     no matter what options are used.

   * On the IBM RT PC, the MetaWare HighC compiler (hc) uses a different
     convention for structure and union returning.  Use the option
     `-mhc-struct-return' to tell GCC to use a convention compatible
     with it.

   * On Ultrix, the Fortran compiler expects registers 2 through 5 to
     be saved by function calls.  However, the C compiler uses
     conventions compatible with BSD Unix: registers 2 through 5 may be
     clobbered by function calls.

     GCC uses the same convention as the Ultrix C compiler.  You can use
     these options to produce code compatible with the Fortran compiler:

          -fcall-saved-r2 -fcall-saved-r3 -fcall-saved-r4 -fcall-saved-r5

   * On the WE32k, you may find that programs compiled with GCC do not
     work with the standard shared C library.  You may need to link with
     the ordinary C compiler.  If you do so, you must specify the
     following options:

          -L/usr/local/lib/gcc-lib/we32k-att-sysv/2.8.1 -lgcc -lc_s

     The first specifies where to find the library `libgcc.a' specified
     with the `-lgcc' option.

     GCC does linking by invoking `ld', just as `cc' does, and there is
     no reason why it _should_ matter which compilation program you use
     to invoke `ld'.  If someone tracks this problem down, it can
     probably be fixed easily.

   * On the Alpha, you may get assembler errors about invalid syntax as
     a result of floating point constants.  This is due to a bug in the
     C library functions `ecvt', `fcvt' and `gcvt'.  Given valid
     floating point numbers, they sometimes print `NaN'.

   * On Irix 4.0.5F (and perhaps in some other versions), an assembler
     bug sometimes reorders instructions incorrectly when optimization
     is turned on.  If you think this may be happening to you, try
     using the GNU assembler; GAS version 2.1 supports ECOFF on Irix.

     Or use the `-noasmopt' option when you compile GCC with itself,
     and then again when you compile your program.  (This is a temporary
     kludge to turn off assembler optimization on Irix.)  If this
     proves to be what you need, edit the assembler spec in the file
     `specs' so that it unconditionally passes `-O0' to the assembler,
     and never passes `-O2' or `-O3'.


File: gcc.info,  Node: External Bugs,  Next: Incompatibilities,  Prev: Interoperation,  Up: Trouble

Problems Compiling Certain Programs
===================================

   Certain programs have problems compiling.

   * Parse errors may occur compiling X11 on a Decstation running
     Ultrix 4.2 because of problems in DEC's versions of the X11 header
     files `X11/Xlib.h' and `X11/Xutil.h'.  People recommend adding
     `-I/usr/include/mit' to use the MIT versions of the header files,
     using the `-traditional' switch to turn off ISO C, or fixing the
     header files by adding this:

          #ifdef __STDC__
          #define NeedFunctionPrototypes 0
          #endif

   * On various 386 Unix systems derived from System V, including SCO,
     ISC, and ESIX, you may get error messages about running out of
     virtual memory while compiling certain programs.

     You can prevent this problem by linking GCC with the GNU malloc
     (which thus replaces the malloc that comes with the system).  GNU
     malloc is available as a separate package, and also in the file
     `src/gmalloc.c' in the GNU Emacs 19 distribution.

     If you have installed GNU malloc as a separate library package,
     use this option when you relink GCC:

          MALLOC=/usr/local/lib/libgmalloc.a

     Alternatively, if you have compiled `gmalloc.c' from Emacs 19, copy
     the object file to `gmalloc.o' and use this option when you relink
     GCC:

          MALLOC=gmalloc.o

