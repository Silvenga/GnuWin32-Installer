<html lang="en">
<head>
<title>The Plotutils Package</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The Plotutils Package">
<meta name="generator" content="makeinfo 4.6">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<h1 class="settitle">The Plotutils Package</h1>
<div class="node">
<p><hr>
Node:&nbsp;<a name="Top">Top</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Plotutils%20Intro">Plotutils Intro</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>
<br>
</div>

   <p>This is the documentation for version 2.4.1 of the GNU plotting
utilities package, including GNU libplot 4.1.  The package consists of
programs and functions for data plotting and vector graphics.

<ul class="menu">
<li><a accesskey="1" href="#Plotutils%20Intro">Plotutils Intro</a>:      GNU plotting utilities
<li><a accesskey="2" href="#graph">graph</a>:                graph, a program for plotting datasets
<li><a accesskey="3" href="#plot">plot</a>:                 plot, a plot format conversion program
<li><a accesskey="4" href="#pic2plot">pic2plot</a>:             pic2plot, a translator for files in the pic language
<li><a accesskey="5" href="#tek2plot">tek2plot</a>:             tek2plot, a translator for legacy Tektronix files
<li><a accesskey="6" href="#plotfont">plotfont</a>:             plotfont, a program for plotting font character maps
<li><a accesskey="7" href="#spline">spline</a>:               spline, an interpolation program
<li><a accesskey="8" href="#ode">ode</a>:                  ode, a differential equation integrator
<li><a accesskey="9" href="#libplot">libplot</a>:              A library for device-independent 2-D vector graphics
<li><a href="#Appendices">Appendices</a>:           Additional Information
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Plotutils%20Intro">Plotutils Intro</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#graph">graph</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">1 The GNU Plotting Utilities</h2>

<p>The GNU plotting utilities consist of eight command-line programs: the
graphics programs <code>graph</code>, <code>plot</code>, <code>pic2plot</code>,
<code>tek2plot</code>, and <code>plotfont</code>, and the mathematical programs
<code>spline</code>, <code>ode</code>, and <code>double</code>.  Distributed with these
programs is GNU <code>libplot</code>, the library on which the graphics
programs are based.  GNU <code>libplot</code> is a function library for
device-independent two-dimensional vector graphics, including vector
graphics animations under the X&nbsp;Window System.  It&nbsp;has bindings
for both C and&nbsp;C++.

   <p>The graphics programs and GNU <code>libplot</code> can export vector graphics
in the following formats.

     <dl>
<dt>X
     <dd>If this output option is selected, there is no output file.  Output is
directed to a popped-up window on an X&nbsp;Window System display. 
<br><dt>PNG
     <dd>This is "portable network graphics" format, which is increasingly
popular on the Web.  Unlike GIF format, it is unencumbered by patents. 
Files in PNG format may be viewed or edited with many applications, such
as the free image display application&nbsp;<code>xv</code> and the free
<code>ImageMagick</code> package. 
<br><dt>PNM
     <dd>This is "portable anymap" format.  There are three types of portable
anymap: PBM (portable bitmap, for monochrome images), PGM (portable
graymap), and PPM (portable pixmap, for colored images).  The output
file will use whichever is most appropriate.  Portable anymaps may be
translated to other formats with the <code>netpbm</code> package. 
<br><dt>GIF
     <dd>This is pseudo-GIF format rather than true GIF format.  Unlike GIF
format it does not use LZW compression, so it does not transgress the
Unisys LZW patent.  However, files in pseudo-GIF format may be viewed or
edited with any application that accepts GIF format, such&nbsp;as
<code>xv</code> and the <code>ImageMagick</code> package. 
<br><dt>SVG
     <dd>This is Scalable Vector Graphics format.  SVG is a new, XML-based format
for vector graphics on the Web.  The <a href="http://www.w3.org">W3&nbsp;Consortium</a> has more information on SVG, which is being developed by
its <a href="http://www.w3.org/Graphics">Graphics Activity</a>. 
<br><dt>AI
     <dd>This is the format used by Adobe Illustrator.  Files in this format may
be edited with Adobe Illustrator (version&nbsp;5, and more recent
versions), or other applications. 
<br><dt>PS
     <dd>This is <code>idraw</code>-editable Postscript format.  Files in this format
may be sent to a Postscript printer, imported into another document, or
edited with the free <code>idraw</code> drawing editor.  See <a href="#idraw">idraw</a>. 
<br><dt>CGM
     <dd>This is Computer Graphics Metafile format, which may be imported into an
application or displayed in any Web browser with a CGM plug-in.  By&nbsp;default, a binary file in version&nbsp;3 CGM format that conforms to the
WebCGM profile is produced.  The <a href="http://www.cgmopen.org">CGM Open Consortium</a> has more information on WebCGM, which is a standard for
Web-based vector graphics. 
<br><dt>Fig
     <dd>This is a vector graphics format that may be displayed or edited with
the free <code>xfig</code> drawing editor.  See <a href="#xfig">xfig</a>. 
<br><dt>PCL 5
     <dd>This is a powerful version of Hewlett-Packard's Printer Control
Language.  Files in this format may be sent to a LaserJet printer or
compatible device (note that most inkjets do not support PCL&nbsp;5). 
<br><dt>HP-GL
     <dd>This is Hewlett-Packard's Graphics Language.  By default, the modern
variant HP-GL/2 is produced.  Files in HP-GL or HP-GL/2 format may be
imported into a document or sent to a plotter. 
<br><dt>ReGIS
     <dd>This is the graphics format understood by several DEC terminals (VT340,
VT330, VT241, VT240) and emulators, including the DECwindows terminal
emulator, <code>dxterm</code>. 
<br><dt>Tek
     <dd>This is the graphics format understood by Tektronix 4014 terminals and
emulators, including the emulators built into the <code>xterm</code> terminal
emulator program and the MS-DOS version of <code>kermit</code>. 
<br><dt>Metafile
     <dd>This is device-independent GNU graphics metafile format.  The
<code>plot</code> program can translate it to any of the preceding formats. 
</dl>

   <p>Of the command-line graphics programs, the best known is <code>graph</code>,
which is an application for plotting two-dimensional scientific data. 
It reads one or more data files containing datasets, and outputs a plot. 
The above output formats are supported.  The corresponding commands are
<code>graph -T&nbsp;X</code>, <code>graph -T png</code>, <code>graph -T pnm</code>,
<code>graph -T gif</code>, <code>graph -T svg</code>, <code>graph -T ai</code>,
<code>graph -T ps</code>, <code>graph -T cgm</code>, <code>graph -T fig</code>,
<code>graph -T pcl</code>, <code>graph -T hpgl</code>, <code>graph -T regis</code>,
<code>graph -T tek</code>, and <code>graph</code>.  <code>graph</code> without a <code>-T</code>
option (referred to as `raw <code>graph</code>') produces output in GNU
metafile format.

   <p><code>graph</code> can read datasets in both ASCII and binary format, and
datasets in the `table' format produced by the plotting program
<code>gnuplot</code>.  It produces a plot with or without axes and labels. 
You may specify labels and ranges for the axes, and the size and
position of the plot on the display.  The labels may contain subscripts
and subscripts, Greek letters, and other special symbols; there is also
support for Cyrillic script (i.e., Russian) and Japanese.  You may
specify the type of marker symbol used for each dataset, and such
parameters as the style and thickness of the line (if&nbsp;any) used to
connect points in a dataset.  The plotting of filled regions is
supported, as is the drawing of error bars.  <code>graph</code> provides full
support for multiplotting.  With a single invocation of <code>graph</code>,
you may produce a multiplot consisting of many plots, either side by
side or inset.  Each plot will have its own axes and data.

   <p><code>graph -T&nbsp;X</code>, <code>graph -T tek</code>, <code>graph -T regis</code>, and
raw <code>graph</code> have a feature that most plotting programs do not have. 
They can accept input from a pipe, and plot data points to the output in
real time.  For this to occur, the user must specify ranges for both
axes, so that <code>graph</code> does not need to wait until the end of the
input before determining them.

   <p>The <code>plot</code> program is a so-called plot filter.  It can translate
GNU graphics metafiles (produced for&nbsp;example by raw <code>graph</code>)
into any supported output format.  The corresponding commands are
<code>plot -T&nbsp;X</code>, <code>plot -T png</code>, <code>plot -T pnm</code>, <code>plot
-T gif</code>, <code>plot -T svg</code>, <code>plot -T ai</code>, <code>plot -T ps</code>,
<code>plot -T cgm</code>, <code>plot -T fig</code>, <code>plot -T pcl</code>, <code>plot
-T hpgl</code>, <code>plot -T regis</code>, <code>plot -T tek</code>, and <code>plot</code>. 
The <code>plot</code> program is useful if you wish to produce output in
several different formats while invoking <code>graph</code> only once.  It&nbsp;is also useful if you wish to translate files in the traditional
`plot(5)' format produced by, e.g., the non-GNU versions of <code>graph</code>
provided with some operating systems.  GNU metafile format is compatible
with plot(5) format.

   <p>The <code>pic2plot</code> program can translate from the pic language to any
supported output format.  The pic language, which was invented at Bell
Laboratories, is used for creating box-and-arrow diagrams of the kind
frequently found in technical papers and textbooks.  The corresponding
commands are <code>pic2plot -T&nbsp;X</code>, <code>pic2plot -T png</code>,
<code>pic2plot -T pnm</code>, <code>pic2plot -T gif</code>, <code>pic2plot -T ai</code>,
<code>pic2plot -T ps</code>, <code>pic2plot -T cgm</code>, <code>pic2plot -T fig</code>,
<code>pic2plot -T pcl</code>, <code>pic2plot -T hpgl</code>, <code>pic2plot -T
regis</code>, <code>pic2plot -T tek</code>, and <code>pic2plot</code>.

   <p>The <code>tek2plot</code> program can translate from Tektronix format to any
supported output format.  The corresponding commands are <code>tek2plot
-T&nbsp;X</code>, <code>tek2plot -T png</code>, <code>tek2plot -T pnm</code>,
<code>tek2plot -T gif</code>, <code>tek2plot -T svg</code>, <code>tek2plot -T ai</code>,
<code>tek2plot -T ps</code>, <code>tek2plot -T cgm</code>, <code>tek2plot -T fig</code>,
<code>tek2plot -T pcl</code>, <code>tek2plot -T hpgl</code>, <code>tek2plot -T
regis</code>, and <code>tek2plot</code>.  <code>tek2plot</code> is useful if you have an
older application that produces drawings in Tektronix format.

   <p>The <code>plotfont</code> program is a simple utility that displays a
character map for any font that is available to <code>graph</code>,
<code>plot</code>, <code>pic2plot</code>, or <code>tek2plot</code>.  The 35 standard
Postscript fonts are available if the <code>-T X</code>, <code>-T ai</code>,
<code>-T ps</code>, <code>-T cgm</code>, or <code>-T fig</code> options are used.  The 45
standard PCL&nbsp;5 fonts (i.e., "LaserJet" fonts) are available if the
<code>-T ai</code>, <code>-T pcl</code> or <code>-T hpgl</code> options are used.  In the
latter two cases (<code>-T pcl</code> and <code>-T hpgl</code>), a&nbsp;number of
Hewlett-Packard vector fonts are available as&nbsp;well.  A&nbsp;set of
22 Hershey vector fonts, including Cyrillic fonts and a Japanese font,
is always available.  When producing output for an X&nbsp;Window&nbsp;System
display, any of the graphics programs can use scalable X&nbsp;fonts.

   <p>Of the command-line mathematical programs, <code>spline</code> does spline
interpolation of scalar or vector-valued data.  It normally uses either
cubic spline interpolation or exponential splines in tension, but like
<code>graph</code> it&nbsp;can function as a real-time filter under some
circumstances.  Besides splining datasets, it&nbsp;can construct curves,
either open or closed, through arbitrarily chosen points in
d-dimensional space.  <code>ode</code> provides the ability to
integrate an ordinary differential equation or a system of ordinary
differential equations, when provided with an explicit expression for
each equation.  It supplements the plotting program <code>gnuplot</code>,
which can plot functions but not integrate ordinary differential
equations.  The final command-line mathematical program, <code>double</code>,
is a filter for converting, scaling and cutting binary or ASCII data
streams.  It&nbsp;is still under development and is not yet documented.

   <p>The GNU <code>libplot</code> function library, on which the command-line
graphics programs are based, is discussed at&nbsp;length elsewhere in
this documentation.  It&nbsp;gives C and&nbsp;C++ programs the ability to
draw such objects as lines, open and closed polylines, arcs (both
circular and elliptic), quadratic and cubic Bezier curves, circles and
ellipses, points (i.e., pixels), marker symbols, and text strings.  The
filling of objects other than points, marker symbols, and text strings
is supported (fill color, as&nbsp;well as pen color, can be set
arbitrarily).  Text strings can be drawn in any of a large number of
fonts.  The 35 standard Postscript fonts are supported by the X&nbsp;Window System, SVG, Illustrator, Postscript, CGM, and <code>xfig</code>
drivers, and the 45 standard PCL&nbsp;5 fonts are supported by the SVG,
Illustrator, PCL&nbsp;5 and HP-GL/2 drivers.  The latter two also support
a number of Hewlett-Packard vector fonts.  All drivers, including the
PNG, PNM, GIF, ReGIS, Tektronix and metafile drivers, support a set of
22 Hershey vector fonts.

   <p>The support for drawing text strings is extensive.  Text strings may
include subscripts and superscripts, and may include characters chosen
from more than one font in a typeface.  Many non-alphanumeric characters
may be included.  The entire collection of over 1700 `Hershey glyphs'
digitized by Allen&nbsp;V. Hershey at the U.S. Naval Surface Weapons
Center, which includes many curious symbols, is built into GNU
<code>libplot</code>.  Text strings in the so-called EUC-JP encoding (the
Extended Unix Code for Japanese) can be also be drawn.  Such strings may
include both syllabic Japanese characters (Hiragana and Katakana) and
ideographic Japanese characters (Kanji).  GNU <code>libplot</code> contains a
library of 603 Kanji, including 596 of the 2965 frequently used
Level&nbsp;1 Kanji.

<div class="node">
<p><hr>
Node:&nbsp;<a name="graph">graph</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#plot">plot</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Plotutils%20Intro">Plotutils Intro</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">2 The <code>graph</code> Application</h2>

<p>Each invocation of <code>graph</code> reads one or more datasets from files
named on the command line or from standard input, and prepares a plot. 
There are many command-line options for adjusting the visual appearance
of the plot. 
The following sections explain how to use the most frequently used
options, by giving examples.

<ul class="menu">
<li><a accesskey="1" href="#Simple%20Examples">Simple Examples</a>:      Simple examples using graph
<li><a accesskey="2" href="#Non-Square%20Plots">Non-Square Plots</a>:     Rotating and changing the aspect ratio of a plot
<li><a accesskey="3" href="#Multiple%20Datasets">Multiple Datasets</a>:    Preparing a plot from more than one dataset
<li><a accesskey="4" href="#Multiplotting">Multiplotting</a>:        Multiple plots on a single page
<li><a accesskey="5" href="#Data%20Formats">Data Formats</a>:         Reading binary and other data formats
<li><a accesskey="6" href="#graph%20Invocation">graph Invocation</a>:     Command-line options
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Simple%20Examples">Simple Examples</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Non-Square%20Plots">Non-Square Plots</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#graph">graph</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph">graph</a>
<br>
</div>

<h3 class="section">2.1 Simple examples using <code>graph</code></h3>

<p>By default, <code>graph</code> reads ASCII data from the files specified on
the command line, or from standard input if no files are specified.  The
data are pairs of numbers, interpreted as the x and&nbsp;y
coordinates of data points.  An example would be:

<pre class="example">     0.0  0.0
     1.0  0.2
     2.0  0.0
     3.0  0.4
     4.0  0.2
     5.0  0.6
     </pre>

<p>Data points do not need to be on different lines, nor do the x
and y coordinates of a data point need to be on the same line. 
However, there should be no blank lines in the input if it is to be
viewed as forming a single dataset.

   <p>To plot such a dataset with <code>graph</code>, you could do

<pre class="example">     graph -T ps datafile &gt; plot.ps
     </pre>

<p>or equivalently

<pre class="example">     graph -T ps &lt; datafile &gt; plot.ps
     </pre>

<p>Either of these would produce an encapsulated Postscript file
<code>plot.ps</code>, which could be included in another document, displayed
on a screen, sent to a printer, or edited with the free <code>idraw</code>
drawing editor.  The <code>--page-size</code> option, or equivalently the
<code>PAGESIZE</code> environment variable, specifies the size of the page on
which the plot will be positioned.  The default is "letter", i.e.,
8.5in by 11in, but "a4" or other ISO or ANSI page sizes
could equally well be specified.  See <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

   <p>Similarly, you would do

<pre class="example">     graph -T svg &lt; datafile &gt; plot.svg
     graph -T cgm &lt; datafile &gt; plot.cgm
     </pre>

<p>to produce SVG and WebCGM files that could be displayed in a Web browser
with SVG and WebCGM support, or

<pre class="example">     graph -T fig &lt; datafile &gt; plot.fig
     </pre>

<p>to produce a file <code>plot.fig</code> in Fig format that could be edited
with the free <code>xfig</code> drawing editor, or

<pre class="example">     graph -T ai &lt; datafile &gt; plot.ai
     </pre>

<p>to produce a file <code>plot.ai</code> that could be edited with Adobe
Illustrator.  If you do

<pre class="example">     graph -T hpgl &lt; datafile &gt; plot.plt
     </pre>

<p>you will produce a file <code>plot.plt</code> in the Hewlett-Packard Graphics
Language (HP-GL/2) that may be sent to a Hewlett-Packard plotter. 
Similarly, you would use <code>graph -T pcl</code> to produce a file in PCL&nbsp;5 format that may be printed on a LaserJet or other laser printer.

   <p>You would use <code>graph -T&nbsp;X</code> to pop&nbsp;up a window on an X&nbsp;Window System display, and display the plot in&nbsp;it.  For that, you
would do

<pre class="example">     graph -T X &lt; datafile
     </pre>

<p>If you use <code>graph -T&nbsp;X</code>, no output file will be produced: only
a window.  The window will vanish if you type&nbsp;<code>q</code> or click your
mouse in&nbsp;it.

   <p>You may also use <code>graph -T png</code> to produce a PNG file, <code>graph
-T pnm</code> to produce a PNM file (a "portable anymap"), and <code>graph
-T gif</code> to produce a pseudo-GIF file.  If the free image display
application <code>xv</code> is available on your system, you could use any
of the three commands

<pre class="example">     graph -T png &lt; datafile | xv -
     graph -T pnm &lt; datafile | xv -
     graph -T gif &lt; datafile | xv -
     </pre>

<p>to view the output file.

   <p>Another thing you can do is use <code>graph -T tek</code> to display a plot on
a device that can emulate a Tektronix 4014 graphics terminal. 
<code>xterm</code>, the X&nbsp;Window System terminal emulator, can do this. 
Within an <code>xterm</code> window, you would type

<pre class="example">     graph -T tek &lt; datafile
     </pre>

<p><code>xterm</code> normally emulates a VT100 terminal, but when this command
is issued from within&nbsp;it, it&nbsp;will pop&nbsp;up a second window
(a&nbsp;`Tektronix window') and draw the plot in&nbsp;it.  The Japanese
terminal emulator <code>kterm</code> should be able to do the same, provided
that it is correctly installed.  Another piece of software that can
emulate a Tektronix 4014 terminal is the MS-DOS version of <code>kermit</code>.

   <p>In the same way, you would use <code>graph -T regis</code> to display a plot
on any graphics terminal or emulator that supports ReGIS graphics. 
<code>dxterm</code>, the DECwindows terminal emulator, can do this.  Several
DEC terminals (in particular the VT340, VT330, VT241, and VT240
terminals) also support ReGIS graphics.

   <p><code>graph</code> may behave differently depending on the environment in
which it is invoked.  We have already mentioned the <code>PAGESIZE</code>
environment variable, which affects the operation of <code>graph -T
svg</code>, <code>graph -T ai</code>, <code>graph -T ps</code>, <code>graph -T cgm</code>,
<code>graph -T fig</code>, <code>graph -T pcl</code>, and <code>graph -T hpgl</code>. 
Similarly, the <code>BITMAPSIZE</code> environment variable affects the
operation of <code>graph -T&nbsp;X</code>, <code>graph -T png</code>, <code>graph -T
pnm</code>, and <code>graph -T gif</code>.  The <code>DISPLAY</code> environment variable
affects the operation of <code>graph -T&nbsp;X</code>, and the <code>TERM</code>
environment variable affects the operation of <code>graph -T tek</code>. 
There are also several environment variables that affect the operation
of <code>graph -T pcl</code> and <code>graph -T hpgl</code>.  For a complete
discussion of the effects of the environment on <code>graph</code>, see
<a href="#graph%20Environment">graph Environment</a>.  The following remarks apply irrespective of
which output format is specified.

   <p>By default, successive points in the dataset are joined by solid line
segments, which form a polygonal line or polyline that we call simply a
`line'.  You may choose the style of line (the `linemode') with the
<code>-m</code> option:

<pre class="example">     graph -T ps -m 2 &lt; datafile &gt; plot.ps
     </pre>

<p>Here <code>-m 2</code> indicates that linemode #2 should be used.  If&nbsp;the
dataset is rendered in monochrome, which is the default, the line can be
drawn in one of five distinct styles.  Linemodes #1 through #5 signify
solid, dotted, dotdashed, shortdashed, and longdashed; thereafter the
sequence repeats.  If&nbsp;the <code>-C</code> option is used, the dataset will
be rendered in color.  For colored datasets, the line can be drawn in
one of 25 distinct styles.  Linemodes #1 through #5 signify red, green,
blue, magenta, and cyan; all are solid.  Linemodes #6 through #10
signify the same five colors, but dotted rather than solid.  Linemodes
#11 through #16 signify the same five colors, but dotdashed, and so
forth.  After linemode #25, the sequence repeats.  Linemode #0,
irrespective of whether the rendering is in monochrome or color, means
that the line is not drawn.

   <p>You may wish to <em>fill</em> the polygon bounded by the line (i.e.,
shade&nbsp;it, or fill it with a solid color).  For this, you would use
the <code>-q</code> option.  For&nbsp;example,

<pre class="example">     echo .1 .1 .1 .9 .9 .9 .9 .1 .1 .1 |
         graph -T ps -C -m 1 -q 0.3 &gt; plot.ps
     </pre>

<p>will plot a square region with vertices (0.1,0.1), (0.1,0.9), (0.9,0.9),
and (0.9,0.1).  The repetition of the first vertex (0.1,0.1) at the end
of the sequence of vertices ensures that the square will be closed: all
four segments of its boundary will be drawn.  The square will be drawn
in red, since the colored version of linemode #1 is requested.  The
interior of the square will be filled with red to an intensity of&nbsp;30%, as the <code>-q 0.3</code> option specifies.  If&nbsp;the intensity
were&nbsp;1.0, the region would be filled with solid color, and if it
were&nbsp;0.0, the region would be filled with white.  If&nbsp;the
intensity were negative, the region would be unfilled, or transparent
(the default).

   <p>You may specify the thickness (`width') of the line, whether it is
filled or not, by using the <code>-W</code> option.  For&nbsp;example, <code>-W
0.01</code> specifies that the line should have a thickness equal to 0.01
times the size of the graphics display.  Also, you may put symbols at
each data point along the line by doing, for&nbsp;example,

<pre class="example">     graph -T ps -S 3 0.1 &lt; datafile &gt; plot.ps
     </pre>

<p>where the first argument 3 indicates which symbol to plot.  The optional
second argument 0.1 specifies the symbol size as a fraction of the size
of the `plotting box': the square within which the plot is drawn. 
Symbol #1 is a dot, symbol #2 is a plus sign, symbol #3 is an asterisk,
symbol #4 is a circle, symbol #5 is a cross, and so forth. 
(See <a href="#Marker%20Symbols">Marker Symbols</a>.)  Symbols 1 through 31 are the same for all
display types, and the color of a symbol will be the same as the color
of the line it is plotted along.

   <p>Actually, you would probably not want to plot symbols at each point in
the dataset unless you turn off the line joining the points.  For this
purpose, the `negative linemode' concept is useful.  A&nbsp;line whose
linemode is negative is not visible; however, any symbols plotted along
it will have the color associated with the corresponding positive
linemode.  So, for&nbsp;example,

<pre class="example">     graph -T ps -C -m -3 -S 4 &lt; datafile &gt; plot.ps
     </pre>

<p>will plot a blue circle at each data point.  The circles will not be
joined by line segments.  By adding the optional second argument to the
<code>-S</code> option, you may adjust the size of the circles.

   <p><code>graph</code> will automatically generate abscissa (i.e.,&nbsp;x)
values for you if you use the <code>-a</code> option.  If&nbsp;this option is
used, no abscissa values should be given in the data file.  The data
points will be taken to be regularly spaced along the abscissa.  The two
arguments following <code>-a</code> on the command line will be taken as the
sampling interval and the abscissa value of the first data point.  If&nbsp;they are absent, they default to 1.0 and 0.0 respectively.  For
example, the command

<pre class="example">     echo 0 1 0 | graph -T ps -a &gt; plot.ps
     </pre>

<p>produces exactly the same plot  as

<pre class="example">     echo 0 0 1 1 2 0 | graph -T ps &gt; plot.ps
     </pre>

   <p>If the <code>-I e</code> option is specified, <code>graph</code> will plot data with
error bars.  In this case the dataset should consist of triples
(x,y,<i>error</i>), rather than pairs (x,y).  A&nbsp;vertical error bar of the appropriate length will be plotted at each
data point.  You would plot a symbol at each data point, along with the
error bar, by using the <code>-S</code> option in the usual way.  The symbol
will be the same for each point in the dataset.  You may use the
<code>-a</code> option in conjunction with <code>-I e</code>, if you wish.  If&nbsp;you do, the dataset should contain no abscissa (i.e.,&nbsp;x)
values.

   <p>By default, the limits on the x and y axes, and the
spacing between the labeled ticks on each axis, are computed
automatically.  You may wish to set them manually.  You would accomplish
this with the <code>-x</code> and <code>-y</code> options.

<pre class="example">     echo 0 0 1 1 2 0 | graph -T ps -x -1 3 -y -1 2 &gt; plot.ps
     </pre>

<p>will produce a plot in which the x axis extends from -1
to&nbsp;3, and the y axis from -1 to&nbsp;2.  By default,
<code>graph</code> tries to place about six numbered ticks on each axis.  By
including an optional third argument to <code>-x</code> or <code>-y</code>, you may
manually set the spacing of the labeled ticks.  For&nbsp;example, using
<code>-y -1 2 1</code> rather than <code>-y -1 2</code> will produce a y&nbsp;axis with labeled ticks at -1, 0, 1, and&nbsp;2, rather than at
the locations that <code>graph</code> would choose by default, which would be
-1, -0.5, 0, 0.5, 1, 1.5, and&nbsp;2.  In&nbsp;general, if a
third argument is present then labeled ticks will be placed at each of
its integer multiples.

   <p>To make an axis logarithmic, you would use the <code>-l</code> option.  For
example,

<pre class="example">     echo 1 1 2 3 3 1 | graph -T ps -l x &gt; plot.ps
     </pre>

<p>will produce a plot in which the x axis is logarithmic, but the
y axis is linear.  To make both axes logarithmic, you would use
<code>-l x -l y</code>.  By default, the upper and lower limits on a
logarithmic axis are powers of ten, and there are tick marks at each
power of ten and at its integer multiples.  The tick marks at the powers
of ten are labeled.  If&nbsp;the axis spans more than five orders of
magnitude, the tick marks at the integer multiples are omitted.

   <p>If you have an unusually short logarithmic axis, you may need to
increase the number of labeled ticks.  To do this, you should specify a
tick spacing manually.  For&nbsp;example, <code>-l x -x 1 9 2</code> would
produce a plot in which the x&nbsp;axis is logarithmic and extends
from 1 to&nbsp;9.  Labeled ticks would be located at each integer
multiple of&nbsp;2, i.e., at 2, 4, 6, and&nbsp;8.

   <p>You would label the x and y axes with the <code>-X</code> and
<code>-Y</code> options, respectively.  For example,

<pre class="example">     echo 1 1 2 3 3 1 | graph -T ps -l x -X "A Logarithmic Axis" &gt; plot.ps
     </pre>

<p>will label the log axis in the preceding example.  By default, the label
for the y axis (if&nbsp;any) will be rotated 90 degrees, unless
you use the <code>--toggle-rotate-y-label</code> option.  You may specify a
`top label', or title for the plot, by using the <code>-L</code> option. 
Doing, for&nbsp;example,

<pre class="example">     echo 1 1 2 3 3 1 | graph -T ps -l x -L "A Simple Example" &gt; plot.ps
     </pre>

<p>will produce a plot with a title on top.

   <p>The font size of the x axis and y axis labels may be
specified with the <code>-f</code> option, and the font size of the title with
the <code>--title-font-size</code> option.  For example,

<pre class="example">     echo 1 1 2 3 3 1 | graph -T ps -X "Abscissa" -f 0.1 &gt; plot.ps
     </pre>

<p>will produce a plot in which the font size of the x axis label,
and each of the numerical tick labels, is very large (0.1 times the size
of the plotting box, i.e., the square within which the plot is drawn).

   <p>The font in which the labels specified with the <code>-X</code>, <code>-Y</code>,
and <code>-L</code> options are drawn can be specified with the <code>-F</code>
option.  For example, <code>-F Times-Roman</code> will make the labels appear
in Times-Roman instead of the default font (which is Helvetica, unless
<code>-T png</code>, <code>-T pnm</code>, <code>-T gif</code>, <code>-T pcl</code>, <code>-T
hpgl</code>, <code>-T regis</code>, or <code>-T tek</code> is specified).  Font names are
case-insensitive, so <code>-F times-roman</code> will work equally well.  The
available fonts include 35 Postscript fonts (for all variants of
<code>graph</code> other than <code>graph -T png</code>, <code>graph -T pnm</code>,
<code>graph -T gif</code>, <code>graph -T pcl</code>, <code>graph -T hpgl</code>,
<code>graph -T regis</code>, and <code>graph -T tek</code>), 45 PCL&nbsp;5 fonts (for
<code>graph -T svg</code>, <code>graph -T ai</code>, <code>graph -T pcl</code> and
<code>graph -T hpgl</code>), a number of Hewlett-Packard vector fonts (for
<code>graph -T pcl</code> and <code>graph -T hpgl</code>), and 22 Hershey vector
fonts.  The Hershey fonts include HersheyCyrillic, for Russian, and
HersheyEUC, for Japanese.  For a discussion of the available fonts, see
<a href="#Text%20Fonts">Text Fonts</a>.  The <code>plotfont</code> utility will produce a character
map of any available font.  See <a href="#plotfont">plotfont</a>.

   <p>The format of the labels drawn with the <code>-X</code>, <code>-Y</code>, and
<code>-L</code> options may be quite intricate.  Subscripts, superscripts,
square roots, and switching fonts within a typeface are all allowed. 
The above examples do not illustrate this, but for details, see
<a href="#Text%20String%20Format">Text String Format</a>.

   <p>Each of the preceding examples produces a plot containing the default
sort of grid (a square plotting box, with ticks and labels drawn along
its lower edge and its left edge).  There are actually several sorts of
grid you may request.  The <code>-g&nbsp;0</code>, <code>-g&nbsp;1</code>, <code>-g&nbsp;2</code>, and <code>-g&nbsp;3</code> options yield successively fancier grids.  What
they yield, respectively, is no&nbsp;grid at&nbsp;all, a&nbsp;pair of axes
with ticks and labels, a square plotting box with ticks and labels, and
a square plotting box with ticks, labels, and grid lines.  As you can
check, <code>-g&nbsp;2</code> is the default.  There is also a <code>-g&nbsp;4</code>
option, which yields a slightly different sort of grid: a&nbsp;pair of
axes that cross at the origin.  This last sort of grid is useful when
the x or&nbsp;y coordinates of the data points you are
plotting are both positive and negative.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Non-Square%20Plots">Non-Square Plots</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Multiple%20Datasets">Multiple Datasets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple%20Examples">Simple Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph">graph</a>
<br>
</div>

<h3 class="section">2.2 Non-square, displaced, and rotated plots</h3>

<p>To alter the linear dimensions of the plotting box, and also to position
it in a different part of the graphics display, you could do something
like

<pre class="example">     graph -T ps -h .3 -w .6 -r .1 -u .1 &lt; datafile &gt; plot.ps
     </pre>

<p>Here the <code>-h</code> and <code>-w</code> options specify the height and width of
the plotting box, and the <code>-r</code> and <code>-u</code> options indicate how
far up and to the right the lower left corner of the plotting box should
be positioned.  All dimensions are expressed as fractions of the size of
the graphics display.  By&nbsp;default, the height and width of the
plotting box equal 0.6, and the `upward shift' and the `rightward shift'
equal&nbsp;0.2.  So&nbsp;the above example will produce a plot that is
half as tall as usual.  Compared to its usual position, the plot will be
shifted slightly downward and to the left.

   <p>Several command-line options specify sizes or dimensions as fractions of
the size of the plotting box.  For example, <code>-S 3 .01</code> specifies
that the marker symbols for the following dataset should be of type&nbsp;#3, and should have a font size equal to&nbsp;0.01, i.e., 0.01 times the
minimum dimension (height or width) of the plotting box.  If the
<code>-h</code> or <code>-w</code> options are employed to expand or contract the
plot, such sizes or dimensions will scale in tandem.  That is presumably
the right thing to&nbsp;do.

   <p>To rotate your plot by 90 degrees counterclockwise, you would add
<code>--rotation 90</code> to the <code>graph</code> command line.  You may also
specify <code>--rotation 180</code>, to produce an upside-down plot, or
<code>--rotation 270</code>.  The <code>--rotation</code> option may be combined
with the <code>-h</code>, <code>-w</code>, <code>-r</code>, and <code>-u</code> options.  If
they appear together, the <code>--rotation</code> option takes effect first. 
That is because <code>--rotation</code> specifies the rotation angle of the
graphics display, while the other options specify how the plotting box
should be positioned within the graphics display.  The two sorts of
positioning are logically distinct.

   <p>The graphics display (sometimes called the `viewport') is an
abstraction.  For <code>graph -T&nbsp;X</code>, it is a popped-up window on an
X&nbsp;display.  For <code>graph -T pnm</code> and <code>graph -T gif</code>, it is a
square or rectangular bitmap.  In these three cases, the size of the
graphics display can be set by using the <code>--bitmap-size</code> option, or
by setting the <code>BITMAPSIZE</code> environment variable.  For <code>graph
-T tek</code>, the graphics display is a square region occupying the central
part of a Tektronix display.  (Tektronix displays are 4/3 times as wide
as they are high.)  For <code>graph -T regis</code>, it is a square region
occupying the central part of a ReGIS display.  For <code>graph -T ai</code>,
<code>graph -T ps</code>, <code>graph -T pcl</code>, and <code>graph -T fig</code>, by&nbsp;default it is a 8-inch square centered on an 8.5in by 11in
page (US&nbsp;letter size).  For <code>graph -T hpgl</code>, it is an 8-inch
square, which by default is not centered.  For <code>graph -T svg</code> and
<code>graph -T cgm</code>, the default graphics display is an 8-inch square,
though if the output file is placed on a Web page, it may be scaled
arbitrarily.

   <p>The page size, which determines the default display size used by
<code>graph -T svg</code>, <code>graph -T ai</code>, <code>graph -T ps</code>, <code>graph
-T cgm</code>, <code>graph -T fig</code>, <code>graph -T pcl</code>, and <code>graph -T
hpgl</code>, can be set by using the <code>--page-size</code> option, or by setting
the environment variable <code>PAGESIZE</code>.  For&nbsp;example, setting the
page size to "a4" would produce output for an A4-size page (21cm
by 29.7cm), and would select a appropriate graphics display size. 
Either or both of the dimensions of the graphics display can be
specified explicitly.  For example, the page size could be specified as
"letter,xsize=4in", or "a4,xsize=10cm,ysize=15cm".  The dimensions of
the graphics display are allowed to be negative (a&nbsp;negative
dimension results in a reflection).

   <p>The position of the display on the page, relative to its default
position, may optionally be adjusted by specifying an offset vector. 
For example, the page size could be specified as "letter,yoffset=1.2in",
or "a4,xoffset=-5mm,yoffset=2.0cm".  It&nbsp;is also possible to
position the graphics display precisely, by specifying the location of
its lower left corner relative to the lower left corner of the page. 
For example, the page size could be specified as
"letter,xorigin=2in,yorigin=3in", or "a4,xorigin=0.5cm,yorigin=0.5cm".

   <p>The preceding options may be intermingled.  However, <code>graph -T svg</code>
and <code>graph -T cgm</code> ignore the "xoffset", "yoffset", "xorigin", and
"yorigin" options, since SVG format and WebCGM format have no notion of
the Web page on which the graphics display will ultimately be
positioned.  They interpret the "xsize" and "ysize" options as
specifying a default size for the graphics display (it&nbsp;is merely a
default, since the output file may be scaled arbitrarily when it is
placed on a Web page).

   <p>For more information on page and graphics display sizes, see <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Multiple%20Datasets">Multiple Datasets</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Multiplotting">Multiplotting</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Non-Square%20Plots">Non-Square Plots</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph">graph</a>
<br>
</div>

<h3 class="section">2.3 Preparing a plot from more than one dataset</h3>

<p>It is frequently the case that several datasets need to be displayed on
the same plot.  If&nbsp;so, you may wish to distinguish the points in
different datasets by joining them by lines of different types, or by
using marker symbols of different types.

   <p>A more complicated example would be the following.  You may have a file
containing a dataset that is the result of experimental observations,
and a file containing closely spaced points that trace out a theoretical
curve.  The second file is a dataset in its own right.  You would
presumably plot it with line segments joining successive data points, so
as to trace out the theoretical curve.  But the first dataset, resulting
from experiment, would be plotted without such line segments.  In&nbsp;fact, a marker symbol would be plotted at each of its points.

   <p>These examples, and others like them, led us to define a set of seven
<em>attributes</em> that define the way a dataset should be plotted. 
These attributes, which can be set by command-line options, are the
following.

     <ol type=1 start=1>
<li>color/monochrome
<li>linemode
<li>linewidth
<li>symbol type
<li>symbol size
<li>symbol font name
<li>fill fraction
        </ol>

<p>Color/monochrome (a choice of one or the other) is the simplest.  The
choice is toggled with the <code>-C</code> option.  The `linemode' (i.e., line
style) specifies how the line segments joining successive points should
be drawn; it is specified with the <code>-m</code> option.  Linemode #0 means
no linemode at&nbsp;all, for&nbsp;example.  `Linewidth' means line
thickness; it&nbsp;is specified with the <code>-W</code> option. `Symbol type'
and `symbol size', which are specified with the <code>-S</code> option,
specify the symbol plotted at each point of the dataset.  `Symbol font
name' refers to the font from which marker symbols #32 and above, which
are taken to be characters rather than geometric symbols, are selected. 
It&nbsp;is set with the <code>--symbol-font-name</code> option, and is relevant
only if <code>-S</code> is used to request such special marker symbols. 
Finally, the polygonal line joining the points in a dataset may be
<em>filled</em>, to create a filled or shaded polygon.  The `fill
fraction' is set with the <code>-q</code> option.  A&nbsp;negative fill
fraction means no fill, or transparent; zero means white, and 1.0 means
solid, or fully colored.

   <p>The preceding seven attributes refer to the way in which datasets are
plotted.  Datasets may also differ from one another in the way in which
they are read from files.  The dataset(s) in a file may or may not
contain error bars, for&nbsp;example.  If&nbsp;a file contains data with
error bars, the <code>-I e</code> option should occur on the command line
before the file name.  (The <code>-I</code> option specifies the input format
for the following files.)

   <p>The following illustrates how datasets in three different input files
could be plotted simultaneously.

<pre class="example">     graph -T ps -m 0 -S 3 file1 -C -m 3 file2 -C -W 0.02 file3 &gt; output.ps
     </pre>

<p>The dataset in <code>file1</code> will be plotted in linemode #0, so
successive points will not be joined by lines.  But symbol #3 (an
asterisk) will be plotted at each point.  The dataset in <code>file2</code>
will be plotted in color, and linemode #3 will be used.  In color
plotting, linemode #3 is interpreted as a solid blue line.  The second
<code>-C</code> on the command line turns off color for <code>file3</code>.  The
points in the third dataset will be joined by a black line with
thickness 0.02, as a fraction of the size (i.e., minimum dimension) of
the graphics display.

   <p>The above command line could be made even more complicated by specifying
additional options (e.g., <code>-q</code> or <code>-I</code>) before each file. 
In&nbsp;fact the command line could also include such standard options as
<code>-x</code> or <code>-y</code>, which specify the range of each axis.  Such
options, which refer to the plot as a whole rather than to individual
datasets, should appear before the first file name.  For&nbsp;example,
you could do

<pre class="example">     graph -T ps -x 0 1 0.5 -m 0 -S 3 file1 -C -m 3 file2 &gt; output.ps
     </pre>

<p>Note that it is possible to include the special file name&nbsp;<code>-</code>,
which refers to standard input, on the command line.  So you may pipe
the output of another program into <code>graph</code>.  You may even generate
a plot in&nbsp;part from piped output, and in&nbsp;part from files.

   <p>Each input file may include more than one dataset.  If so, the command
line options preceding a file on the command line will take effect for
all datasets in that file.  There are two exceptions to this.  By&nbsp;default, the linemode is incremented (`bumped') from one dataset to the
next.  This feature is usually quite convenient.  For&nbsp;example, if
you do

<pre class="example">     graph -T ps -m 3 file1 &gt; output.ps
     </pre>

<p>the first dataset in <code>file1</code> will appear in linemode #3, the second
in linemode #4, etc.  In&nbsp;fact, if you do

<pre class="example">     graph -T ps file1 file2 ... &gt; output.ps
     </pre>

<p>without specifying linemode explicitly, the successive datasets read
from the files on the command line will appear in linemode #1, linemode
#2, <small class="dots">...</small>.  If&nbsp;you do not like this feature, you may turn it
off, or in general toggle&nbsp;it, by using the <code>-B</code> option.

   <p>You may also control manually the linemode and symbol type used for the
datasets within any file.  You would do this by including directives in
the file itself, rather than on the command line.  For example, if the
line

<pre class="example">     #m=-5,S=10
     </pre>

<p>appeared in an ASCII-format input file, it would be interpreted as a
directive to switch to linemode #-5 and symbol type #10 for the
following dataset.  Future releases of <code>graph</code> may provide the
ability to set each of the seven dataset attributes in this way.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Multiplotting">Multiplotting</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Data%20Formats">Data Formats</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multiple%20Datasets">Multiple Datasets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph">graph</a>
<br>
</div>

<h3 class="section">2.4 Multiplotting: placing multiple plots on a single page</h3>

<p>It is occasionally useful to display several plots at once on a single
page, or on a single graphics display.  We call such a composite plot a
<em>multiplot</em>.  One common sort of multiplot is a small plot inset
into a larger one.  Another sort is two or more plots side by side.

   <p><code>graph</code> can draw multiplots consisting of an arbitrarily large
number of plots.  When multiplotting, <code>graph</code> draws each plot in
its own `virtual display'.  When an ordinary plot is drawn, the virtual
display is the same as the physical display.  But when a plot of a
multiplot is drawn, the virtual display may be any smaller square
region.  The following two-plot example illustrates the idea.

<pre class="example">     graph -T X datafile1 --reposition .35 .35 .3 datafile2
     </pre>

<p>Here <code>datafile1</code> is plotted in the usual way.  The
<code>--reposition</code> option, which serves as a separator between plots,
specifies that the second plot will be drawn in a virtual display.  For
the purposes of the <code>--reposition</code> option, the physical display is
a square with lower left corner (0.0,0.0) and upper right corner
(1.0,1.0).  In&nbsp;those coordinates the virtual display will be a
square of size 0.3, with lower left corner (0.35,0.35).  So&nbsp;the
second plot will be inset into the first.

   <p>Just as the <code>-w</code>, <code>-h</code>, <code>-r</code>, and <code>-u</code> options may
be used to set the size and position of a plotting box within the
physical display, so they may be used to set the size and position of a
plotting box within a virtual display.  For example,

<pre class="example">     graph -T X datafile1 --reposition .35 .35 .3 -w .4 -r .3 datafile2
     </pre>

<p>will yield a two-plot multiplot in which the second plot is
significantly different.  Its plotting box will have a width only 0.4
times the width of the virtual display.  However, the plotting box will
be centered within the virtual display, since the distance between the
left edge of the plotting box and the left edge of the virtual display
will be 0.3&nbsp;times the width of the virtual display.

   <p>By convention, before each plot of a multiplot other than the first is
drawn, a `blankout region' surrounding its plotting box is erased. 
(That&nbsp;is, it&nbsp;is filled with white, or whatever the background
color&nbsp;is.)  This erasure prevents the plots from overlapping and
producing a messy result.  By&nbsp;default, the blankout region is a
rectangular region 30% larger in each dimension than the plotting box
for the plot.  That is appropriate if the plot is a small one that is
inset into the first plot.  It&nbsp;may not be appropriate, however,
if&nbsp;you are preparing a multiplot in which several plots appear side
by side.  You may use the <code>--blankout</code> option to adjust this
parameter.  For&nbsp;example, specifying <code>--blankout 1.0</code> will make
the blankout region for a plot coincide with its plotting box. 
Specifying <code>--blankout 0.0</code> will prevent any blanking out from
occurring.  The blankout parameter may be set more than once, so&nbsp;as
to differ from plot to plot.

   <p>It should be emphasized that every plot in a multiplot is a plot in its
own right.  All the usual options (<code>-m</code>, <code>-S</code>, <code>-x</code>,
<code>-y</code>, etc.) can be applied to each plot separately.  The options
for a plot should occur on the <code>graph</code> command line immediately
after the <code>--reposition</code> option that applies to it.  Each plot may
be prepared from more than a single dataset, also.  The names of the
data files for each plot should occur on the command line before the
following <code>--reposition</code> option, if&nbsp;any.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Data%20Formats">Data Formats</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#graph%20Invocation">graph Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multiplotting">Multiplotting</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph">graph</a>
<br>
</div>

<h3 class="section">2.5 Reading binary and other data formats</h3>

<p>By default, <code>graph</code> reads datasets in ASCII format.  But it can
also read datasets in any of three binary formats (single precision
floating point, double precision floating point, and integer). 
These three input formats are specified by the <code>-I d</code>, <code>-I f</code>,
and <code>-I i</code> options, respectively.

   <p>There are two advantages to using binary data: 1)&nbsp;<code>graph</code> runs
significantly faster because the computational overhead for converting
data from ASCII to binary is eliminated, and 2)&nbsp;the input files may
be significantly smaller.  If&nbsp;you have very large datasets, using
binary format may reduce storage and runtime costs.

   <p>For example, you may create a single precision binary dataset as output
from a C language program:

<pre class="example">     #include &lt;stdio.h&gt;
     void write_point (float x, float y)
     {
       fwrite(&amp;x, sizeof (float), 1, stdout);
       fwrite(&amp;y, sizeof (float), 1, stdout);
     }
     </pre>

<p>You may plot data written this way by doing:

<pre class="example">     graph -T ps -I f &lt; binary_datafile &gt; plot.ps
     </pre>

<p>The inclusion of multiple datasets within a single binary file is
supported.  If a binary file contains more than a single dataset,
successive datasets should be separated by a single occurrence of the
the largest possible number.  For single precision datasets this is the
quantity <code>FLT_MAX</code>, for double precision datasets it is the
quantity <code>DBL_MAX</code>, and for integer datasets it is the quantity
<code>INT_MAX</code>.  On&nbsp;most machines <code>FLT_MAX</code> is approximately
3.4x10^38, <code>DBL_MAX</code> is approximately 1.8x10^308, and
<code>INT_MAX</code> is 2^32-1.

   <p>If you are reading datasets from more than one file, it is not required
that the files be in the same format.  For example,

<pre class="example">     graph -T ps -I f binary_datafile -I a ascii_datafile &gt; plot.ps
     </pre>

<p>will read <code>binary_datafile</code> in <code>f</code> (binary single precision)
format, and <code>datafile</code> in <code>a</code> (normal ASCII) format.

   <p>There is currently no support for reading and plotting binary data with
error bars.  If you have data with error bars, you should supply the data
to <code>graph</code> in ASCII, and use the <code>-I e</code> option.

   <p><code>graph</code> can also read data files in the ASCII `table' format
produced by the <code>gnuplot</code> plotting program.  For this, you should
use the <code>-I g</code> option.  Such a data file may consist of more than
one dataset.

   <p>To sum up: there are six supported data formats, <code>a</code> (normal
ASCII), <code>e</code> (ASCII with error bars), <code>g</code> (the ASCII `table'
format produced by <code>gnuplot</code>), <code>f</code> (binary single precision),
<code>d</code> (binary double precision), and <code>i</code> (binary integer). 
Input files may be in any of these six formats.

<div class="node">
<p><hr>
Node:&nbsp;<a name="graph%20Invocation">graph Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data%20Formats">Data Formats</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph">graph</a>
<br>
</div>

<h3 class="section">2.6 <code>graph</code> command-line options</h3>

<p>The <code>graph</code> program reads one or more datasets from files named on
the command line or from standard input, and prepares a plot.  The
output format or display type is specified with the <code>-T</code> option.

   <p>By default, <code>graph</code> reads ASCII data from the files specified on
the command line.  The data are pairs of numbers, interpreted as the
x and&nbsp;y coordinates of data points.  If no files are
specified, or the file name&nbsp;<code>-</code> is specified, the standard
input is read.  An output file is written to standard output, unless the
<code>-T X</code> option is specified.  In&nbsp;that case the graph is
displayed in a popped-up window on an X&nbsp;Window System display, and
there is no output file.

   <p>There are many command-line options for adjusting the visual appearance
of the plot.  The relative order of file names and command-line options
is important.  Only the options that precede a file name on the command
line take effect for that file.

   <p>The following sections list the possible options.  Each option that
takes an argument is followed, in parentheses, by the type and default
value of the argument.  There are five sorts of option.

   <p>The behavior of <code>graph</code> is also affected by a number of environment
variables, so there is a section discussing them as well.

<ul class="menu">
<li><a accesskey="1" href="#Plot%20Options">Plot Options</a>:         Options affecting an entire plot
<li><a accesskey="2" href="#Dataset%20Options">Dataset Options</a>:      Options affecting the reading and plotting of datasets
<li><a accesskey="3" href="#Multiplot%20Options">Multiplot Options</a>:    Options for drawing several plots at once
<li><a accesskey="4" href="#Raw%20graph%20Options">Raw graph Options</a>:    Options relevant only to raw graph
<li><a accesskey="5" href="#Info%20Options">Info Options</a>:         Options requesting information (e.g., ---help)
<li><a accesskey="6" href="#graph%20Environment">graph Environment</a>:    Environment variables
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Plot%20Options">Plot Options</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Dataset%20Options">Dataset Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#graph%20Invocation">graph Invocation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph%20Invocation">graph Invocation</a>
<br>
</div>

<h3 class="subsection">2.6.1 Plot options</h4>

<p>The following options affect an entire plot.  They should normally occur
at most once, and should appear on the command line before the first
file name.  If&nbsp;a multiplot is being drawn, they may (with the
exception of the <code>-T</code> option) occur more than once.  If&nbsp;so, the
second and later occurrences should be placed on the command line
immediately after each <code>--reposition </code><var>x</var><code> </code><var>y</var><code></code> option, which
separates the plots in a multiplot.

     <dl>
<dt><code>-T </code><var>type</var><code></code>
     <dd><dt><code>--display-type </code><var>type</var><code></code>
     <dd>(String, default "meta".)  Select a display type or output format of
type <var>type</var>, which may be one of the strings "X", "png", "pnm",
"gif", "svg", "ai", "ps", "cgm", "fig", "pcl", "hpgl", "regis", "tek",
and "meta".  These refer respectively to the X&nbsp;Window&nbsp;System, PNG
format, portable anymap (PBM/PGM/PPM) format, pseudo-GIF format, the new
XML-based Scalable Vector Graphics format, the format used by Adobe
Illustrator, <code>idraw</code>-editable Postscript, the WebCGM format for
Web-based vector graphics, the format used by the <code>xfig</code> drawing
editor, the Hewlett-Packard PCL&nbsp;5 printer language, the
Hewlett-Packard Graphics Language (by&nbsp;default, HP-GL/2), the ReGIS
(remote graphics instruction set) format developed by&nbsp;DEC, Tektronix
format, and device-independent GNU graphics metafile format.

     <br><dt><code>-E </code><var>x|y</var><code></code>
     <dd><dt><code>--toggle-axis-end </code><var>x|y</var><code></code>
     <dd>Set the position of the indicated axis to be on the other end of the
plotting box from what is currently the case.  E.g., <code>-E y</code> will
cause the y axis to appear on the right of the plot rather than
the left, which is the default.  Similarly, <code>-E x</code> will cause the
x&nbsp;axis to appear at the top of the plot rather than the
bottom.  Note that if the x&nbsp;axis appears at the top, no&nbsp;plot title will be drawn, since there will be no room.

     <br><dt><code>-f </code><var>size</var><code></code>
     <dd><dt><code>--font-size </code><var>size</var><code></code>
     <dd>(Float, default 0.0525.)  Set the size of the font used for the axis and
tick labels to be <var>size</var>.  The size is specified as a fraction of
the minimum dimension (width or height) of the plotting box.

     <br><dt><code>-F </code><var>font_name</var><code></code>
     <dd><dt><code>--font-name </code><var>font_name</var><code></code>
     <dd>(String, default "Helvetica" except for <code>graph -T pcl</code>, for which
"Univers" is the default, and <code>graph -T png</code>, <code>graph -T pnm</code>,
<code>graph -T gif</code>, <code>graph -T hpgl</code>, <code>graph -T regis</code>,
<code>graph -T tek</code>, and raw <code>graph</code>, for all of which
"HersheySerif" is the default.)  Set the font used for the axis and tick
labels, and for the plot title (if&nbsp;any), to be <var>font_name</var>.  The
choice of font for the plot title may be overridden with the
<code>--title-font-name</code> option (see below).  Font names are
case-insensitive.  If&nbsp;the specified font is not available, the
default font will be used.  Which fonts are available depends on which
<code>-T</code> option is used.  For a list of all fonts, see <a href="#Text%20Fonts">Text Fonts</a>.  The <code>plotfont</code> utility will produce a character map of any
available font.  See <a href="#plotfont">plotfont</a>.

     <br><dt><code>-g </code><var>grid_style</var><code></code>
     <dd><dt><code>--grid-style </code><var>grid_style</var><code></code>
     <dd>(Integer in the range 0<small class="dots">...</small>4, default 2.)  Set the grid style for the
plot to be <var>grid_style</var>.  Grid styles 0 through&nbsp;3 are
progressively more fancy, but style&nbsp;4 is a somewhat different style.

          <ol type=1 start=0>
<li>no axes, tick marks or labels. 
<li>a pair of axes, with tick marks and labels. 
<li>box around plot, with tick marks and labels. 
<li>box around plot, with tick marks and labels; also grid lines. 
<li>axes intersect at the origin, with tick marks and labels.
          </ol>

     <br><dt><code>-h </code><var>height</var><code></code>
     <dd><dt><code>--height-of-plot </code><var>height</var><code></code>
     <dd>(Float, default 0.6.)  Set the fractional height of the plot with
respect to the height of the display (or virtual display, in the case of
a multiplot) to be <var>height</var>.  A&nbsp;value of 1.0 will produce a
plotting box that fills the entire available area.  Since labels and
tick marks may be placed outside the plotting box, values considerably
less than 1.0 are normally chosen.

     <br><dt><code>-H</code>
     <dd><dt><code>--toggle-frame-on-top</code>
     <dd>Toggle whether or not a copy of the plot frame should be drawn on top of
the plot, as&nbsp;well as beneath&nbsp;it.  This option is useful when the
plotted dataset(s) project slightly beyond the frame, which can happen
if a large line thickness or symbol size is specified.

     <br><dt><code>-k </code><var>length</var><code></code>
     <dd><dt><code>--tick-size </code><var>length</var><code></code>
     <dd>(Float, default .02.)  Set the length of the tick marks on each axis to
be <var>length</var>.  A&nbsp;value of 1.0 produces tick marks whose length is
equal to the minimum dimension (width or height) of the plotting box. 
A&nbsp;negative <var>length</var> yields tick marks that extend outside the
box, rather than inside.

     <br><dt><code>-K </code><var>clip_mode</var><code></code>
     <dd><dt><code>--clip-mode </code><var>clip_mode</var><code></code>
     <dd>(Integer, default 1.)  Set the clip mode for the plot to
<var>clip_mode</var>.  The clip mode is relevant only if data points are
being joined by a line, and the line is not being filled to create a
filled region (since filled regions are clipped in a fixed way).

     <p>There are three clip modes: 0, 1, and&nbsp;2.  They have the same meaning
as in the <code>gnuplot</code> plotting program.  Clip mode&nbsp;0 means that a
line segment joining two data points will be plotted only if neither
point is outside the plotting box.  Clip mode&nbsp;1 means that it will
be plotted if no more than one of the two points is outside, and clip
mode&nbsp;2 means that it will be plotted even if both are outside. 
In&nbsp;all three clip modes the line segment will be clipped to the
plotting box.

     <br><dt><code>-l </code><var>x|y</var><code></code>
     <dd><dt><code>--toggle-log-axis </code><var>x|y</var><code></code>
     <dd>Set the specified axis to be a log axis rather than a linear axis, or
vice versa.  By default, both axes are linear axes.

     <br><dt><code>-L </code><var>top_label</var><code></code>
     <dd><dt><code>--top-label </code><var>top_label</var><code></code>
     <dd>(String, default empty.)  Place the text string <var>top_label</var> above
the plot, as its `top label', i.e., title.  The string may include
escape sequences (see <a href="#Text%20String%20Format">Text String Format</a>).  The
<code>--title-font-size</code> option may be used to specify the size of the
font.  The font is normally the same as the font used for labeling axes
and ticks, as selected by the <code>-F</code> option.  But this can be
overridden with the <code>--title-font-name</code> option.

     <br><dt><code>-N </code><var>x|y</var><code></code>
     <dd><dt><code>--toggle-no-ticks </code><var>x|y</var><code></code>
     <dd>Toggle the presence of ticks and tick labels on the specified axis. 
This applies to the grid styles that normally include ticks and tick
labels, i.e., grid styles 1, 2, 3, and&nbsp;4.

     <br><dt><code>-r </code><var>right</var><code></code>
     <dd><dt><code>--right-shift </code><var>right</var><code></code>
     <dd>(Float, default 0.2.)  Move the plot to the right by a fractional amount
<var>right</var> with respect to the width of the display (or virtual
display, in the case of a multiplot).  This produces a margin on the
left side of the plotting box.  A&nbsp;value of 0.5 will produce a margin
half the width of the available area.  Note that the tick marks and
labels are drawn in the margin.

     <br><dt><code>-R </code><var>x|y</var><code></code>
     <dd><dt><code>--toggle-round-to-next-tick </code><var>x|y</var><code></code>
     <dd>Toggle whether or not the upper and lower limits of the specified axis
should be expanded, so that they both become integer multiples of the
spacing between labeled tick marks.

     <p>This option is meaningful whenever the user specifies either or both of
the limits, by using the <code>-x</code> or <code>-y</code> option.  If&nbsp;the user
leaves both limits unspecified, they will always be chosen to satisfy
the `integer multiple' constraint.

     <br><dt><code>-s</code>
     <dd><dt><code>--save-screen</code>
     <dd>Save the screen.  This option requests that <code>graph</code> not erase the
output device before it begins to plot.

     <p>This option is relevant only to <code>graph -T tek</code> and raw
<code>graph</code>.  Tektronix displays and emulators are persistent, in the
sense that previously drawn graphics remain visible.  So by repeatedly
using <code>graph -T tek -s</code>, you can build&nbsp;up a multiplot.

     <br><dt><code>-t</code>
     <dd><dt><code>--toggle-transpose-axes</code>
     <dd>Transpose the abscissa and ordinate.  This causes the axes to be
interchanged, and the options that apply to each axis to be applied to
the opposite axis.  That is, data points are read in as (y, x)
pairs, and such options as <code>-x</code> and <code>-X</code> apply to the
y&nbsp;axis rather than the x&nbsp;axis.  If&nbsp;the
<code>-I e</code> option is in force, so that the data points are read with
error bars, the orientation of the error bars will be switched between
vertical and horizontal.

     <br><dt><code>-u </code><var>up</var><code></code>
     <dd><dt><code>--upward-shift </code><var>up</var><code></code>
     <dd>(Float, default 0.2.)  Move the plot up by a fractional amount <var>up</var>
with respect to the height of the display (or virtual display, in the
case of a multiplot).  This produces a margin below the plotting box. 
A&nbsp;value of 0.5 will produce a margin half the height of the
available area.  Note that the tick marks and labels are drawn in the
margin.

     <br><dt><code>-w </code><var>width</var><code></code>
     <dd><dt><code>--width-of-plot </code><var>width</var><code></code>
     <dd>(Float, default 0.6.)  Set the fractional width of the plot with respect
to the width of the display (or virtual display, in the case of a
multiplot) to be <var>width</var>.  A&nbsp;value of 1.0 will produce a
plotting box that fills the entire available area.  Since labels and
tick marks may be placed outside the plotting box, values considerably
less than 1.0 are normally chosen.

     <br><dt><code>-x [</code><var>lower_limit</var><code> [</code><var>upper_limit</var><code> [</code><var>spacing</var><code>]]]</code>
     <dd><dt><code>--x-limits [</code><var>lower_limit</var><code> [</code><var>upper_limit</var><code> [</code><var>spacing</var><code>]]]</code>
     <dd>(Floats.) The arguments <var>lower_limit</var> and <var>upper_limit</var> specify
the limits of the x&nbsp;axis, and the optional argument
<var>spacing</var> specifies the spacing of labeled ticks along the axis. 
If&nbsp;any of the three arguments is missing or is supplied as&nbsp;<code>-</code> (i.e., as a single hyphen), it&nbsp;is computed from the data. 
Both arguments <var>lower_limit</var> and <var>upper_limit</var> must be present
if <code>graph</code> is to act as a real-time filter.

     <p>By default, the supplied limit(s) are strictly respected.  However, the
<code>-R x</code> option may be used to request that they be rounded to the
nearest integer multiple of the spacing between labeled ticks.  The
lower limit will be rounded downward, and the upper limit upward.

     <br><dt><code>-X </code><var>x_label</var><code></code>
     <dd><dt><code>--x-label </code><var>x_label</var><code></code>
     <dd>(String, default empty.)  Set the label for the x axis to be the text
string <var>x_label</var>.  The string may include escape sequences
(see <a href="#Text%20String%20Format">Text String Format</a>).  The <code>-F</code> and <code>-f</code> options may
be used to specify the name of the font and the size of the font.

     <br><dt><code>-y [</code><var>lower_limit</var><code> [</code><var>upper_limit</var><code> [</code><var>spacing</var><code>]]]</code>
     <dd><dt><code>--y-limits [</code><var>lower_limit</var><code> [</code><var>upper_limit</var><code> [</code><var>spacing</var><code>]]]</code>
     <dd>(Floats.)  The arguments specify the limits of the y axis, and
the spacing of labeled ticks along it, as for the x&nbsp;axis (see
above).  Both arguments <var>lower_limit</var> and <var>upper_limit</var> must be
present if <code>graph</code> is to act as a real-time filter.

     <p>By default, the supplied limit(s) are strictly respected.  However, the
<code>-R y</code> option may be used to request that they be rounded to the
nearest multiple of the tick spacing.  The lower limit will be rounded
downward, and the upper limit upward.

     <br><dt><code>-Y </code><var>y_label</var><code></code>
     <dd><dt><code>--y-label </code><var>y_label</var><code></code>
     <dd>(String, default empty.)  Set the label for the y axis to be the
text string <var>y_label</var>.  The string may include escape sequences
(see <a href="#Text%20String%20Format">Text String Format</a>).  The label will be rotated by 90 degrees
so that it is parallel to the axis, unless the
<code>--toggle-rotate-y-label</code> option is used.  Some old X&nbsp;Window
System displays do not support rotated labels, and require the
<code>--toggle-rotate-y-label</code> option.  The <code>-F</code> and <code>-f</code>
options can be used to specify the name of the font and the size of the
font.

     <br><dt><code>--bg-color </code><var>name</var><code></code>
     <dd>(String, default "white".)  Set the color used for the plot background
to be <var>name</var>.  This is relevant only to <code>graph -T&nbsp;X</code>,
<code>graph -T png</code>, <code>graph -T pnm</code>, <code>graph -T gif</code>,
<code>graph -T cgm</code>, <code>graph -T regis</code>, and <code>graph -T meta</code>. 
An&nbsp;unrecognized name sets the color to the default.  For information
on what names are recognized, see <a href="#Color%20Names">Color Names</a>.  The environment
variable <code>BG_COLOR</code> can equally well be used to specify the
background color.

     <p>If the <code>-T png</code> or <code>-T gif</code> option is used, a transparent PNG
file or a transparent pseudo-GIF, respectively, may be produced by
setting the <code>TRANSPARENT_COLOR</code> environment variable to the name of
the background color.  See <a href="#graph%20Environment">graph Environment</a>.  If&nbsp;the <code>-T
svg</code> or <code>-T cgm</code> option is used, an output file without a
background may be produced by setting the background color to "none".

     <br><dt><code>--bitmap-size </code><var>bitmap_size</var><code></code>
     <dd>(String, default "570x570".)  Set the size of the graphics display in
which the plot will be drawn, in terms of pixels, to be
<var>bitmap_size</var>.  This is relevant only to <code>graph -T&nbsp;X</code>,
<code>graph -T png</code>, <code>graph -T pnm</code>, and <code>graph -T gif</code>, for
all of which the size can be expressed in terms of pixels.  The
environment variable <code>BITMAPSIZE</code> may equally well be used to
specify the size.

     <p>The graphics display used by <code>graph -T X</code> is a popped-up X&nbsp;window.  Command-line positioning of this window on an X&nbsp;Window
System display is supported.  For example, if <var>bitmap_size</var> is
"570x570+0+0" then the window will be popped&nbsp;up in the upper left
corner.

     <p>If you choose a rectangular (non-square) window size, the fonts in the
plot will be scaled anisotropically, i.e., by different factors in the
horizontal and vertical direction.  For this, <code>graph -T&nbsp;X</code>
requires an X11R6 display.  Any font that cannot be anisotropically
scaled will be replaced by a default scalable font, such as the Hershey
vector font "HersheySerif".

     <p>For backward compatibility, <code>graph -T X</code> allows the user to set the
window size and position by setting the X&nbsp;resource
<code>Xplot.geometry</code>, instead of <code>--bitmap-size</code> or
<code>BITMAPSIZE</code>.

     <br><dt><code>--emulate-color </code><var>option</var><code></code>
     <dd>(String, default "no".)  If <var>option</var> is "yes", replace each color in
the output by an appropriate shade of gray.  This is seldom useful,
except when using <code>graph -T pcl</code> to prepare output for a PCL&nbsp;5
device.  (Many monochrome PCL&nbsp;5 devices, such as monochrome
LaserJets, do a poor job of emulating color on their own.  They usually
map HP-GL/2's seven standard pen colors, including even yellow, to
black.)  You may equally well request color emulation by setting the
environment variable <code>EMULATE_COLOR</code> to "yes".

     <br><dt><code>--frame-color </code><var>name</var><code></code>
     <dd>(String, default "black".)  Set the color used for drawing the plot
frame, and for drawing monochrome datasets (if&nbsp;any) to be
<var>name</var>.  An&nbsp;unrecognized name sets the color to the default. 
For information on what names are recognized, see <a href="#Color%20Names">Color Names</a>.

     <br><dt><code>--frame-line-width </code><var>frame_line_width</var><code></code>
     <dd>(Float, default -1.0.)  Set the thickness of lines in the plot
frame, as a fraction of the size (i.e., minimum dimension) of the
graphics display, to <var>frame_line_width</var>.  A&nbsp;negative value means
that the default value for the line thickness provided by the GNU
<code>libplot</code> graphics library should be used.  This is usually 1/850
times the size of the display, although if <code>-T X</code>, <code>-T png</code>,
<code>-T pnm</code>, or <code>-T gif</code> is specified, it is zero.  By
convention, a zero-thickness line is the thinnest line that can be
drawn.  This is the case in all output formats.  Note, however, that the
drawing editors <code>idraw</code> and <code>xfig</code> treat zero-thickness lines
as invisible.

     <p><code>graph -T tek</code> and <code>graph -T regis</code> do not support drawing
lines with other than a default thickness, and <code>graph -T hpgl</code> does
not support doing&nbsp;so if the environment variable <code>HPGL_VERSION</code>
is set to a value less than&nbsp;"2" (the default).

     <br><dt><code>--max-line-length </code><var>max_line_length</var><code></code>
     <dd>(Integer, default 500.)  Set the maximum number of points that a
polygonal line drawn through any dataset may contain, before it is
flushed to the output device, to equal <var>max_line_length</var>.  If&nbsp;this flushing occurs, the polygonal line will be split into two or more
sub-lines, though the splitting should not be noticeable.  Splitting
will not take place if the <code>-q</code> option, which requests filling, is
used.

     <p>The reason for splitting long polygonal lines is that some display
devices (e.g., old Postscript printers and HP-GL pen plotters) have
limited buffer sizes.  The environment variable <code>MAX_LINE_LENGTH</code>
can also be used to specify the maximum line length.  This option has no
effect on <code>graph -T tek</code> or raw <code>graph</code>, since they draw
polylines in real time and have no buffer limitations.

     <br><dt><code>--page-size </code><var>pagesize</var><code></code>
     <dd>(String, default "letter".)  Set the size of the page on which the plot
will be positioned.  This is relevant only to <code>graph -T svg</code>,
<code>graph -T ai</code>, <code>graph -T ps</code>, <code>graph -T cgm</code>, <code>graph
-T fig</code>, <code>graph -T pcl</code>, and <code>graph -T hpgl</code>.  "letter" means
an 8.5in by 11in page.  Any ISO page size in the range
"a0"<small class="dots">...</small>"a4" or ANSI page size in the range "a"<small class="dots">...</small>"e" may be
specified ("letter" is an alias for&nbsp;"a" and "tabloid" is an alias
for&nbsp;"b").  "legal", "ledger", and&nbsp;"b5" are recognized page sizes
also.  The environment variable <code>PAGESIZE</code> can equally well be used
to specify the page size.

     <p>For <code>graph -T ai</code>, <code>graph -T ps</code>, <code>graph -T pcl</code>, and
<code>graph -T fig</code>, the graphics display (or `viewport') within which
the plot is drawn will be, by default, a square region centered on the
specified page.  For <code>graph -T hpgl</code>, it will be a square region of
the same size, but may be positioned differently.  Either or both of the
dimensions of the graphics display can be specified explicitly.  For
example, <var>pagesize</var> could be specified as "letter,xsize=4in", or
"a4,xsize=10cm,ysize=15cm".  The dimensions are allowed to be negative
(a&nbsp;negative dimension results in a reflection).

     <p>The position of the graphics display, relative to its default position,
may optionally be adjusted by specifying an offset vector.  For example,
<var>pagesize</var> could be specified as "letter,yoffset=1.2in", or
"a4,xoffset=-5mm,yoffset=2.0cm".  It&nbsp;is also possible to
position the graphics display precisely, by specifying the location of
its lower left corner relative to the lower left corner of the page. 
For example, <var>pagesize</var> could be specified as
"letter,xorigin=2in,yorigin=3in", or "a4,xorigin=0.5cm,yorigin=0.5cm". 
The preceding options may be intermingled.  <code>graph -T svg</code> and
<code>graph -T cgm</code> ignore the "xoffset", "yoffset", "xorigin", and
"yorigin" options, since SVG format and WebCGM format have no notion of
the Web page on which the graphics display will ultimately be
positioned.  For more on page sizes, see <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

     <br><dt><code>--pen-colors </code><var>colors</var><code></code>
     <dd>(String, default "1=red:2=green:3=blue:4=magenta:5=cyan".)  Set the
colors of the pens used for drawing plots, as numbered, to be
<var>colors</var>.  The format should be self-explanatory.  An&nbsp;unrecognized name sets the corresponding color to the default.  For
information on what names are recognized, see <a href="#Color%20Names">Color Names</a>.

     <br><dt><code>--rotation </code><var>angle</var><code></code>
     <dd>(Integer, default 0.)  Set the rotation angle of the graphics display to
be <var>angle</var> degrees.  Recognized values are 0,&nbsp;90, 180, and&nbsp;270.  The rotation is counterclockwise.  The environment variable
<code>ROTATION</code> can equally well be used to specify the rotation angle.

     <p>This option is used for switching between portrait and landscape
orientations.  Postmodernists may also find it useful.

     <br><dt><code>--title-font-name </code><var>font_name</var><code></code>
     <dd>(String, default "Helvetica" except for <code>graph -T pcl</code>, for which
"Univers" is the default, and <code>graph -T png</code>, <code>graph -T pnm</code>,
<code>graph -T gif</code>, <code>graph -T hpgl</code>, <code>graph -T regis</code>, and
<code>graph -T tek</code>, for all of which "HersheySerif" is the default.) 
Set the font used for the plot title to be <var>font_name</var>.  Normally
the font used for the plot title is the same as that used for labeling
the axes and the ticks along the axes, as specified by the <code>-F</code>
option.  But the <code>--title-font-name</code> option can be used to override
this.  Font names are case-insensitive.  If&nbsp;the specified font is
not available, the default font will be used.  Which fonts are available
depends on which <code>-T</code> option is used.  For a list of all fonts, see
<a href="#Text%20Fonts">Text Fonts</a>.  The <code>plotfont</code> utility will produce a character
map of any available font.  See <a href="#plotfont">plotfont</a>.

     <br><dt><code>--title-font-size </code><var>size</var><code></code>
     <dd>(Float, default 0.07.)  Set the size of the font used for the top label
(`title'), as specified by the <code>-L</code> option, to be <var>size</var>.  The
size is specified as a fraction of the minimum dimension (width or
height) of the plotting box.

     <br><dt><code>--toggle-rotate-y-label</code>
     <dd>Position the label on the y axis (which is set with the <code>-Y</code>
option) horizontally instead of vertically, or vice versa.  By default,
the label is rotated, so that it is parallel to the y&nbsp;axis. 
But some output devices (e.g., old X&nbsp;Window System displays) cannot
handle rotated fonts. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Dataset%20Options">Dataset Options</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Multiplot%20Options">Multiplot Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Plot%20Options">Plot Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph%20Invocation">graph Invocation</a>
<br>
</div>

<h3 class="subsection">2.6.2 Dataset options</h4>

<p>The following options affect the way in which individual datasets are
read from files, and drawn as part of a plot.  They should appear on the
command line before the file containing the datasets whose reading or
rendering they will affect.  They may appear more than once on a command
line, if more than one file is to be read.

   <p>The following three options affect the way in which datasets are read
from files.

     <dl>
<dt><code>-I </code><var>data-format</var><code></code>
     <dd><dt><code>--input-format </code><var>data-format</var><code></code>
     <dd>This specifies which format the subsequent input file(s) are in.

          <dl>
<dt><code>a</code>
          <dd>ASCII format.  Each input file is a sequence of floating point numbers,
interpreted as the x and&nbsp;y coordinates of the
successive data points in a dataset.  The x and&nbsp;y
coordinates of a point need not appear on the same line, and points need
not appear on different lines.  But if a blank line occurs (i.e., two
newlines in succession are seen), it&nbsp;is interpreted as the end of a
dataset, and the beginning of the next.

          <br><dt><code>e</code>
          <dd>ASCII format, including error bars.  Similar to <code>a</code> format, except
that triples (x,y,<i>error</i>) appear instead of pairs
(x,y).

          <br><dt><code>g</code>
          <dd>The ASCII `table' format produced by the <code>gnuplot</code> plotting program.

          <br><dt><code>f</code>
          <dd>Single precision binary format.  Each input file is a sequence of single
precision floating point numbers, interpreted as forming pairs
(x,y).  Successive datasets are separated by a single
occurrence of the quantity <code>FLT_MAX</code>, which is the largest possible
single precision floating point number.  On&nbsp;most machines this is
approximately 3.4x10^38.

          <br><dt><code>d</code>
          <dd>Double precision binary format.  Each input file is a sequence of double
precision floating point numbers, interpreted as forming pairs
(x,y).  Successive datasets are separated by a single
occurrence of the quantity <code>DBL_MAX</code>, which is the largest possible
double precision floating point number.  On&nbsp;most machines this is
approximately 1.8x10^308.

          <br><dt><code>i</code>
          <dd>Integer binary format.  Each input file is a sequence of integers,
interpreted as forming pairs (x,y).  Successive datasets
are separated by a single occurrence of the quantity <code>INT_MAX</code>,
which is the largest possible integer.  On&nbsp;most machines this is
2^31-1. 
</dl>

     <br><dt><code>-a [</code><var>step_size</var><code> [</code><var>lower_limit</var><code>]]</code>
     <dd><dt><code>--auto-abscissa [</code><var>step_size</var><code> [</code><var>lower_limit</var><code>]]</code>
     <dd>(Floats, defaults 1.0 and 0.0.) Automatically generate abscissa
(x) values.  Irrespective of data format (<code>a</code>, <code>e</code>,
<code>f</code>, <code>d</code>, or&nbsp;<code>i</code>), this option specifies that the
abscissa (x) values are missing from the input file: the
dataset(s) to be read contain only ordinate (y) values.  The
increment from each x&nbsp;value to the next will be
<var>step_size</var>, and the first x&nbsp;value will be
<var>lower_limit</var>.  To&nbsp;return to reading abscissa values from the
input, i.e., for subsequent input files, you would use <code>-a 0</code>,
which disables automatic generation of the abscissa values and returns
<var>step_size</var> and <var>lower_limit</var> to their default values.

     <br><dt><code>-B</code>
     <dd><dt><code>--toggle-auto-bump</code>
     <dd>By default, the linemode (set with <code>-m</code>, see below) is `bumped'
(incremented by unity) at the beginning of each new dataset.  This
option toggles auto-bumping: it&nbsp;turns it off if it was on, and on if
it was off. 
</dl>

   <p>The following options affect the way in which individual datasets are
drawn as part of a plot.  These options set the six `attributes' (symbol
type, symbol font, linemode, line thickness, fill fraction, and
color/monochrome) that each dataset has.

     <dl>
<dt><code>-m </code><var>line_mode</var><code></code>
     <dd><dt><code>--line-mode </code><var>line_mode</var><code></code>
     <dd>(Integer, default 1.)  <var>line_mode</var> specifies the mode (i.e., style)
of the lines drawn between successive points in a dataset.  By
convention, linemode #0 means no line at&nbsp;all (data points are
disconnected).  If&nbsp;the dataset is being rendered in monochrome, the
interpretation of <var>line_mode</var> is as follows.

          <ol type=1 start=1>
<li>solid
<li>dotted
<li>dotdashed
<li>shortdashed
<li>longdashed
          </ol>

     <p>Thereafter (i.e., for <var>line_mode</var> greater than 5) the sequence of
five linemodes repeats.  So besides linemode #0, there are a total of
five distinct monochrome linemodes.  If&nbsp;the dataset is being
rendered in color (as may be requested with the <code>-C</code> option), the
interpretation of linemodes #1 through #5 is instead

          <ol type=1 start=1>
<li>red, solid
<li>green, solid
<li>blue, solid
<li>magenta, solid
<li>cyan, solid
          </ol>

     <p>Linemodes #6 through #10 use the same five colors, but are dotted;
linemodes #11 through #15 are dotdashed; linemodes #16 through #20 are
shortdashed; and linemodes #21 through #25 are longdashed.  So besides
linemode #0, there are a total of 25 distinct colored linemodes.  A&nbsp;negative linemode indicates that no line should be drawn, but that the
marker symbol, if&nbsp;any (see below), should be in the color of the
corresponding positive linemode.

     <br><dt><code>-S [</code><var>symbol_number</var><code> [</code><var>symbol_size</var><code>]]</code>
     <dd><dt><code>--symbol [</code><var>symbol_number</var><code> [</code><var>symbol_size</var><code>]]</code>
     <dd>(Integer and float, defaults 0 and 0.03.)  Draw a marker symbol at each
data point.  <var>symbol_number</var> specifies the symbol type, and
<var>symbol_size</var> specifies the font size of the symbol, as a fraction
of the minimum dimension (width or height) of the plotting box.  If&nbsp;the dataset is being rendered in color, the symbol will have the color
of the line that is being drawn to connect the data points.

     <p>If you use the <code>-S</code> option, you would usually also use the
<code>-m</code> option, to request that the symbols be drawn without any line
connecting them.  By specifying a negative argument to&nbsp;<code>-m</code>
(a&nbsp;`negative linemode'), you may obtain colored symbols.

     <p>The following table lists the first few symbols (by convention,
symbol&nbsp;#0 means no&nbsp;symbol at&nbsp;all).

          <ol type=1 start=1>
<li>dot
<li>plus (+)
<li>asterisk (*)
<li>circle
<li>cross
          </ol>

     <p>Marker symbols 0<small class="dots">...</small>31 are furnished by the GNU <code>libplot</code>
graphics library.  See <a href="#Marker%20Symbols">Marker Symbols</a>.  Symbol numbers greater than
or equal to&nbsp;32 are interpreted as characters in a symbol font, which
can be set with the <code>--symbol-font-name</code> option (see below).

     <br><dt><code>-W </code><var>line_width</var><code></code>
     <dd><dt><code>--line-width </code><var>line_width</var><code></code>
     <dd>(Float, default -1.0.)  Set the thickness of the lines used to
join successive points in a dataset, as a fraction of the size (i.e.,
minimum dimension) of the graphics display, to <var>line_width</var>.  A&nbsp;negative value means that the default value for the line thickness
provided by the GNU <code>libplot</code> graphics library should be used. 
This is usually 1/850 times the size of the display, although if
<code>-T X</code>, <code>-T png</code>, <code>-T pnm</code>, or <code>-T gif</code> is
specified, it is zero.  By convention, a zero-thickness line is the
thinnest line that can be drawn.  This is the case in all output
formats.  Note, however, that the drawing editors <code>idraw</code> and
<code>xfig</code> treat zero-thickness lines as invisible.

     <p><code>graph -T tek</code> and <code>graph -T regis</code> do not support drawing
lines with other than a default thickness, and <code>graph -T hpgl</code> does
not support doing&nbsp;so if the environment variable <code>HPGL_VERSION</code>
is set to a value less than&nbsp;"2" (the default).

     <br><dt><code>-q </code><var>fill_fraction</var><code></code>
     <dd><dt><code>--fill-fraction </code><var>fill_fraction</var><code></code>
     <dd>(Float, default -1.0.)  If successive points in a dataset are
joined by line segments, set the shading intensity for the polygon
formed by the line segments to be <var>fill_fraction</var>.  A&nbsp;solid
polygon (i.e., one filled with the `pen color' used for drawing the line
segments) is obtained by choosing <var>fill_fraction</var>=1.0.  The interior
of the polygon will be white if <var>fill_fraction</var>=0.0.  The polygon
will be unfilled (transparent) if <var>fill_fraction</var> is negative.

     <p>If&nbsp;the polygon intersects itself, the `even-odd fill rule' will
normally be used to determine which points are inside rather than
outside, i.e., to determine which portions of the polygon should be
shaded.  The even-odd fill rule is explained in the <cite>Postscript
Language Reference Manual</cite>.

     <p>The <code>-q</code> option has no effect on <code>graph -T tek</code>, and it is
only partly effective in <code>graph -T hpgl</code> if the environment
variable <code>HPGL_VERSION</code> is set to a value less than&nbsp;"2" (the
default).

     <br><dt><code>-C</code>
     <dd><dt><code>--toggle-use-color</code>
     <dd>Toggle between color and monochrome rendering of datasets.  The
interpretation of linemode depends on whether the rendering is being
performed in color or monochrome; see the <code>-m</code> option above.

     <br><dt><code>--symbol-font-name </code><var>symbol_font_name</var><code></code>
     <dd>(String, default "ZapfDingbats" unless <code>-T png</code>, <code>-T pnm</code>,
<code>-T gif</code>, <code>-T pcl</code>, <code>-T hpgl</code>, <code>-T regis</code>, or
<code>-T&nbsp;tek</code> is specified, in which case it is "HersheySerif".) 
Set the symbol font, from which marker symbols numbered 32 and higher
are selected, to be <var>symbol_font_name</var>.  Font names are
case-insensitive.  If&nbsp;the specified font is not available, the
default font will be used.  Which fonts are available depends on which
<code>-T</code> option is used.  For example, if the <code>-T pcl</code> or <code>-T
hpgl</code> option is used then normally the Wingdings font, which is an
alternative source of symbols, becomes available.  For a list of all
fonts, see <a href="#Text%20Fonts">Text Fonts</a>.  The <code>plotfont</code> utility will produce a
character map of any available font.  See <a href="#plotfont">plotfont</a>.

   </dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Multiplot%20Options">Multiplot Options</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Raw%20graph%20Options">Raw graph Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Dataset%20Options">Dataset Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph%20Invocation">graph Invocation</a>
<br>
</div>

<h3 class="subsection">2.6.3 Multiplot options</h4>

<p>The following options are used for multiplotting (placing more than a
single plots on a display, or a page).  The <code>--reposition</code>
directive serves as a separator, on the command line, between the
options and file names that apply to successive plots.

     <dl>
<dt><code>--reposition </code><var>x</var><code> </code><var>y</var><code> </code><var>size</var><code></code>
     <dd>(Floats, defaults 0.0, 0.0, 1.0) Set the `virtual display' within which
the next plot will be drawn to be a square of size <var>size</var>, with
lower left corner (<var>x</var>,<var>y</var>).  Normalized coordinates are used
here: (0,0) means the lower left corner of the physical display and
(1,1) means the upper right corner of the physical display.  The size of
the plot within the virtual display may be adjusted with the <code>-h</code>
and <code>-w</code> options, and its position within the virtual display with
the <code>-u</code> and <code>-w</code> options.  After a <code>--reposition</code>
directive, the arguments of those four options will be interpreted in
terms of the virtual display, not the physical display.

     <br><dt><code>--blankout </code><var>blankout_fraction</var><code></code>
     <dd>(Float, default 1.3.)  Before each additional plot of a multiplot is
drawn, the region of the display that the plot will occupy is cleared. 
If <var>blankout_fraction</var>=1.3, a&nbsp;region 30%&nbsp;larger in each
dimension is cleared.  If, for example, <var>blankout_fraction</var>=1.0, the
region covered by the plot's plotting box, and no&nbsp;more, is cleared. 
The default value, 1.3, is appropriate for inset plots.  1.0&nbsp;would
be appropriate for side by side plots.

     <p><code>graph -T tek</code> cannot clear regions, and <code>graph -T hpgl</code>
cannot clear them if the environment variables <code>HPGL_VERSION</code> and
<code>HPGL_OPAQUE_MODE</code> are set to non-default values (i.e., values
other than "2"&nbsp;and&nbsp;"yes", respectively). 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Raw%20graph%20Options">Raw graph Options</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Info%20Options">Info Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Multiplot%20Options">Multiplot Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph%20Invocation">graph Invocation</a>
<br>
</div>

<h3 class="subsection">2.6.4 Raw <code>graph</code> options</h4>

<p>The following option is relevant only to raw <code>graph</code>, i.e., is
relevant only if no display type or output format is specified with the
<code>-T</code> option.  In this case <code>graph</code> outputs a graphics
metafile, which may be translated to other formats by invoking
<code>plot</code>.  This option should appear on the command line before any
file names, since it affects the output of the plot (or multiplot) as a
whole.

     <dl>
<dt><code>-O</code>
     <dd><dt><code>--portable-output</code>
     <dd>Output the portable (human-readable) version of GNU metafile format,
rather than a binary version (the default).  This can also be requested
by setting the environment variable <code>META_PORTABLE</code> to "yes". 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Info%20Options">Info Options</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#graph%20Environment">graph Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Raw%20graph%20Options">Raw graph Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph%20Invocation">graph Invocation</a>
<br>
</div>

<h3 class="subsection">2.6.5 Informational options</h4>

<p>The following options request information.

     <dl>
<dt><code>--help</code>
     <dd>Print a list of command-line options, and then exit.

     <br><dt><code>--help-fonts</code>
     <dd>Print a table of available fonts, and then exit.  The table will depend
on which display type or output format is specified with the <code>-T</code>
option.  <code>graph -T&nbsp;X</code>, <code>graph -T svg</code>, <code>graph -T ai</code>,
<code>graph -T ps</code>, <code>graph -T cgm</code>, and <code>graph -T fig</code> each
support the 35 standard Postscript fonts.  <code>graph -T svg</code>,
<code>graph -T ai</code>, <code>graph -T pcl</code>, and <code>graph -T hpgl</code>
support the 45 standard PCL&nbsp;5 fonts, and <code>graph -T pcl</code> and
<code>graph -T hpgl</code> support a number of Hewlett-Packard vector fonts. 
All of the preceding, together with <code>graph -T png</code>, <code>graph -T
pnm</code>, <code>graph -T gif</code>, <code>graph -T regis</code>, and <code>graph -T
tek</code>, support a set of 22 Hershey vector fonts.  Raw <code>graph</code> in&nbsp;principle supports any of these fonts, since its output must be
translated to other formats with <code>plot</code>.  The <code>plotfont</code>
utility will produce a character map of any available font. 
See <a href="#plotfont">plotfont</a>.

     <br><dt><code>--list-fonts</code>
     <dd>Like <code>--help-fonts</code>, but lists the fonts in a single column to
facilitate piping to other programs.  If&nbsp;no display type or output
format is specified with the <code>-T</code> option, the full set of supported
fonts is listed.

     <br><dt><code>--version</code>
     <dd>Print the version number of <code>graph</code> and the plotting utilities
package, and exit. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="graph%20Environment">graph Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Info%20Options">Info Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#graph%20Invocation">graph Invocation</a>
<br>
</div>

<h3 class="section">2.7 Environment variables</h3>

<p>The behavior of <code>graph</code> is affected by several environment
variables.  We have already mentioned the environment variables
<code>BITMAPSIZE</code>, <code>PAGESIZE</code>, <code>BG_COLOR</code>,
<code>EMULATE_COLOR</code>, <code>MAX_LINE_LENGTH</code>, and <code>ROTATION</code>. 
They serve as backups for the several options <code>--bitmap-size</code>,
<code>--page-size</code>, <code>--bg-color</code>, <code>--emulate-color</code>,
<code>--max-line-length</code>, and <code>--rotation</code>.  The remaining
environment variables are specific to individual output formats.

   <p><code>graph -T&nbsp;X</code>, which pops up a window on an X&nbsp;Window System
display and draws graphics in&nbsp;it, checks the <code>DISPLAY</code>
environment variable.  The value of this variable determines the display
on which the window will be popped&nbsp;up.

   <p><code>graph -T png</code> and <code>graph -T gif</code>, which produce output in PNG
and pseudo-GIF format respectively, are affected by two environment
variables.  If the value of the <code>INTERLACE</code> variable is "yes", the
output file will be interlaced.  Also, if the value of the
<code>TRANSPARENT_COLOR</code> environment variable is the name of a color
that appears in the output file, that color will be treated as
transparent by most applications.  For information on what color names
are recognized, see <a href="#Color%20Names">Color Names</a>.

   <p><code>graph -T pnm</code>, which produces output in Portable Anymap
(PBM/PGM/PPM) format, is affected by the <code>PNM_PORTABLE</code> environment
variable.  If its value is "yes", the output file will be in the
portable (human readable) version of PBM, PGM, or PPM format, rather
than the default (binary) version.

   <p><code>graph -T cgm</code>, which produces CGM files that comply with the
WebCGM profile for Web-based vector graphics, is affected by two
environment variables.  By default, a version&nbsp;3 CGM file is
generated.  Many older CGM interpreters and viewers, such as the ones
built into Microsoft Office and other commercial software, only support
version&nbsp;1 CGM files.  The <code>CGM_MAX_VERSION</code> environment
variable may be set to "1", "2", "3", or&nbsp;"4" (the default) to
specify an maximum value for the version number.  The
<code>CGM_ENCODING</code> variable may also be set, to specify the type of
encoding used in the CGM file.  Supported values are "clear_text" (i.e.,
human readable) and "binary" (the default).  The WebCGM profile requires
that the binary encoding be used.

   <p><code>graph -T pcl</code>, which produces PCL&nbsp;5 output for
Hewlett-Packard printers, is affected by the environment variable
<code>PCL_ASSIGN_COLORS</code>.  It should be set to "yes" when producing
PCL&nbsp;5 output for a color printer or other color device.  This will
ensure accurate color reproduction by giving the output device complete
freedom in assigning colors, internally, to its "logical pens".  If it
is "no" then the device will use a fixed set of colored pens, and will
emulate other colors by shading.  The default is "no" because monochrome
PCL&nbsp;5 devices, which are more common than colored ones, must use
shading to emulate color.

   <p><code>graph -T hpgl</code>, which produces Hewlett-Packard Graphics Language
output, is also affected by several environment variables.  The most
important is <code>HPGL_VERSION</code>, which may be set to "1", "1.5", or&nbsp;"2" (the default).  "1"&nbsp;means that the output should be generic
HP-GL, "1.5"&nbsp;means that the output should be suitable for the
HP7550A graphics plotter and the HP758x, HP7595A and HP7596A drafting
plotters (HP-GL with some HP-GL/2 extensions), and "2"&nbsp;means that
the output should be modern HP-GL/2.  If&nbsp;the version is "1" or&nbsp;"1.5" then the only available fonts will be vector fonts, and all lines
will be drawn with a default thickness (the <code>-W</code> option will not
work).  Additionally, if the version is&nbsp;"1" then the filling of
arbitrary curves with solid color will not be supported (the <code>-q</code>
option may be used to fill circles and rectangles aligned with the
coordinate axes, though).

   <p>The position of the <code>graph -T hpgl</code> graphics display on the page
can be rotated 90&nbsp;degrees counterclockwise by setting the
<code>HPGL_ROTATE</code> environment variable to "yes".  This is not the same
as the rotation obtained with the <code>--rotation</code> option, since it
both rotates the graphics display and repositions its lower left corner
toward another corner of the page.  Besides "no" and "yes", recognized
values for the <code>HPGL_ROTATE</code> variable are "0", "90", "180", and&nbsp;"270".  "no"&nbsp;and "yes" are equivalent to "0"&nbsp;and&nbsp;"90",
respectively.  "180" and "270" are supported only if <code>HPGL_VERSION</code>
is&nbsp;"2" (the default).

   <p><em>Opaque</em> filling and the drawing of visible white lines are
supported only if <code>HPGL_VERSION</code> is "2" (the default) and the
environment variable <code>HPGL_OPAQUE_MODE</code> is "yes" (the default). 
If&nbsp;the value is "no" then opaque filling will not be used, and white
lines (if&nbsp;any), which are normally drawn with pen&nbsp;#0, will not
be drawn.  This feature is to accommodate older HP-GL/2 devices. 
HP-GL/2 pen plotters, for&nbsp;example, do not support opacity or the use
of pen&nbsp;#0 to draw visible white lines.  Some older HP-GL/2 devices
reportedly malfunction if asked to draw opaque objects.

   <p>By&nbsp;default, <code>graph -T hpgl</code> will draw with a fixed set of pens. 
Which pens are present may be specified by setting the <code>HPGL_PENS</code>
environment variable.  If <code>HPGL_VERSION</code> is&nbsp;"1", the default
value of <code>HPGL_PENS</code> is "1=black"; if <code>HPGL_VERSION</code> is
"1.5" or&nbsp;"2", the default value of <code>HPGL_PENS</code> is
"1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan".  The format
should be self-explanatory.  By setting <code>HPGL_PENS</code>, you may
specify a color for any pen in the range #1<small class="dots">...</small>#31.  For information
on what color names are recognized, see <a href="#Color%20Names">Color Names</a>.  Pen&nbsp;#1
must always be present, though it need not be black. Any other pen in
the range #1<small class="dots">...</small>#31 may be omitted.

   <p>If <code>HPGL_VERSION</code> is "2" then <code>graph -T hpgl</code> will also be
affected by the environment variable <code>HPGL_ASSIGN_COLORS</code>.  If&nbsp;the value of this variable is "yes", then <code>graph -T hpgl</code> will not
be restricted to the palette specified in <code>HPGL_PENS</code>: it&nbsp;will
assign colors to "logical pens" in the range #1<small class="dots">...</small>#31, as&nbsp;needed.  The default value is "no" because other than color LaserJet
printers and DesignJet plotters, not many HP-GL/2 devices allow the
assignment of colors to logical pens.  In particular, HP-GL/2 pen
plotters do not.

   <p><code>graph -T tek</code>, which produces output for a Tektronix terminal or
emulator, checks the <code>TERM</code> environment variable.  If&nbsp;the value
of <code>TERM</code> is a string beginning with "xterm", "nxterm", or "kterm",
it&nbsp;is taken as a sign that <code>graph</code> is running in an X&nbsp;Window System VT100 terminal emulator: an&nbsp;<code>xterm</code>,
<code>nxterm</code>, or <code>kterm</code>.  Before drawing graphics, <code>graph -T
tek</code> will emit an escape sequence that causes the terminal emulator's
auxiliary Tektronix window, which is normally hidden, to pop&nbsp;up. 
After the graphics are drawn, an escape sequence that returns control to
the original VT100 window will be emitted.  The Tektronix window will
remain on the screen.

   <p>If the value of <code>TERM</code> is a string beginning with "kermit",
"ansi.sys", or "nansi.sys", it&nbsp;is taken as a sign that <code>graph</code>
is running in the VT100 terminal emulator provided by the MS-DOS version
of <code>kermit</code>.  Before drawing graphics, <code>graph -T tek</code> will
emit an escape sequence that switches the terminal emulator to Tektronix
mode.  Also, some of the Tektronix control codes emitted by <code>graph
-T tek</code> will be <code>kermit</code>-specific.  There will be a limited amount
of color support, which is not normally the case (the 16 <code>ansi.sys</code>
colors will be supported).  After drawing graphics, <code>graph -T tek</code>
will emit an escape sequence that returns the emulator to VT100 mode. 
The key sequence `ALT&nbsp;minus' can be employed manually within
<code>kermit</code> to switch between the two modes.

<div class="node">
<p><hr>
Node:&nbsp;<a name="plot">plot</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#pic2plot">pic2plot</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#graph">graph</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">3 The <code>plot</code> Program</h2>

<ul class="menu">
<li><a accesskey="1" href="#plot%20Examples">plot Examples</a>:        How to use a plot filter
<li><a accesskey="2" href="#plot%20Invocation">plot Invocation</a>:      Command-line options
<li><a accesskey="3" href="#plot%20Environment">plot Environment</a>:     Environment variables
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="plot%20Examples">plot Examples</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#plot%20Invocation">plot Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plot">plot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#plot">plot</a>
<br>
</div>

<h3 class="section">3.1 How to use <code>plot</code></h3>

<p>The GNU plot filter <code>plot</code> displays GNU graphics metafiles or
translates them to other formats.  It&nbsp;will take input from files
specified on the command line or from standard input.  The <code>-T</code>
option is used to specify the desired output format.  Supported output
formats include "X", "png", "pnm", "gif", "svg", "ai", "ps", "cgm",
"fig", "pcl", "hpgl", "regis", "tek", and "meta" (the default).

   <p>The metafile format is a device-independent format for storage of vector
graphics.  By default, it is a binary rather than a human-readable
format (see <a href="#Metafiles">Metafiles</a>).  Each of the <code>graph</code>, <code>pic2plot</code>,
<code>tek2plot</code>, and <code>plotfont</code> utilities will write a graphics
metafile to standard output if no <code>-T</code> option is specified on its
command line.  The GNU <code>libplot</code> graphics library may also be used
to produce metafiles.  Metafiles may contain arbitrarily many pages of
graphics, but each metafile produced by <code>graph</code> contains only a
single page.

   <p><code>plot</code>, like the metafile format itself, is useful if you wish to
preserve a vector graphics file, and display or edit it with more than
one drawing editor.  The following example shows how you may do this.

   <p>To produce a plot of data arranged as alternating x and y
coordinates in an ASCII file, you may use <code>graph</code> as follows:

<pre class="example">     graph &lt; datafile &gt; test.meta
     </pre>

<p>The file <code>test.meta</code> will be a single-page graphics metafile. 
Similarly, to create in metafile format a plot consisting of a simple
figure, you may do:

<pre class="example">     echo 0 0 1 1 2 0 | spline | graph &gt; test.meta
     </pre>

<p>To display any such plot on an X&nbsp;Window System display, you
would do

<pre class="example">     plot -T X test.meta
     </pre>

<p>or

<pre class="example">     plot -T X &lt; test.meta
     </pre>

<p>To print the plot on a Postscript printer, you would do something
like

<pre class="example">     plot -T ps &lt; test.meta | lpr
     </pre>

<p>To edit it with the free <code>idraw</code> drawing editor, you would do

<pre class="example">     plot -T ps &lt; test.meta &gt; test.ps
     idraw test.ps
     </pre>

<p>To produce a PNG file, you would do
<pre class="example">     plot -T png &lt; test.meta &gt; test.png
     </pre>

<p>To produce a "portable anymap" (a file in PBM, PGM, or PPM format,
whichever is most appropriate) you would do
<pre class="example">     plot -T pnm &lt; test.meta &gt; test.pnm
     </pre>

<p>and to produce a pseudo-GIF file, you would do
<pre class="example">     plot -T gif &lt; test.meta &gt; test.gif
     </pre>

<p>Similarly, to produce versions of the plot in SVG format and WebCGM
format that can be displayed in a Web browser with SVG and WebCGM
support, you would do

<pre class="example">     plot -T svg &lt; test.meta &gt; test.svg
     plot -T cgm &lt; test.meta &gt; test.cgm
     </pre>

<p>To produce a version of the plot that can be viewed and edited with
Adobe Illustrator, you would do

<pre class="example">     plot -T ai &lt; test.meta &gt; test.ai
     </pre>

<p>and to produce a version that can be viewed and edited with the free
<code>xfig</code> drawing editor, you would do

<pre class="example">     plot -T fig &lt; test.meta &gt; test.fig
     xfig test.fig
     </pre>

<p>Other formats may be obtained by using <code>plot -T pcl</code>, <code>plot -T
hpgl</code>, <code>plot -T regis</code>, and <code>plot -T tek</code>.

   <p><code>plot</code> may behave differently depending on the environment in which
it is invoked.  In particular, <code>plot -T svg</code>, <code>plot -T ai</code>,
<code>plot -T ps</code>, <code>plot -T cgm</code>, <code>plot -T fig</code>, <code>plot -T
pcl</code>, and <code>plot -T hpgl</code> are affected by the environment variable
<code>PAGESIZE</code>.  <code>plot -T&nbsp;X</code>, <code>plot -T png</code>, <code>plot
-T pnm</code>, and <code>plot -T gif</code> are affected by the environment variable
<code>BITMAPSIZE</code>.  The <code>DISPLAY</code> environment variable affects the
operation of <code>plot -T&nbsp;X</code>, and the <code>TERM</code> environment
variable affects the operation of <code>plot -T tek</code>.  There are also
several environment variables that affect the operation of <code>plot -T
pcl</code> and <code>plot -T hpgl</code>.  For a complete discussion of the effects
of the environment on <code>plot</code>, see <a href="#plot%20Environment">plot Environment</a>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="plot%20Invocation">plot Invocation</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#plot%20Environment">plot Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plot%20Examples">plot Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#plot">plot</a>
<br>
</div>

<h3 class="section">3.2 <code>plot</code> command-line options</h3>

<p>The plot filter <code>plot</code> translates GNU graphics metafiles to other
formats.  The <code>-T</code> option is used to specify the output format or
display type.  Files in metafile format are produced by GNU
<code>graph</code>, <code>pic2plot</code>, <code>tek2plot</code>, <code>plotfont</code>, and
other applications that use the GNU <code>libplot</code> graphics library. 
For technical details on the metafile format, see <a href="#Metafiles">Metafiles</a>.

   <p>Input file names may be specified anywhere on the command line.  That
is, the relative order of file names and command-line options does not
matter.  If no files are specified, or the file name&nbsp;<code>-</code> is
specified, the standard input is read.  An output file is written to
standard output, unless the <code>-T X</code> option is specified.  In&nbsp;that case the output is displayed in a window or windows on an X&nbsp;Window System display, and there is no output file.

   <p>The full set of command-line options is listed below.  There are four
sorts of option:

     <ol type=1 start=1>
<li>Options setting the values of drawing parameters. 
<li>Options relevant only to raw <code>plot</code>, i.e., relevant only if no
display type or output format is specified with the <code>-T</code> option. 
<li>Options specifying the type of metafile format the input is in (for
backward compatibility only). 
<li>Options requesting information (e.g., <code>--help</code>).
        </ol>

<p>Each option that takes an argument is followed, in parentheses, by the
type and default value of the argument.

   <p>The following options set the values of drawing parameters.

     <dl>
<dt><code>-T </code><var>type</var><code></code>
     <dd><dt><code>--display-type </code><var>type</var><code></code>
     <dd>(String, default "meta".)  Select a display type or output format of
type <var>type</var>, which may be one of the strings "X", "png", "pnm",
"gif", "svg", "ai", "ps", "cgm", "fig", "pcl", "hpgl", "regis", "tek",
and "meta".  These refer respectively to the X&nbsp;Window&nbsp;System, PNG
format, portable anymap (PBM/PGM/PPM) format, pseudo-GIF format, the new
XML-based Scalable Vector Graphics format, the format used by Adobe
Illustrator, <code>idraw</code>-editable Postscript, the WebCGM format for
Web-based vector graphics, the format used by the <code>xfig</code> drawing
editor, the Hewlett-Packard PCL&nbsp;5 printer language, the
Hewlett-Packard Graphics Language (by&nbsp;default, HP-GL/2), the ReGIS
(remote graphics instruction set) format developed by&nbsp;DEC, Tektronix
format, and device-independent GNU graphics metafile format.

     <br><dt><code>-p </code><var>n</var><code></code>
     <dd><dt><code>--page-number </code><var>n</var><code></code>
     <dd>(Positive integer.) Display only page number <var>n</var>, within the
metafile or sequence of metafiles that is being translated.

     <p>Metafiles may consist of one or more pages, numbered beginning with&nbsp;1.  Also, each page may contain multiple `frames'.  <code>plot -T&nbsp;X</code>, <code>plot -T regis</code>, or <code>plot -T tek</code>, which plot in real
time, will separate successive frames by screen erasures.  <code>plot -T
png</code>, <code>plot -T pnm</code>, <code>plot -T gif</code>, <code>plot -T svg</code>,
<code>plot -T ai</code>, <code>plot -T ps</code>, <code>plot -T cgm</code>, <code>plot -T
fig</code>, <code>plot -T pcl</code>, <code>plot -T hpgl</code>, which do not plot in real
time, will display only the last frame of any multi-frame page.

     <p>The default behavior, if <code>-p</code> is not used, is to display all pages. 
For example, <code>plot -T&nbsp;X</code> displays each page in its own X&nbsp;window.  If&nbsp;the <code>-T png</code> option, the <code>-T pnm</code> option, the
<code>-T gif</code> option, the <code>-T svg</code> option, the <code>-T ai</code> option,
or the <code>-T fig</code> option is used, the default behavior is to display
only the first page, since files in PNG, PNM, pseudo-GIF, SVG, AI, or
Fig format may contain only a single page of graphics.

     <p>Most metafiles produced by the GNU plotting utilities (e.g., by raw
<code>graph</code>) contain only a single page, consisting of two frames: an
empty one to clear the display, and a second one containing graphics.

     <br><dt><code>-s</code>
     <dd><dt><code>--merge-pages</code>
     <dd>Merge all displayed pages into a single page, and also merge all
`frames' within each displayed page.

     <p>This option is useful when merging together single-page plots from
different sources.  For example, it can be used to merge together plots
obtained from separate invocations of <code>graph</code>.  This is an
alternative form of multiplotting (see <a href="#Multiplotting">Multiplotting</a>).

     <br><dt><code>--bitmap-size </code><var>bitmap_size</var><code></code>
     <dd>(String, default "570x570".)  Set the size of the graphics display in
which the plot will be drawn, in terms of pixels, to be
<var>bitmap_size</var>.  This is relevant only to <code>plot -T&nbsp;X</code>,
<code>plot -T png</code>, <code>plot -T pnm</code>, and <code>plot -T gif</code>, for all
of which the size can be expressed in terms of pixels.  The environment
variable <code>BITMAPSIZE</code> may equally well be used to specify the size.

     <p>The graphics display used by <code>plot -T X</code> is a popped-up X&nbsp;window.  Command-line positioning of this window on an X&nbsp;Window
System display is supported.  For example, if <var>bitmap_size</var> is
"570x570+0+0" then the window will be popped&nbsp;up in the upper left
corner.

     <p>If you choose a rectangular (non-square) window size, the fonts in the
plot will be scaled anisotropically, i.e., by different factors in the
horizontal and vertical direction.  For this, <code>plot -T&nbsp;X</code>
requires an X11R6 display.  Any font that cannot be anisotropically
scaled will be replaced by a default scalable font, such as the Hershey
vector font "HersheySerif".

     <p>For backward compatibility, <code>plot -T X</code> allows the user to set the
window size and position by setting the X&nbsp;resource
<code>Xplot.geometry</code>, instead of <code>--bitmap-size</code> or
<code>BITMAPSIZE</code>.

     <br><dt><code>--emulate-color </code><var>option</var><code></code>
     <dd>(String, default "no".)  If <var>option</var> is "yes", replace each color in
the output by an appropriate shade of gray.  This is seldom useful,
except when using <code>plot -T pcl</code> to prepare output for a PCL&nbsp;5
device.  (Many monochrome PCL&nbsp;5 devices, such as monochrome
LaserJets, do a poor job of emulating color on their own.  They usually
map HP-GL/2's seven standard pen colors, including even yellow, to
black.)  You may equally well request color emulation by setting the
environment variable <code>EMULATE_COLOR</code> to "yes".

     <br><dt><code>--max-line-length </code><var>max_line_length</var><code></code>
     <dd>(Integer, default 500.)  Set the maximum number of points that a
polygonal line may contain, before it is flushed to the output device,
to equal <var>max_line_length</var>.  If this flushing occurs, the polygonal
line will be split into two or more sub-lines, though the splitting
should not be noticeable.  Splitting will not take place if the line is
the boundary of a filled polygon.

     <p>The reason for splitting long polygonal lines is that some display
devices (e.g., old Postscript printers and HP-GL pen plotters) have
limited buffer sizes.  The environment variable <code>MAX_LINE_LENGTH</code>
can also be used to specify the maximum line length.  This option has no
effect on <code>plot -T tek</code> or raw <code>plot</code>, since they draw
polylines in real time and have no buffer limitations.

     <br><dt><code>--page-size </code><var>pagesize</var><code></code>
     <dd>(String, default "letter".)  Set the size of the page on which the plot
will be positioned.  This is relevant only to <code>plot -T svg</code>,
<code>plot -T ai</code>, <code>plot -T ps</code>, <code>plot -T cgm</code>, <code>plot -T
fig</code>, <code>plot -T pcl</code>, and <code>plot -T hpgl</code>.  "letter" means an
8.5in by 11in page.  Any ISO page size in the range
"a0"<small class="dots">...</small>"a4" or ANSI page size in the range "a"<small class="dots">...</small>"e" may be
specified ("letter" is an alias for&nbsp;"a" and "tabloid" is an alias
for&nbsp;"b").  "legal", "ledger", and&nbsp;"b5" are recognized page sizes
also.  The environment variable <code>PAGESIZE</code> can equally well be used
to specify the page size.

     <p>For <code>plot -T ai</code>, <code>plot -T ps</code>, <code>plot -T pcl</code>, and
<code>plot -T fig</code>, the graphics display (or `viewport') within which
the plot is drawn will be, by default, a square region centered on the
specified page.  For <code>plot -T hpgl</code>, it will be a square region of
the same size, but may be positioned differently.  Either or both of the
dimensions of the graphics display can be specified explicitly.  For
example, <var>pagesize</var> could be specified as "letter,xsize=4in", or
"a4,xsize=10cm,ysize=15cm".  The dimensions are allowed to be negative
(a&nbsp;negative dimension results in a reflection).

     <p>The position of the graphics display, relative to its default position,
may optionally be adjusted by specifying an offset vector.  For example,
<var>pagesize</var> could be specified as "letter,yoffset=1.2in", or
"a4,xoffset=-5mm,yoffset=2.0cm".  It&nbsp;is also possible to
position the graphics display precisely, by specifying the location of
its lower left corner relative to the lower left corner of the page. 
For example, <var>pagesize</var> could be specified as
"letter,xorigin=2in,yorigin=3in", or "a4,xorigin=0.5cm,yorigin=0.5cm". 
The preceding options may be intermingled.  <code>plot -T svg</code> and
<code>plot -T cgm</code> ignore the "xoffset", "yoffset", "xorigin", and
"yorigin" options, since SVG format and WebCGM format have no notion of
the Web page on which the graphics display will ultimately be
positioned.  For more on page sizes, see <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>. 
</dl>

   <p>The following options set the initial values of additional drawing
parameters.  Any of these may be overridden by a directive in the
metafile itself.  In&nbsp;fact, these options are useful only when
plotting old metafiles in the pre-GNU `plot(5)' format, which did not
include such directives.

     <dl>
<dt><code>--bg-color </code><var>name</var><code></code>
     <dd>(String, default "white".)  Set the color used for the plot background
to be <var>name</var>.  This is relevant only to <code>plot -T&nbsp;X</code>,
<code>plot -T png</code>, <code>plot -T pnm</code>, <code>plot -T gif</code>, <code>plot
-T cgm</code>, <code>plot -T regis</code>, and <code>plot -Tmeta</code>.  An&nbsp;unrecognized name sets the color to the default.  For information on
what names are recognized, see <a href="#Color%20Names">Color Names</a>.  The environment
variable <code>BG_COLOR</code> can equally well be used to specify the
background color.

     <p>If the <code>-T png</code> or <code>-T gif</code> option is used, a transparent PNG
file or a transparent pseudo-GIF, respectively, may be produced by
setting the <code>TRANSPARENT_COLOR</code> environment variable to the name of
the background color.  See <a href="#plot%20Environment">plot Environment</a>.  If&nbsp;the <code>-T
svg</code> or <code>-T cgm</code> option is used, an output file without a
background may be produced by setting the background color to "none".

     <br><dt><code>-f </code><var>font_size</var><code></code>
     <dd><dt><code>--font-size </code><var>font_size</var><code></code>
     <dd>(Float, initial value device-dependent.)  Set the initial size of the
font used for rendering text, as a fraction of the width of the graphics
display, to <var>font_size</var>.

     <br><dt><code>-F </code><var>font_name</var><code></code>
     <dd><dt><code>--font-name </code><var>font_name</var><code></code>
     <dd>(String, default "Helvetica" except for <code>plot -T pcl</code>, for which
"Univers" is the default, and <code>plot -T png</code>, <code>plot -T pnm</code>,
<code>plot -T gif</code>, <code>plot -T hpgl</code>, <code>plot -T regis</code>,
<code>plot -T tek</code>, and raw <code>plot</code>, for all of which "HersheySerif"
is the default.)  Set the font initially used for text (i.e., for
`labels') to <var>font_name</var>.  Font names are case-insensitive.  If&nbsp;the specified font is not available, the default font will be used. 
Which fonts are available depends on which <code>-T</code> option is used. 
For a list of all fonts, see <a href="#Text%20Fonts">Text Fonts</a>.  The <code>plotfont</code>
utility will produce a character map of any available font. 
See <a href="#plotfont">plotfont</a>.

     <br><dt><code>-W </code><var>line_width</var><code></code>
     <dd><dt><code>--line-width </code><var>line_width</var><code></code>
     <dd>(Float, default -1.0.)  Set the thickness of lines, as a fraction
of the size (i.e., minimum dimension) of the graphics display, to
<var>line_width</var>.  A&nbsp;negative value means that the default value
provided by the GNU <code>libplot</code> graphics library should be used. 
This is usually 1/850 times the size of the display, although if
<code>-T X</code>, <code>-T png</code>, <code>-T pnm</code>, or <code>-T gif</code> is
specified, it is zero.  By convention, a zero-thickness line is the
thinnest line that can be drawn.  This is the case in all output
formats.  Note, however, that the drawing editors <code>idraw</code> and
<code>xfig</code> treat zero-thickness lines as invisible.

     <p><code>plot -T tek</code> and <code>plot -T regis</code> do not support drawing lines
with other than a default thickness, and <code>plot -T hpgl</code> does not
support doing&nbsp;so if the environment variable <code>HPGL_VERSION</code> is
set to a value less than&nbsp;"2" (the default).

     <br><dt><code>--pen-color </code><var>name</var><code></code>
     <dd>(String, default "black".)  Set the pen color to be <var>name</var>.  An
unrecognized name sets the pen color to the default.  For information on
what color names are recognized, see <a href="#Color%20Names">Color Names</a>. 
</dl>

   <p>The following option is relevant only to raw <code>plot</code>, i.e., relevant
only if no output type is specified with the <code>-T</code> option.  In this
case <code>plot</code> outputs a graphics metafile, which may be translated to
other formats by a second invocation of <code>plot</code>.

     <dl>
<dt><code>-O</code>
     <dd><dt><code>--portable-output</code>
     <dd>Output the portable (human-readable) version of GNU metafile format,
rather than a binary version (the default).  This can also be requested
by setting the environment variable <code>META_PORTABLE</code> to "yes". 
</dl>

   <p><code>plot</code> will automatically determine which type of GNU metafile
format the input is&nbsp;in.  There are two types: binary (the default)
and portable (human-readable).  The binary format is machine-dependent. 
See <a href="#Metafiles">Metafiles</a>.

   <p>For compatibility with older plotting software, the reading of input
files in the pre-GNU `plot(5)' format is also supported.  This is
normally a binary format, with each integer in the metafile represented
as a pair of bytes.  The order of the two bytes is machine dependent. 
You may specify that input file(s) are in plot(5) format rather than
ordinary GNU metafile format by using either the <code>-h</code> option
("high byte first") or the <code>-l</code> option ("low byte first"),
whichever is appropriate.  Some non-GNU systems support an ASCII
(human-readable) variant of plot(5) format.  You may specify that the
input is in this format by using the <code>-A</code> option.  Irrespective of
the variant, a file in plot(5) format includes only one page of
graphics.

     <dl>
<dt><code>-h</code>
     <dd><dt><code>--high-byte-first-input</code>
     <dd>Input file(s) are assumed to be in traditional `plot(5)' metafile
format, with the high-order byte of each integer occurring first.  This
variant is uncommon.

     <br><dt><code>-l</code>
     <dd><dt><code>--low-byte-first-input</code>
     <dd>Input file(s) are assumed to be in traditional `plot(5)' metafile
format, with the low-order byte of each integer occurring first.  This
variant is the most common.

     <br><dt><code>-A</code>
     <dd><dt><code>--ascii-input</code>
     <dd>Input file(s) are assumed to be in the ASCII variant of traditional
`plot(5)' metafile format.  This variant is rare: on some older systems,
it is produced by a program called <code>plottoa</code>. 
</dl>

   <p>The following options request information.

     <dl>
<dt><code>--help</code>
     <dd>Print a list of command-line options, and then exit.

     <br><dt><code>--help-fonts</code>
     <dd>Print a table of available fonts, and then exit.  The table will depend
on which display type or output format is specified with the <code>-T</code>
option.  <code>plot -T&nbsp;X</code>, <code>plot -T svg</code>, <code>plot -T ai</code>,
<code>plot -T ps</code>, <code>plot -T cgm</code>, and <code>plot -T fig</code> each
support the 35 standard Postscript fonts.  <code>plot -T svg</code>,
<code>plot -T ai</code>, <code>plot -T pcl</code>, and <code>plot -T hpgl</code> support
the 45 standard PCL&nbsp;5 fonts, and <code>plot -T pcl</code> and <code>plot
-T hpgl</code> support a number of Hewlett-Packard vector fonts.  All of the
preceding, together with <code>plot -T png</code>, <code>plot -T pnm</code>,
<code>plot -T gif</code>, <code>plot -T regis</code>, and <code>plot -T tek</code>,
support a set of 22 Hershey vector fonts.  Raw <code>plot</code> in&nbsp;principle supports any of these fonts, since its output must be
translated to other formats with <code>plot</code>.  The <code>plotfont</code>
utility will produce a character map of any available font. 
See <a href="#plotfont">plotfont</a>.

     <br><dt><code>--list-fonts</code>
     <dd>Like <code>--help-fonts</code>, but lists the fonts in a single column to
facilitate piping to other programs.  If&nbsp;no display type or output
format is specified with the <code>-T</code> option, the full set of supported
fonts is listed.

     <br><dt><code>--version</code>
     <dd>Print the version number of <code>plot</code> and the plotting utilities
package, and exit. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="plot%20Environment">plot Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plot%20Invocation">plot Invocation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#plot">plot</a>
<br>
</div>

<h3 class="section">3.3 Environment variables</h3>

<p>The behavior of <code>plot</code> is affected by several environment
variables.  We have already mentioned the environment variables
<code>BITMAPSIZE</code>, <code>PAGESIZE</code>, <code>BG_COLOR</code>,
<code>EMULATE_COLOR</code>, <code>MAX_LINE_LENGTH</code>, and <code>ROTATION</code>. 
They serve as backups for the several options <code>--bitmap-size</code>,
<code>--page-size</code>, <code>--bg-color</code>, <code>--emulate-color</code>,
<code>--max-line-length</code>, and <code>--rotation</code>.  The remaining
environment variables are specific to individual output formats.

   <p><code>plot -T&nbsp;X</code>, which pops up a window on an X&nbsp;Window System
display and draws graphics in&nbsp;it, checks the <code>DISPLAY</code>
environment variable.  The value of this variable determines the display
on which the window will be popped&nbsp;up.

   <p><code>plot -T png</code> and <code>plot -T gif</code>, which produce output in PNG
format and pseudo-GIF format respectively, are affected by two
environment variables.  If the value of the <code>INTERLACE</code> variable is
"yes", the output file will be interlaced.  Also, if the value of the
<code>TRANSPARENT_COLOR</code> environment variable is the name of a color
that appears in the output file, that color will be treated as
transparent by most applications.  For information on what color names
are recognized, see <a href="#Color%20Names">Color Names</a>.

   <p><code>plot -T pnm</code>, which produces output in Portable Anymap
(PBM/PGM/PPM) format, is affected by the <code>PNM_PORTABLE</code> environment
variable.  If its value is "yes", the output file will be in the
portable (human readable) version of PBM, PGM, or PPM format, rather
than the default (binary) version.

   <p><code>plot -T cgm</code>, which produces CGM files that comply with the WebCGM
profile for Web-based vector graphics, is affected by two environment
variables.  By default, a version&nbsp;3 CGM file is generated.  Many
older CGM interpreters and viewers, such as the ones built into
Microsoft Office and other commercial software, only support version&nbsp;1 CGM files.  The <code>CGM_MAX_VERSION</code> environment variable may be
set to "1", "2", "3", or&nbsp;"4" (the default) to specify a maximum
value for the version number.  The <code>CGM_ENCODING</code> variable may also
be set, to specify the type of encoding used in the CGM file.  Supported
values are "clear_text" (i.e., human readable) and "binary" (the
default).  The WebCGM profile requires that the binary encoding be used.

   <p><code>plot -T pcl</code>, which produces PCL&nbsp;5 output for Hewlett-Packard
printers, is affected by the environment variable
<code>PCL_ASSIGN_COLORS</code>.  It should be set to "yes" when producing
PCL&nbsp;5 output for a color printer or other color device.  This will
ensure accurate color reproduction by giving the output device complete
freedom in assigning colors, internally, to its "logical pens".  If it
is "no" then the device will use a fixed set of colored pens, and will
emulate other colors by shading.  The default is "no" because monochrome
PCL&nbsp;5 devices, which are more common than colored ones, must use
shading to emulate color.

   <p><code>plot -T hpgl</code>, which produces Hewlett-Packard Graphics Language
output, is also affected by several environment variables.  The most
important is <code>HPGL_VERSION</code>, which may be set to "1", "1.5", or&nbsp;"2" (the default).  "1"&nbsp;means that the output should be generic
HP-GL, "1.5"&nbsp;means that the output should be suitable for the
HP7550A graphics plotter and the HP758x, HP7595A and HP7596A drafting
plotters (HP-GL with some HP-GL/2 extensions), and "2"&nbsp;means that
the output should be modern HP-GL/2.  If&nbsp;the version is "1" or&nbsp;"1.5" then the only available fonts will be vector fonts, and all lines
will be drawn with a default thickness (the <code>-W</code> option will not
work).  Additionally, if the version is&nbsp;"1" then the filling of
arbitrary curves with solid color will not be supported (circles and
rectangles aligned with the coordinate axes may be filled, though).

   <p>The position of the <code>plot -T hpgl</code> graphics display on the page can
be rotated 90&nbsp;degrees counterclockwise by setting the
<code>HPGL_ROTATE</code> environment variable to "yes".  This is not the same
as the rotation obtained with the <code>--rotation</code> option, since it
both rotates the graphics display and repositions its lower left corner
toward another corner of the page.  Besides "no" and "yes", recognized
values for the <code>HPGL_ROTATE</code> variable are "0", "90", "180", and&nbsp;"270".  "no"&nbsp;and "yes" are equivalent to "0"&nbsp;and&nbsp;"90",
respectively.  "180" and "270" are supported only if <code>HPGL_VERSION</code>
is&nbsp;"2" (the default).

   <p><em>Opaque</em> filling and the drawing of visible white lines are
supported only if <code>HPGL_VERSION</code> is "2" (the default) and the
environment variable <code>HPGL_OPAQUE_MODE</code> is "yes" (the default). 
If&nbsp;the value is "no" then opaque filling will not be used, and white
lines (if&nbsp;any), which are normally drawn with pen&nbsp;#0, will not
be drawn.  This feature is to accommodate older HP-GL/2 devices. 
HP-GL/2 pen plotters, for&nbsp;example, do not support opacity or the use
of pen&nbsp;#0 to draw visible white lines.  Some older HP-GL/2 devices
reportedly malfunction if asked to draw opaque objects.

   <p>By&nbsp;default, <code>plot -T hpgl</code> will draw with a fixed set of pens. 
Which pens are present may be specified by setting the <code>HPGL_PENS</code>
environment variable.  If <code>HPGL_VERSION</code> is&nbsp;"1", the default
value of <code>HPGL_PENS</code> is "1=black"; if <code>HPGL_VERSION</code> is
"1.5" or&nbsp;"2", the default value of <code>HPGL_PENS</code> is
"1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan".  The format
should be self-explanatory.  By setting <code>HPGL_PENS</code>, you may
specify a color for any pen in the range #1<small class="dots">...</small>#31.  For information
on what color names are recognized, see <a href="#Color%20Names">Color Names</a>.  Pen&nbsp;#1
must always be present, though it need not be black. Any other pen in
the range #1<small class="dots">...</small>#31 may be omitted.

   <p>If <code>HPGL_VERSION</code> is "2" then <code>plot -T hpgl</code> will also be
affected by the environment variable <code>HPGL_ASSIGN_COLORS</code>.  If&nbsp;the value of this variable is "yes", then <code>plot -T hpgl</code> will not
be restricted to the palette specified in <code>HPGL_PENS</code>: it&nbsp;will
assign colors to "logical pens" in the range #1<small class="dots">...</small>#31, as&nbsp;needed.  The default value is "no" because other than color LaserJet
printers and DesignJet plotters, not many HP-GL/2 devices allow the
assignment of colors to logical pens.  In particular, HP-GL/2 pen
plotters do not.

   <p><code>plot -T tek</code>, which produces output for a Tektronix terminal or
emulator, checks the <code>TERM</code> environment variable.  If&nbsp;the value
of <code>TERM</code> is a string beginning with "xterm", "nxterm", or "kterm",
it&nbsp;is taken as a sign that <code>plot</code> is running in an X&nbsp;Window
System VT100 terminal emulator: an&nbsp;<code>xterm</code>, <code>nxterm</code>, or
<code>kterm</code>.  Before drawing graphics, <code>plot -T tek</code> will emit an
escape sequence that causes the terminal emulator's auxiliary Tektronix
window, which is normally hidden, to pop&nbsp;up.  After the graphics are
drawn, an escape sequence that returns control to the original VT100
window will be emitted.  The Tektronix window will remain on the screen.

   <p>If the value of <code>TERM</code> is a string beginning with "kermit",
"ansi.sys", or "nansi.sys", it&nbsp;is taken as a sign that <code>plot</code>
is running in the VT100 terminal emulator provided by the MS-DOS version
of <code>kermit</code>.  Before drawing graphics, <code>plot -T tek</code> will emit
an escape sequence that switches the terminal emulator to Tektronix
mode.  Also, some of the Tektronix control codes emitted by <code>plot
-T tek</code> will be <code>kermit</code>-specific.  There will be a limited amount
of color support, which is not normally the case (the 16 <code>ansi.sys</code>
colors will be supported).  After drawing graphics, <code>plot -T tek</code>
will emit an escape sequence that returns the emulator to VT100 mode. 
The key sequence `ALT&nbsp;minus' can be employed manually within
<code>kermit</code> to switch between the two modes.

<div class="node">
<p><hr>
Node:&nbsp;<a name="pic2plot">pic2plot</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#tek2plot">tek2plot</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plot">plot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">4 The <code>pic2plot</code> Program</h2>

<ul class="menu">
<li><a accesskey="1" href="#pic2plot%20Introduction">pic2plot Introduction</a>:      What pic2plot is used for
<li><a accesskey="2" href="#pic2plot%20Invocation">pic2plot Invocation</a>:        Command-line options
<li><a accesskey="3" href="#pic2plot%20Environment">pic2plot Environment</a>:       Environment variables
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="pic2plot%20Introduction">pic2plot Introduction</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#pic2plot%20Invocation">pic2plot Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pic2plot">pic2plot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#pic2plot">pic2plot</a>
<br>
</div>

<h3 class="section">4.1 What <code>pic2plot</code> is used for</h3>

<p>The <code>pic2plot</code> program takes one or more files in the pic language,
and either displays the figures that they contain on an X&nbsp;Window
System display, or produces an output file containing the figures.  Many
graphics file formats are supported.

   <p>The pic language is a `little language' that was developed at Bell
Laboratories for creating box-and-arrow diagrams of the kind frequently
found in technical papers and textbooks.  A&nbsp;directory containing
documentation on the pic language is distributed along with the plotting
utilities.  On&nbsp;most systems it is installed as
<code>/usr/share/pic2plot</code> or <code>/usr/local/share/pic2plot</code>.  The
directory includes Brian Kernighan's original technical report on the
language, Eric&nbsp;S. Raymond's tutorial on the GNU implementation, and
some sample pic macros contributed by the late W.&nbsp;Richard Stevens.

   <p>The pic language was originally designed to work with the <code>troff</code>
document formatter.  In that context it is read by a translator called
<code>pic</code>, or its GNU counterpart <code>gpic</code>.  Since extensive
documentation on <code>pic</code> and <code>gpic</code> is available, this section
simply gives an example of an input file, and mentions some extra
features supported by <code>pic2plot</code>.

   <p>A pic file contains one or more figures, each of the box-and-arrow type. 
Each figure is begun by a line reading <tt>.PS</tt>, and ended by a line
reading <tt>.PE</tt>.  Lines that are not contained in a
<tt>.PS</tt><small class="dots">...</small><tt>.PE</tt> pair are ignored.  Each&nbsp;figure is built from
geometrical objects, such as rectangular boxes, circles, ellipses,
quarter circles ("arcs"), polygonal lines, and splines.  Arcs,
polygonal lines, and spline may be equipped with arrowheads.  Any object
may be labeled with one or more lines of text.

   <p>Objects are usually positioned not by specifying their positions in
absolute coordinates, but rather by specifying their positions relative
to other, previously drawn objects.  The following figure is an example.

<pre class="example">     .PS
     box "START"; arrow; circle dashed filled; arrow
     circle diam 2 thickness 3 "This is a" "big, thick" "circle" dashed; up
     arrow from top of last circle; ellipse "loopback" dashed
     arrow dotted from left of last ellipse to top of last box
     arc cw radius 1/2 from top of last ellipse; arrow
     box "END"
     .PE
     </pre>

<p>If you put this example in a file and run <code>pic2plot -T X</code> on the
file, a window containing the figure will be popped&nbsp;up on your X&nbsp;display.  Similarly, if you run <code>pic2plot -T ps</code> on the file, a
Postscript file containing the figure will be written to standard
output.  The Postscript file may be edited with the <code>idraw</code> drawing
editor.  Other graphics formats such as PNG format, PNM format,
pseudo-GIF format, SVG format, WebCGM format, or Fig format (which is
editable with the <code>xfig</code> drawing editor) may be obtained similarly. 
You would use the options <code>-T png</code>, <code>-T pnm</code>, <code>-T gif</code>,
<code>samp -T svg</code>, <code>-T cgm</code>, and <code>-T fig</code>, respectively.

   <p>The above example illustrates some of the features of the pic language. 
By default, successive objects are drawn so as to touch each other.  The
drawing proceeds in a certain direction, which at startup is
left-to-right.  The <code>up</code> command changes this direction to
bottom-to-top, so that the next object (the arrow extending from the top
of the big circle) will point upward rather than to the right.

   <p>Objects have sizes and other attributes, which may be set globally, or
specified on a per-object basis.  For example, the diameter of a circle
may be specified, or the radius of an arc.  An&nbsp;arc may be oriented
clockwise rather than counterclockwise by specifying the <code>cw</code>
attribute.  The line style of most objects may be altered by specifying
the <code>dashed</code> or <code>dotted</code> attribute.  Also, any object may be
labeled, by specifying one or more text strings as attributes.  A&nbsp;text string may contain escape sequences that shift the font, append
subscripts or superscripts, or include non-ASCII characters and
mathematical symbols.  See <a href="#Text%20String%20Format">Text String Format</a>.

   <p>Most sizes and positions are expressed in terms of `virtual inches'. 
The use of virtual inches is peculiar to <code>pic2plot</code>.  The graphics
display used by <code>pic2plot</code>, i.e., its drawing region, is defined to
be a square, 8&nbsp;virtual inches wide and 8&nbsp;virtual inches high. 
If the page size for the output file is the "letter" size, which is the
default for Postscript output, virtual inches will the same as real
inches.  But a different page size may be specified; for example, by
using the <code>--page-size a4</code> option.  If&nbsp;so, a virtual inch will
simply equal one-eighth of the width of the graphics display.  On&nbsp;A4
paper, the graphics display is a square of size 19.81cm.

   <p>By default, each figure is centered in the graphics display.  You may
turn off centering, so that you can use absolute coordinates, by using
the <code>-n</code> option.  For example, a figure consisting only of the
object <code>arrow from (8,8) to (4,4)</code> will be positioned in the
absence of centering so that the head of the arrow is at the center of
the display.  Its tail will be at the upper right corner.

   <p>The thickness of lines is not specified in terms of virtual inches.  For
compatibility with <code>gpic</code>, it is specified in terms of virtual
points.  The example above, which specifies the <code>thickness</code>
attribute of one of the objects, illustrates this.  There are 72&nbsp;virtual points per virtual inch.

   <p>If there is more than one figure to be displayed, they will appear in
different X&nbsp;windows, or on successive pages of the output file. 
Some output formats (such&nbsp;as PNG, PNM, pseudo-GIF, SVG, Illustrator,
and Fig) support only a single page of graphics.  If&nbsp;any of those
output formats is chosen, only the first figure will appear in the
output file.  Currently, <code>pic2plot</code> cannot produce animated
pseudo-GIFs.

   <p>The preceding survey does not do justice to the pic language, which is
actually a full-featured programming language, with support for
variables, looping constructs, etc.  Its advanced features make the
drawing of large, repetitive diagrams quite easy.

<div class="node">
<p><hr>
Node:&nbsp;<a name="pic2plot%20Invocation">pic2plot Invocation</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#pic2plot%20Environment">pic2plot Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pic2plot%20Introduction">pic2plot Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#pic2plot">pic2plot</a>
<br>
</div>

<h3 class="section">4.2 <code>pic2plot</code> command-line options</h3>

<p>The <code>pic2plot</code> program translates files in the pic language, which
is used for creating box-and-arrow diagrams of the kind frequently found
in technical papers and textbooks, to other graphics formats.  The
output format or display type is specified with the <code>-T</code> option. 
The possible output formats are the same formats that are supported by
the GNU <code>graph</code> and <code>plot</code> programs.

   <p>Input file names may be specified anywhere on the command line.  That
is, the relative order of file names and command-line options does not
matter.  If no files are specified, or the file name&nbsp;<code>-</code> is
specified, the standard input is read.  An output file is written to
standard output, unless the <code>-T X</code> option is specified.  In&nbsp;that case the output is displayed in one or more windows on an X&nbsp;Window System display, and there is no output file.

   <p>The full set of command-line options is listed below.  There are three
sorts of option:

     <ol type=1 start=1>
<li>General options. 
<li>Options relevant only to raw <code>pic2plot</code>, i.e., relevant only if no
display type or output format is specified with the <code>-T</code> option. 
<li>Options requesting information (e.g., <code>--help</code>).
        </ol>

<p>Each option that takes an argument is followed, in parentheses, by the
type and default value of the argument.

   <p>The following are general options.

     <dl>
<dt><code>-T </code><var>type</var><code></code>
     <dd><dt><code>--display-type </code><var>type</var><code></code>
     <dd>(String, default "meta".)  Select a display type or output format of
type <var>type</var>, which may be one of the strings "X", "png", "pnm",
"gif", "svg", "ai", "ps", "cgm", "fig", "pcl", "hpgl", "regis", "tek",
and "meta".  These refer respectively to the X&nbsp;Window&nbsp;System, PNG
format, portable anymap (PBM/PGM/PPM) format, pseudo-GIF format, the new
XML-based Scalable Vector Graphics format, the format used by Adobe
Illustrator, <code>idraw</code>-editable Postscript, the WebCGM format for
Web-based vector graphics, the format used by the <code>xfig</code> drawing
editor, the Hewlett-Packard PCL&nbsp;5 printer language, the
Hewlett-Packard Graphics Language (by&nbsp;default, HP-GL/2), the ReGIS
(remote graphics instruction set) format developed by&nbsp;DEC, Tektronix
format, and device-independent GNU graphics metafile format.

     <br><dt><code>-d</code>
     <dd><dt><code>--precision-dashing</code>
     <dd>Draw dashed and dotted lines carefully, i.e., draw each dash and dot as
a separately positioned object.  The default is to use the support for
dashed and dotted lines provided by the underlying graphics library, GNU
<code>libplot</code>.

     <p>This option may produce slightly better-looking dashed and dotted lines. 
However, it will come at a price: if an editable output file is produced
(i.e.,&nbsp;an output file in Illustrator, Postscript or Fig format),
it&nbsp;will be difficulty to modify its dashed and dotted lines with a
drawing editor.

     <br><dt><code>-f </code><var>font_size</var><code></code>
     <dd><dt><code>--font-size </code><var>font_size</var><code></code>
     <dd>(Float, default 0.0175.)  Set the size of the font used for rendering
text, as a fraction of the width of the graphics display, to
<var>font_size</var>.

     <br><dt><code>-F </code><var>font_name</var><code></code>
     <dd><dt><code>--font-name </code><var>font_name</var><code></code>
     <dd>(String, default "Helvetica" except for <code>pic2plot -T pcl</code>, for
which "Univers" is the default, and <code>pic2plot -T png</code>,
<code>pic2plot -T pnm</code>, <code>pic2plot -T gif</code>, <code>pic2plot -T hpgl</code>,
<code>pic2plot -T regis</code>, <code>pic2plot -T tek</code>, and raw
<code>pic2plot</code>, for all of which "HersheySerif" is the default.)  Set
the font used for text to <var>font_name</var>.  Font names are
case-insensitive.  If&nbsp;the specified font is not available, the
default font will be used.  Which fonts are available depends on which
<code>-T</code> option is used.  For a list of all fonts, see <a href="#Text%20Fonts">Text Fonts</a>.  The <code>plotfont</code> utility will produce a character map of any
available font.  See <a href="#plotfont">plotfont</a>.

     <br><dt><code>-n</code>
     <dd><dt><code>--no-centering</code>
     <dd>Turn off the automatic centering of each figure.  If this option is
specified, the position of the objects in each figure may be specified
in terms of absolute coordinates.  E.g., <code>line from (0,0) to (4,4)</code>
will draw a line segment from the lower left corner to the center of the
graphics display, since the display width and display height are defined
to equal 8&nbsp;virtual inches.

     <br><dt><code>-W </code><var>line_width</var><code></code>
     <dd><dt><code>--line-width </code><var>line_width</var><code></code>
     <dd>(Float, default -1.0.)  Set the default thickness of lines, as a
fraction of the size (i.e., minimum dimension) of the graphics display,
to <var>line_width</var>.  A&nbsp;negative value means that the default value
provided by the GNU <code>libplot</code> graphics library should be used. 
This is usually 1/850 times the size of the display, although if
<code>-T X</code>, <code>-T png</code>, <code>-T pnm</code>, or <code>-T gif</code> is
specified, it is zero.  By convention, a zero-thickness line is the
thinnest line that can be drawn.  This is the case in all output
formats.  Note, however, that the drawing editors <code>idraw</code> and
<code>xfig</code> treat zero-thickness lines as invisible.

     <p><code>pic2plot -T hpgl</code> does not support drawing lines with other than a
default thickness if the environment variable <code>HPGL_VERSION</code> is set
to a value less than&nbsp;"2" (the default).

     <br><dt><code>--bg-color </code><var>name</var><code></code>
     <dd>(String, default "white".)  Set the color used for the background to be
<var>name</var>.  This is relevant only to <code>pic2plot -T&nbsp;X</code>,
<code>pic2plot -T png</code>, <code>pic2plot -T pnm</code>, <code>pic2plot -T gif</code>,
<code>pic2plot -T cgm</code>, <code>pic2plot -T regis</code>, and <code>pic2plot -T
meta</code>.  An&nbsp;unrecognized name sets the color to the default.  For
information on what names are recognized, see <a href="#Color%20Names">Color Names</a>.  The
environment variable <code>BG_COLOR</code> can equally well be used to specify
the background color.

     <p>If the <code>-T png</code> or <code>-T gif</code> option is used, a transparent PNG
file or a transparent pseudo-GIF, respectively, may be produced by
setting the <code>TRANSPARENT_COLOR</code> environment variable to the name of
the background color.  See <a href="#pic2plot%20Environment">pic2plot Environment</a>.  If&nbsp;the <code>-T
svg</code> or <code>-T cgm</code> option is used, an output file without a
background may be produced by setting the background color to "none".

     <br><dt><code>--bitmap-size </code><var>bitmap_size</var><code></code>
     <dd>(String, default "570x570".)  Set the size of the graphics display in
which the plot will be drawn, in terms of pixels, to be
<var>bitmap_size</var>.  This is relevant only to <code>pic2plot -T&nbsp;X</code>,
<code>pic2plot -T png</code>, <code>pic2plot -T pnm</code>, and <code>pic2plot -T
gif</code>, for all of which the size can be expressed in terms of pixels. 
The environment variable <code>BITMAPSIZE</code> may equally well be used to
specify the size.

     <p>The graphics display used by <code>pic2plot -T X</code> is a popped-up X&nbsp;window.  Command-line positioning of this window on an X&nbsp;Window
System display is supported.  For example, if <var>bitmap_size</var> is
"570x570+0+0" then the window will be popped&nbsp;up in the upper left
corner.

     <p>If you choose a rectangular (non-square) window size, the fonts in the
plot will be scaled anisotropically, i.e., by different factors in the
horizontal and vertical direction.  For this, <code>pic2plot -T&nbsp;X</code>
requires an X11R6 display.  Any font that cannot be anisotropically
scaled will be replaced by a default scalable font, such as the Hershey
vector font "HersheySerif".

     <p>For backward compatibility, <code>pic2plot -T X</code> allows the user to set
the window size and position by setting the X&nbsp;resource
<code>Xplot.geometry</code>, instead of <code>--bitmap-size</code> or
<code>BITMAPSIZE</code>.

     <br><dt><code>--emulate-color </code><var>option</var><code></code>
     <dd>(String, default "no".)  If <var>option</var> is "yes", replace each color in
the output by an appropriate shade of gray.  This is seldom useful,
except when using <code>pic2plot -T pcl</code> to prepare output for a PCL&nbsp;5 device.  (Many monochrome PCL&nbsp;5 devices, such as monochrome
LaserJets, do a poor job of emulating color on their own.  They usually
map HP-GL/2's seven standard pen colors, including even yellow, to
black.)  You may equally well request color emulation by setting the
environment variable <code>EMULATE_COLOR</code> to "yes".

     <br><dt><code>--max-line-length </code><var>max_line_length</var><code></code>
     <dd>(Integer, default 500.)  Set the maximum number of points that a
polygonal line may contain, before it is flushed to the output device,
to equal <var>max_line_length</var>.  If this flushing occurs, the polygonal
line will be split into two or more sub-lines, though the splitting
should not be noticeable.

     <p>The reason for splitting long polygonal lines is that some display
devices (e.g., old Postscript printers and HP-GL pen plotters) have
limited buffer sizes.  The environment variable <code>MAX_LINE_LENGTH</code>
can also be used to specify the maximum line length.  This option has no
effect on raw <code>pic2plot</code>, since it draws polylines in real time and
has no buffer limitations.

     <br><dt><code>--page-size </code><var>pagesize</var><code></code>
     <dd>(String, default "letter".)  Set the size of the page on which the plot
will be positioned.  This is relevant only to <code>pic2plot -T svg</code>,
<code>pic2plot -T ai</code>, <code>pic2plot -T ps</code>, <code>pic2plot -T cgm</code>,
<code>pic2plot -T fig</code>, <code>pic2plot -T pcl</code>, and <code>pic2plot
-T hpgl</code>.  "letter" means an 8.5in by 11in page.  Any
ISO page size in the range "a0"<small class="dots">...</small>"a4" or ANSI page size in the
range "a"<small class="dots">...</small>"e" may be specified ("letter" is an alias for&nbsp;"a"
and "tabloid" is an alias for&nbsp;"b").  "legal", "ledger", and&nbsp;"b5"
are recognized page sizes also.  The environment variable
<code>PAGESIZE</code> can equally well be used to specify the page size.

     <p>For <code>pic2plot -T ai</code>, <code>pic2plot -T ps</code>, <code>pic2plot -T
pcl</code>, and <code>pic2plot -T fig</code>, the graphics display (or `viewport')
within which the plot is drawn will be, by default, a square region
centered on the specified page.  For <code>pic2plot -T hpgl</code>, it will be
a square region of the same size, but may be positioned differently. 
Either or both of the dimensions of the graphics display can be
specified explicitly.  For example, <var>pagesize</var> could be specified as
"letter,xsize=4in", or "a4,xsize=10cm,ysize=15cm".  The dimensions are
allowed to be negative (a&nbsp;negative dimension results in a
reflection).

     <p>The position of the graphics display, relative to its default position,
may optionally be adjusted by specifying an offset vector.  For example,
<var>pagesize</var> could be specified as "letter,yoffset=1.2in", or
"a4,xoffset=-5mm,yoffset=2.0cm".  It&nbsp;is also possible to
position the graphics display precisely, by specifying the location of
its lower left corner relative to the lower left corner of the page. 
For example, <var>pagesize</var> could be specified as
"letter,xorigin=2in,yorigin=3in", or "a4,xorigin=0.5cm,yorigin=0.5cm". 
The preceding options may be intermingled.  <code>pic2plot -T svg</code> and
<code>pic2plot -T cgm</code> ignore the "xoffset", "yoffset", "xorigin", and
"yorigin" options, since SVG format and WebCGM format have no notion of
the Web page on which the graphics display will ultimately be
positioned.  For more on page sizes, see <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

     <br><dt><code>--pen-color </code><var>name</var><code></code>
     <dd>(String, default "black".)  Set the pen color to be <var>name</var>.  An
unrecognized name sets the pen color to the default.  For information on
what color names are recognized, see <a href="#Color%20Names">Color Names</a>.

     <br><dt><code>--rotation </code><var>angle</var><code></code>
     <dd>(Integer, default 0.)  Set the rotation angle of the graphics display to
be <var>angle</var> degrees.  Recognized values are 0,&nbsp;90, 180, and&nbsp;270.  The rotation is counterclockwise.  The environment variable
<code>ROTATION</code> can equally well be used to specify the rotation angle.

     <p>This option is used for switching between portrait and landscape
orientations.  Postmodernists may also find it useful. 
</dl>

   <p>The following option is relevant only to raw <code>pic2plot</code>, i.e.,
relevant only if no display type or output format is specified with the
<code>-T</code> option.  In this case <code>pic2plot</code> outputs a graphics
metafile, which may be translated to other formats by invoking
<code>plot</code>.

     <dl>
<dt><code>-O</code>
     <dd><dt><code>--portable-output</code>
     <dd>Output the portable (human-readable) version of GNU metafile format,
rather than a binary version (the default).  This can also be requested
by setting the environment variable <code>META_PORTABLE</code> to "yes". 
</dl>

   <p>The following options request information.

     <dl>
<dt><code>--help</code>
     <dd>Print a list of command-line options, and then exit.

     <br><dt><code>--help-fonts</code>
     <dd>Print a table of available fonts, and then exit.  The table will depend
on which display type or output format is specified with the <code>-T</code>
option.  <code>pic2plot -T&nbsp;X</code>, <code>pic2plot -T svg</code>,
<code>pic2plot -T ai</code>, <code>pic2plot -T ps</code>, <code>pic2plot -T cgm</code>,
and <code>pic2plot -T fig</code> each support the 35 standard Postscript
fonts.  <code>pic2plot -T svg</code>, <code>pic2plot -T ai</code>, <code>pic2plot -T
pcl</code>, and <code>pic2plot -T hpgl</code> support the 45 standard PCL&nbsp;5
fonts, and <code>pic2plot -T pcl</code> and <code>pic2plot -T hpgl</code> support a
number of Hewlett-Packard vector fonts.  All of the preceding, together
with <code>pic2plot -T png</code>, <code>pic2plot -T pnm</code>, <code>pic2plot -T
gif</code>, <code>pic2plot -T regis</code>, and <code>pic2plot -T tek</code>, support a
set of 22 Hershey vector fonts.  Raw <code>pic2plot</code> in&nbsp;principle
supports any of these fonts, since its output must be translated to
other formats with <code>plot</code>.  The <code>plotfont</code> utility will
produce a character map of any available font.  See <a href="#plotfont">plotfont</a>.

     <br><dt><code>--list-fonts</code>
     <dd>Like <code>--help-fonts</code>, but lists the fonts in a single column to
facilitate piping to other programs.  If&nbsp;no display type or output
format is specified with the <code>-T</code> option, the full set of supported
fonts is listed.

     <br><dt><code>--version</code>
     <dd>Print the version number of <code>pic2plot</code> and the plotting utilities
package, and exit. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="pic2plot%20Environment">pic2plot Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pic2plot%20Invocation">pic2plot Invocation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#pic2plot">pic2plot</a>
<br>
</div>

<h3 class="section">4.3 Environment variables</h3>

<p>The behavior of <code>pic2plot</code> is affected by several environment
variables.  We have already mentioned the environment variables
<code>BITMAPSIZE</code>, <code>PAGESIZE</code>, <code>BG_COLOR</code>,
<code>EMULATE_COLOR</code>, <code>MAX_LINE_LENGTH</code>, and <code>ROTATION</code>. 
They serve as backups for the several options <code>--bitmap-size</code>,
<code>--page-size</code>, <code>--bg-color</code>, <code>--emulate-color</code>,
<code>--max-line-length</code>, and <code>--rotation</code>.  The remaining
environment variables are specific to individual output formats.

   <p><code>pic2plot -T&nbsp;X</code>, which pops up a window on an X&nbsp;Window
System display for each figure, checks the <code>DISPLAY</code> environment
variable.  The value of this variable determines the display on which
the windows will be popped&nbsp;up.

   <p><code>pic2plot -T png</code> and <code>pic2plot -T gif</code>, which produce output
in PNG format and pseudo-GIF format respectively, are affected by two
environment variables.  If the value of the <code>INTERLACE</code> variable is
"yes", the output file will be interlaced.  Also, if the value of the
<code>TRANSPARENT_COLOR</code> environment variable is the name of a color
that appears in the output file, that color will be treated as
transparent by most applications.  For information on what color names
are recognized, see <a href="#Color%20Names">Color Names</a>.

   <p><code>pic2plot -T pnm</code>, which produces output in Portable Anymap
(PBM/PGM/PPM) format, is affected by the <code>PNM_PORTABLE</code> environment
variable.  If its value is "yes", the output file will be in the
portable (human readable) version of PBM, PGM, or PPM format, rather
than the default (binary) version.

   <p><code>pic2plot -T cgm</code>, which produces CGM files that comply with the
WebCGM profile for Web-based vector graphics, is affected by two
environment variables.  By default, a version&nbsp;3 CGM file is
generated.  Many older CGM interpreters and viewers, such as the ones
built into Microsoft Office and other commercial software, only support
version&nbsp;1 CGM files.  The <code>CGM_MAX_VERSION</code> environment
variable may be set to "1", "2", "3", or&nbsp;"4" (the default) to
specify a maximum value for the version number.  The <code>CGM_ENCODING</code>
variable may also be set, to specify the type of encoding used in the
CGM file.  Supported values are "clear_text" (i.e., human readable) and
"binary" (the default).  The WebCGM profile requires that the binary
encoding be used.

   <p><code>pic2plot -T pcl</code>, which produces PCL&nbsp;5 output for
Hewlett-Packard printers, is affected by the environment variable
<code>PCL_ASSIGN_COLORS</code>.  It should be set to "yes" when producing
PCL&nbsp;5 output for a color printer or other color device.  This will
ensure accurate color reproduction by giving the output device complete
freedom in assigning colors, internally, to its "logical pens".  If it
is "no" then the device will use a fixed set of colored pens, and will
emulate other colors by shading.  The default is "no" because monochrome
PCL&nbsp;5 devices, which are more common than colored ones, must use
shading to emulate color.

   <p><code>pic2plot -T hpgl</code>, which produces Hewlett-Packard Graphics
Language output, is also affected by several environment variables.  The
most important is <code>HPGL_VERSION</code>, which may be set to "1", "1.5",
or&nbsp;"2" (the default).  "1"&nbsp;means that the output should be
generic HP-GL, "1.5"&nbsp;means that the output should be suitable for
the HP7550A graphics plotter and the HP758x, HP7595A and HP7596A
drafting plotters (HP-GL with some HP-GL/2 extensions), and "2"&nbsp;means that the output should be modern HP-GL/2.  If&nbsp;the version is
"1" or&nbsp;"1.5" then the only available fonts will be vector fonts, and
all lines will be drawn with a default thickness (the <code>-W</code> option
will not work).  Additionally, if the version is&nbsp;"1" then the
filling of arbitrary curves with solid color will not be supported
(circles and rectangles aligned with the coordinate axes may be filled,
though).

   <p>The position of the <code>pic2plot -T hpgl</code> graphics display on the page
can be rotated 90&nbsp;degrees counterclockwise by setting the
<code>HPGL_ROTATE</code> environment variable to "yes".  This is not the same
as the rotation obtained with the <code>--rotation</code> option, since it
both rotates the graphics display and repositions its lower left corner
toward another corner of the page.  Besides "no" and "yes", recognized
values for the <code>HPGL_ROTATE</code> variable are "0", "90", "180", and&nbsp;"270".  "no"&nbsp;and "yes" are equivalent to "0"&nbsp;and&nbsp;"90",
respectively.  "180" and "270" are supported only if <code>HPGL_VERSION</code>
is&nbsp;"2" (the default).

   <p><em>Opaque</em> filling and the drawing of visible white lines are
supported only if <code>HPGL_VERSION</code> is "2" (the default) and the
environment variable <code>HPGL_OPAQUE_MODE</code> is "yes" (the default). 
If&nbsp;the value is "no" then opaque filling will not be used, and white
lines (if&nbsp;any), which are normally drawn with pen&nbsp;#0, will not
be drawn.  This feature is to accommodate older HP-GL/2 devices. 
HP-GL/2 pen plotters, for&nbsp;example, do not support opacity or the use
of pen&nbsp;#0 to draw visible white lines.  Some older HP-GL/2 devices
reportedly malfunction if asked to draw opaque objects.

   <p>By&nbsp;default, <code>pic2plot -T hpgl</code> will draw with a fixed set of
pens.  Which pens are present may be specified by setting the
<code>HPGL_PENS</code> environment variable.  If <code>HPGL_VERSION</code> is&nbsp;"1", the default value of <code>HPGL_PENS</code> is "1=black"; if
<code>HPGL_VERSION</code> is "1.5" or&nbsp;"2", the default value of
<code>HPGL_PENS</code> is
"1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan".  The format
should be self-explanatory.  By setting <code>HPGL_PENS</code>, you may
specify a color for any pen in the range #1<small class="dots">...</small>#31.  For information
on what color names are recognized, see <a href="#Color%20Names">Color Names</a>.  Pen&nbsp;#1
must always be present, though it need not be black. Any other pen in
the range #1<small class="dots">...</small>#31 may be omitted.

   <p>If <code>HPGL_VERSION</code> is "2" then <code>pic2plot -T hpgl</code> will also be
affected by the environment variable <code>HPGL_ASSIGN_COLORS</code>.  If&nbsp;the value of this variable is "yes", then <code>plot -T hpgl</code> will not
be restricted to the palette specified in <code>HPGL_PENS</code>: it&nbsp;will
assign colors to "logical pens" in the range #1<small class="dots">...</small>#31, as&nbsp;needed.  The default value is "no" because other than color LaserJet
printers and DesignJet plotters, not many HP-GL/2 devices allow the
assignment of colors to logical pens.  In particular, HP-GL/2 pen
plotters do not.

   <p><code>pic2plot -T tek</code>, which produces output for a Tektronix terminal
or emulator, checks the <code>TERM</code> environment variable.  If&nbsp;the
value of <code>TERM</code> is a string beginning with "xterm", "nxterm", or
"kterm", it&nbsp;is taken as a sign that <code>pic2plot</code> is running in an
X&nbsp;Window System VT100 terminal emulator: an&nbsp;<code>xterm</code>,
<code>nxterm</code>, or <code>kterm</code>.  Before drawing graphics, <code>pic2plot
-T tek</code> will emit an escape sequence that causes the terminal emulator's
auxiliary Tektronix window, which is normally hidden, to pop&nbsp;up. 
After the graphics are drawn, an escape sequence that returns control to
the original VT100 window will be emitted.  The Tektronix window will
remain on the screen.

   <p>If the value of <code>TERM</code> is a string beginning with "kermit",
"ansi.sys", or "nansi.sys", it&nbsp;is taken as a sign that
<code>pic2plot</code> is running in the VT100 terminal emulator provided by
the MS-DOS version of <code>kermit</code>.  Before drawing graphics,
<code>pic2plot -T tek</code> will emit an escape sequence that switches the
terminal emulator to Tektronix mode.  Also, some of the Tektronix
control codes emitted by <code>pic2plot -T tek</code> will be
<code>kermit</code>-specific.  There will be a limited amount of color
support, which is not normally the case (the 16 <code>ansi.sys</code> colors
will be supported).  After drawing graphics, <code>pic2plot -T tek</code> will
emit an escape sequence that returns the emulator to VT100 mode.  The
key sequence `ALT&nbsp;minus' can be employed manually within
<code>kermit</code> to switch between the two modes.

<div class="node">
<p><hr>
Node:&nbsp;<a name="tek2plot">tek2plot</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#plotfont">plotfont</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pic2plot">pic2plot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">5 The <code>tek2plot</code> Program</h2>

<ul class="menu">
<li><a accesskey="1" href="#tek2plot%20Introduction">tek2plot Introduction</a>:      What tek2plot is used for
<li><a accesskey="2" href="#tek2plot%20Invocation">tek2plot Invocation</a>:        Command-line options
<li><a accesskey="3" href="#tek2plot%20Environment">tek2plot Environment</a>:       Environment variables
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="tek2plot%20Introduction">tek2plot Introduction</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#tek2plot%20Invocation">tek2plot Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tek2plot">tek2plot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#tek2plot">tek2plot</a>
<br>
</div>

<h3 class="section">5.1 What <code>tek2plot</code> is used for</h3>

<p>GNU <code>tek2plot</code> is a command-line Tektronix translator.  It displays
Tektronix graphics files, or translates them to other formats.  The
<code>-T</code> option is used to specify the output format or display type. 
Supported output formats include "X", "png", "pnm", "gif", "svg", "ai",
"ps", "cgm", "fig", "pcl", "hpgl", "regis", "tek", and "meta" (the
default).  These are the same formats that are supported by the GNU
<code>graph</code>, <code>plot</code>, and <code>pic2plot</code> programs. 
<code>tek2plot</code> will take input from a file specified on the command
line or from standard input, just as the plot filter <code>plot</code> does.

   <p>Tektronix graphics files are produced by many older applications, such
as <a href="http://tdc-www.harvard.edu/software/skymap">SKYMAP</a>, a powerful
astronomical display program.  A&nbsp;directory containing sample
Tektronix graphics files, which you may experiment with, is distributed
along with the GNU plotting utilities.  On&nbsp;most systems it is
installed as <code>/usr/share/tek2plot</code> or
<code>/usr/local/share/tek2plot</code>.

   <p>Tektronix graphics format is defined as a noninteractive version of the
graphics format understood by Tektronix 4010/4014 terminals, as
documented in the <cite>4014 Service Manual</cite>, Tektronix Inc., 1974
(Tektronix Part #070-1648-00).  <code>tek2plot</code> does not support
interactive features such as graphics input mode ("GIN mode") or
status enquiry.  However, it does support a few additional features
provided by popular Tektronix emulators, such as the color extensions
supported by the Tektronix emulator contained in the MS-DOS version of
<code>kermit</code>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="tek2plot%20Invocation">tek2plot Invocation</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#tek2plot%20Environment">tek2plot Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tek2plot%20Introduction">tek2plot Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#tek2plot">tek2plot</a>
<br>
</div>

<h3 class="section">5.2 <code>tek2plot</code> command-line options</h3>

<p>The <code>tek2plot</code> program translates the Tektronix graphics files
produced by many older applications to other formats.  The output format
or display type is specified with the <code>-T</code> option.  The possible
output formats are the same formats that are supported by the GNU
<code>graph</code>, <code>plot</code>, and <code>pic2plot</code> programs.

   <p>Input file names may be specified anywhere on the command line.  That
is, the relative order of file names and command-line options does not
matter.  If no files are specified, or the file name&nbsp;<code>-</code> is
specified, the standard input is read.  An output file is written to
standard output, unless the <code>-T X</code> option is specified.  In&nbsp;that case the output is displayed in one or more windows on an X&nbsp;Window System display, and there is no output file.

   <p>The full set of command-line options is listed below.  There are three
sorts of option:

     <ol type=1 start=1>
<li>General options. 
<li>Options relevant only to raw <code>tek2plot</code>, i.e., relevant only if no
display type or output format is specified with the <code>-T</code> option. 
<li>Options requesting information (e.g., <code>--help</code>).
        </ol>

<p>Each option that takes an argument is followed, in parentheses, by the
type and default value of the argument.

   <p>The following are general options.

     <dl>
<dt><code>-T </code><var>type</var><code></code>
     <dd><dt><code>--display-type </code><var>type</var><code></code>
     <dd>(String, default "meta".)  Select a display type or output format of
type <var>type</var>, which may be one of the strings "X", "png", "pnm",
"gif", "svg", "ai", "ps", "cgm", "fig", "pcl", "hpgl", "regis", "tek",
and "meta".  These refer respectively to the X&nbsp;Window&nbsp;System, PNG
format, portable anymap (PBM/PGM/PPM) format, pseudo-GIF format, the new
XML-based Scalable Vector Graphics format, the format used by Adobe
Illustrator, <code>idraw</code>-editable Postscript, the WebCGM format for
Web-based vector graphics, the format used by the <code>xfig</code> drawing
editor, the Hewlett-Packard PCL&nbsp;5 printer language, the
Hewlett-Packard Graphics Language (by&nbsp;default, HP-GL/2), the ReGIS
(remote graphics instruction set) format developed by&nbsp;DEC, Tektronix
format, and device-independent GNU graphics metafile format.

     <br><dt><code>-p </code><var>n</var><code></code>
     <dd><dt><code>--page-number </code><var>n</var><code></code>
     <dd>(Nonnegative integer.) Display only page number <var>n</var>, within the
Tektronix file or sequence of Tektronix files that is being translated. 
Tektronix files may consist of one or more pages, numbered beginning
with zero.

     <p>The default behavior, if the <code>-p</code> option is not used, is to display
all nonempty pages in succession.  For example, <code>tek2plot -T&nbsp;X</code>
displays each page in its own X&nbsp;window.  If&nbsp;the <code>-T png</code>
option, the <code>-T pnm</code> option, the <code>-T gif</code> option, the <code>-T
svg</code> option, the <code>-T ai</code> option, or the <code>-T fig</code> option is
used, the default behavior is to display only the first page, since
files in PNG, PNM, pseudo-GIF, SVG, AI, or Fig format may contain only a
single page of graphics.

     <p>Most Tektronix files consist of either one page (page #0) or
two pages (an&nbsp;empty page&nbsp;#0, and page&nbsp;#1).  Tektronix files
produced by the GNU plotting utilities (e.g., by <code>graph -T tek</code>)
are normally of the latter sort.

     <br><dt><code>-F </code><var>font_name</var><code></code>
     <dd><dt><code>--font-name </code><var>font_name</var><code></code>
     <dd>(String, default "Courier" except for <code>tek2plot -T png</code>,
<code>tek2plot -T pnm</code>, <code>tek2plot -T gif</code>, <code>tek2plot -T hpgl</code>,
<code>tek2plot -T regis</code>, and raw <code>tek2plot</code>, for all of which
"HersheySerif" is the default.)  Set the font used for text to
<var>font_name</var>.  Font names are case-insensitive.  If&nbsp;a font
outside the Courier family is chosen, the <code>--position-chars</code> option
(see below) should probably be used.  For a list of all fonts, see
<a href="#Text%20Fonts">Text Fonts</a>.  If&nbsp;the specified font is not available, the
default font will be used.

     <p>If you intend to print a PCL&nbsp;5 file prepared with <code>tek2plot -T
pcl</code> on a LaserJet III, you should specify a font other than Courier. 
That is because the LaserJet III, which was Hewlett-Packard's first
PCL&nbsp;5 printer, did not come with a scalable Courier typeface.  The
only PCL&nbsp;5 fonts it supported were the eight fonts in the CGTimes
and Univers families.  See <a href="#Text%20Fonts">Text Fonts</a>.

     <br><dt><code>-W </code><var>line_width</var><code></code>
     <dd><dt><code>--line-width </code><var>line_width</var><code></code>
     <dd>(Float, default -1.0.)  Set the thickness of lines, as a fraction
of the size (i.e., minimum dimension) of the graphics display, to
<var>line_width</var>.  A&nbsp;negative value means that the default value
provided by the GNU <code>libplot</code> graphics library should be used. 
This is usually 1/850 times the size of the display, although if
<code>-T X</code>, <code>-T png</code>, <code>-T pnm</code>, or <code>-T gif</code> is
specified, it is zero.  By convention, a zero-thickness line is the
thinnest line that can be drawn.  This is the case in all output
formats.  Note, however, that the drawing editors <code>idraw</code> and
<code>xfig</code> treat zero-thickness lines as invisible.

     <p><code>tek2plot -T regis</code> does not support drawing lines with other than
a default thickness, and <code>tek2plot -T hpgl</code> does not support doing
so if the environment variable <code>HPGL_VERSION</code> is set to a value
less than&nbsp;"2" (the default).

     <br><dt><code>--bg-color </code><var>name</var><code></code>
     <dd>(String, default "white".)  Set the color used for the background to be
<var>name</var>.  This is relevant only to <code>tek2plot -T&nbsp;X</code>,
<code>tek2plot -T png</code>, <code>tek2plot -T pnm</code>, <code>tek2plot -T gif</code>,
<code>tek2plot -T cgm</code>, <code>tek2plot -T regis</code>, and <code>tek2plot -T
meta</code>.  An&nbsp;unrecognized name sets the color to the default.  For
information on what names are recognized, see <a href="#Color%20Names">Color Names</a>.  The
environment variable <code>BG_COLOR</code> can equally well be used to specify
the background color.

     <p>If the <code>-T png</code> or <code>-T gif</code> option is used, a transparent PNG
file or a transparent pseudo-GIF, respectively, may be produced by
setting the <code>TRANSPARENT_COLOR</code> environment variable to the name of
the background color.  See <a href="#tek2plot%20Environment">tek2plot Environment</a>.  If&nbsp;the <code>-T
svg</code> or <code>-T cgm</code> option is used, an output file without a
background may be produced by setting the background color to "none".

     <br><dt><code>--bitmap-size </code><var>bitmap_size</var><code></code>
     <dd>(String, default "570x570".)  Set the size of the graphics display in
which the plot will be drawn, in terms of pixels, to be
<var>bitmap_size</var>.  This is relevant only to <code>tek2plot -T&nbsp;X</code>,
<code>tek2plot -T png</code>, <code>tek2plot -T pnm</code>, and <code>tek2plot -T
gif</code>, for all of which the size can be expressed in terms of pixels. 
The environment variable <code>BITMAPSIZE</code> may equally well be used to
specify the size.

     <p>The graphics display used by <code>tek2plot -T X</code> is a popped-up X&nbsp;window.  Command-line positioning of this window on an X&nbsp;Window
System display is supported.  For example, if <var>bitmap_size</var> is
"570x570+0+0" then the window will be popped&nbsp;up in the upper left
corner.

     <p>If you choose a rectangular (non-square) window size, the fonts in the
plot will be scaled anisotropically, i.e., by different factors in the
horizontal and vertical direction.  For this, <code>tek2plot -T&nbsp;X</code>
requires an X11R6 display.  Any font that cannot be anisotropically
scaled will be replaced by a default scalable font, such as the Hershey
vector font "HersheySerif".

     <p>For backward compatibility, <code>tek2plot -T X</code> allows the user to set
the window size and position by setting the X&nbsp;resource
<code>Xplot.geometry</code>, instead of <code>--bitmap-size</code> or
<code>BITMAPSIZE</code>.

     <br><dt><code>--emulate-color </code><var>option</var><code></code>
     <dd>(String, default "no".)  If <var>option</var> is "yes", replace each color in
the output by an appropriate shade of gray.  This is seldom useful,
except when using <code>tek2plot -T pcl</code> to prepare output for a PCL&nbsp;5 device.  (Many monochrome PCL&nbsp;5 devices, such as monochrome
LaserJets, do a poor job of emulating color on their own.  They usually
map HP-GL/2's seven standard pen colors, including even yellow, to
black.)  You may equally well request color emulation by setting the
environment variable <code>EMULATE_COLOR</code> to "yes".

     <br><dt><code>--max-line-length </code><var>max_line_length</var><code></code>
     <dd>(Integer, default 500.)  Set the maximum number of points that a
polygonal line may contain, before it is flushed to the output device,
to equal <var>max_line_length</var>.  If this flushing occurs, the polygonal
line will be split into two or more sub-lines, though the splitting
should not be noticeable.

     <p>The reason for splitting long polygonal lines is that some display
devices (e.g., old Postscript printers and HP-GL pen plotters) have
limited buffer sizes.  The environment variable <code>MAX_LINE_LENGTH</code>
can also be used to specify the maximum line length.  This option has no
effect on raw <code>tek2plot</code>, since it draws polylines in real time and
has no buffer limitations.

     <br><dt><code>--page-size </code><var>pagesize</var><code></code>
     <dd>(String, default "letter".)  Set the size of the page on which the plot
will be positioned.  This is relevant only to <code>tek2plot -T svg</code>,
<code>tek2plot -T ai</code>, <code>tek2plot -T ps</code>, <code>tek2plot -T cgm</code>,
<code>tek2plot -T fig</code>, <code>tek2plot -T pcl</code>, and <code>tek2plot
-T hpgl</code>.  "letter" means an 8.5in by 11in page.  Any
ISO page size in the range "a0"<small class="dots">...</small>"a4" or ANSI page size in the
range "a"<small class="dots">...</small>"e" may be specified ("letter" is an alias for&nbsp;"a"
and "tabloid" is an alias for&nbsp;"b").  "legal", "ledger", and&nbsp;"b5"
are recognized page sizes also.  The environment variable
<code>PAGESIZE</code> can equally well be used to specify the page size.

     <p>For <code>tek2plot -T ai</code>, <code>tek2plot -T ps</code>, <code>tek2plot -T
pcl</code>, and <code>tek2plot -T fig</code>, the graphics display (or `viewport')
within which the plot is drawn will be, by default, a square region
centered on the specified page.  For <code>tek2plot -T hpgl</code>, it will be
a square region of the same size, but may be positioned differently. 
Either or both of the dimensions of the graphics display can be
specified explicitly.  For example, <var>pagesize</var> could be specified as
"letter,xsize=4in", or "a4,xsize=10cm,ysize=15cm".  The dimensions are
allowed to be negative (a&nbsp;negative dimension results in a
reflection).

     <p>The position of the graphics display, relative to its default position,
may optionally be adjusted by specifying an offset vector.  For example,
<var>pagesize</var> could be specified as "letter,yoffset=1.2in", or
"a4,xoffset=-5mm,yoffset=2.0cm".  It&nbsp;is also possible to
position the graphics display precisely, by specifying the location of
its lower left corner relative to the lower left corner of the page. 
For example, <var>pagesize</var> could be specified as
"letter,xorigin=2in,yorigin=3in", or "a4,xorigin=0.5cm,yorigin=0.5cm". 
The preceding options may be intermingled.  <code>tek2plot -T svg</code> and
<code>tek2plot -T cgm</code> ignore the "xoffset", "yoffset", "xorigin", and
"yorigin" options, since SVG format and WebCGM format have no notion of
the Web page on which the graphics display will ultimately be
positioned.  For more on page sizes, see <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

     <br><dt><code>--pen-color </code><var>name</var><code></code>
     <dd>(String, default "black".)  Set the pen color to be <var>name</var>.  An
unrecognized name sets the pen color to the default.  For information on
what color names are recognized, see <a href="#Color%20Names">Color Names</a>.

     <br><dt><code>--position-chars</code>
     <dd>Position the characters in each text string individually on the display. 
If&nbsp;the text font is not a member of the Courier family, and
especially if it is not a fixed-width font, this option is recommended. 
It&nbsp;will improve the appearance of text strings, at the price of
making it difficult to edit the output file with <code>xfig</code> or
<code>idraw</code>.

     <br><dt><code>--rotation </code><var>angle</var><code></code>
     <dd>(Integer, default 0.)  Set the rotation angle of the graphics display to
be <var>angle</var> degrees.  Recognized values are 0,&nbsp;90, 180, and&nbsp;270.  The rotation is counterclockwise.  The environment variable
<code>ROTATION</code> can equally well be used to specify the rotation angle.

     <p>This option is used for switching between portrait and landscape
orientations.  Postmodernists may also find it useful.

     <br><dt><code>--use-tek-fonts</code>
     <dd>Use the bitmap fonts that were used on the original Tektronix 4010/4014
terminal.  This option is relevant only to <code>tek2plot -T&nbsp;X</code>. 
The four relevant bitmap fonts are distributed with most versions of the
plotting utilities package, under the names
<code>tekfont0</code><small class="dots">...</small><code>tekfont3</code>.  They may easily be installed on
any modern X&nbsp;Window System display.  For this option to work
properly, you must also select a window size of 1024x1024 pixels, either
by using the <code>--bitmap-size 1024x1024</code> option or by setting the
value of the <code>Xplot.geometry</code> resource.  The reason for this
restriction is that bitmap fonts, unlike the scalable fonts that the
plotting utilities normally use, cannot be rescaled.

     <p>This option is useful only if you have a file in Tektronix format that
draws text using native Tektronix fonts.  Tektronix files produced by
the GNU plotting utilities (e.g., by <code>graph -T tek</code>) do&nbsp;not use
native Tektronix fonts to draw text. 
</dl>

   <p>The following option is relevant only to raw <code>tek2plot</code>, i.e.,
relevant only if no display type or output format is specified with the
<code>-T</code> option.  In this case <code>tek2plot</code> outputs a graphics
metafile, which may be translated to other formats by invoking
<code>plot</code>.

     <dl>
<dt><code>-O</code>
     <dd><dt><code>--portable-output</code>
     <dd>Output the portable (human-readable) version of GNU metafile format,
rather than a binary version (the default).  This can also be requested
by setting the environment variable <code>META_PORTABLE</code> to "yes". 
</dl>

   <p>The following options request information.

     <dl>
<dt><code>--help</code>
     <dd>Print a list of command-line options, and then exit.

     <br><dt><code>--help-fonts</code>
     <dd>Print a table of available fonts, and then exit.  The table will depend
on which display type or output format is specified with the <code>-T</code>
option.  <code>tek2plot -T&nbsp;X</code>, <code>tek2plot -T svg</code>,
<code>tek2plot -T ai</code>, <code>tek2plot -T ps</code>, <code>tek2plot -T cgm</code>,
and <code>tek2plot -T fig</code> each support the 35 standard Postscript
fonts.  <code>tek2plot -T svg</code>, <code>tek2plot -T ai</code>, <code>tek2plot -T
pcl</code>, and <code>tek2plot -T hpgl</code> support the 45 standard PCL&nbsp;5
fonts, and <code>tek2plot -T pcl</code> and <code>tek2plot -T hpgl</code> support a
number of Hewlett-Packard vector fonts.  All of the preceding, together
with <code>tek2plot -T png</code>, <code>tek2plot -T pnm</code>, <code>tek2plot -T
gif</code>, <code>tek2plot -T regis</code>, and <code>tek2plot -T tek</code>, support a
set of 22 Hershey vector fonts.  Raw <code>tek2plot</code> in&nbsp;principle
supports any of these fonts, since its output must be translated to
other formats with <code>plot</code>.  The <code>plotfont</code> utility will
produce a character map of any available font.  See <a href="#plotfont">plotfont</a>.

     <br><dt><code>--list-fonts</code>
     <dd>Like <code>--help-fonts</code>, but lists the fonts in a single column to
facilitate piping to other programs.  If&nbsp;no display type or output
format is specified with the <code>-T</code> option, the full set of supported
fonts is listed.

     <br><dt><code>--version</code>
     <dd>Print the version number of <code>tek2plot</code> and the plotting utilities
package, and exit. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="tek2plot%20Environment">tek2plot Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tek2plot%20Invocation">tek2plot Invocation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#tek2plot">tek2plot</a>
<br>
</div>

<h3 class="section">5.3 Environment variables</h3>

<p>The behavior of <code>tek2plot</code> is affected by several environment
variables, which are the same as those that affect <code>graph</code> and
<code>plot</code>.  For convenience, we list them here.

   <p>We have already mentioned the environment variables <code>BITMAPSIZE</code>,
<code>PAGESIZE</code>, <code>BG_COLOR</code>, <code>EMULATE_COLOR</code>,
<code>MAX_LINE_LENGTH</code>, and <code>ROTATION</code>.  They serve as backups for
the several options <code>--bitmap-size</code>, <code>--page-size</code>,
<code>--bg-color</code>, <code>--emulate-color</code>, <code>--max-line-length</code>, and
<code>--rotation</code>.  The remaining environment variables are specific to
individual output formats.

   <p><code>tek2plot -T&nbsp;X</code>, which pops up a window on an X&nbsp;Window
System display and draws graphics in&nbsp;it, checks the <code>DISPLAY</code>
environment variable.  The value of this variable determines the display
on which the window will be popped&nbsp;up.

   <p><code>tek2plot -T png</code> and <code>tek2plot -T gif</code>, which produce output
in PNG format and pseudo-GIF format respectively, are affected by two
environment variables.  If the value of the <code>INTERLACE</code> variable is
"yes", the output file will be interlaced.  Also, if the value of the
<code>TRANSPARENT_COLOR</code> environment variable is the name of a color
that appears in the output file, that color will be treated as
transparent by most applications.  For information on what color names
are recognized, see <a href="#Color%20Names">Color Names</a>.

   <p><code>tek2plot -T pnm</code>, which produces output in Portable Anymap
(PBM/PGM/PPM) format, is affected by the <code>PNM_PORTABLE</code> environment
variable.  If its value is "yes", the output file will be in the
portable (human readable) version of PBM, PGM, or PPM format, rather
than the default (binary) version.

   <p><code>tek2plot -T cgm</code>, which produces CGM files that comply with the
WebCGM profile for Web-based vector graphics, is affected by two
environment variables.  By default, a version&nbsp;3 CGM file is
generated.  Many older CGM interpreters and viewers, such as the ones
built into Microsoft Office and other commercial software, only support
version&nbsp;1 CGM files.  The <code>CGM_MAX_VERSION</code> environment
variable may be set to "1", "2", "3", or&nbsp;"4" (the default) to
specify a maximum value for the version number.  The <code>CGM_ENCODING</code>
variable may also be set, to specify the type of encoding used in the
CGM file.  Supported values are "clear_text" (i.e., human readable) and
"binary" (the default).  The WebCGM profile requires that the binary
encoding be used.

   <p><code>tek2plot -T pcl</code>, which produces PCL&nbsp;5 output for
Hewlett-Packard printers, is affected by the environment variable
<code>PCL_ASSIGN_COLORS</code>.  It should be set to "yes" when producing
PCL&nbsp;5 output for a color printer or other color device.  This will
ensure accurate color reproduction by giving the output device complete
freedom in assigning colors, internally, to its "logical pens".  If it
is "no" then the device will use a fixed set of colored pens, and will
emulate other colors by shading.  The default is "no" because monochrome
PCL&nbsp;5 devices, which are more common than colored ones, must use
shading to emulate color.

   <p><code>tek2plot -T hpgl</code>, which produces Hewlett-Packard Graphics
Language output, is also affected by several environment variables.  The
most important is <code>HPGL_VERSION</code>, which may be set to "1", "1.5",
or&nbsp;"2" (the default).  "1"&nbsp;means that the output should be
generic HP-GL, "1.5"&nbsp;means that the output should be suitable for
the HP7550A graphics plotter and the HP758x, HP7595A and HP7596A
drafting plotters (HP-GL with some HP-GL/2 extensions), and "2"&nbsp;means that the output should be modern HP-GL/2.  If&nbsp;the version is
"1" or&nbsp;"1.5" then the only available fonts will be vector fonts, and
all lines will be drawn with a default thickness (the <code>-W</code> option
will not work).

   <p>The position of the <code>tek2plot -T hpgl</code> graphics display on the page
can be rotated 90&nbsp;degrees counterclockwise by setting the
<code>HPGL_ROTATE</code> environment variable to "yes".  This is not the same
as the rotation obtained with the <code>--rotation</code> option, since it
both rotates the graphics display and repositions its lower left corner
toward another corner of the page.  Besides "no" and "yes", recognized
values for the <code>HPGL_ROTATE</code> variable are "0", "90", "180", and&nbsp;"270".  "no"&nbsp;and "yes" are equivalent to "0"&nbsp;and&nbsp;"90",
respectively.  "180" and "270" are supported only if <code>HPGL_VERSION</code>
is&nbsp;"2" (the default).

   <p>The drawing of visible white lines is supported only if
<code>HPGL_VERSION</code> is "2" and the environment variable
<code>HPGL_OPAQUE_MODE</code> is "yes" (the default).  If&nbsp;the value is
"no" then white lines (if&nbsp;any), which are normally drawn with pen&nbsp;#0, will not be drawn.  This feature is to accommodate older HP-GL/2
devices.  HP-GL/2 pen plotters, for&nbsp;example, do not support the use
of pen&nbsp;#0 to draw visible white lines.  Some older HP-GL/2 devices
may, in&nbsp;fact, malfunction if asked to draw opaque objects.

   <p>By&nbsp;default, <code>tek2plot -T hpgl</code> will draw with a fixed set of
pens.  Which pens are present may be specified by setting the
<code>HPGL_PENS</code> environment variable.  If <code>HPGL_VERSION</code> is&nbsp;"1", the default value of <code>HPGL_PENS</code> is "1=black"; if
<code>HPGL_VERSION</code> is "1.5" or&nbsp;"2", the default value of
<code>HPGL_PENS</code> is
"1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan".  The format
should be self-explanatory.  By setting <code>HPGL_PENS</code>, you may
specify a color for any pen in the range #1<small class="dots">...</small>#31.  For information
on what color names are recognized, see <a href="#Color%20Names">Color Names</a>.  Pen&nbsp;#1
must always be present, though it need not be black. Any other pen in
the range #1<small class="dots">...</small>#31 may be omitted.

   <p>If <code>HPGL_VERSION</code> is "2" then <code>tek2plot -T hpgl</code> will also be
affected by the environment variable <code>HPGL_ASSIGN_COLORS</code>.  If&nbsp;the value of this variable is "yes", then <code>tek2plot -T hpgl</code> will
not be restricted to the palette specified in <code>HPGL_PENS</code>: it&nbsp;will assign colors to "logical pens" in the range #1<small class="dots">...</small>#31, as&nbsp;needed.  The default value is "no" because other than color LaserJet
printers and DesignJet plotters, not many HP-GL/2 devices allow the
assignment of colors to logical pens.  In particular, HP-GL/2 pen
plotters do not.

<div class="node">
<p><hr>
Node:&nbsp;<a name="plotfont">plotfont</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#spline">spline</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tek2plot">tek2plot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">6 The <code>plotfont</code> Utility</h2>

<ul class="menu">
<li><a accesskey="1" href="#plotfont%20Examples">plotfont Examples</a>:          How to use plotfont
<li><a accesskey="2" href="#plotfont%20Invocation">plotfont Invocation</a>:        Command-line options
<li><a accesskey="3" href="#plotfont%20Environment">plotfont Environment</a>:       Environment variables
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="plotfont%20Examples">plotfont Examples</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#plotfont%20Invocation">plotfont Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plotfont">plotfont</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#plotfont">plotfont</a>
<br>
</div>

<h3 class="section">6.1 How to use <code>plotfont</code></h3>

<p>GNU <code>plotfont</code> is a simple utility that will produce a character
map for any font available to the GNU plotting utilities <code>graph</code>,
<code>plot</code>, <code>pic2plot</code>, and <code>tek2plot</code>, and the GNU
<code>libplot</code> graphics library on which they are based.  The map may be
displayed on an X&nbsp;Window System display, or produced in any of
several output formats.  The <code>-T</code> option is used to specify the
desired output format.  Supported output formats include "X", "png",
"pnm", "gif", "svg", "ai", "ps", "cgm", "fig", "pcl", "hpgl", "regis",
"tek", and "meta" (the default).

   <p>Which fonts are available depends on the choice of display or output
format.  To&nbsp;get a list of the available fonts, use the
<code>--help-fonts</code> option.  For example,

<pre class="example">     plotfont -T ps --help-fonts
     </pre>

<p>will list the fonts that are available when producing Postscript output. 
One of these fonts is "Times-Roman".  Doing

<pre class="example">     plotfont -T ps Times-Roman &gt; map.ps
     </pre>

<p>will produce a character map of the lower half of this font, which
consists of printable ASCII characters.  The map will be a 12x8 grid,
with a character centered in each grid cell.  If you include the
<code>-2</code> option, you will get a map of the upper half of the font.

   <p>Most built-in fonts are ISO-Latin-1 fonts, which means that the upper
half is arranged according to the ISO-Latin-1 encoding.  The
"HersheyCyrillic" font is one that is not.  If you do

<pre class="example">     plotfont -T ps -2 HersheyCyrillic &gt; map.ps
     </pre>

<p>you will get a map that illustrates its arrangment, which is called
KOI8-R.  The KOI8-R arrangement is the standard for Unix and
networking applications in the former Soviet Union.  So-called dingbats
fonts, such as "ZapfDingbats" and "Wingdings", also have an
individualistic layout.  In most installations of the plotting
utilities, the Wingdings font is not available when producing Postscript
output.  However, it&nbsp;is available when producing output in PCL&nbsp;5
or HP-GL/2 format.  If you do

<pre class="example">     plotfont -T hpgl Wingdings &gt; map.plt
     </pre>

<p>you will get a Wingdings character map, in HP-GL/2 format, that may be
imported into any application that understands HP-GL/2.  Similarly,
<code>plot -T pcl Wingdings</code> will produce a Wingdings character map in
PCL&nbsp;5 format, which may be printed on a LaserJet or other PCL&nbsp;5
device.

   <p>In all, more than a hundred fonts are built into the plotting utilities. 
See <a href="#Text%20Fonts">Text Fonts</a>.  Actually, if you are using the plotting utilities to
display output on an X&nbsp;display, you are not restricted to the
built-in fonts.  Doing

<pre class="example">     plotfont -T X --help-fonts
     </pre>

<p>produces a list of the built-in fonts that are available, including both
Hershey and Postscript fonts.  But fonts available on your X&nbsp;display
may also be used.  The <code>xlsfonts</code> command will list the fonts
available on your X&nbsp;display, most font names being given in what is
called XLFD format.  The plotting utilities refer to X&nbsp;fonts by
shortened versions of their XLFD names.  For example, the font
"Utopia-Regular" is available on many X&nbsp;displays.  Its XLFD name is
"-adobe-utopia-medium-r-normal-0-0-0-0-p-0-iso8859-1", and its
shortened XLFD name is "utopia-medium-r-normal".  If you do

<pre class="example">     plotfont -T X utopia-medium-r-normal
     </pre>

<p>then a character map for this font will be displayed in a popped-up
X&nbsp;window.

   <p>When using the <code>-T X</code> option, you may also use the
<code>--bitmap-size</code> option to choose the size of the popped-up window. 
Modern X&nbsp;displays can scale fonts by different amounts in the
horizontal and vertical directions.  If, for example, you add
<code>--bitmap-size 600x300</code> to the above command line, both the
character map and the Utopia-Regular font within&nbsp;it will be scaled
in this way.  If&nbsp;your X&nbsp;display does not support font scaling,
a&nbsp;scalable font will be substituted.

<div class="node">
<p><hr>
Node:&nbsp;<a name="plotfont%20Invocation">plotfont Invocation</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#plotfont%20Environment">plotfont Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plotfont%20Examples">plotfont Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#plotfont">plotfont</a>
<br>
</div>

<h3 class="section">6.2 <code>plotfont</code> command-line options</h3>

<p>The <code>plotfont</code> font display utility will produce a character map
for any of the fonts available to the GNU plotting utilities
<code>graph</code>, <code>plot</code>, <code>pic2plot</code>, and <code>tek2plot</code>, and the
GNU <code>libplot</code> graphics library on which they are based.  The map
may be produced in any supported output format, or displayed on an X&nbsp;Window System display.  The output format or display type is specified
with the <code>-T</code> option.

   <p>The names of the fonts for which a character map will be produced may
appear anywhere on the <code>plotfont</code> command line.  That is, the
relative order of font names and command-line options does not matter. 
The character map is written to standard output, unless the <code>-T X</code>
option is specified.  In&nbsp;that case the character map is displayed in
a window on an X&nbsp;Window System display, and there is no output file.

   <p>The possible options are listed below.  There are three sorts of option:

     <ol type=1 start=1>
<li>General options. 
<li>Options relevant only to raw <code>plotfont</code>, i.e., relevant only if no
display type or output format is specified with the <code>-T</code> option. 
<li>Options requesting information (e.g., <code>--help</code>).
        </ol>

<p>Each option that takes an argument is followed, in parentheses, by the
type and default value of the argument.

   <p>The following are general options.

     <dl>
<dt><code>-1</code>
     <dd><dt><code>--lower-half</code>
     <dd>Generate a character map for the lower half of each specified font. 
This is the default.

     <br><dt><code>-2</code>
     <dd><dt><code>--upper-half</code>
     <dd>Generate a character map for the upper half of each specified font.

     <br><dt><code>-o</code>
     <dd><dt><code>--octal</code>
     <dd>Number the characters in octal rather than in decimal (the default).

     <br><dt><code>-x</code>
     <dd><dt><code>--hexadecimal</code>
     <dd>Number the characters in hexadecimal rather than in decimal (the default).

     <br><dt><code>--box</code>
     <dd>Surround each character with a box, showing its extent to left and
right.  The default is not to do this.

     <br><dt><code>-j </code><var>row</var><code></code>
     <dd><dt><code>--jis-row </code><var>row</var><code></code>
     <dd>Generate a character map for row <var>row</var> of a Japanese font arranged
according to JIS [Japanese Industrial Standard] X0208.  The only such
font currently available is the HersheyEUC [Extended Unix Code] font. 
If&nbsp;used, this option overrides the <code>-1</code> and <code>-2</code> options.

     <p>The valid rows are 1<small class="dots">...</small>94.  In the JIS X0208 standard, Roman
characters are located in row&nbsp;3, and Japanese syllabic characters
(Hiragana and Katakana) are located in rows 4 and&nbsp;5.  Greek and
Cyrillic characters are located in rows 6 and&nbsp;7.  Japanese
ideographic characters (Kanji) are located in rows 16<small class="dots">...</small>84.  Rows
16<small class="dots">...</small>47 contain the JIS Level&nbsp;1 Kanji, which are the most
frequently used.  They are arranged according to&nbsp;On (old Chinese)
reading.  Rows 48<small class="dots">...</small>84 contain the less frequently used JIS Level&nbsp;2 Kanji.

     <p>The HersheyEUC font contains 596 of the 2965 Level&nbsp;1 Kanji, and
seven of the Level&nbsp;2 Kanji.  It&nbsp;uses the 8-bit EUC-JP encoding. 
This encoding is a multibyte encoding that includes the ASCII character
set as&nbsp;well as the JIS X0208 characters.  It represents each ASCII
character in the usual way, i.e., as a single byte that does not have
its high bit set.  Each JIS X0208 character is represented as two bytes,
each with the high bit set.  The first byte contains the row number
(plus&nbsp;32), and the second byte contains the character number.

     <br><dt><code>-T </code><var>type</var><code></code>
     <dd><dt><code>--display-type </code><var>type</var><code></code>
     <dd>(String, default "meta".)  Select a display type or output format of
type <var>type</var>, which may be one of the strings "X", "png", "pnm",
"gif", "svg", "ai", "ps", "cgm", "fig", "pcl", "hpgl", "regis", "tek",
and "meta".  These refer respectively to the X&nbsp;Window&nbsp;System, PNG
format, portable anymap (PBM/PGM/PPM) format, pseudo-GIF format, the new
XML-based Scalable Vector Graphics format, the format used by Adobe
Illustrator, <code>idraw</code>-editable Postscript, the WebCGM format for
Web-based vector graphics, the format used by the <code>xfig</code> drawing
editor, the Hewlett-Packard PCL&nbsp;5 printer language, the
Hewlett-Packard Graphics Language (by&nbsp;default, HP-GL/2), the ReGIS
(remote graphics instruction set) format developed by&nbsp;DEC, Tektronix
format, and device-independent GNU graphics metafile format.

     <p>Files in PNG, PNM, pseudo-GIF, SVG, AI, or Fig format may contain only a
single page of graphics.  So if the <code>-T png</code> option, the <code>-T
pnm</code> option, the <code>-T gif</code> option, the <code>-T svg</code> option, the
<code>-T ai</code> option, or the <code>-T fig</code> option is used, a character
map will be produced for only the first-specified font.

     <br><dt><code>--bg-color </code><var>name</var><code></code>
     <dd>(String, default "white".)  Set the color used for the background to be
<var>name</var>.  This is relevant only to <code>plotfont -T&nbsp;X</code>,
<code>plotfont -T png</code>, <code>plotfont -T pnm</code>, <code>plotfont -T gif</code>,
<code>plotfont -T cgm</code>, <code>plotfont -T regis</code>, and <code>plotfont -T
meta</code>.  An&nbsp;unrecognized name sets the color to the default.  For
information on what names are recognized, see <a href="#Color%20Names">Color Names</a>.  The
environment variable <code>BG_COLOR</code> can equally well be used to specify
the background color.

     <p>If the <code>-T png</code> or <code>-T gif</code> option is used, a transparent PNG
file or a transparent pseudo-GIF, respectively, may be produced by
setting the <code>TRANSPARENT_COLOR</code> environment variable to the name of
the background color.  See <a href="#plotfont%20Environment">plotfont Environment</a>.  If&nbsp;the <code>-T
svg</code> or <code>-T cgm</code> option is used, an output file without a
background may be produced by setting the background color to "none".

     <br><dt><code>--bitmap-size </code><var>bitmap_size</var><code></code>
     <dd>(String, default "570x570".)  Set the size of the graphics display in
which the character map will be drawn, in terms of pixels, to be
<var>bitmap_size</var>.  This is relevant only to <code>plotfont -T&nbsp;X</code>,
<code>plotfont -T png</code>, <code>plotfont -T pnm</code>, and <code>plotfont -T
gif</code>, for all of which the size can be expressed in terms of pixels. 
The environment variable <code>BITMAPSIZE</code> may equally well be used to
specify the size.

     <p>The graphics display used by <code>plotfont -T X</code> is a popped-up X&nbsp;window.  Command-line positioning of this window on an X&nbsp;Window
System display is supported.  For example, if <var>bitmap_size</var> is
"570x570+0+0" then the window will be popped&nbsp;up in the upper left
corner.

     <p>If you choose a rectangular (non-square) window size, the fonts in the
plot will be scaled anisotropically, i.e., by different factors in the
horizontal and vertical direction.  For this, <code>plotfont -T&nbsp;X</code>
requires an X11R6 display.  Any font that cannot be anisotropically
scaled will be replaced by a default scalable font, such as the Hershey
vector font "HersheySerif".

     <p>For backward compatibility, <code>plotfont -T X</code> allows the user to set
the window size and position by setting the X&nbsp;resource
<code>Xplot.geometry</code>, instead of <code>--bitmap-size</code> or
<code>BITMAPSIZE</code>.

     <br><dt><code>--emulate-color </code><var>option</var><code></code>
     <dd>(String, default "no".)  If <var>option</var> is "yes", replace each color in
the output by an appropriate shade of gray.  This is seldom useful,
except when using <code>plotfont -T pcl</code> to prepare output for a PCL&nbsp;5 device.  (Many monochrome PCL&nbsp;5 devices, such as monochrome
LaserJets, do a poor job of emulating color on their own.  They usually
map HP-GL/2's seven standard pen colors, including even yellow, to
black.)  You may equally well request color emulation by setting the
environment variable <code>EMULATE_COLOR</code> to "yes".

     <br><dt><code>--numbering-font-name </code><var>font_name</var><code></code>
     <dd>(String, default "Helvetica" except for <code>plotfont -T pcl</code>, for
which "Univers" is the default, and <code>plotfont -T png</code>,
<code>plotfont -T pnm</code>, <code>plotfont -T gif</code>, <code>plotfont -T hpgl</code>,
<code>plotfont -T regis</code>, and <code>plotfont -T tek</code>, for all of which
"HersheySerif" is the default.)  Set the font used for the numbering of
the characters in the character map(s) to be <var>font_name</var>.

     <br><dt><code>--page-size </code><var>pagesize</var><code></code>
     <dd>(String, default "letter".)  Set the size of the page on which the
character map(s) will be drawn.  This is relevant only to <code>plotfont
-T svg</code>, <code>plotfont -T ai</code>, <code>plotfont -T ps</code>, <code>plotfont -T
fig</code>, <code>plotfont -T pcl</code>, and <code>plotfont -T hpgl</code>.  "letter"
means an 8.5in by 11in page.  Any ISO page size in the range
"a0"<small class="dots">...</small>"a4" or ANSI page size in the range "a"<small class="dots">...</small>"e" may be
specified ("letter" is an alias for&nbsp;"a" and "tabloid" is an alias
for&nbsp;"b").  "legal", "ledger", and&nbsp;"b5" are recognized page sizes
also.  The environment variable <code>PAGESIZE</code> can equally well be used
to specify the page size.

     <p>For <code>plotfont -T ai</code>, <code>plotfont -T ps</code>, <code>plotfont -T
pcl</code>, and <code>plotfont -T fig</code>, the graphics display (or `viewport')
within which the character map is drawn will be, by default, a square
region centered on the specified page.  For <code>plotfont -T hpgl</code>, it
will be a square region of the same size, but may be positioned
differently.  Either or both of the dimensions of the graphics display
can be specified explicitly.  For example, <var>pagesize</var> could be
specified as "letter,xsize=4in", or "a4,xsize=10cm,ysize=15cm".  The
dimensions are allowed to be negative (a&nbsp;negative dimension results
in a reflection).

     <p>The position of the graphics display, relative to its default position,
may optionally be adjusted by specifying an offset vector.  For example,
<var>pagesize</var> could be specified as "letter,yoffset=1.2in", or
"a4,xoffset=-5mm,yoffset=2.0cm".  It&nbsp;is also possible to
position the graphics display precisely, by specifying the location of
its lower left corner relative to the lower left corner of the page. 
For example, <var>pagesize</var> could be specified as
"letter,xorigin=2in,yorigin=3in", or "a4,xorigin=0.5cm,yorigin=0.5cm". 
The preceding options may be intermingled.  <code>plotfont -T svg</code> and
<code>plotfont -T cgm</code> ignore the "xoffset", "yoffset", "xorigin", and
"yorigin" options, since SVG format and WebCGM format have no notion of
the Web page on which the graphics display will ultimately be
positioned.  For more on page sizes, see <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

     <br><dt><code>--pen-color </code><var>name</var><code></code>
     <dd>(String, default "black".)  Set the pen color to be <var>name</var>.  An
unrecognized name sets the pen color to the default.  For information on
what color names are recognized, see <a href="#Color%20Names">Color Names</a>.

     <br><dt><code>--rotation </code><var>angle</var><code></code>
     <dd>(Integer, default 0.)  Set the rotation angle of the graphics display to
be <var>angle</var> degrees.  Recognized values are 0,&nbsp;90, 180, and&nbsp;270.  The rotation is counterclockwise.  The environment variable
<code>ROTATION</code> can equally well be used to specify the rotation angle.

     <p>This option is used for switching between portrait and landscape
orientations.  Postmodernists may also find it useful.

     <br><dt><code>--title-font-name </code><var>font_name</var><code></code>
     <dd>(String) Set the font used for the title of each character map to be
<var>font_name</var>.  Normally the font used for the title is the same as
the font whose character set is being displayed.  This option is useful
when producing character maps for unusual fonts such as "ZapfDingbats"
and "Wingdings". 
</dl>

   <p>The following option is relevant only to raw <code>plotfont</code>, i.e.,
relevant only if no display type or output format is specified with the
<code>-T</code> option.  In this case <code>plotfont</code> outputs a graphics
metafile, which may be translated to other formats by invoking
<code>plot</code>.

     <dl>
<dt><code>-O</code>
     <dd><dt><code>--portable-output</code>
     <dd>Output the portable (human-readable) version of GNU metafile format,
rather than a binary version (the default).  This can also be requested
by setting the environment variable <code>META_PORTABLE</code> to "yes". 
</dl>

   <p>The following options request information.

     <dl>
<dt><code>--help</code>
     <dd>Print a list of command-line options, and then exit.

     <br><dt><code>--help-fonts</code>
     <dd>Print a table of available fonts, and then exit.  The table will depend
on which display type or output format is specified with the <code>-T</code>
option.  <code>plotfont -T&nbsp;X</code>, <code>plotfont -T svg</code>,
<code>plotfont -T ai</code>, <code>plotfont -T ps</code>, <code>plotfont -T cgm</code>,
and <code>plotfont -T fig</code> each support the 35 standard Postscript
fonts.  <code>plotfont -T svg</code>, <code>plotfont -T ai</code>, <code>plotfont -T
pcl</code>, and <code>plotfont -T hpgl</code> support the 45 standard PCL&nbsp;5
fonts, and <code>plotfont -T pcl</code> and <code>plotfont -T hpgl</code> support a
number of Hewlett-Packard vector fonts.  All of the preceding, together
with <code>plotfont -T png</code>, <code>plotfont -T pnm</code>, <code>plotfont -T
gif</code>, <code>plotfont -T regis</code>, and <code>plotfont -T tek</code>, support a
set of 22 Hershey vector fonts.  Raw <code>plotfont</code> in&nbsp;principle
supports any of these fonts, since its output must be translated to
other formats with <code>plot</code>.

     <br><dt><code>--list-fonts</code>
     <dd>Like <code>--help-fonts</code>, but lists the fonts in a single column to
facilitate piping to other programs.  If&nbsp;no display type or output
format is specified with the <code>-T</code> option, the full set of supported
fonts is listed.

     <br><dt><code>--version</code>
     <dd>Print the version number of <code>plotfont</code> and the plotting utilities
package, and exit. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="plotfont%20Environment">plotfont Environment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plotfont%20Invocation">plotfont Invocation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#plotfont">plotfont</a>
<br>
</div>

<h3 class="section">6.3 Environment variables</h3>

<p>The behavior of <code>plotfont</code> is affected by several environment
variables, which are the same as those that affect <code>graph</code>,
<code>plot</code>, and <code>tek2plot</code>.  For convenience, we list them here.

   <p>We have already mentioned the environment variables <code>BITMAPSIZE</code>,
<code>PAGESIZE</code>, <code>BG_COLOR</code>, <code>EMULATE_COLOR</code>, and
<code>ROTATION</code>.  They serve as backups for the several options
<code>--bitmap-size</code>, <code>--page-size</code>, <code>--bg-color</code>,
<code>--emulate-color</code>, and <code>--rotation</code>.  The remaining
environment variables are specific to individual output formats.

   <p><code>plotfont -T&nbsp;X</code>, which pops up a window on an X&nbsp;Window
System display and draws a character map in&nbsp;it, checks the
<code>DISPLAY</code> environment variable.  The value of this variable
determines the display on which the window will be popped&nbsp;up.

   <p><code>plotfont -T png</code> and <code>plotfont -T gif</code>, which produce output
in PNG format and pseudo-GIF format respectively, are affected by two
environment variables.  If the value of the <code>INTERLACE</code> variable is
"yes", the output file will be interlaced.  Also, if the value of the
<code>TRANSPARENT_COLOR</code> environment variable is the name of a color
that appears in the output file, that color will be treated as
transparent by most applications.  For information on what color names
are recognized, see <a href="#Color%20Names">Color Names</a>.

   <p><code>plotfont -T pnm</code>, which produces output in Portable Anymap
(PBM/PGM/PPM) format, is affected by the <code>PNM_PORTABLE</code> environment
variable.  If its value is "yes", the output file will be in the
portable (human readable) version of PBM, PGM, or PPM format, rather
than the default (binary) version.

   <p><code>plotfont -T cgm</code>, which produces CGM files that comply with the
WebCGM profile for Web-based vector graphics, is affected by two
environment variables.  By default, a version&nbsp;3 CGM file is
generated.  Many older CGM interpreters and viewers, such as the ones
built into Microsoft Office and other commercial software, only support
version&nbsp;1 CGM files.  The <code>CGM_MAX_VERSION</code> environment
variable may be set to "1", "2", "3", or&nbsp;"4" (the default) to
specify a maximum value for the version number.  The <code>CGM_ENCODING</code>
variable may also be set, to specify the type of encoding used in the
CGM file.  Supported values are "clear_text" (i.e., human readable) and
"binary" (the default).  The WebCGM profile requires that the binary
encoding be used.

   <p><code>plotfont -T pcl</code>, which produces PCL&nbsp;5 output for
Hewlett-Packard printers, is affected by the environment variable
<code>PCL_ASSIGN_COLORS</code>.  It should be set to "yes" when producing
PCL&nbsp;5 output for a color printer or other color device.  This will
ensure accurate color reproduction by giving the output device complete
freedom in assigning colors, internally, to its "logical pens".  If it
is "no" then the device will use a fixed set of colored pens, and will
emulate other colors by shading.  The default is "no" because monochrome
PCL&nbsp;5 devices, which are more common than colored ones, must use
shading to emulate color.

   <p><code>plotfont -T hpgl</code>, which produces Hewlett-Packard Graphics
Language output, is also affected by several environment variables.  The
most important is <code>HPGL_VERSION</code>, which may be set to "1", "1.5",
or&nbsp;"2" (the default).  "1"&nbsp;means that the output should be
generic HP-GL, "1.5"&nbsp;means that the output should be suitable for
the HP7550A graphics plotter and the HP758x, HP7595A and HP7596A
drafting plotters (HP-GL with some HP-GL/2 extensions), and "2"&nbsp;means that the output should be modern HP-GL/2.  If&nbsp;the version is
"1" or&nbsp;"1.5" then the only available fonts will be vector fonts.

   <p>The position of the <code>plotfont -T hpgl</code> graphics display on the page
can be rotated 90&nbsp;degrees counterclockwise by setting the
<code>HPGL_ROTATE</code> environment variable to "yes".  This is not the same
as the rotation obtained with the <code>--rotation</code> option, since it
both rotates the graphics display and repositions its lower left corner
toward another corner of the page.  Besides "no" and "yes", recognized
values for the <code>HPGL_ROTATE</code> variable are "0", "90", "180", and&nbsp;"270".  "no"&nbsp;and "yes" are equivalent to "0"&nbsp;and&nbsp;"90",
respectively.  "180" and "270" are supported only if <code>HPGL_VERSION</code>
is&nbsp;"2" (the default).

   <p>By&nbsp;default, <code>plotfont -T hpgl</code> will draw with a fixed set of
pens.  Which pens are present may be specified by setting the
<code>HPGL_PENS</code> environment variable.  If <code>HPGL_VERSION</code> is&nbsp;"1", the default value of <code>HPGL_PENS</code> is "1=black"; if
<code>HPGL_VERSION</code> is "1.5" or&nbsp;"2", the default value of
<code>HPGL_PENS</code> is
"1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan".  The format
should be self-explanatory.  By setting <code>HPGL_PENS</code>, you may
specify a color for any pen in the range #1<small class="dots">...</small>#31.  For information
on what color names are recognized, see <a href="#Color%20Names">Color Names</a>.  Pen&nbsp;#1
must always be present, though it need not be black. Any other pen in
the range #1<small class="dots">...</small>#31 may be omitted.

   <p>If <code>HPGL_VERSION</code> is "2" then <code>plotfont -T hpgl</code> will also be
affected by the environment variable <code>HPGL_ASSIGN_COLORS</code>.  If&nbsp;the value of this variable is "yes", then <code>plotfont -T hpgl</code> will
not be restricted to the palette specified in <code>HPGL_PENS</code>: it&nbsp;will assign colors to "logical pens" in the range #1<small class="dots">...</small>#31, as&nbsp;needed.  The default value is "no" because other than color LaserJet
printers and DesignJet plotters, not many HP-GL/2 devices allow the
assignment of colors to logical pens.  In particular, HP-GL/2 pen
plotters do not.

   <p><code>plotfont -T tek</code>, which produces output for a Tektronix terminal
or emulator, checks the <code>TERM</code> environment variable.  If&nbsp;the
value of <code>TERM</code> is a string beginning with "xterm", "nxterm", or
"kterm", it&nbsp;is taken as a sign that <code>plotfont</code> is running in an
X&nbsp;Window System VT100 terminal emulator: an&nbsp;<code>xterm</code>,
<code>nxterm</code>, or <code>kterm</code>.  Before drawing graphics, <code>plotfont
-T tek</code> will emit an escape sequence that causes the terminal emulator's
auxiliary Tektronix window, which is normally hidden, to pop&nbsp;up. 
After the graphics are drawn, an escape sequence that returns control to
the original VT100 window will be emitted.  The Tektronix window will
remain on the screen.

   <p>If the value of <code>TERM</code> is a string beginning with "kermit",
"ansi.sys", or "nansi.sys", it&nbsp;is taken as a sign that
<code>plotfont</code> is running in the VT100 terminal emulator provided by
the MS-DOS version of <code>kermit</code>.  Before drawing graphics,
<code>plotfont -T tek</code> will emit an escape sequence that switches the
terminal emulator to Tektronix mode.  Also, some of the Tektronix
control codes emitted by <code>plotfont -T tek</code> will be
<code>kermit</code>-specific.  There will be a limited amount of color
support, which is not normally the case (the 16 <code>ansi.sys</code> colors
will be supported).  After drawing graphics, <code>plotfont -T tek</code> will
emit an escape sequence that returns the emulator to VT100 mode.  The
key sequence `ALT&nbsp;minus' can be employed manually within
<code>kermit</code> to switch between the two modes.

<div class="node">
<p><hr>
Node:&nbsp;<a name="spline">spline</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#ode">ode</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#plotfont">plotfont</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">7 The <code>spline</code> Program</h2>

<ul class="menu">
<li><a accesskey="1" href="#spline%20Examples">spline Examples</a>:          How to use spline
<li><a accesskey="2" href="#Advanced%20Use%20of%20spline">Advanced Use of spline</a>:   More sophisticated uses
<li><a accesskey="3" href="#spline%20Invocation">spline Invocation</a>:        Command-line options
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="spline%20Examples">spline Examples</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Advanced%20Use%20of%20spline">Advanced Use of spline</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#spline">spline</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#spline">spline</a>
<br>
</div>

<h3 class="section">7.1 How to use <code>spline</code></h3>

<p>GNU <code>spline</code> is a program for interpolating between the data points
in one or more datasets.  Each dataset would consist of values for an
independent variable and a dependent variable, which may be a vector of
specified fixed length.  When discussing interpolation, we call these
variables `t' and `y', respectively.  To&nbsp;emphasize:
t&nbsp;is&nbsp;a&nbsp;scalar, but in&nbsp;general the dependent variable
y&nbsp;may be a vector.

   <p>The simplest case is when there is a single input file, which is in
ASCII format, and the vector&nbsp;y is one-dimensional.  This is
the default.  For example, the input file could contain the dataset

<pre class="example">     0.0  0.0
     1.0  1.0
     2.0  0.0
     </pre>

<p>which are the coordinates (t,y) of the data points (0,0), (1,1),
and (2,0).  Data points do not need to be on different lines, nor do the
t and&nbsp;y coordinates of a data point need to be on the
same line.  However, there should be no blank lines in the input if it
is to be viewed as forming a single dataset.  Also, by&nbsp;default the
t coordinate should be monotonically increasing, so that
y&nbsp;may be viewed as a function of&nbsp;t.

   <p>You would construct a spline (the graph of an `interpolating function')
passing through the points in this dataset by doing

<pre class="example">     spline input_file &gt; output_file
     </pre>

<p>To produce a Postscript plot of the spline with the <code>graph</code>
utility, you would do

<pre class="example">     spline input_file | graph -T ps &gt; output.ps
     </pre>

<p>To display a spline on an X&nbsp;Window System display, you could do

<pre class="example">     echo 0 0 1 1 2 0 | spline | graph -T X
     </pre>

<p>Notice that the last example avoids the use of the input file
altogether.  <code>spline</code> will read from standard input if no files are
specified on the command line, or if the special file name&nbsp;<code>-</code>
is specified.

   <p>What exactly does <code>spline</code> do?  First, it fits a curve (the graph
of an interpolating function) through the points in the dataset.  Then
it splits the interval over which the independent variable&nbsp;t
ranges into 100 sub-intervals, and computes the y&nbsp;values at
each of the 101 subdivision points.  It&nbsp;then outputs each of the
pairs (t, y).  These are the coordinates of 101 points that lie
along a curve that interpolates between the points in the dataset.  If
there is more than one dataset in the input (separated by blank lines),
each dataset is interpolated separately.

   <p>You may use the <code>-n</code> option to replace `100' by any other positive
integer.  You may also use the <code>-t</code> option to specify an
interpolation interval that differs from the default (the interval over
which the independent variable ranges).  For example, the command

<pre class="example">     echo 0 0 1 1 2 0 | spline -n 20 -t 1.0 1.5 &gt; output_file
     </pre>

<p>will produce a dataset consisting of 21 (rather than 101) data points,
with t&nbsp;values spaced regularly between 1.0 and 1.5 (rather
than between 0.0 and 2.0).  The data points will lie along a curve
passing through (0,0), (1,1), and (2,0).  This curve will be a parabola.

   <p>In general, the interpolating function will be a piecewise cubic spline. 
That is, between each pair of adjacent `knots' (points in the input
dataset), y&nbsp;will be a cubic function of&nbsp;t.  This
function will differ, depending on which pair of knots y&nbsp;lies
between.  At each knot, both the slope and curvature of the cubic pieces
to either side will match.  In mathematical terms, the interpolating
curve will be twice continuously differentiable.

   <p><code>spline</code> supports `adding tension' to the interpolating curve. 
A&nbsp;nonzero value for the tension can be specified with the <code>-T</code>
option.  For example, a spline under considerable tension can be
computed and displayed by doing

<pre class="example">     echo 0 0 1 0 2 0 | spline -T 10 | graph -T X
     </pre>

<p>As the tension parameter is increased to positive infinity, the spline
will converge to a polygonal line.  You are meant to think of the spline
as being drawn taut.  Actually, tension may be negative as&nbsp;well as
positive.  A&nbsp;spline with negative tension will tend to bow outward,
in&nbsp;fact to oscillate sinusoidally.  But as the tension decreases to
negative infinity, the spline, though oscillatory, will again converge
to a polygonal line.

   <p>If the tension is positive, its reciprocal will be the maximum range of
the independent variable&nbsp;t over which the spline will `like
to curve'.  Increasing the tension far above zero will accordingly force
the spline to consist of short curved sections, centered on the data
points, and sections that are almost straight.  It follows that tension
is a `dimensionful' quantity.  If&nbsp;the tension is nonzero, then when
the values of the independent variable are multiplied by some common
positive factor, the tension should be divided by the same factor to
obtain a scaled version of the original spline.  If&nbsp;the tension is
zero (the default, or cubic spline case), then the computation of the
spline will be unaffected by linear scaling of the data.

   <p>In mathematical terms, a spline under tension will satisfy the
differential equation
y""=sgn(tension)*(tension^2)y"
between each successive pair of knots.  If the tension equals zero,
which is the default, the fourth derivative of y with respect
to&nbsp;t will equal zero at every point.  In this case, y
as a function of&nbsp;t will reduce to a cubic polynomial between
each successive pair of knots.  But if the tension is nonzero, y
will not be a polynomial function of&nbsp;t.  It&nbsp;may be expressed
in&nbsp;terms of exponential functions, however.

   <p>Irrespective of whether or not the spline is under tension, you may
specify the <code>-p</code> option if you wish the spline to be a periodic
function of&nbsp;t.  This will only work if the y values for
the first and last points in the dataset are equal.  Otherwise, it would
make no sense to compute a periodic interpolation.

   <p>It is sometimes useful to interpolate between data points at the same
time as they are generated by an auxiliary program.  That&nbsp;is, it&nbsp;is useful for <code>spline</code> to function as a real-time filter. 
<code>spline</code> does not normally act as a filter, since computing an
interpolating curve that is as smooth as possible is a global task.  But
if the <code>-f</code> option is specified, <code>spline</code> will indeed function
as a filter.  A&nbsp;different interpolation algorithm (cubic Bessel
interpolation, which is local rather than global) will be used.  If&nbsp;<code>-f</code> is specified, <code>-p</code> may not be specified.  Also, if
<code>-f</code> is specified then an interpolation interval (a&nbsp;range of
t&nbsp;values) must be requested explicitly with the <code>-t</code>
option.

   <p>Cubic Bessel interpolation is inherently less smooth than the
construction of a global cubic spline.  If&nbsp;the <code>-f</code> option is
specified, the slope of the spline at each knot will be chosen by
fitting a parabola through that knot, and the two adjacent knots.  The
slopes of the two interpolating segments to either side of each interior
knot will match at that knot, but typically their curvatures will not. 
In mathematical terms, the interpolating curve will be continuously
differentiable, but in general not twice continuously differentiable. 
This loss of differentiability is the price that is paid for functioning
as a real-time filter.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Advanced%20Use%20of%20spline">Advanced Use of spline</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#spline%20Invocation">spline Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#spline%20Examples">spline Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#spline">spline</a>
<br>
</div>

<h3 class="section">7.2 Advanced use of <code>spline</code></h3>

<p>The preceding section explains how <code>spline</code> can be employed to
interpolate a function y of a scalar variable t, in the
case when y is a scalar.  In this section we explain how to
perform more sophisticated interpolations.  This includes
multidimensional interpolations, and interpolations that are splinings
of curves, rather than of functions.

   <p><code>spline</code> can handle the case when y&nbsp;is a vector of
arbitrary specified dimensionality.  The dimension can be specified with
the <code>-d</code> option.  For example, an input file could contain the
multidimensional dataset

<pre class="example">     0.0  0.0  1.0
     1.0  1.0  0.0
     2.0  0.0  1.0
     </pre>

<p>which are the coordinates (t,y) of the data points (0,0,1),
(1,1,0), and (2,0,1).  You would construct a spline (the graph of an
interpolating function) passing through the points in this dataset by
doing

<pre class="example">     spline -d 2 input_file &gt; output_file
     </pre>

<p>The option <code>-d 2</code> is used because in this example, the dependent
variable y is a two-dimensional vector.  Each of the components
of y will be interpolated independently, and the output file will
contain points that lie along the graph of the resulting interpolating
function.

   <p>When doing multidimensional splining, you may use any of the options
that apply in the default one-dimensional case.  For example, the
<code>-f</code> option will yield real-time cubic Bessel interpolation.  As&nbsp;in the one-dimensional case, if the <code>-f</code> option is used then the
<code>-t</code> option must be used as&nbsp;well, to specify an interpolation
interval (a&nbsp;range of t&nbsp;values).  The <code>-p</code> option
will yield a periodic spline, i.e., the graph of a periodic
vector-valued function.  For this, the first and last dataset
y&nbsp;values must be the same.

   <p><code>spline</code> can also be used to draw a curve through arbitrarily
chosen points in the plane, or in&nbsp;general through arbitrarily chosen
points in d-dimensional space.  This is not the same as splining,
at&nbsp;least as the term is conventionally defined.  The reason is that
`splining' refers to construction of a function, rather than the
construction of a curve that may or may not be the graph of a function. 
Not every curve is the graph of a function.

   <p>The following example shows how you may `spline a curve'.  The command

<pre class="example">     echo 0 0 1 0 1 1 0 1 | spline -d 2 -a -s | graph -T X
     </pre>

<p>will construct a curve in the plane through the four points (0,0),
(1,0), (1,1), and (0,1), and graph it on an X&nbsp;Window System display. 
The <code>-d 2</code> option specifies that the dependent variable y is
two-dimensional.  The <code>-a</code> option specifies that t&nbsp;values are missing from the input, and should be automatically
generated.  By&nbsp;default, the first t&nbsp;value is&nbsp;0, the
second is&nbsp;1, etc.  The <code>-s</code> option specifies that the
t&nbsp;values should be stripped from the output.

   <p>The same technique may be used to spline a closed curve.  For example,
doing

<pre class="example">     echo 0 0 1 0 0 1 0 0 | spline -d 2 -a -s -p | graph -T X
     </pre>

<p>will construct and graph a closed, lozenge-shaped curve through the
three points (0,0), (1,0), and (0,1).  The construction of a closed
curve is guaranteed by the <code>-p</code> (i.e., <code>--periodic</code>) option,
and by the repetition of the initial point (0,0) at the end of the
sequence.

   <p>When splining a curve, whether open or closed, you may wish to
substitute the <code>-A</code> option for the <code>-a</code> option.  Like the
<code>-a</code> option, the <code>-A</code> option specifies that t&nbsp;values are missing from the input and should be automatically
generated.  However, the increment from one t&nbsp;value to the
next will be the distance between the corresponding values of&nbsp;y.  This scheme for generating t&nbsp;values, when
constructing a curve through a sequence of data points, is the scheme
that is used in the well&nbsp;known FITPACK subroutine library.  It&nbsp;is probably the best approach when the distances between successive
points fluctuate considerably.

   <p>A curve through a sequence of points in the plane, whether open or
closed, may cross itself.  Some interesting visual effects can be
obtained by adding negative tension to such a curve.  For example, doing

<pre class="example">     echo 0 0 1 0 1 1 0 0 | spline -d 2 -a -s -p -T -14 -n 500 | graph -T X
     </pre>

<p>will construct a closed curve through the three points (0,0), (1,0),
and (0,1), which is wound into curlicues.  The <code>-n 500</code> option is
included because there are so many windings.  It&nbsp;specifies that 501
points should be generated, which is enough to draw a smooth curve.

<div class="node">
<p><hr>
Node:&nbsp;<a name="spline%20Invocation">spline Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Advanced%20Use%20of%20spline">Advanced Use of spline</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#spline">spline</a>
<br>
</div>

<h3 class="section">7.3 <code>spline</code> command-line options</h3>

<p>The <code>spline</code> program will interpolate vector-valued functions of a
scalar variable&nbsp;t, and curves in d-dimensional space. 
The algorithms used by <code>spline</code> are similar to those discussed in
D.&nbsp;Kincaid and [E.]&nbsp;W. Cheney, <cite>Numerical Analysis</cite> (2nd
ed., Brooks/Cole, 1996), section 6.4, and C.&nbsp;de&nbsp;Boor, <cite>A
Practical Guide to Splines</cite> (Springer-Verlag, 1978), Chapter&nbsp;4.

   <p>Input file names may be specified anywhere on the command line.  That
is, the relative order of font names and command-line options does not
matter.  If no file names are specified, or the file name&nbsp;<code>-</code>
is specified, the standard input is read.

   <p>An input file may contain more than a single dataset.  Unless the
<code>-a</code> or <code>-A</code> options are used (see below), each dataset is
expected to consist of a sequence of data points, given as alternating
t and&nbsp;y values.  t&nbsp;is the scalar
independent variable, and y&nbsp;is the vector-valued dependent
variable.  The dimensionality of&nbsp;y is specified with the
<code>-d</code> option (the default is&nbsp;1).

   <p>If the input file is in ASCII format (the default), its datasets are
separated by blank lines.  An input file may also contain any number of
comment lines, which must begin with the comment character&nbsp;`#'. 
Comment lines are ignored.  They are not treated as blank, i.e., they do
not interrupt a dataset in progress.

   <p>The options to <code>spline</code> are listed below.  There are three sorts of
option:

     <ol type=1 start=1>
<li>Options specifying the type of interpolation to be performed on each dataset. 
<li>Options specifying the input or output format. 
<li>Options requesting information (e.g., <code>--help</code>).
        </ol>

<p>Options that take an argument are followed, in parentheses, by the type
and default value of the argument.

   <p>The following options specify the type of interpolation to be performed
on each dataset.

     <dl>
<dt><code>-f</code>
     <dd><dt><code>--filter</code>
     <dd>Use a local interpolation algorithm (the cubic Bessel algorithm), so
that <code>spline</code> can be used as a real-time filter.  The slope of the
interpolating curve at each point in a dataset will be chosen by fitting
a quadratic function through that point and the two adjacent points in
the dataset.  If <code>-f</code> is specified then the <code>-t</code> option,
otherwise optional, must be used as&nbsp;well.  Also, if <code>-f</code> is
specified then the <code>-k</code>, <code>-p</code>, and <code>-T</code> options may not
be used.

     <p>If <code>-f</code> is <em>not</em> specified, then a different (global)
interpolation algorithm will be used.

     <br><dt><code>-k </code><var>k</var><code></code>
     <dd><dt><code>--boundary-condition </code><var>k</var><code></code>
     <dd>(Float, default 1.0.)  Set the boundary condition parameter for each
constructed spline to be&nbsp;<var>k</var>.  In each of its components, the
spline will satisfy the two boundary conditions y"[0]=ky"[1]
and y"[n]=ky"[n-1].  Here y[0] and y[1] signify
the values of a specified component of the vector-valued dependent
variable y at the first two points of a dataset, and
y[n-1] and y[n] the values at the last two points. 
Setting <var>k</var> to zero will yield a `natural' spline, i.e., one that
has zero curvature at the two ends of the dataset.  The <code>-k</code> option
may not be used if <code>-f</code> or <code>-p</code> is specified.

     <br><dt><code>-n </code><var>n</var><code></code>
     <dd><dt><code>--number-of-intervals </code><var>n</var><code></code>
     <dd>(Positive integer, default 100.)  Subdivide the interval over which
interpolation occurs into <var>n</var> subintervals.  The number of data
points computed, and written to the output, will be n+1.

     <br><dt><code>-p</code>
     <dd><dt><code>--periodic</code>
     <dd>Construct a periodic spline.  If this option is specified, the y
values for the first and last points in each dataset must be equal.  The
<code>-f</code> and <code>-k</code> options may not be used if <code>-p</code> is
specified.

     <br><dt><code>-T </code><var>tension</var><code></code>
     <dd><dt><code>--tension </code><var>tension</var><code></code>
     <dd>(Float, default 0.0.)  Set the tension in each interpolating spline to
be <var>tension</var>.  Between each pair of successive points in a dataset,
the constructed spline will satisfy the differential equation
y""=sgn(tension)*(tension^2)y"
in each of its components.  If <var>tension</var> equals zero, the spline
will be piecewise cubic.  As <var>tension</var> increases to positive
infinity, the spline will converge to a polygonal line.  The <code>-T</code>
option may not be used if <code>-f</code> is specified.

     <br><dt><code>-t </code><var>tmin</var><code> </code><var>tmax</var><code> [</code><var>tspacing</var><code>]</code>
     <dd><dt><code>--t-limits </code><var>tmin</var><code> </code><var>tmax</var><code> [</code><var>tspacing</var><code>]</code>
     <dd>For each dataset, set the interval over which interpolation occurs to be
the interval between <var>tmin</var> and&nbsp;<var>tmax</var>.  If <var>tspacing</var>
is not specified, the interval will be divided into the number of
subintervals specified by the <code>-n</code> option.  If&nbsp;the <code>-t</code>
option is not used, the interval over which interpolation occurs will be
the entire range of the independent variable in the dataset.  The
<code>-t</code> option must always be used if the <code>-f</code> option is used to
request filter-like behavior (see above). 
</dl>

<p>The following options specify the format of the input file(s) and the
output file.

     <dl>
<dt><code>-d </code><var>dimension</var><code></code>
     <dd><dt><code>--y-dimension </code><var>dimension</var><code></code>
     <dd>(Integer, default 1.)  Set the dimensionality of the dependent variable
y in the input and output files to be <var>dimension</var>.

     <br><dt><code>-I </code><var>data-format</var><code></code>
     <dd><dt><code>--input-format </code><var>data-format</var><code></code>
     <dd>(Character, default <code>a</code>.)  Set the data format for the input file(s)
to be <var>data-format</var>.  The possible data formats are as follows.

          <dl>
<dt><code>a</code>
          <dd>ASCII format.  Each file is a sequence of floating point numbers,
interpreted as the t and&nbsp;y coordinates of the
successive data points in a dataset.  If y is
d-dimensional, there will be d+1 numbers for each point. 
The t and&nbsp;y coordinates of a point need not appear on
the same line, and points need not appear on different lines.  But if a
blank line occurs (i.e., two newlines in succession are seen), it&nbsp;is
interpreted as the end of a dataset, and the beginning of the next.

          <br><dt><code>f</code>
          <dd>Single precision binary format.  Each file is a sequence of floating
point numbers, interpreted as the t and&nbsp;y coordinates
of the successive data points in a dataset.  If y is
d-dimensional, there will be d+1 numbers for each point. 
Successive datasets are separated by a single occurrence of the quantity
<code>FLT_MAX</code>, which is the largest possible single precision floating
point number.  On&nbsp;most machines this is approximately 3.4x10^38.

          <br><dt><code>d</code>
          <dd>Double precision binary format.  Each file is a sequence of double
precision floating point numbers, interpreted as the t and&nbsp;y coordinates of the successive data points in a dataset.  If
y is d-dimensional, there will be d+1 numbers for
each point.  Successive datasets are separated by a single occurrence of
the quantity <code>DBL_MAX</code>, which is the largest possible double
precision floating point number.  On&nbsp;most machines this is
approximately 1.8x10^308.

          <br><dt><code>i</code>
          <dd>Integer binary format.  Each file is a sequence of integers, interpreted
as the t and&nbsp;y coordinates of the successive data
points in a dataset.  If y is d-dimensional, there will be
d+1 numbers for each point.  Successive datasets are separated by
a single occurrence of the quantity <code>INT_MAX</code>, which is the largest
possible integer.  On&nbsp;most machines this is 2^31-1. 
</dl>

     <br><dt><code>-a [</code><var>step_size</var><code> [</code><var>lower_limit</var><code>]]</code>
     <dd><dt><code>--auto-abscissa [</code><var>step_size</var><code> [</code><var>lower_limit</var><code>]]</code>
     <dd>(Floats, defaults 1.0 and 0.0.)  Automatically generate values for the
independent variable&nbsp;(t).  Irrespective of data format
(<code>a</code>, <code>f</code>, <code>d</code>, or&nbsp;<code>i</code>), this option specifies
that the values of the independent variable (t) are missing from
the input file: the dataset(s) to be read contain only values of the
dependent variable&nbsp;(y), so&nbsp;that if y is
d-dimensional, there will be only d&nbsp;numbers for each
point.  The increment from each t&nbsp;value to the next will be
<var>step_size</var>, and the first t&nbsp;value will be
<var>lower_limit</var>.

     <br><dt><code>-A</code>
     <dd><dt><code>--auto-dist-abscissa</code>
     <dd>Automatically generate values for the independent variable&nbsp;(t).  This is a variant form of the <code>-a</code> option.  The
increment from each t&nbsp;value to the next will be the distance
between the corresponding y values, and the first t&nbsp;value will be 0.0.  This option is useful when interpolating curves
rather than functions (see <a href="#Advanced%20Use%20of%20spline">Advanced Use of spline</a>).

     <br><dt><code>-O </code><var>data-format</var><code></code>
     <dd><dt><code>--output-format </code><var>data-format</var><code></code>
     <dd>(Character, default <code>a</code>.)  Set the data format for the output file
to be <var>data-format</var>.  The interpretation of the <var>data-format</var>
argument is the same as for the <code>-I</code> option.

     <br><dt><code>-P </code><var>significant-digits</var><code></code>
     <dd><dt><code>--precision </code><var>significant-digits</var><code></code>
     <dd>(Positive integer, default 6.)  Set the numerical precision for the
t and y values in the output file to be
<var>significant-digits</var>.  This takes effect only if the output file is
written in <code>a</code> format, i.e., in ASCII.

     <br><dt><code>-s</code>
     <dd><dt><code>--suppress-abscissa</code>
     <dd>Omit the independent variable t from the output file; for each
point, supply only the dependent variable&nbsp;y.  If y is
d-dimensional, there will be only d&nbsp;numbers for each
point, not&nbsp;d+1.  This option is useful when interpolating
curves rather than functions (see <a href="#Advanced%20Use%20of%20spline">Advanced Use of spline</a>). 
</dl>

<p>The following options request information.

     <dl>
<dt><code>--help</code>
     <dd>Print a list of command-line options, and then exit.

     <br><dt><code>--version</code>
     <dd>Print the version number of <code>spline</code> and the plotting utilities
package, and exit. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="ode">ode</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#libplot">libplot</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#spline">spline</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">8 The <code>ode</code> Program</h2>

<p>The GNU <code>ode</code> utility can produce a numerical solution to the
initial value problem for many systems of first-order ordinary
differential equations (ODE's).  <code>ode</code> can also be used to solve
systems of higher-order ODE's, since a simple procedure converts an
n'th-order equation into n&nbsp;first-order equations.  The
output of <code>ode</code> can easily be piped to <code>graph</code>, so that one or
more solution curves may be plotted as they are generated.

   <p>Three distinct schemes for numerical solution are implemented:
Runge-Kutta-Fehlberg (the default), Adams-Moulton, and Euler.  The
Runge-Kutta-Fehlberg and Adams-Moulton schemes are available with
adaptive stepsize.

<ul class="menu">
<li><a accesskey="1" href="#Basic%20Math">Basic Math</a>:                   Ordinary differential equations
<li><a accesskey="2" href="#Simple%20ode%20Examples">Simple ode Examples</a>:          Simple examples using ode
<li><a accesskey="3" href="#Additional%20ode%20Examples">Additional ode Examples</a>:      Additional examples using ode
<li><a accesskey="4" href="#ode%20Invocation">ode Invocation</a>:               ode command-line options
<li><a accesskey="5" href="#Diagnostics">Diagnostics</a>:                  Diagnostic messages
<li><a accesskey="6" href="#Numerical%20Error">Numerical Error</a>:              Numerical error and how to avoid it
<li><a accesskey="7" href="#Running%20Time">Running Time</a>:                 Time spent running ode
<li><a accesskey="8" href="#Input%20Language">Input Language</a>:               The ode input language formally specified
<li><a accesskey="9" href="#ODE%20Bibliography">ODE Bibliography</a>:             Bibliography on ode and ODE's

   </ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Basic%20Math">Basic Math</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Simple%20ode%20Examples">Simple ode Examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ode">ode</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.1 Mathematical basics</h3>

<p>We begin with some standard definitions.  A <em>differential equation</em>
is an equation involving an unknown function and its derivatives.  A&nbsp;differential equation is <em>ordinary</em> if the unknown function
depends on only one independent variable, often denoted&nbsp;t. 
The <em>order</em> of the differential equation is the order of the
highest-order derivative in the equation.  One speaks of a family, or
<em>system</em> of equations when more than one equation is involved. 
If&nbsp;the equations are dependent on one another, they are said to be
<em>coupled</em>.  A&nbsp;<em>solution</em> is any function satisfying the
equations.  An <em>initial value problem</em> is present when there exist
subsidiary conditions on the unknown function and its derivatives, all
of which are given at the same value of the independent variable.  In
principle, such an `initial condition' specifies a unique solution. 
Questions about the existence and uniqueness of a solution, along with
further terminology, are discussed in any introductory text.  (See
Chapter&nbsp;1 of Birkhoff and Rota's <cite>Ordinary Differential
Equations</cite>.  For this and other references relevant to <code>ode</code>, see
<a href="#ODE%20Bibliography">ODE Bibliography</a>.)

   <p>In practical problems, the solution of a differential equation is
usually not expressible in&nbsp;terms of elementary functions.  Hence the
need for a numerical solution.

   <p>A numerical scheme for solving an initial value problem produces an
approximate solution, using only functional evaluations and the
operations of arithmetic.  <code>ode</code> solves first-order initial value
problems of the form:

<pre class="example">     x' = f(t,x,y,...,z)
     y' = g(t,x,y,...,z)
        .
        .
        .
     z' = h(t,x,y,...,z)
     </pre>

<p>given the initial values for each dependent variable at the initial
value of the independent variable&nbsp;t, i.e.,

<pre class="example">     x(a) = b
     y(a) = c
          .
          .
          .
     z(a) = d
     t = a
     </pre>

<p>where a,b,c,...,d are constants.

   <p>For <code>ode</code> to be able to solve such a problem numerically, the
functions f,g,<small class="dots">...</small>,h must be expressed, using the usual operators
(+,&nbsp;-, *, /, and&nbsp;^), in&nbsp;terms of
certain basic functions that <code>ode</code> recognizes.  These are the same
functions that the plotting program <code>gnuplot</code> recognizes. 
Moreover, each of f,g,<small class="dots">...</small>,h must be given explicitly.  <code>ode</code>
cannot deal with a system in which one or more of the first derivatives
is defined implicitly rather than explicitly.

   <p>All schemes for numerical solution involve the calculation of an
approximate solution at discrete values of the independent variable&nbsp;t, where the `stepsize' (the difference between any two
successive values of&nbsp;t, usually denoted&nbsp;h) may be
constant or chosen adaptively.  In&nbsp;general, as the stepsize
decreases the solution becomes more accurate.  In&nbsp;<code>ode</code>, the
stepsize can be adjusted by the user.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Simple%20ode%20Examples">Simple ode Examples</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Additional%20ode%20Examples">Additional ode Examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Basic%20Math">Basic Math</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.2 Simple examples using <code>ode</code></h3>

<p>The following examples should illustrate the procedure of stating an
initial value problem and solving it with <code>ode</code>.  If&nbsp;these
examples are too elementary, see <a href="#Input%20Language">Input Language</a>, for a formal
specification of the <code>ode</code> input language.  There is also a
directory containing examples of <code>ode</code> input, which is distributed
along with the GNU plotting utilities.  On&nbsp;most systems it is
installed as <code>/usr/share/ode</code> or <code>/usr/local/share/ode</code>.

   <p>Our first example is a simple one, namely

<pre class="example">     y'(t) = y(t)
     </pre>

<p>with the initial condition

<pre class="example">     y(0) = 1
     </pre>

<p>The solution to this differential equation is

<pre class="example">     y(t) = e^t.
     </pre>

<p>In particular

<pre class="example">     y(1) = e^1 = 2.718282
     </pre>

<p>to seven digits of accuracy.

   <p>You may obtain this result with the aid of <code>ode</code> by typing on the
command line the sequence of commands

<pre class="example">     ode
     y' = y
     y = 1
     print t, y
     step 0, 1
     </pre>

<p>Two columns of numbers will appear.  Each line will show the value of
the independent variable&nbsp;t, and the value of the
variable&nbsp;y, as t is `stepped' from 0 to&nbsp;1.  The
last line will be

<pre class="example">     1 2.718282
     </pre>

<p>as expected.  You may use the <code>-p</code> option to change the precision. 
If, for&nbsp;example, you type <code>ode -p 10</code> rather than <code>ode</code>,
you will get ten digits of accuracy in the output, rather than seven
(the default).

   <p>After the above output, <code>ode</code> will wait for further instructions. 
Entering for example the line

<pre class="example">     step 1, 0
     </pre>

<p>should yield two more columns of numbers, containing the values of
t and y that are computed when t&nbsp;is stepped
back from 1 to&nbsp;0.  You could type instead

<pre class="example">     step 1, 2
     </pre>

<p>to increase rather than decrease&nbsp;t.  To&nbsp;exit <code>ode</code>,
you would type a line containing only <code>.</code>, i.e. a&nbsp;single period,
and tap `return'.  <code>ode</code> will also exit if it sees an end-of-file
indicator in its input stream, which you may send from your terminal by
typing control-D.

   <p>Each line of the preceding example should be self-explanatory.  A&nbsp;<code>step</code> statement sets the beginning and the end of an interval
over which the independent variable (here,&nbsp;t) will range, and
causes <code>ode</code> to set the numerical scheme in motion.  The initial
value appearing in the first <code>step</code> statement (i.e.,&nbsp;0) and the
assignment statement

<pre class="example">     y = 1
     </pre>

<p>are equivalent to the initial condition y(0) = 1.  The statements
<code>y'&nbsp;=&nbsp;y</code> and <code>y = 1</code> are very different: <code>y' = y</code>
defines a way of computing the derivative of&nbsp;y, while <code>y
= 1</code> sets the initial value of&nbsp;y.  Whenever a <code>step</code>
statement is encountered, <code>ode</code> tries to step the independent
variable through the interval it specifies.  Which values are to be
printed at each step is specified by the most recent <code>print</code>
statement.  For&nbsp;example,

<pre class="example">     print t, y, y'
     </pre>

<p>would cause the current value of the independent variable&nbsp;t,
the variable&nbsp;y, and its derivative to be printed at each
step.

   <p>To illustrate <code>ode</code>'s ability to take its input or the initial part
of its input from a file, you could prepare a file containing the
following lines:

<pre class="example">     # an ode to Euler
     y  = 1
     y' = y
     print t, y, y'
     </pre>

<p>Call this file <code>euler</code>.  (The <code>#</code> line is a comment line,
which may appear at any point.  Everything from the&nbsp;<code>#</code> to the
end of the line on which it appears will be ignored.)  To&nbsp;process
this file with <code>ode</code>, you could type on your terminal

<pre class="example">     ode -f euler
     step 0, 1
     </pre>

<p>These two lines cause <code>ode</code> to read the file <code>euler</code>, and the
stepping to take place.  You will now get three quantities (t,
y, and y') printed at each of the values of&nbsp;t
between 0 and&nbsp;1.  At&nbsp;the conclusion of the stepping, <code>ode</code>
will wait for any further commands to be input from the terminal.  This
example illustrates that

<pre class="example">     ode -f euler
     </pre>

<p>is not equivalent to

<pre class="example">     ode &lt; euler
     </pre>

<p>The latter would cause <code>ode</code> to take all its input from the file
<code>euler</code>, while the former allows subsequent input from the
terminal.  For the latter to produce output, you would need to include a
<code>step</code> line at the end of the file.  You would not need to include
a <code>.</code> line, however.  <code>.</code>&nbsp;is used to terminate input only
when input is being read from a terminal.

   <p>A second simple example involves the numerical solution of a
second-order differential equation.  Consider the initial value problem

<pre class="example">     y''(t) = -y(t)
     y(0) = 0
     y'(0) = 1
     </pre>

<p>Its solution would be

<pre class="example">     y(t) = sin(t)
     </pre>

<p>To solve this problem using <code>ode</code>, you must express this
second-order equation as two first-order equations.  Toward this end you
would introduce a new function, called yp say, of the independent
variable&nbsp;t.  The pair of equations

<pre class="example">     y' = yp
     yp' = -y
     </pre>

<p>would be equivalent to the single equation above.  This sort of
reduction of an n'th order problem to n first order
problems is a standard technique.

   <p>To plot the variable y as a function of the variable&nbsp;t, you could create a file containing the lines

<pre class="example">     # sine : y''(t) = -y(t), y(0) = 0, y'(0) = 1
     sine' = cosine
     cosine' = -sine
     sine = 0
     cosine = 1
     print t, sine
     </pre>

<p>(y and yp have been renamed <i>sine</i> and <i>cosine</i>, since
that is what they will be.)  Call this file <code>sine</code>.  To display the
generated data points on an X&nbsp;Window System display as they are
generated, you would type

<pre class="example">     ode -f sine | graph -T X -x 0 10 -y -1 1
     step 0, 2*PI
     .
     </pre>

<p>After you type the <code>ode</code> line, <code>graph -T&nbsp;X</code> will pop&nbsp;up a window, and after you type the <code>step</code> line, the generated
dataset will be drawn in&nbsp;it.  The <code>-x 0 10</code> and <code>-y -1 1</code>
options, which set the bounds for the two axes, are necessary if you
wish to display points in real&nbsp;time: as they are generated. 
If&nbsp;the axis bounds were not specified on the command line,
<code>graph -T&nbsp;X</code> would wait until all points are read from the
input before determining the bounds, and drawing the plot.

   <p>A slight modification of this example, showing how <code>ode</code> can
generate several datasets in succession and plot them on the same graph,
would be the following.  Suppose that you type on your terminal the
following lines.

<pre class="example">     ode -f sine | graph -T X -C -x 0 10 -y -1 1
     step 0, PI
     step PI, 2*PI
     step 2*PI, 3*PI
     .
     </pre>

<p>Then the sine curve will be traced out in three stages.  Since the
output from each <code>step</code> statement ends with a blank line,
<code>graph -T&nbsp;X</code> will treat each section of the sine curve as a
different dataset.  If you are using a color display, each of the three
sections will be plotted in a different color.  This is a feature
provided by <code>graph</code>, which normally changes its linemode after each
dataset it reads.  If you do not like this feature, you may turn it off
by using <code>graph -T X -B</code> instead of <code>graph -T&nbsp;X</code>.

   <p>In the above examples, you could use any of the other variants of
<code>graph</code> instead of <code>graph -T&nbsp;X</code>.  For example, you could use
<code>graph -T ps</code> to obtain a plot in encapsulated Postscript format,
by typing

<pre class="example">     ode -f sine | graph -T ps &gt; plot.ps
     step 0, 2*PI
     .
     </pre>

<p>You should note that of the variants of <code>graph</code>, the variants
<code>graph -T png</code>, <code>graph -T pnm</code>, <code>graph -T gif</code>,
<code>graph -T svg</code>, <code>graph -T ai</code>, <code>graph -T ps</code>, <code>graph
-T cgm</code>, <code>graph -T fig</code>, <code>graph -T pcl</code> and <code>graph -T
hpgl</code> do not produce output in real time, even when the axis bounds are
specified with the <code>-x</code> and&nbsp;<code>-y</code> options.  So&nbsp;if any
of these variants is used, the plot will be produced only when input
from <code>ode</code> is terminated, which will occur when you type&nbsp;<code>.</code>.

   <p>In the preceding examples, the derivatives of the dependent variables
were specified by comparatively simple expressions.  They are allowed to
be arbitrarily complicated functions of the dependent variables and the
independent variable.  They may also involve any of the functions that
are built into <code>ode</code>.  <code>ode</code> has a fair number of functions
built&nbsp;in, including <tt>abs</tt>, <tt>sqrt</tt>, <tt>exp</tt>, <tt>log</tt>, <tt>log10</tt>,
<tt>sin</tt>, <tt>cos</tt>, <tt>tan</tt>, <tt>asin</tt>, <tt>acos</tt>, <tt>atan</tt>, <tt>sinh</tt>,
<tt>cosh</tt>, <tt>tanh</tt>, <tt>asinh</tt>, <tt>acosh</tt>, and <tt>atanh</tt>.  Less familiar
functions which are built into&nbsp;it are <tt>besj0</tt>, <tt>besj1</tt>,
<tt>besy0</tt>, <tt>besy1</tt>, <tt>erf</tt>, <tt>erfc</tt>, <tt>inverf</tt>, <tt>lgamma</tt>,
<tt>gamma</tt>, <tt>norm</tt>, <tt>invnorm</tt>, <tt>ibeta</tt>, and <tt>igamma</tt>.  These have
the same definitions as in the plotting program <code>gnuplot</code>.  (All
functions take a single argument, except for <tt>ibeta</tt>, which takes
three, and <tt>igamma</tt>, which takes two).  <code>ode</code> also knows the
meaning of the constant <code>PI</code>, as the above examples show.  The
names of the preceding functions are reserved, so, e.g., <code>cos</code> and
<code>sin</code> may not be used as names for variables.

   <p>Other than the restriction of avoiding reserved names and keywords, the
names of variables may be chosen arbitrarily.  Any sequence of
alphanumeric characters starting with an alphabetic character may be
used; the first 32 characters are significant.  It&nbsp;is worth noting
that <code>ode</code> identifies the independent variable by the fact that it
is (or should be) the only variable that has not appeared on the left
side of a differential equation or an initial value assignment.  If&nbsp;there is more than than one such variable then no stepping takes place;
instead, an error message is printed.  If&nbsp;there is no such variable,
a&nbsp;dummy independent variable is invented and given the name
<code>(indep)</code>, internally.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Additional%20ode%20Examples">Additional ode Examples</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#ode%20Invocation">ode Invocation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple%20ode%20Examples">Simple ode Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.3 Additional examples using <code>ode</code></h3>

<p>We explain here how to use some additional features of <code>ode</code>. 
However, the discussion below does not cover all of its capabilities. 
For a complete list of command-line options, see <a href="#ode%20Invocation">ode Invocation</a>.

   <p>It is easy to use <code>ode</code> to create plots of great beauty.  An
example would be a plot of a <em>strange attractor</em>, namely the Lorenz
attractor.  Suppose that a file named <code>lorenz</code> contains the
following lines.

<pre class="example">     # The Lorenz model, a system of three coupled ODE's with parameter r.
     x' = -3*(x-y)
     y' = -x*z+r*x-y
     z' = x*y-z
     
     r = 26
     x = 0; y = 1; z = 0
     
     print x, y
     step 0, 200
     </pre>

<p>Then executing the command

<pre class="example">     ode &lt; lorenz | graph -T X -C -x -10 10 -y -10 10
     </pre>

<p>would produce a plot of the Lorenz attractor (strictly speaking, a&nbsp;plot of one of its two-dimensional projections).  You may produce a
Postscript plot of the Lorenz attractor, and print it, by doing
something like

<pre class="example">     ode &lt; lorenz | graph -T ps -x -10 10 -y -10 10 -W 0 | lpr
     </pre>

<p>The <code>-W 0</code> ("zero width") option requests that <code>graph -T ps</code>
use the thinnest line possible, to improve the visual appearance of the
plot on a printer or other Postscript device.

   <p>Besides plotting a visually striking object in real time, the Lorenz
attractor example shows how statements may be separated by semicolons,
rather than appearing on different lines.  It&nbsp;also shows how to use
symbolic constants.  In&nbsp;the description read by <code>ode</code> the
parameter&nbsp;r is a variable like x, y, and&nbsp;z.  But unlike them it is not updated during stepping, since no
formula for its derivative&nbsp;r' is given.

   <p>Our second example deals with the interactive construction of a `phase
portrait': a&nbsp;set of solution curves with different initial
conditions.  Phase portraits are of paramount interest in the
qualitative theory of differential equations, and also possess
&aelig;sthetic appeal.

   <p>Since a description read by <code>ode</code> may contain any number of
<code>step</code> statements, multiple solution curves may be plotted in a
single run.  The most recent <code>print</code> statement will be used with
each <code>step</code> statement.  In&nbsp;practice, a phase portrait would be
drawn from a few well-chosen solution curves.  Choosing a good set of
solution curves may require experimentation, which makes interactivity
and real-time plotting all-important.

   <p>As an example, consider a so-called Lotka-Volterra predator-prey
model.  Suppose that in a lake there are two species of fish: A&nbsp;(the&nbsp;prey) who live by eating a plentiful supply of plants, and B (the
predator) who eat&nbsp;A.  Let x(t) be the population of&nbsp;A
and y(t) the population of&nbsp;B at time&nbsp;t.  A&nbsp;crude model for the interaction of A and&nbsp;B is given by the
equations

<pre class="example">     x' = x(a-by)
     y' = y(cx-d)
     </pre>

<p>where a, b, c, d are positive constants.  To draw a phase
portrait for this system interactively, you could type

<pre class="example">     ode | graph -T X -C -x 0 5 -y 0 5
     x' = (a - b*y) * x
     y' = (c*x - d) * y
     a = 1; b = 1; c = 1; d = 1;
     print x, y
     x = 1; y = 2
     step 0, 10
     x = 1; y = 3
     step 0, 10
     x = 1; y = 4
     step 0, 10
     x = 1; y = 5
     step 0, 10
     .
     </pre>

<p>Four curves will be drawn in succession, one per <code>step</code> line.  They
will be periodic; this periodicity is similar to the fluctuations
between predator and prey populations that occur in real-world
ecosystems.  On&nbsp;a color display the curves will appear in different
colors, since by&nbsp;default, <code>graph</code> changes the linemode between
datasets.  That feature may be turned&nbsp;off by using <code>graph -T X
-B</code> rather than <code>graph -T&nbsp;X</code>.

   <p>It is sometimes useful to use <code>ode</code> and <code>graph</code> to plot
discrete points, which are not joined by line segments to form a curve. 
Our third example illustrates this.  Suppose the file <code>atwoods</code>
contains the lines

<pre class="example">     m = 1
     M = 1.0625
     a = 0.5; adot = 0
     l = 10; ldot = 0
     
     ldot' = ( m * l * adot * adot - M * 9.8 + m * 9.8 * cos(a) ) / (m + M)
     l'    = ldot
     adot' = (-1/l) * (9.8 * sin(a) +  2 * adot * ldot)
     a'    = adot
     
     print l, ldot
     step 0, 400
     </pre>

<p>The first few lines describe the functioning of a so-called swinging
Atwood's machine.  An ordinary Atwood's machine consists of a taut cord
draped over a pulley, with a mass attached to the cord at each end. 
Normally, the heavier mass&nbsp;(M) would win against the lighter
mass&nbsp;(m), and draw it upward.  A&nbsp;swinging Atwood's
machine allows the lighter mass to swing back and forth as&nbsp;well as
move vertically.

   <p>The <code>print l, ldot</code> statement requests that the vertical position
and vertical velocity of the lighter mass be printed out at each step. 
If&nbsp;you run the command

<pre class="example">     ode &lt; atwoods | graph -T X -x 9 11 -y -1 1 -m 0 -S 1 -X l -Y ldot
     </pre>

<p>you will obtain a real-time plot.  The <code>-m 0</code> option requests that
successive data points not be joined by line segments, and the <code>-S
1</code> option requests that plotting symbol&nbsp;#1 (a&nbsp;dot) be plotted at
the location of each point.  As you will see if you run this command,
the heavy mass does not win against the lighter mass.  Instead the
machine oscillates non-periodically.  Since the motion is non-periodic,
the plot benefits from being drawn as a sequence of unconnected points.

   <p>We conclude by mentioning a few features of <code>ode</code> that may be
useful when things are not going quite right.  One of them is the
<code>examine</code> statement.  It&nbsp;may be used to discover pertinent
information about any variable in a system.  For details, see <a href="#Input%20Language">Input Language</a>.

   <p>Another useful feature is that the <code>print</code> statement may be used to
print out more than just the value of a variable.  As we have seen, if
the name of the variable is followed by <code>'</code>, the derivative of the
variable will be printed instead.  In&nbsp;a similar way, following the
variable name with <code>?</code>, <code>!</code>, or <code>~</code> prints respectively
the relative single-step error, the absolute single-step error, or the
accumulated error (not currently implemented).  These quantities are
discussed in <a href="#Numerical%20Error">Numerical Error</a>.

   <p>The <code>print</code> statement may be more complicated than was shown in the
preceding examples.  Its general structure is

<pre class="example">     print &lt;pr-list&gt; [every &lt;const&gt;] [from &lt;const&gt;]
     </pre>

<p>The bracket notation <code>[...]</code> means that the enclosed statements
are optional.  Until now we have not mentioned the <code>every</code> clause
or the <code>from</code> clause.  The <tt>&lt;pr-list&gt;</tt> is familiar, however; it
is simply a comma-separated list of variables.  For example, in the
statement

<pre class="example">     print t, y, y' every 5 from 1
     </pre>

<p>the <tt>&lt;pr-list&gt;</tt> is <tt>&lt;t, y, y'&gt;</tt>.  The clauses <code>every 5</code> and
<code>from 1</code> specify that printing should take place after every fifth
step, and that the printing should begin when the independent
variable&nbsp;t reaches&nbsp;1.  An&nbsp;<code>every</code> clause is
useful if you wish to `thin&nbsp;out' the output generated by a
<code>step</code> statement, and a <code>from</code> clause is useful if you wish to
view only the final portion of a solution curve.

<div class="node">
<p><hr>
Node:&nbsp;<a name="ode%20Invocation">ode Invocation</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Diagnostics">Diagnostics</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Additional%20ode%20Examples">Additional ode Examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.4 <code>ode</code> command-line options</h3>

<p>The command-line options to <code>ode</code> are listed below.  There are
several sorts of option:

     <ol type=1 start=1>
<li>Options affecting the way in which input is read. 
<li>Options affecting the format of the output. 
<li>Options affecting the choice of numerical solution scheme, and the
error bounds that will be imposed on&nbsp;it. 
<li>Options that request information.
        </ol>

<p>The following option affects the way input is read.

     <dl>
<dt><code>-f </code><var>filename</var><code></code>
     <dd><dt><code>--input-file </code><var>filename</var><code></code>
     <dd>Read input from <var>filename</var> before reading from standard input. 
</dl>

<p>The following options affect the output format.

     <dl>
<dt><code>-p </code><var>significant-digits</var><code></code>
     <dd><dt><code>--precision </code><var>significant-digits</var><code></code>
     <dd>(Positive integer, default 6.)  When printing numerical results, use a
precision specified by <var>significant-digits</var>.  If&nbsp;this option is
given, the print format will be scientific notation.

     <br><dt><code>-t</code>
     <dd><dt><code>--title</code>
     <dd>Print a title line at the head of the output, naming the columns.  If&nbsp;this option is given, the print format will be scientific notation. 
</dl>

<p>The following options specify the numerical integration scheme.  Only
one of the three basic option <code>-R</code>, <code>-A</code>, and <code>-E</code> may be
specified.  The default is <code>-R</code> (Runge-Kutta-Fehlberg).

     <dl>
<dt><code>-R [</code><var>stepsize</var><code>]</code>
     <dd><dt><code>--runge-kutta [</code><var>stepsize</var><code>]</code>
     <dd>Use a fifth-order Runge-Kutta-Fehlberg algorithm, with an adaptive
stepsize unless a constant stepsize is specified.  When a constant
stepsize is specified and no error analysis is requested, then a
classical fourth-order Runge-Kutta scheme is used.

     <br><dt><code>-A [</code><var>stepsize</var><code>]</code>
     <dd><dt><code>--adams-moulton [</code><var>stepsize</var><code>]</code>
     <dd>Use a fourth-order Adams-Moulton predictor-corrector scheme, with an
adaptive stepsize unless a constant stepsize, <var>stepsize</var>, is
specified.  The Runge-Kutta-Fehlberg algorithm is used to get past
`bad' points (if&nbsp;any).

     <br><dt><code>-E [</code><var>stepsize</var><code>]</code>
     <dd><dt><code>--euler [</code><var>stepsize</var><code>]</code>
     <dd>Use a `quick and dirty' Euler scheme, with a constant stepsize.  The
default value of <var>stepsize</var> is&nbsp;0.1.  Not recommended for serious
applications.

     <p>The error bound options <code>-r</code> and <code>-e</code> (see below) may not
be used if <code>-E</code> is specified.

     <br><dt><code>-h </code><var>hmin</var><code> [</code><var>hmax</var><code>]</code>
     <dd><dt><code>--step-size-bound </code><var>hmin</var><code> [</code><var>hmax</var><code>]</code>
     <dd>Use a lower bound <var>hmin</var> on the stepsize.  The numerical scheme will
not let the stepsize go below <var>hmin</var>.  The default is to allow the
stepsize to shrink to the machine limit, i.e., the minimum nonzero
double-precision floating point number.  The optional argument
<var>hmax</var>, if included, specifies a maximum value for the stepsize. 
It&nbsp;is useful in preventing the numerical routine from skipping
quickly over an interesting region. 
</dl>

<p>The following options set the error bounds on the numerical solution
scheme.

     <dl>
<dt><code>-r </code><var>rmax</var><code> [</code><var>rmin</var><code>]</code>
     <dd><dt><code>--relative-error-bound </code><var>rmax</var><code> [</code><var>rmin</var><code>]</code>
     <dd>
<br><dt><code>-e </code><var>emax</var><code> [</code><var>emin</var><code>]</code>
     <dd><dt><code>--absolute-error-bound </code><var>emax</var><code> [</code><var>emin</var><code>]</code>
     <dd>The <code>-r</code> option sets an upper bound on the relative single-step
error.  If the <code>-r</code> option is used, the relative single-step error
in any dependent variable will never exceed <var>rmax</var> (the default for
which is 10^(-9)).  If this should occur, the solution will be
abandoned and an error message will be printed.  If&nbsp;the stepsize is
not constant, the stepsize will be decreased `adaptively', so that the
upper bound on the single-step error is not violated.  Thus, choosing a
smaller upper bound on the single-step error will cause smaller
stepsizes to be chosen.  A&nbsp;lower bound <var>rmin</var> may optionally be
specified, to suggest when the stepsize should be increased (the default
for <var>rmin</var> is <var>rmax</var>/1000).  The <code>-e</code> option is similar to
<code>-r</code>, but bounds the absolute rather than the relative single-step
error.

     <br><dt><code>-s</code>
     <dd><dt><code>--suppress-error-bound</code>
     <dd>Suppress the ceiling on single-step error, allowing <code>ode</code> to
continue even if this ceiling is exceeded.  This may result in large
numerical errors. 
</dl>

<p>Finally, the following options request information.

     <dl>
<dt><code>--help</code>
     <dd>Print a list of command-line options, and then exit.

     <br><dt><code>--version</code>
     <dd>Print the version number of <code>ode</code> and the plotting utilities
package, and exit. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Diagnostics">Diagnostics</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Numerical%20Error">Numerical Error</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ode%20Invocation">ode Invocation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.5 Diagnostic messages</h3>

<p><code>ode</code> is always in one of two states:

     <ul>
<li>Reading input.  The input includes a specification of a system of
ordinary differential equations, together with instructions for
solving&nbsp;it numerically: a&nbsp;<code>print</code> line and a <code>step</code>
line.

     <li>Numerically solving a system, and printing the resulting output. 
</ul>

<p><code>ode</code> moves from the first to the second state after it sees and
processes a <code>step</code> line.  It&nbsp;returns to the first state after
the generated output has been printed.  Errors may occur in the
`reading' state or the `solving' state, and may terminate computations
or even cause <code>ode</code> to exit.  We now explain the possible sorts of
error.

   <p>While reading input, <code>ode</code> may encounter a syntax error: an
ungrammatical line that it is unable to parse.  (For a summary of its
input grammar, see <a href="#Input%20Language">Input Language</a>.)  If&nbsp;so, it emits the error
message

<pre class="example">     ode::nnn: syntax error
     </pre>

<p>where <code>nnn</code> is the number of the line containing the error.  When
the <code>-f filename</code> option is used to specify an input file,
the error message will read

<pre class="example">     ode:filename:nnn: syntax error
     </pre>

<p>for errors encountered inside the input file.  Subsequently, when
<code>ode</code> begins reading the standard input, line numbers will start
over again from&nbsp;1.

   <p>No effort is made to recover from syntax errors in the input.  However,
there is a meager effort to resynchronize, so that more than one syntax
error in a file may be found at the same time.

   <p>It is also possible that a fatal arithmetic exception (such as a
division by zero, or a floating point overflow) may occur while
<code>ode</code> is reading input.  If such an exception occurs, <code>ode</code>
will print an "Floating point exception" error message and exit. 
Arithmetic exceptions are machine-dependent.  On&nbsp;some machines, the
line

<pre class="example">     y = 1/0
     </pre>

<p>would induce an arithmetic exception.  Also on some machines (not
necessarily the same ones), the lines

<pre class="example">     y = 1e100
     z = y^4
     </pre>

<p>would induce an arithmetic exception.  That is because on most
machines, the double precision quantities that <code>ode</code> uses
internally are limited to a maximum size of approximately 1.8x10^308.

   <p>When <code>ode</code> is in the `solving' state, i.e., computing a numerical
solution, similar arithmetic exceptions may occur.  If so, the solution
will be interrupted and a message resembling

<pre class="example">     ode: arithmetic exception while calculating y'
     </pre>

<p>will be printed.  However, <code>ode</code> will not exit; the exception will
be `caught'.  <code>ode</code> itself recognizes the following exceptional
conditions: square root of a negative number, logarithm of a
non-positive number, and negative number raised to a non-integer power. 
<code>ode</code> will catch any of these operations before it is performed,
and print an error message specifying which illegal operation it has
encountered.

<pre class="example">     ode: square root of a negative number while calculating y'
     </pre>

<p>would be a typical error message.

   <p>If the machine on which <code>ode</code> is running supports the
<code>matherr</code> facility for reporting errors in the computation of
standard mathematical functions, it will be used.  This facility reports
domain errors and range errors (overflows, underflows, and losses of
significance) that could occur when evaluating such functions as
<code>log</code>, <code>gamma</code>, etc.; again, before they are performed.  If
the <code>matherr</code> facility is present, the error message will be fairly
informative.  For&nbsp;example, the error message

<pre class="example">     ode: range error (overflow) in lgamma while calculating y'
     </pre>

<p>could be generated if the logarithmic gamma function <code>lgamma</code> is
evaluated at a value of its argument that is too large.  The generation
of any such message, except a message warning of an underflow, will
cause the numerical solution to be interrupted.

   <p>There is another sort of error that may occur during numerical solution:
the condition that an error ceiling, which the user may set with the
<code>-r</code> option or the <code>-e</code> option, is exceeded.  This too will
cause the numerical solution to be abandoned, and <code>ode</code> to switch
back to reading input.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Numerical%20Error">Numerical Error</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Running%20Time">Running Time</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Diagnostics">Diagnostics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.6 Numerical error and how to avoid it</h3>

<p>This discussion is necessarily incomplete.  Entire books exist on any
subject mentioned below (e.g., floating point error).  Our goals are
modest: first, to introduce the basic notions of error analysis as they
apply to <code>ode</code>; second, to&nbsp;steer you around the more obvious
pitfalls.  You should look through a numerical analysis text (e.g.,
Atkinson's <cite>Introduction to Numerical Analysis</cite>) before beginning
this discussion.

   <p>We begin with some key definitions.  The error of greatest concern is
the difference between the actual solution and the numerical
approximation to the solution; this is termed the <em>accumulated
error</em>, since the error is built&nbsp;up during each numerical step. 
Unfortunately, an estimate of this error is usually not available
without knowledge of the actual solution.  There are, however, several
more usable notions of error.  The <em>single-step error</em>, in
particular, is the difference between the actual solution and the
numerical approximation to the solution after any single step, assuming
the value at the beginning of the step is correct.

   <p>The <em>relative single-step error</em> is the single-step error, divided
by the current value of the numerical approximation to the solution. 
Why not divided by the current value of the solution itself?  The reason
is that the solution is not exactly known.  When free to choose a
stepsize, <code>ode</code> will do so on the basis of the relative single-step
error.  By&nbsp;default, it will choose the stepsize so as to maintain an
accuracy of eight significant digits in each step.  That is, it will
choose the stepsize so as not to violate an upper bound of
10^(-9) on the relative single-step error.  This ceiling may be
adjusted with the <code>-r</code> option.

   <p>Where does numerical error come from?  There are two sources.  The first
is the finite precision of machine computation.  All computers work with
floating point numbers, which are not real numbers, but only an
approximation to real numbers.  However, all computations performed by
<code>ode</code> are done to double precision, so floating point error tends
to be relatively small.  You may nonetheless detect the difference
between real numbers and floating point numbers by experimenting with
the <code>-p 17</code> option, which will print seventeen significant digits. 
On&nbsp;most machines, that is the precision of a double precision
floating point number.

   <p>The second source of numerical error is often called the
<em>theoretical truncation error</em>.  It&nbsp;is the difference between
the actual solution and the approximate solution due solely to the
numerical scheme.  At the root of many numerical schemes is an infinite
series; for ordinary differential equations, it&nbsp;is a Taylor
expansion.  Since the computer cannot compute all the terms in an
infinite series, a&nbsp;numerical scheme necessarily uses a truncated
series; hence the term.  The single-step error is the sum of the
theoretical truncation error and the floating point error, though in
practice the floating point error is seldom included.  The single-step
error estimated by <code>ode</code> consists only of the theoretical
truncation error.

   <p>We say that a numerical scheme is <em>stable</em>, when applied to a
particular initial value problem, if the error accumulated during the
solution of the problem over a fixed interval decreases as the stepsize
decreases; at&nbsp;least, over a wide range of step sizes.  With this
definition both the Runge-Kutta-Fehlberg (<code>-R</code>) scheme and the
Adams-Moulton (<code>-A</code>) scheme are stable (a&nbsp;statement based more
on experience than on theoretical results) for a wide class of problems.

   <p>After these introductory remarks, we list some common sources of
accumulated error and instability in any numerical scheme.  Usually,
problems with large accumulated error and instability are due to the
single-step error in the vicinity of a `bad' point being large.

     <ol type=1 start=1>
<li>Singularities.

     <p><code>ode</code> should not be used to generate a numerical solution on any
interval containing a singularity.  That is, <code>ode</code> should not be
asked to step over points at which the system of differential equations
is singular or undefined.

     <p>You will find the definitions of singular point, regular singular point,
and irregular singular point in any good differential equations text. 
If you have no favorite, try Birkhoff and Rota's <cite>Ordinary
Differential Equations</cite>, Chapter&nbsp;9.  Always locate and classify the
singularities of a system, if&nbsp;any, before applying <code>ode</code>.

     </p><li>Ill-posed problems.

     <p>For <code>ode</code> to yield an accurate numerical solution on an interval,
the true solution must be defined and well-behaved on that interval. 
The solution must also be real.  Whenever any of these conditions is
violated, the problem is said to be <em>ill-posed</em>.  Ill-posedness may
occur even if the system of differential equations is well-behaved on
the interval.  Strange results, e.g., the stepsize suddenly shrinking to
the machine limit or the solution suddenly blowing&nbsp;up, may indicate
ill-posedness.

     <p>As an example of ill-posedness (in fact, an undefined solution) consider
the innocent-looking problem:

     <pre class="example">          y' = y^2
          y(1) = -1
          </pre>

     <p>The solution on the domain t &gt; 0 is

     <pre class="example">          y(t) = -1/t.
          </pre>

     <p>With this problem you must not compute a numerical solution on any
interval that includes t=0.  To convince yourself of this, try to
use the <code>step</code> statement

     <pre class="example">          step 1, -1
          </pre>

     <p>on this system.  How does <code>ode</code> react?

     <p>As another example of ill-posedness, consider the system

     <pre class="example">          y'=1/y
          </pre>

     <p>which is undefined at y=0.  The general solution is

     <pre class="example">          y = +/- (2(t-C))^(1/2),
          </pre>

     <p>so that if the condition y(2)=2 is imposed, the solution will be
(2t)^(1/2).  Clearly, if the domain specified in a <code>step</code>
statement includes negative values of&nbsp;t, the generated
solution will be bogus.

     <p>In general, when using a constant stepsize you should be careful not to
`step&nbsp;over' bad points or bad regions.  When allowed to choose a
stepsize adaptively, <code>ode</code> will often spot bad points, but not
always.

     </p><li>Critical points.

     <p>An <em>autonomous</em> system is one that does not include the independent
variable explicitly on the right-hand side of any differential equation. 
A <em>critical point</em> for such a system is a point at which all
right-hand sides equal zero.  For example, the system

     <pre class="example">          y' = 2x
          x' = 2y
          </pre>

     <p>has only one critical point, at (x,y) = (0,0).

     <p>A critical point is sometimes referred to as a <em>stagnation point</em>. 
That is because a system at a critical point will remain there forever,
though a system near a critical point may undergo more violent motion. 
Under some circumstances, passing near a critical point may give rise to
a large accumulated error.

     <p>As an exercise, solve the system above using <code>ode</code>, with the
initial condition x(0) = y(0) = 0.  The solution should be
constant in time.  Now do the same with points near the critical point. 
What happens?

     <p>You should always locate the critical points of a system before
attempting a solution with <code>ode</code>.  Critical points may be
classified (as equilibrium, vortex, unstable, stable, etc.) and this
classification may be of&nbsp;use.  To find out more about this, consult
any book dealing with the qualitative theory of differential equations
(e.g., Birkhoff and Rota's <cite>Ordinary Differential Equations</cite>,
Chapter&nbsp;6).

     </p><li>Unsuitable numerical schemes

     <p>If the results produced by <code>ode</code> are bad in the sense that
instability appears to be present, or an unusually small stepsize needs
to be chosen needed in order to reduce the single-step error to
manageable levels, it may simply be that the numerical scheme being used
is not suited to the problem.  For&nbsp;example, <code>ode</code> currently has
no numerical scheme which handles so-called `stiff' problems very well.

     <p>As an example, you may wish to examine the stiff problem:

     <pre class="example">          y' = -100 + 100t + 1
          y(0) = 1
          </pre>

     <p>on the domain [0,1].  The exact solution is

     <pre class="example">          y(t) = e^(-100t) + t.
          </pre>

     <p>It is a useful exercise to solve this problem with <code>ode</code> using
various numerical schemes, stepsizes, and relative single-step error
bounds, and compare the generated solution curves with the actual
solution.
        </ol>

   <p>There are several rough and ready heuristic checks you may perform on
the accuracy of any numerical solution produced by <code>ode</code>.  We
discuss them in&nbsp;turn.

     <ol type=1 start=1>
<li>Examine the stability of  solution curves: do they converge?

     <p>That is, check how changing the stepsize affects a solution curve.  As
the stepsize decreases, the curve should converge.  If it does not, then
the stepsize is not small enough or the numerical scheme is not suited
to the problem.  In practice, you would proceed as follows.

          <ul>
<li>If using an adaptive stepsize, superimpose the solution curves for
successively smaller bounds on the relative single-step error (obtained
with, e.g., <code>-r 1e-9</code>, <code>-r 1e-11</code>, <code>-r 1e-13</code>, <small class="dots">...</small>). 
If the curves converge then the solution is to all appearances stable,
and your accuracy is sufficient.

          <li>If employing a constant stepsize, perform a similar analysis by
successively halving the stepsize. 
</ul>

     <p>The following example is one that you may wish to experiment with.  Make
a file named <code>qcd</code> containing:

     <pre class="example">          # an equation arising in QCD (quantum chromodynamics)
          f'   = fp
          fp'  = -f*g^2
          g'   = gp
          gp'  = g*f^2
          f = 0; fp = -1; g = 1; gp = -1
          
          print t, f
          step 0, 5
          </pre>

     <p>Next make a file named <code>stability</code>, containing the lines:

     <pre class="example">          : sserr is the bound on the relative single-step error
          for sserr
          do
          ode -r $sserr &lt; qcd
          done | spline -n 500 | graph -T X -C
          </pre>

     <p>This is a `shell script', which when run will superimpose numerical
solutions with specified bounds on the relative single-step error.  To
run it, type:

     <pre class="example">          sh stability 1 .1 .01 .001
          </pre>

     <p>and a plot of the solutions with the specified error bounds will be
drawn.  The convergence, showing stability, should be quite
illuminating.

     </p><li>Check invariants of the system: are they constant?

     <p>Many systems have invariant quantities.  For example, if the system is a
mathematical model of a `conservative' physical system then the `energy'
(a&nbsp;particular function of the dependent variables of the system)
should be constant in time.  In general, knowledge about the qualitative
behavior of any dependent variable may be used to check the quality of
the solution.

     </p><li>Check a family of solution curves: do they diverge?

     <p>A rough idea of how error is propagated is obtained by viewing a family
of solution curves about the numerical solution in question, obtained by
varying the initial conditions.  If&nbsp;they diverge sharply--that&nbsp;is, if two solutions which start out very close nonetheless end&nbsp;up
far apart--then the quality of the numerical solution is dubious. 
On&nbsp;the other hand, if the curves do not diverge sharply then any
error that is present will in all likelihood not increase by more than
an order of magnitude or&nbsp;so over the interval.  Problems exhibiting
no sharp divergence of neighboring solution curves are sometimes called
<em>well-conditioned</em>.
        </ol>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Running%20Time">Running Time</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Input%20Language">Input Language</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Numerical%20Error">Numerical Error</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.7 Running time</h3>

<p>The time required for <code>ode</code> to solve numerically a system of
ordinary differential equations depends on a great many factors.  A&nbsp;few of them are: number of equations, complexity of equations (number
of operators and nature of the operators), and number of steps taken
(a&nbsp;very complicated function of the difficulty of solution, unless
constant stepsizes are used).  The most effective way to gauge the time
required for solution of a system is to clock a short or imprecise run
of the problem, and reason as follows: the time required to take two
steps is roughly twice that required for one; and there is a
relationship between the number of steps required and the relative error
ceiling chosen.  That relationship depends on the numerical scheme being
used, the difficulty of solution, and perhaps on the magnitude of the
error ceiling itself.  A&nbsp;few carefully planned short runs may be
used to determine this relationship, enabling a long but imprecise run
to be used as an aid in projecting the cost of a more precise run over
the same region.  Lastly, if a great deal of data is printed, it&nbsp;is
likely that more time is spent in printing the results than in computing
the numerical solution.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Input%20Language">Input Language</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#ODE%20Bibliography">ODE Bibliography</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Running%20Time">Running Time</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.8 The <code>ode</code> input language formally specified</h3>

<p>The following is a formal specification of the grammar for <code>ode</code>'s
input language, in Backus-Naur form.  Nonterminal symbols in the
grammar are enclosed in angle brackets.  Terminal tokens are in all
capitals.  Bare words and symbols stand for themselves.

<pre class="example">     &lt;program&gt;    ::=        ... empty ...
                    |  &lt;program&gt; &lt;statement&gt;
     
     
     &lt;statement&gt;  ::=  SEP
                    |  IDENTIFIER = &lt;const&gt; SEP
                    |  IDENTIFIER ' = &lt;expression&gt; SEP
                    |  print &lt;printlist&gt; &lt;optevery&gt; &lt;optfrom&gt; SEP
                    |  step &lt;const&gt; , &lt;const&gt; , &lt;const&gt; SEP
                    |  step &lt;const&gt; , &lt;const&gt; SEP
                    |  examine IDENTIFIER SEP
     
     
     &lt;printlist&gt;  ::=  &lt;printitem&gt;
                    |  &lt;printlist&gt; , &lt;printitem&gt;
     
     
     &lt;printitem&gt;  ::=  IDENTIFIER
                    |  IDENTIFIER '
                    |  IDENTIFIER ?
                    |  IDENTIFIER !
                    |  IDENTIFIER ~
     
     
     &lt;optevery&gt;   ::=        ... empty ...
                    |  every &lt;const&gt;
     
     
     &lt;optfrom&gt;    ::=        ... empty ...
                    |  from &lt;const&gt;
     
     
     &lt;const&gt;      ::=  &lt;expression&gt;
     
     
     &lt;expression&gt; ::=  ( &lt;expression&gt; )
                    |  &lt;expression&gt; + &lt;expression&gt;
                    |  &lt;expression&gt; - &lt;expression&gt;
                    |  &lt;expression&gt; * &lt;expression&gt;
                    |  &lt;expression&gt; / &lt;expression&gt;
                    |  &lt;expression&gt; ^ &lt;expression&gt;
                    |  FUNCTION ( &lt;expression&gt; )
                    |  - &lt;expression&gt;
                    |  NUMBER
                    |  IDENTIFIER
     </pre>

<p>Since this grammar is ambiguous, the following table summarizes the
precedences and associativities of operators within expressions. 
Precedences decrease from top to bottom.

<pre class="example">     Class           Operators    Associativity
     
     Exponential         ^            right
     Multiplicative      * /          left
     Additive            + -          left
     </pre>

   <p>As noted in the grammar, there are six types of nontrivial statement. 
We now explain the effects (the `semantics') of each type, in&nbsp;turn.

     <ol type=1 start=1>
<li><tt>IDENTIFIER ' = &lt;expression&gt;</tt>

     <p>This defines a first-order differential equation. 
The derivative of <tt>IDENTIFIER</tt> is specified by <tt>&lt;expression&gt;</tt>.  If a
dynamic variable does not appear on the left side of a statement of this
form, its derivative is assumed to be zero.  That is, it&nbsp;is a
symbolic constant.

     </p><li><tt>IDENTIFIER = &lt;const&gt;</tt>

     <p>This sets the value of <tt>IDENTIFIER</tt> to the current value of
<tt>&lt;expression&gt;</tt>.  Dynamic variables that have not been initialized in
this way are set to zero.

     </p><li><tt>step &lt;const&gt; , &lt;const&gt;</tt>
<li><tt>step &lt;const&gt; , &lt;const&gt; , &lt;const&gt;</tt>

     <p>A <code>step</code> statement causes the numerical scheme to be executed.  The
first <tt>&lt;const&gt;</tt> is the initial value of the independent variable.  The
second is its final value.  The third is a stepsize; if given, it
overrides any stepsize that may be specified on the command line. 
Usually the stepsize is not specified, and it varies adaptively as the
computation proceeds.

     </p><li><tt>print &lt;printlist&gt; [ every &lt;const&gt; ] [ from &lt;const&gt; ]</tt>

     <p>A <code>print</code> statement controls the content and frequency of the
numerical output.  <tt>&lt;printlist&gt;</tt> is a comma-separated list of
<tt>IDENTIFIER</tt>s, where each <tt>IDENTIFIER</tt> may be followed by <code>'</code>,
denoting the derivative, or <code>?</code>, denoting the relative single-step
error, or <code>!</code>, denoting the absolute single-step error, or
<code>~</code>, denoting the accumulated error (not currently implemented). 
The specified values are printed in the order they are found.  Both the
<code>every</code> clause and the <code>from</code> clause are optional.  If&nbsp;the
<code>every</code> clause is present, a printing occurs every <tt>&lt;const&gt;</tt>
iterations of the numerical algorithm.  The default is to print on every
iteration (i.e. <code>every 1</code>).  The first and last values are always
printed.  If&nbsp;the <code>from</code> clause is present, it means to begin
printing when the independent variable reaches or exceeds <tt>&lt;const&gt;</tt>. 
The default is to begin printing immediately.

     <p>If no <code>print</code> statement has been supplied, then the independent
variable and all dependent variables which have differential equations
associated with them are printed.  The independent variable is printed
first; the dependent variables follow in the order their equations were
given.

     </p><li><tt>examine IDENTIFIER</tt>

     <p>An <code>examine</code> statement, when executed, causes a table of
interesting information about the named variable to be printed on the
standard output.  For example, if the statement <code>examine y</code> were
encountered after execution of the `ode to Euler' example discussed
elsewhere, the output would be:

     <pre class="example">          "y" is a dynamic variable
          value:2.718282
          prime:2.718282
          sserr:1.121662e-09
          aberr:3.245638e-09
          acerr:0
           code:  push "y"
          </pre>

     <p>The phrase `dynamic variable' means that there is a differential
equation describing the behavior of&nbsp;<tt>y</tt>.  The numeric items in the
table are:

          <dl>
<dt><tt>value</tt>
          <dd>Current value of the variable.

          <br><dt><tt>prime</tt>
          <dd>Current derivative of the variable.

          <br><dt><tt>sserr</tt>
          <dd>Relative single-step error for the last step taken.

          <br><dt><tt>aberr</tt>
          <dd>Absolute single-step error for the last step taken.

          <br><dt><tt>acerr</tt>
          <dd>Total error accumulated during the most recent <code>step</code> statement. 
Not currently implemented. 
</dl>

     <p>The <code>code</code> section of the table lists the stack operations required
to compute the derivative of&nbsp;<tt>y</tt> (somewhat reminiscent of a
reverse Polish calculator).  This information may be useful in
discovering whether the precedences in the differential equation
statement were interpreted correctly, or in determining the time or
space expense of a particular calculation.  <code></code><tt>push "y"</tt><code></code> means to
load <tt>y</tt>'s value on the stack, which is all that is required to
compute its derivative in this case.
        </ol>

   <p>The grammar for the <code>ode</code> input language contains four types of
terminal token: <tt>FUNCTION</tt>, <tt>IDENTIFIER</tt>, <tt>NUMBER</tt>, and&nbsp;<tt>SEP</tt>.  They have the following meanings.

     <ol type=1 start=1>
<li><tt>FUNCTION</tt>

     <p>One of the words: <tt>abs</tt>, <tt>sqrt</tt>, <tt>exp</tt>, <tt>log</tt>, <tt>ln</tt>,
<tt>log10</tt>, <tt>sin</tt>, <tt>cos</tt>, <tt>tan</tt>, <tt>asin</tt>, <tt>acos</tt>, <tt>atan</tt>,
<tt>sinh</tt>, <tt>cosh</tt>, <tt>tanh</tt>, <tt>asinh</tt>, <tt>acosh</tt>, <tt>atanh</tt>,
<tt>floor</tt>, <tt>ceil</tt>, <tt>besj0</tt>, <tt>besj1</tt>, <tt>besy0</tt>, <tt>besy1</tt>,
<tt>erf</tt>, <tt>erfc</tt>, <tt>inverf</tt>, <tt>lgamma</tt>, <tt>gamma</tt>, <tt>norm</tt>,
<tt>invnorm</tt>, <tt>ibeta</tt>, <tt>igamma</tt>.  These are defined to have the same
meaning as in the plotting program <code>gnuplot</code>.  All functions take a
single argument, except for <tt>ibeta</tt>, which takes three, and
<tt>igamma</tt>, which takes two.  For trigonometric functions, all arguments
are expressed in radians.  The <tt>atan</tt> function is defined to give a
value between -PI/2 and PI/2 (inclusive).

     </p><li><tt>IDENTIFIER</tt>

     <p>A sequence of alphanumeric characters starting with an alphabetic
character.  The first 32 characters are significant.  Upper and
lower-case letters are distinct.  In identifiers, the underscore
character is considered alphabetic.  Function names and keywords may not
be used as identifiers, nor may <code>PI</code>.

     </p><li><tt>NUMBER</tt>

     <p>A non-empty sequence of digits possibly containing a decimal point and
possibly followed by an exponent.  An exponent is <code>e</code> or&nbsp;<code>E</code>, followed by an (optionally signed) one, two, or three-digit
number.  All numbers and all parts of numbers are radix&nbsp;10.  A&nbsp;number may not contain any white space.  The special word <code>PI</code> is
a number.

     </p><li><tt>SEP</tt>

     <p>A separator: a semicolon or a (non-escaped) newline.
        </ol>

   <p>In the <code>ode</code> input language, upper and lower-case letters are
distinct.  Comments begin with the character <code>#</code> and continue to
the end of the line.  Long lines may be continued onto a second line by
ending the first line with a backslash&nbsp;(<code>\</code>).  That is because
the combination backslash-newline is equivalent to a space.

   <p>Spaces or tabs are required in the input whenever they are needed to
separate identifiers, numbers, and keywords from one another.  Except as
separators, they are ignored.

<div class="node">
<p><hr>
Node:&nbsp;<a name="ODE%20Bibliography">ODE Bibliography</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Input%20Language">Input Language</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#ode">ode</a>
<br>
</div>

<h3 class="section">8.9 Bibliography on <code>ode</code> and solving differential equations</h3>

     <ul>
<li>K. E. Atkinson, <cite>An Introduction to Numerical Analysis</cite>, Wiley,
1978.  Chapter&nbsp;6 contains a discussion of the literature on the
numerical solution of ordinary differential equations.

     <li>G. Birkhoff and G. Rota, <cite>Ordinary Differential Equations</cite>, 4th
ed., Wiley, 1989.

     <li>N. B. Tufillaro, T. Abbott, and J. Reilly, <cite>An Experimental
Approach to Nonlinear Dynamics and Chaos</cite>, Addison-Wesley, 1992. 
Appendix&nbsp;C discusses an earlier version of <code>ode</code>.

     <li>N. B. Tufillaro, E. F. Redish, and J. S. Risley, "<code>ode</code>: A&nbsp;numerical simulation of ordinary differential equations,"
pp. 480-481 in <cite>Proceedings of the Conference on Computers in
Physics Instruction</cite>, Addison-Wesley, 1990. 
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="libplot">libplot</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Appendices">Appendices</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ode">ode</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

<h2 class="chapter">9 <code>libplot</code>, a 2-D Vector Graphics Library</h2>

<p>This is the documentation for version 4.1 of GNU libplot, which is
a free function library for drawing two-dimensional vector graphics.

<ul class="menu">
<li><a accesskey="1" href="#libplot%20Overview">libplot Overview</a>:     Programming with libplot: An overview
<li><a accesskey="2" href="#C%20Programming">C Programming</a>:        C programming with libplot
<li><a accesskey="3" href="#C++%20Programming">C++ Programming</a>:      C++ programming with libplotter
<li><a accesskey="4" href="#Functions">Functions</a>:            A list of functions contained in libplot
<li><a accesskey="5" href="#Plotter%20Parameters">Plotter Parameters</a>:   Plotter parameters
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="libplot%20Overview">libplot Overview</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#C%20Programming">C Programming</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#libplot">libplot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#libplot">libplot</a>
<br>
</div>

<h3 class="section">9.1 Programming with <code>libplot</code>: An overview</h3>

<p>GNU <code>libplot</code> 4.1 is a free function library for drawing
two-dimensional vector graphics.  It can produce smooth, double-buffered
animations for the X&nbsp;Window System, and can export graphics files in
many file formats.  It&nbsp;is `device-independent' in the sense that its
API (application programming interface) is to a large extent independent
of the display type or output file format.  The API is thread-safe, so
it may be used in multithreaded programs.

   <p>There are bindings for C, C++, and other languages.  The C&nbsp;binding,
which is the most frequently used, is also called <code>libplot</code>, and
the C++ binding, when it needs to be distinguished, is called
<code>libplotter</code>.  In&nbsp;this section we use <code>libplot</code> to refer
to the library itself, irrespective of binding.

   <p>The graphical objects that <code>libplot</code> can draw include paths,
`adjusted labels' (i.e., justified text strings), marker symbols, and
points (i.e., pixels).  Paths may be simple or compound.  A&nbsp;simple
path is a contiguous sequence of line segments, circular arcs, elliptic
arcs, quadratic Bezier curves, and/or cubic Bezier curves.  A&nbsp;simple
path may also be a circle, an ellipse, or a rectangle.  A&nbsp;compound
path consists of one or more nested simple paths.  User-specified
filling of paths, both simple and compound, is supported (fill color and
fill rule, as&nbsp;well as pen color, may be specified).

   <p>There is support for maintaining a Postscript-style stack of graphics
contexts, i.e., a&nbsp;stack of drawing attribute sets.  Path-related
attributes include pen color, line thickness, line type, cap type, join
type, miter limit, fill color, fill rule, and transformation matrix, and
text-related attributes include font name, font size, text angle, and
transformation matrix.

   <p>The fundamental abstraction provided by <code>libplot</code> is that of a
<em>Plotter</em>.  A Plotter is an object with an interface for the
drawing of vector graphics which is similar to the interface provided by
a traditional pen plotter.  There are many types of Plotter, which
differ in the output format they produce.  Any number of Plotters, of
the same or different types, may exist simultaneously in an application.

   <p>The drawing operations supported by Plotters of different types are
identical, in agreement with the principle of device independence. 
So&nbsp;a graphics application that is linked with <code>libplot</code> may
easily be written so as to produce output in any or all of the
supported output formats.

   <p>The following are the currently supported types of Plotter.

     <ul>
<li>X Plotters.  An X Plotter, when opened, pops up a window on an X&nbsp;Window System display and draws graphics in&nbsp;it.  The window will be
`spun&nbsp;off' when the Plotter is closed; if it is subsequently
reopened, a new window will be popped&nbsp;up.  A spun-off window will
remain on the screen but will vanish if you type <code>q</code> or click your
mouse in&nbsp;it.  Future releases may permit X&nbsp;Plotters, when
reopened, to reuse an existing window.

     <li>X Drawable Plotters.  An X Drawable Plotter draws graphics in one or two
specified drawables associated with an X&nbsp;Window&nbsp;System display. 
A&nbsp;`drawable' is either a window or a pixmap.  The drawables must be
passed to the Plotter as parameters.  (See <a href="#Plotter%20Parameters">Plotter Parameters</a>.)

     <li>PNG Plotters.  A PNG Plotter produces a single page of output in PNG
(Portable Network Graphics) format, and directs it to a file or other
specified output stream.  The file may be viewed or edited with many
applications, such as the free image display application <code>xv</code> and
the free <code>ImageMagick</code> package.

     <li>PNM Plotters.  A PNM Plotter produces a single page of output in
"portable anymap" format, and directs it to a file or other specified
output stream.  There are three types of portable anymap: PBM (portable
bitmap, for monochrome graphics), PGM (portable graymap), and PPM
(portable pixmap, for colored graphics).  The output file will be in
whichever of these three formats is most appropriate.  The file may be
viewed or edited with many applications, such as <code>xv</code> and the
<code>ImageMagick</code> package.

     <li>GIF Plotters.  A GIF Plotter produces a single page of output in a
pseudo-GIF format.  Unlike true GIF format, the pseudo-GIF format does
not use LZW compression: it&nbsp;uses run-length encoding instead.  So&nbsp;it does not transgress the Unisys patent that restricts the use of LZW
compression.  However, the output file may be viewed or edited with any
application that understands GIF format, such as <code>xv</code> and the
<code>ImageMagick</code> package.  The creation of animated pseudo-GIFs is
supported.

     <li>SVG Plotters.  An SVG Plotter produces a single page of output in
Scalable Vector Graphics format and directs it to a file or other
specified output stream.  SVG is a new XML-based format for vector
graphics on the Web, which is being developed by the
<a href="http://www.w3.org/Graphics">Graphics Activity</a> of the
<a href="http://www.w3.org">W3&nbsp;Consortium</a>.  The output conforms to the
3&nbsp;March 2000 version of the SVG specification.

     <li>Illustrator Plotters.  An Illustrator Plotter produces a single page of
output in the format used by Adobe Illustrator, and directs it to a file
or other specified output stream.  The file may be edited with Adobe
Illustrator (version&nbsp;5, and more recent versions), or other
applications.

     <li>Postscript Plotters.  A Postscript Plotter produces Postscript output
and directs it to a file or other specified output stream.  If only a
single page of graphics is drawn on the Plotter then its output is in
EPS (encapsulated Postscript) format, so it may be included in another
document.  It&nbsp;may also be edited with the free <code>idraw</code> drawing
editor.  See <a href="#idraw">idraw</a>.

     <li>CGM Plotters.  A CGM Plotter produces output in Computer Graphics
Metafile format and directs it to a file or other specified output
stream.  By default, binary-encoded version&nbsp;3 CGM format is used. 
The output complies with the WebCGM profile for Web-based vector
graphics, so it may be displayed in any Web browser with WebCGM support. 
The <a href="http://www.cgmopen.org">CGM Open Consortium</a> has more
information on WebCGM.

     <li>Fig Plotters.  A Fig Plotter produces a single page of output in Fig
format and directs it to a file or other specified output stream.  The
output may be edited with the free <code>xfig</code> drawing editor.  The
<code>xfig</code> editor can export drawings in various other formats for
inclusion in documents.  See <a href="#xfig">xfig</a>.

     <li>PCL Plotters.  A PCL Plotter produces output in PCL&nbsp;5 format and
directs it to a file or other specified output stream.  PCL&nbsp;5 is a
powerful version of Hewlett-Packard's Printer Control Language, which
supports vector graphics.  The output may be sent to a PCL&nbsp;5 device
such as a LaserJet printer or high-end inkjet.

     <li>HP-GL Plotters.  An HP-GL Plotter produces output in the
Hewlett-Packard Graphics Language (by&nbsp;default, in HP-GL/2), and
directs it to a file or other specified output stream.  The output may
be imported into another application, or sent to a plotter.

     <li>ReGIS Plotters.  A ReGIS Plotter produces output in ReGIS (remote
graphics instruction set) format and directs it to a file or other
specified output stream.  The output may be displayed on any terminal or
emulator that understands ReGIS format.  This includes several terminals
from DEC (in particular, the VT340, VT330, VT241, and VT240 terminals),
and <code>dxterm</code>, the DECwindows terminal emulation program.

     <li>Tektronix Plotters.  A Tektronix Plotter produces output in Tektronix
4014 format and directs it to a file or other specified output stream. 
The output may be displayed on any Tektronix 4014 emulator.  Such an
emulator is built into <code>xterm</code>, the X&nbsp;Window System terminal
emulation program.  The MS-DOS version of <code>kermit</code> also includes
such an emulator.

     <li>Metafile Plotters.  A Metafile Plotter produces output in GNU graphics
metafile format and directs it to a file or other specified output
stream.  This format is an extended version of the `plot(5)' format
found on some other operating systems.  (See <a href="#Metafiles">Metafiles</a>.)  It&nbsp;may
be translated to other formats by an invocation of GNU <code>plot</code>. 
(See <a href="#plot">plot</a>.) 
</ul>

   <p>A distinction among these types of Plotter is that all except X and X&nbsp;Drawable Plotters write graphics to a file or other output stream.  An
X&nbsp;Plotter pops&nbsp;up its own windows, and an X&nbsp;Drawable Plotter
draws graphics in one or two X&nbsp;drawables.

   <p>Another distinction is that the first five types of Plotter (X, X&nbsp;Drawable, PNG, PNM, and GIF) produce bitmap output, while the remaining
types produce output in a vector graphics format.  In bitmap output the
structure of the graphical objects is lost, but in a vector format it is
retained.

   <p>An additional distinction is that X, X Drawable, ReGIS, Tektronix and
Metafile Plotters are real-time.  This means that they draw graphics or
write to an output stream as the drawing operations are invoked on them. 
The remaining types of Plotter are not real-time, since their output
streams can only be emitted after all functions have been called.  For
PNM and GIF Plotters, this is because the bitmap must be constructed
before it is written out.  For Illustrator and Postscript Plotters,
it&nbsp;is because a `bounding box' line must be placed at the head of
the output file.  For a Fig Plotter, it&nbsp;is because color definitions
must be placed at the head of the output file.

   <p>The most important operations supported by any Plotter are <code>openpl</code>
and <code>closepl</code>, which open and close&nbsp;it.  Graphics may be drawn,
and drawing attributes set, only within an
<code>openpl</code><small class="dots">...</small><code>closepl</code> pair.  The graphics produced within
each <code>openpl</code><small class="dots">...</small><code>closepl</code> pair constitute a `page'.  In
principle, any Plotter may be opened and closed arbitrarily many times. 
An X&nbsp;Plotter displays each page in a separate X&nbsp;window, and
Postscript, PCL, and HP-GL Plotters render each page as a separate
physical page.  X&nbsp;Drawable, ReGIS and Tektronix Plotters manipulate
a single drawable or display, on which pages are displayed in
succession.  Plotters that do not draw in real time (PNG, PNM, GIF,
Illustrator, Postscript, CGM, Fig, PCL, and HP-GL Plotters) may wait
until their existence comes to an end (i.e., until they are deleted)
before outputting their pages of graphics.

   <p>In the current release of <code>libplot</code>, Postscript and CGM Plotters
delay outputting graphics in this way, but PCL and HP-GL Plotters output
each page of graphics individually, i.e., when <code>closepl</code> is
invoked.  PNG, PNM, GIF, SVG, Illustrator and Fig Plotters are similar,
but output only the first page.  That is because PNG, PNM, GIF, SVG,
Illustrator and Fig formats support only a single page of graphics.

   <p>The graphics display, or `viewport', that is drawn&nbsp;in by a Plotter
is normally a square or rectangular region on its output device.  But
when using any Plotter to draw graphics, a&nbsp;user will specify the
coordinates of graphical objects in device-independent `user'
coordinates, not in device coordinates.  A&nbsp;Plotter transforms user
coordinates to device coordinates by performing an affine
transformation.

   <p>After invoking <code>openpl</code> to open a Plotter, an application would
usually invoke <code>space</code>.  <code>space</code> specifies a rectangular
`window' in the user coordinate system that will be mapped affinely to
the viewport on the output device.  (The default window is a square,
with opposite corners (0,0) and&nbsp;(1,1).)  The transformation from
user coordinates to device coordinates may be updated at any later time
by reinvoking <code>space</code>, or by invoking <code>fconcat</code>.  The
<code>fconcat</code> operation will concatenate (i.e., compose) the current
affine transformation with any specified affine transformation.  This
sort of concatenation is a capability familiar from, e.g., Postscript.

   <p>Each Plotter maintains a Postscript-style stack of graphics contexts. 
This makes possible the rapid, efficient drawing of complicated pages of
graphics.  A&nbsp;graphics context includes the current affine
transformation from user coordinates to device coordinates.  It&nbsp;also
includes such modal drawing attributes as graphics cursor position, pen
color, line type, line thickness, fill color, and the font used for
drawing text.  The state of any uncompleted path (if&nbsp;any) is
included as&nbsp;well, since paths may be drawn incrementally, one
portion (line segment, arc, or Bezier curve) at a time.

   <p><strong>Warning</strong>: Much as in Postscript, the current graphics context
may be pushed onto the stack by calling <code>savestate</code>, and popped&nbsp;off by calling <code>restorestate</code>.  However, <code>libplot</code>'s and
Postscript's drawing models are significantly different.  In
<code>libplot</code>, the new graphics context created by <code>savestate</code>
contains no path.  So a new path may be constructed in&nbsp;it from
scratch, and drawn.  Afterwards, the path in the former graphics context
will be returned&nbsp;to when <code>restorestate</code> is called, at which
time it may be extended further.  Another difference from Postscript is
that in <code>libplot</code>, there is no need to start a new path by calling
a `<code>newpath</code>' function.  Instead, you just start drawing.  At&nbsp;least in theory, you do need to end a path explicitly, by calling
<code>endpath</code> to request that it be drawn on the graphics display.  But
the call to <code>endpath</code> can usually be omitted.  For example, calling
<code>restorestate</code> automatically invokes <code>endpath</code> to end the path
(if&nbsp;any) contained in the current graphics context.

   <p>To permit vector graphics animation, any page of graphics may be split
into `frames'.  A&nbsp;frame is ended, and a new frame is begun, by
invoking the <code>erase</code> operation.  This first terminates the path
under construction, if&nbsp;any.  What then happens depends on whether
the Plotter does real-time plotting.  If&nbsp;it does (i.e., if the
Plotter is an&nbsp;X, X&nbsp;Drawable, ReGIS, Tektronix, or Metafile
Plotter), <code>erase</code> removes all plotted objects from the graphics
display, allowing a new frame to be drawn.  Displaying a sequence of
frames in succession creates the illusion of smooth animation.

   <p>On&nbsp;most Plotters that do not do real-time plotting (i.e., PNG, PNM,
SVG, Illustrator, Postscript, CGM, Fig, PCL, or HP-GL Plotters),
invoking <code>erase</code> deletes all plotted objects from an internal
buffer.  For this reason, most Plotters that do not do real-time
plotting will display only the final frame of any multiframe page.

   <p>GIF Plotters are in a class by themselves.  Even though they do not do
real time plotting, a&nbsp;GIF Plotter can produce multi-image output,
i.e., an animated pseudo-GIF file, from a multiframe page.  As&nbsp;noted
above, the pseudo-GIF file produced by a GIF Plotter will contain only
the first page of graphics.  But if this page consists of multiple
frames, then each invocation of <code>erase</code> after the first will be
treated, by&nbsp;default, as a separator between successive images.

<div class="node">
<p><hr>
Node:&nbsp;<a name="C%20Programming">C Programming</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#C++%20Programming">C++ Programming</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#libplot%20Overview">libplot Overview</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#libplot">libplot</a>
<br>
</div>

<h3 class="section">9.2 C Programming with <code>libplot</code></h3>

<ul class="menu">
<li><a accesskey="1" href="#The%20C%20API">The C API</a>:                    The C application programming interface
<li><a accesskey="2" href="#Older%20C%20APIs">Older C APIs</a>:                 Older C interfaces
<li><a accesskey="3" href="#C%20Compiling%20and%20Linking">C Compiling and Linking</a>:      C compiling and linking
<li><a accesskey="4" href="#Sample%20C%20Drawings">Sample C Drawings</a>:            Sample drawings in C
<li><a accesskey="5" href="#Paths%20and%20Subpaths">Paths and Subpaths</a>:           Simple paths and compound paths
<li><a accesskey="6" href="#Drawing%20on%20a%20Page">Drawing on a Page</a>:            Drawing on a physical page
<li><a accesskey="7" href="#Animated%20GIFs">Animated GIFs</a>:                Animated GIFs in C
<li><a accesskey="8" href="#X%20Animations">X Animations</a>:                 X Window System animations in C
<li><a accesskey="9" href="#X%20Programming">X Programming</a>: 		Advanced X Window System programming
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="The%20C%20API">The C API</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Older%20C%20APIs">Older C APIs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C%20Programming">C Programming</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.1 The C application programming interface</h4>

<p>GNU <code>libplot</code> has bindings for several programming languages. 
Regardless of which binding is used, the concepts behind <code>libplot</code>
(Plotters, and a fixed set of operations that may be applied to any
Plotter) remain the same.  However, the ways in which Plotters are
manipulated (created, selected for&nbsp;use, and deleted) may differ
between bindings.  This section discusses the current C&nbsp;binding. 
For information on older C&nbsp;bindings, see <a href="#Older%20C%20APIs">Older C APIs</a>.

   <p>In the C&nbsp;binding, a Plotter is implemented as an opaque datatype,
<code>plPlotter</code>, which must be accessed through a pointer.  Each
drawing operation takes a pointer to a <code>plPlotter</code> as its first
argument.  The functions <code>pl_newpl_r</code> and <code>pl_deletepl_r</code> are
the constructor and destructor for the <code>plPlotter</code> datatype.  The
final argument of <code>pl_newpl_r</code> must be a pointer to a
<code>plPlotterParams</code> object, which specifies Plotter parameters. 
<code>pl_newpl_r</code> returns a pointer to a <code>plPlotter</code>.

   <p>You should always call <code>pl_deletepl_r</code> when you are finished using
a Plotter.  In general, Plotters that do not plot graphics in real time
(Postscript Plotters and CGM Plotters in particular) write&nbsp;out
graphics only when <code>pl_deletepl_r</code> is called.

   <p>The following tables summarize the action of the Plotter manipulation
functions in the C&nbsp;binding.

     <dl>
<dt>plPlotter * <tt>pl_newpl_r</tt> (const char *<var>type</var>, FILE *<var>infile</var>, FILE *<var>outfile</var>, FILE *<var>errfile</var>, plPlotterParams *<var>params</var>);
     <dd>Create a Plotter of type <var>type</var>, where <var>type</var> may be "X",
"Xdrawable", "png", "pnm", "gif", "svg", "ai", "ps", "cgm", "fig",
"pcl", "hpgl", "regis", "tek", or "meta".  The Plotter will have input
stream <var>infile</var>, output stream <var>outfile</var>, and error stream
<var>errfile</var>.  Any or all of these three may be NULL.  Currently, all
Plotters are write-only, so <var>infile</var> is ignored.  X&nbsp;Plotters and
X&nbsp;Drawable Plotters write graphics to an X&nbsp;Window System display
rather than to an output stream, so if <var>type</var> is "X" or "Xdrawable"
then <var>outfile</var> is ignored as&nbsp;well.  Error messages (if&nbsp;any)
are written to the stream <var>errfile</var>, unless <var>errfile</var> is NULL.

     <p>All Plotter parameters will be copied from the <code>plPlotterParams</code>
object pointed to by <var>params</var>.  A&nbsp;NULL return value indicates
the Plotter could not be created.

     <br><dt>int <tt>pl_deletepl_r</tt> (plPlotter *<var>plotter</var>);
     <dd>Delete the specified Plotter.  A negative return value indicates the
Plotter could not be deleted. 
</dl>

   <p>The functions <code>pl_newplparams</code>, <code>pl_deleteplparams</code>, and
<code>pl_copyplparams</code> are the constructor, destructor, and copy
constructor for the <code>plPlotterParams</code> datatype.  The function
<code>pl_setplparam</code> sets any single Plotter parameter in a
<code>plPlotterParams</code> object.

     <dl>
<dt>plPlotterParams * <tt>pl_newplparams</tt> ();
     <dd>
<br><dt>int <tt>pl_deleteplparams</tt> (plPlotterParams *<var>plotter_params</var>);
     <dd>
<br><dt>plPlotterParams * <tt>pl_copyplparams</tt> (const plPlotterParams *<var>params</var>);
     <dd>
<br><dt>int <tt>pl_setplparam</tt> (plPlotterParams *<var>params</var>, const char *<var>parameter</var>, void *<var>value</var>);
     <dd>Set the value of the parameter <var>parameter</var> to <var>value</var> in the
object pointed to by <var>params</var>.  For most parameters, <var>value</var>
should be a <code>char *</code>, i.e., a string.  If&nbsp;<var>value</var> is NULL,
the parameter is unset.

     <p>For a list of recognized parameters and their meaning, see <a href="#Plotter%20Parameters">Plotter Parameters</a>.  Unrecognized parameters are ignored. 
</dl>

   <p>The reason why the <code>plPlotterParams</code> datatype exists is that even
though the Plotter interface is largely Plotter-independent, it&nbsp;is
useful to be able to specify certain aspects of a Plotter's behavior at
creation time.  If&nbsp;a a parameter has been set in the specified
<code>plPlotterParams</code> object, that will be the value used by the
Plotter.  If&nbsp;a parameter is <em>not</em> set, the Plotter will use a
default value for&nbsp;it, unless the parameter is string-valued and
there is an environment variable of the same name, in which case the
value of that environment variable will be used.  This rule increases
run-time flexibility: an&nbsp;application programmer may allow
non-critical Plotter parameters to be specified by the user via
environment variables.

   <p>In the C binding, each drawing operation that may be invoked on a
Plotter is represented by a function whose name begins with "pl_" and
ends with "_r".  For example, the <code>openpl</code> operation is invoked on
a Plotter by calling the function <code>pl_openpl_r</code>, the first argument
of which is a pointer to the corresponding <code>plPlotter</code> object.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Older%20C%20APIs">Older C APIs</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#C%20Compiling%20and%20Linking">C Compiling and Linking</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The%20C%20API">The C API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.2 Older C application programming interfaces</h4>

<p>The current C API (application programming interface), which is
thread-safe, is a revision of an older API that is not thread-safe. 
That is why most functions in the current API have names that end in&nbsp;"_r", which stands for `revised' or `reentrant'.

   <p>In the old C API, the Plotter on which an operation was performed is not
specified as an argument of the function that was called to perform the
operation.  Instead, a Plotter is first `selected'.  Then the API
function is called.  <code>pl_openpl</code> was one such function; it&nbsp;opens the currently selected Plotter, i.e., begins a page of graphics.

   <p>The old API is deprecated, but is still supported.  The four functions
in the old API that perform Plotter manipulation have the following
semantics.

     <dl>
<dt>int <tt>pl_newpl</tt> (const char *<var>type</var>, FILE *<var>infile</var>, FILE *<var>outfile</var>, FILE *<var>errfile</var>);
     <dd>Create a Plotter of type <var>type</var>, where <var>type</var> may be "X",
"Xdrawable", "png", "pnm", "gif", "svg", "ai", "ps", "fig", "pcl",
"hpgl", "regis", "tek", or "meta".  The Plotter will have input stream
<var>infile</var>, output stream <var>outfile</var>, and error stream
<var>errfile</var>.  The return value is a `handle': a&nbsp;nonnegative
integer by which the newly created Plotter is referred&nbsp;to.  A&nbsp;negative return value indicates the Plotter could not be created.

     <br><dt>int <tt>pl_selectpl</tt> (int <var>handle</var>);
     <dd>Select a Plotter, referred to by its handle, for use.  Only one Plotter
may be selected at a time.  A&nbsp;negative return value indicates the
specified Plotter could not be selected.  Otherwise, the return value is
the handle of the previously selected Plotter.

     <p>At startup, a single Metafile Plotter that writes to standard output
(with handle&nbsp;`0') is automatically created and selected.

     <br><dt>int <tt>pl_deletepl</tt> (int <var>handle</var>);
     <dd>Delete a Plotter, specified by its handle.  The Plotter must not be
selected at the time it is deleted.  A&nbsp;negative return value
indicates the Plotter could not be deleted.

     <br><dt>int <tt>pl_parampl</tt> (const char *<var>parameter</var>, void *<var>value</var>);
     <dd>Set the global value of the Plotter parameter <var>parameter</var> to
<var>value</var>.  The parameter values in&nbsp;effect at the time any Plotter
is created will be copied into&nbsp;it. 
</dl>

<p>In the old API, selecting a Plotter with <code>pl_selectpl</code> and setting
a value for a Plotter parameter with <code>pl_parampl</code> are global
operations.  That is why the old API is not thread-safe.

   <p>An even older C&nbsp;API omitted the prefix "pl_" from the names of
<code>libplot</code> functions.  The prefix "pl_" was added in&nbsp;part to
distinguish GNU <code>libplot</code> from pre-GNU versions of <code>libplot</code>. 
If&nbsp;you need to compile code written for very early versions of GNU
<code>libplot</code> or for pre-GNU <code>libplot</code>, you should include the
header file <code>plotcompat.h</code>.  <code>plotcompat.h</code> redefines
<code>openpl</code> as <code>pl_openpl</code>, and so&nbsp;forth.  See <a href="#C%20Compiling%20and%20Linking">C Compiling and Linking</a>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="C%20Compiling%20and%20Linking">C Compiling and Linking</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Sample%20C%20Drawings">Sample C Drawings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Older%20C%20APIs">Older C APIs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.3 C compiling and linking</h4>

<p>The source code for a graphics application written in C, if it is to use
the GNU <code>libplot</code> C&nbsp;API (C&nbsp;application programming
interface), must contain the lines

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     </pre>

<p>The header file <code>plot.h</code> is distributed with <code>libplot</code>, and
should have been installed on your system where your C&nbsp;compiler will
find it.  It&nbsp;contains a prototype for each of the functions in the
C&nbsp;API, and some miscellaneous definitions.

   <p>To each Plotter operation there corresponds a function in the C&nbsp;API
whose name begins with "pl_" and ends with&nbsp;"_r".  To&nbsp;invoke the
Plotter operation, this function would be called.  For example, the
<code>openpl</code> operation would be invoked on a Plotter by calling the
function <code>pl_openpl_r</code>, the first argument of which is a pointer to
the Plotter.  All such functions are declared in <code>plot.h</code>.

   <p>In releases of GNU <code>libplot</code> before <code>libplot</code> 3.0, Plotter
operations were performed in a different way.  For example, there was a
function <code>pl_openpl</code> that operated on a Plotter that was
`selected', rather than specified as an argument.  The old C&nbsp;API is
still supported by <code>plot.h</code>.  For more information on&nbsp;it, see
<a href="#Older%20C%20APIs">Older C APIs</a>.

   <p>In even older releases of GNU <code>libplot</code>, and in the non-GNU
versions of <code>libplot</code> that preceded it, the "pl_" prefix was not
used.  If&nbsp;you need to compile code written for early versions of GNU
<code>libplot</code> or for non-GNU <code>libplot</code>, you should also include
the header file <code>plotcompat.h</code>.  That file redefines <code>openpl</code>
as <code>pl_openpl</code>, and so&nbsp;forth.

   <p>To link your application with GNU <code>libplot</code>, you would use the
appropriate <code>-l</code> option(s) on the command line when compiling it. 
You would use

<pre class="example">     -lplot -lXaw -lXmu -lXt -lXext -lX11 -lpng -lz -lm
     </pre>

<p>or, in recent releases of the X&nbsp;Window System,

<pre class="example">     -lplot -lXaw -lXmu -lXt -lSM -lICE -lXext -lX11 -lpng -lz -lm
     </pre>

<p>These linking options assume that your version of <code>libplot</code> has
been compiled with PNG support; if&nbsp;not, you would omit the
<code>-lpng -lz</code> options.

   <p>As an alternative to the preceding, you may need to use <code>-lplot
-lXm -lXt -lXext -lX11 -lpng -lz -lm</code>, <code>-lplot -lXm -lXt -lXext
-lX11 -lpng -lz -lm -lc -lgen</code>, or <code>-lplot -lXm -lXt -lXext -lX11
-lpng -lz -lm -lc -lPW</code>, on systems that provide Motif widgets instead
of Athena widgets.  In recent releases of the X&nbsp;Window System, you
would insert <code>-lSM -lICE</code>.  Recent releases of Motif require
<code>-lXp</code> and possibly <code>-lXpm</code> as&nbsp;well.)

   <p>On some platforms, the directories in which <code>libplot</code> or the other
libraries are stored must be specified on the command line.  For&nbsp;example, the options <code>-lXaw -lXmu -lXt -lSM -lICE -lXext -lX11</code>,
which specify X&nbsp;Window System libraries, may need to be preceded by
an option like <code>-L/usr/X11/lib</code>.

   <p>On most systems <code>libplot</code> is installed as a shared library.  This
means that the linking with your application will take place at run time
rather than compile time.  The environment variable
<code>LD_LIBRARY_PATH</code> lists the directories which will be searched for
shared libraries at run time.  For your application to be executable,
this environment variable should include the directory in which
<code>libplot</code> is stored.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Sample%20C%20Drawings">Sample C Drawings</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Paths%20and%20Subpaths">Paths and Subpaths</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C%20Compiling%20and%20Linking">C Compiling and Linking</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.4 Sample drawings in C</h4>

<p>The following is a sample application, written in C, that invokes GNU
<code>libplot</code> operations to draw vector graphics.  It&nbsp;draws an
intricate and beautiful path (Bill Gosper's "C"&nbsp;curve, discussed
as Item #135 in <cite>HAKMEM</cite>, MIT Artificial Intelligence Laboratory
Memo #239, 1972).  As&nbsp;the numeric constant <code>MAXORDER</code> (here
equal to&nbsp;12) is increased, the path will take&nbsp;on the shape of a
curly letter&nbsp;"C", which is the envelope of a myriad of epicyclic
octagons.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     #define MAXORDER 12
     
     void draw_c_curve (plPlotter *plotter, double dx, double dy, int order)
     {
       if (order &gt;= MAXORDER)
         /* continue path along (dx, dy) */
         pl_fcontrel_r (plotter, dx, dy);
       else
         {
           draw_c_curve (plotter,
                         0.5 * (dx - dy), 0.5 * (dx + dy), order + 1);
           draw_c_curve (plotter,
                         0.5 * (dx + dy), 0.5 * (dy - dx), order + 1);
         }
     }
     
     int main ()
     {
       plPlotter *plotter;
       plPlotterParams *plotter_params;
     
       /* set a Plotter parameter */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "PAGESIZE", "letter");
     
       /* create a Postscript Plotter that writes to standard output */
       if ((plotter = pl_newpl_r ("ps", stdin, stdout, stderr,
                                  plotter_params)) == NULL)
         {
           fprintf (stderr, "Couldn't create Plotter\n");
           return 1;
         }
     
       if (pl_openpl_r (plotter) &lt; 0)      /* open Plotter */
         {
           fprintf (stderr, "Couldn't open Plotter\n");
           return 1;
         }
       pl_fspace_r (plotter, 0.0, 0.0, 1000.0, 1000.0); /* set coor system */
       pl_flinewidth_r (plotter, 0.25);    /* set line thickness */
       pl_pencolorname_r (plotter, "red"); /* use red pen */
       pl_erase_r (plotter);               /* erase graphics display */
       pl_fmove_r (plotter, 600.0, 300.0); /* position the graphics cursor */
       draw_c_curve (plotter, 0.0, 400.0, 0);
       if (pl_closepl_r (plotter) &lt; 0)     /* close Plotter */
         {
           fprintf (stderr, "Couldn't close Plotter\n");
           return 1;
         }
     
       if (pl_deletepl_r (plotter) &lt; 0)    /* delete Plotter */
         {
           fprintf (stderr, "Couldn't delete Plotter\n");
           return 1;
         }
       return 0;
     }
     </pre>

   <p>As you can see, this application begins by creating a
<code>plPlotterParams</code> object to hold Plotter parameters, and sets the
<code>PAGESIZE</code> parameter.  It&nbsp;then calls the <code>pl_newpl_r</code>
function to create a Postscript Plotter.  The Postscript Plotter will
produce output for a US letter-sized page, though any other standard
page size, e.g., "a4", could be substituted.  This would be arranged by
altering the call to <code>pl_setplparam</code>.  The <code>PAGESIZE</code>
parameter is one of several Plotter parameters that an application
programmer may set.  For a list, see <a href="#Plotter%20Parameters">Plotter Parameters</a>.

   <p>After the Plotter is created, the application opens&nbsp;it and draws the
"C"&nbsp;curve recursively.  The drawing of the curve is accomplished
by calling the <code>pl_fmove_r</code> function to position the Plotter's
graphics cursor, and then calling <code>draw_c_curve</code>.  This subroutine
repeatedly calls <code>pl_fcontrel_r</code>.  The <code>pl_fcontrel_r</code>
function continues a path by adding a line segment to&nbsp;it.  The
endpoint of each line segment is specified in relative floating point
coordinates, i.e., as a floating point offset from the previous cursor
position.  After the "C"&nbsp;curve is drawn, the Plotter is closed by
calling <code>pl_closepl_r</code>, which automatically invokes
<code>pl_endpath_r</code> to end the path.  A&nbsp;Postscript file is written
to standard output when <code>pl_deletepl_r</code> is called to delete the
Plotter.

   <p>Specifying "png", "pnm", "gif", "svg", "ai", "cgm", "fig", "pcl",
"hpgl", "regis", "tek", or "meta" as the first argument in the call to
<code>pl_newpl_r</code>, instead of "ps", would yield a Plotter that would
write graphics to standard output in the specified format, instead of
Postscript.  The <code>PAGESIZE</code> parameter is relevant to the "svg",
"ai", "cgm", "fig", "pcl", and "hpgl" output formats, but is ignored for
the others.  Specifying "meta" as the Plotter type may be useful if you
wish to avoid recompilation for different output devices.  Graphics
metafile output may be piped to the <code>plot</code> utility and converted to
any other supported output format, or displayed in an X&nbsp;window. 
See <a href="#plot">plot</a>.

   <p>If&nbsp;"X" were specified as the first argument of <code>pl_newpl_r</code>,
the curve would be drawn in a popped-up X&nbsp;window, and the output
stream argument would be ignored.  Which X&nbsp;Window System display the
window would pop&nbsp;up on would be determined by the <code>DISPLAY</code>
parameter, or if that parameter were not set, by the <code>DISPLAY</code>
environment variable.  The size of the X&nbsp;window would be determined
by the <code>BITMAPSIZE</code> parameter, or if that parameter were not set,
by the <code>BITMAPSIZE</code> environment variable.  The default value is
"570x570".  For the "png", "pnm", and "gif" Plotter types, the
interpretation of <code>BITMAPSIZE</code> is similar.

   <p>You could also specify "Xdrawable" as the Plotter type.  For you to make
this work, you would need to know a bit about X&nbsp;Window System
programming.  You would need to create at&nbsp;least one X&nbsp;drawable
(i.e., window or a pixmap), and by invoking <code>pl_setplparam</code> before
<code>pl_newpl_r</code> is called, set it as the value of the parameter
<code>XDRAWABLE_DRAWABLE1</code> or <code>XDRAWABLE_DRAWABLE2</code>.  For the
parameters that affect X&nbsp;Drawable Plotters, see <a href="#Plotter%20Parameters">Plotter Parameters</a>.

   <p>The following is another sample application, written in C, that invokes
<code>libplot</code> operations to draw vector graphics.  It&nbsp;draws a
spiral consisting of elliptically boxed text strings, each of which
reads "GNU libplot!".  This figure will be sent to standard output in
Postscript format.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     #include &lt;math.h&gt;
     #define SIZE 100.0   /* nominal size of user coordinate frame */
     #define EXPAND 2.2   /* expansion factor for elliptical box */
     
     void draw_boxed_string (plPlotter *plotter,
                             char *s, double size, double angle)
     {
       double true_size, width;
     
       pl_ftextangle_r (plotter, angle);      /* set text angle (degrees) */
       true_size = pl_ffontsize_r (plotter, size);  /* set font size */
       width = pl_flabelwidth_r (plotter, s); /* compute width of string */
       pl_fellipserel_r (plotter, 0.0, 0.0,
                         EXPAND * 0.5 * width, EXPAND * 0.5 * true_size,
                         angle);              /* draw surrounding ellipse */
       pl_alabel_r (plotter, 'c', 'c', s);    /* draw centered text string */
     }
     
     int main()
     {
       plPlotter *plotter;
       plPlotterParams *plotter_params;
       int i;
     
       /* set a Plotter parameter */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "PAGESIZE", "letter");
     
       /* create a Postscript Plotter that writes to standard output */
       if ((plotter = pl_newpl_r ("ps", stdin, stdout, stderr,
                                  plotter_params)) == NULL)
         {
           fprintf (stderr, "Couldn't create Plotter\n");
           return 1;
         }
     
       if (pl_openpl_r (plotter) &lt; 0)      /* open Plotter */
         {
           fprintf (stderr, "Couldn't open Plotter\n");
           return 1;
         }
       /* specify user coor system */
       pl_fspace_r (plotter, -(SIZE), -(SIZE), SIZE, SIZE);
       pl_pencolorname_r (plotter, "blue");     /* use blue pen */
       pl_fillcolorname_r (plotter, "white");   /* set white fill color */
       pl_filltype_r (plotter, 1);   /* fill ellipses with fill color */
       /* choose a Postscript font */
       pl_fontname_r (plotter, "NewCenturySchlbk-Roman");
     
       for (i = 80; i &gt; 1; i--)      /* loop through angles */
         {
           double theta, radius;
     
           theta = 0.5 * (double)i;  /* theta is in radians */
           radius = SIZE / pow (theta, 0.35);  /* this yields a spiral */
           pl_fmove_r (plotter, radius * cos (theta), radius * sin (theta));
           draw_boxed_string (plotter, "GNU libplot!", 0.04 * radius,
                              (180.0 * theta / M_PI) - 90.0);
         }
     
       if (pl_closepl_r (plotter) &lt; 0)        /* close Plotter */
         {
           fprintf (stderr, "Couldn't close Plotter\n");
           return 1;
         }
       if (pl_deletepl_r (plotter) &lt; 0)       /* delete Plotter */
         {
           fprintf (stderr, "Couldn't delete Plotter\n");
           return 1;
         }
       return 0;
     }
     </pre>

   <p>This example shows what is involved in plotting a text string or text
strings.  First, the desired font must be retrieved.  A&nbsp;font is
fully specified by calling <code>pl_fontname_r</code>, <code>pl_fontsize_r</code>,
and <code>pl_textangle_r</code>, or their floating point counterparts
<code>pl_ffontname_r</code>, <code>pl_ffontsize_r</code>, and
<code>pl_ftextangle_r</code>.  Since these three functions may be called in
any order, each of them returns the size of the font that it selects, as
a convenience to the programmer.  This may differ slightly from the size
specified in the most recent call to <code>pl_fontsize_r</code> or
<code>pl_ffontsize_r</code>, since many Plotters have only a limited repertory
of fonts.  The above example plots each text string in the
"NewCenturySchlbk-Roman" font, which is available on Postscript
Plotters.  See <a href="#Text%20Fonts">Text Fonts</a>.

   <p>If you replace "ps" by "X" in the call to <code>pl_newpl_r</code>, an X&nbsp;Plotter rather than a Postscript Plotter will be used, and the spiral
will be drawn in a popped-up X&nbsp;window.  If your X&nbsp;display does
not support the "NewCenturySchlbk-Roman" font, you may substitute any
other scalable font, such as the widely available
"utopia-medium-r-normal".  For the format of font names, see <a href="#Text%20Fonts%20in%20X">Text Fonts in X</a>.  If&nbsp;the X&nbsp;Plotter is unable to retrieve the font
you specify, it will first attempt to use a default scalable font
("Helvetica"), and if that fails, use a default Hershey vector font
("HersheySerif") instead.  Hershey fonts are constructed from line
segments, so each built-in Hershey font is available on all types of
Plotter.

   <p>If you are using an older (pre-X11R6) X&nbsp;Window System display, you
will find that retrieving a scalable font is a time-consuming operation. 
The above example may run slowly on some older X&nbsp;displays, since a
new font must be retrieved before each text string is drawn.  That is
because each text string has a different angle of inclination.  It&nbsp;is possible to retrieve individual characters from an X11R6 display,
rather than retrieving an entire rasterized font.  If&nbsp;this feature
is available, the X&nbsp;Plotter will automatically take advantage of&nbsp;it to save time.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Paths%20and%20Subpaths">Paths and Subpaths</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Drawing%20on%20a%20Page">Drawing on a Page</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Sample%20C%20Drawings">Sample C Drawings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.5 Simple paths and compound paths</h4>

<p>The most sophisticated sort of graphical object that <code>libplot</code> can
draw is a <em>path</em>.  In this section we explain the fine details of
constructing paths.  The other three sorts of graphical object (text
strings, marker symbols, and points [i.e., pixels]) are discussed
elsewhere.

   <p>As in Postscript, paths may be simple or compound.  A&nbsp;simple path is
a contiguous sequence of line segments, circular arcs, elliptic arcs,
quadratic Bezier curves, and/or cubic Bezier curves.  A&nbsp;simple path
may also be a circle, an ellipse, or a rectangle.  A&nbsp;compound path
consists of one or more simple paths, which must be <em>nested</em>: they
should not intersect each other.  <em>This is more restrictive than in
Postscript.</em>

   <p><code>libplot</code>'s drawing model is significantly different from
Postscript's, and is more user-friendly.  Before drawing a path by
invoking <code>libplot</code> operations, you do not need to call any special
function.  You would specify the attributes of the path before drawing,
however.  Attributes include pen color, line type, line width, cap type,
join type, and miter limit.  If&nbsp;the path is to be filled, the fill
color and fill rule would be specified too.  All these attributes are
`modal': their values are preserved from path to path.

   <p>In principle, you would end any path you construct, and request that it
be drawn on the graphics display, by invoking the <code>endpath</code>
operation.  But <code>endpath</code> is called automatically when any
path-related attribute is changed, when <code>move</code> is called to change
the graphics cursor position, and before any other object is constructed
and drawn.  It&nbsp;is also called at the end of each page of graphics,
i.e., when <code>closepl</code> is invoked.  So invoking <code>endpath</code>
explicitly is usually unnecessary.  This is quite different from
Postscript, where an explicit command to stroke or fill a path is
required.

   <p><code>libplot</code> also differs from Postscript in the way it constructs and
draws compound paths.  In <code>libplot</code>, you would end each of the
constituent simple paths of a compound path by invoking the
<code>endsubpath</code> operation.  After all simple paths are drawn, the
compound path as a whole would be drawn by invoking <code>endpath</code>. 
After each of the calls to <code>endsubpath</code>, you are allowed to call
<code>move</code> to reposition the graphics cursor, prior to beginning the
next simple path.  Immediately after an invocation of <code>endsubpath</code>,
a call to <code>move</code> will not automatically invoke <code>endpath</code>.

   <p>The following sample program uses a Postscript Plotter to produce
Postscript output.  It draws a typical compound path, which consists of
17&nbsp;simple paths.  The first simple path is a large box.  This box
contains 7&nbsp;circles, nested within each other, and a separate set of
7&nbsp;circles that are also nested within each other.  Within each of
the two sets of nested circles is a pair of contiguous line segments,
which make up an additional simple path.  The compound path is drawn in
green, and it is filled.  The fill color is light blue.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     
     int main ()
     {
       int i, j;
       plPlotter *plotter;
       plPlotterParams *plotter_params;
     
       /* set a Plotter parameter */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "PAGESIZE", "letter");
       /* create a Postscript Plotter that writes to standard output */
       plotter = pl_newpl_r ("ps", stdin, stdout, stderr, plotter_params);
       /* open Plotter, i.e. begin a page of graphics */
       pl_openpl_r (plotter);
     
       pl_fspace_r (plotter, 0.0, 0.0, 1000.0, 1000.0); /* set coor system */
       pl_flinewidth_r (plotter, 5.0);  /* set line thickness */
       pl_pencolorname_r (plotter, "green");
       pl_fillcolorname_r (plotter, "light blue");
       pl_filltype_r (plotter, 1);      /* do filling, full strength */
       pl_erase_r (plotter);            /* erase graphics display */
     
       /* draw a compound path consisting of 17 simple paths */
     
       /* draw the first simple path: a large box */
       pl_orientation_r (plotter, 1);
       pl_fbox_r (plotter, 50.0, 50.0, 950.0, 950.0);
       pl_endsubpath_r (plotter);
       for (i = 0; i &lt; 2; i++)
         /* draw 8 simple paths that are nested inside the box */
         {
           /* first, draw 7 simple paths: nested circles */
           for (j = 9; j &gt;= 3; j--)
             {
               pl_orientation_r (plotter, j % 2 ? -1 : 1);
               pl_fcircle_r (plotter, 250.0 + 500 * i, 500.0, j * 20.0);
               pl_endsubpath_r (plotter);
             }
           /* draw an open simple path comprising two line segments */
           pl_fmove_r (plotter, 225.0 + 500 * i, 475.0);
           pl_fcont_r (plotter, 250.0 + 500 * i, 525.0);
           pl_fcont_r (plotter, 275.0 + 500 * i, 475.0);
           pl_endsubpath_r (plotter);
         }
       /* formally end the compound path (not actually necessary) */
       pl_endpath_r (plotter);
     
       /* close Plotter, i.e. end page of graphics */
       pl_closepl_r (plotter);
       /* delete Plotter */
       if (pl_deletepl_r (plotter) &lt; 0)
         {
           fprintf (stderr, "Couldn't delete Plotter\n");
           return 1;
         }
       return 0;
     }
     </pre>

   <p>As you will see if you run this program, the filling of the compound
path takes place in a visually pleasing way: alternating annular regions
are filled.  That is because <code>libplot</code>'s default fill rule is
"even-odd".  Since a compound path's constituent simple paths must
always be nested, it is easy for <code>libplot</code> to determine which
regions between them are `even' and which are `odd'.  It&nbsp;is the
latter that are filled.

   <p>The above program includes many invocations of <code>orientation</code>.  The
value of the modal `orientation' attribute (1,&nbsp;meaning
counterclockwise, or&nbsp;-1, meaning clockwise) applies to
subsequently drawn boxes, circles, and ellipses.  If "even-odd" filling
is used, they have no effect.  But&nbsp;if the fill rule for the compound
path is set to "nonzero-winding" by an initial call to <code>fillmod</code>,
these calls to <code>orientation</code> will arrange matters so that
alternating annular regions are filled, just as if "even-odd" filling
were used.

   <p>If the preceding paragraph is mysterious, it would be wise to consult a
good book on Postscript programming, or any other reference on the
subject of `winding numbers'.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Drawing%20on%20a%20Page">Drawing on a Page</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Animated%20GIFs">Animated GIFs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Paths%20and%20Subpaths">Paths and Subpaths</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.6 Drawing on a physical page</h4>

<p>GNU <code>libplot</code> can draw graphics over an entire page of paper, not
merely within the graphics display or `viewport' that it normally uses.

   <p>The default viewport used by an Illustrator, Postscript, Fig, or PCL
Plotter is a square region centered on the page.  The size of the
default viewport depends on the <code>PAGESIZE</code> parameter, which may be
"letter", "a4", etc.  See <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.  For example,
the default viewport on a letter-sized page, which has width 8.5in
and height 11in, is a square of side 8in.

   <p>However, you may specify different dimensions for the viewport, and a
different position as&nbsp;well.  In particular, you may specify a
viewport that covers the entire page.  This would be accomplished by
setting <code>PAGESIZE</code> to, for example,
"letter,xsize=8.5in,ysize=11in,xorigin=0in,yorigin=0in".  "xorigin" and
"yorigin" specify the location of the lower left corner of the viewport,
relative to the lower left corner of the page.

   <p>With this choice for the viewport, the entire page is in&nbsp;principle
imageable.  For full-page drawing, it is convenient to define a user
coordinate system in terms of which the lower left corner of the page is
(0,0), and in which the units are physical inches or centimeters.  To&nbsp;do so, you would use appropriate arguments when invoking the
<code>space</code> operation on the Plotter.  The following program shows how
the <code>space</code> operation would be invoked.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     
     int main()
     {
       plPlotter *plotter;
       plPlotterParams *plotter_params;
     
       /* set page size parameter, including viewport size and location */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "PAGESIZE",
                      "letter,xsize=8.5in,ysize=11in,xorigin=0in,yorigin=0in");
     
       /* create a Postscript Plotter with the specified parameter */
       plotter = pl_newpl_r ("ps", stdin, stdout, stderr, plotter_params);
     
       pl_openpl_r (plotter);                /* begin page of graphics */
       pl_fspace_r (plotter,
                    0.0, 0.0, 8.5, 11.0);   /* set user coor system */
     
       pl_fontname_r (plotter, "Times-Bold");
       pl_ffontsize_r (plotter, 0.5);        /* font size = 0.5in = 36pt */
     
       pl_fmove_r (plotter, 1.0, 10.0);
       pl_alabel_r (plotter, 'l', 'x', "One inch below the top");
       pl_fline_r (plotter, 1.0, 10.0, 7.5, 10.0);
     
       pl_fmove_r (plotter, 7.5, 1.0);
       pl_alabel_r (plotter, 'r', 'x', "One inch above the bottom");
       pl_fline_r (plotter, 1.0, 1.0, 7.5, 1.0);
     
       pl_closepl_r (plotter);               /* end page of graphics */
       pl_deletepl_r (plotter);              /* delete Plotter */
       return 0;
     }
     </pre>

<p>The program will print two strings and draw the baseline for each.  The
first string will be left-justified at position (1.0,11.0), which is one
inch below the top of the page.  The second string will be
right-justified at position (7.5,1.0), which is one inch above the
bottom of the page.  For both strings, the <tt>'x'</tt> argument of
<code>pl_alabel_r</code> specifies the vertical positioning: it&nbsp;requests
that the baseline of the string, rather than (say) its top or bottom, be
positioned at the current vertical position.

   <p>The preceding discussion and sample program dealt with the portrait
orientation of the printed page, which is the default.  Drawing in
landscape orientation is only slightly more complicated.  For this, the
viewport would be rotated on the page by setting the Plotter parameter
<code>ROTATION</code>.  Its default value is&nbsp;"0" (or&nbsp;"no"), and other
allowed values are "90" (or&nbsp;"yes"), "180", and "270".  On&nbsp;a
letter-sized page in landscape orientation, a rotated viewport has lower
left corner (0.0,0.0) and upper right corner (11.0,8.5), provided that
inches are used.  The following program is a modified version of the
preceding, showing how a landscape orientation would be produced.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     
     int main()
     {
       plPlotter *plotter;
       plPlotterParams *plotter_params;
     
       /* set Plotter parameters */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "PAGESIZE",
                      "letter,xsize=8.5in,ysize=11in,xorigin=0in,yorigin=0in");
       pl_setplparam (plotter_params, "ROTATION", "90");
     
       /* create a Postscript Plotter with the specified parameters */
       plotter = pl_newpl_r ("ps", stdin, stdout, stderr, plotter_params);
     
       pl_openpl_r (plotter);                /* begin page of graphics */
       pl_fspace_r (plotter,
                    0.0, 0.0, 11.0, 8.5);   /* set user coor system */
     
       pl_fontname_r (plotter, "Times-Bold");
       pl_ffontsize_r (plotter, 0.5);        /* font size = 0.5in = 36pt */
     
       pl_fmove_r (plotter, 1.0, 7.5);
       pl_alabel_r (plotter, 'l', 'x', "One inch below the top");
       pl_fline_r (plotter, 1.0, 7.5, 10.0, 7.5);
     
       pl_fmove_r (plotter, 10.0, 1.0);
       pl_alabel_r (plotter, 'r', 'x', "One inch above the bottom");
       pl_fline_r (plotter, 1.0, 1.0, 10.0, 1.0);
     
       pl_closepl_r (plotter);               /* end page of graphics */
       pl_deletepl_r (plotter);              /* delete Plotter */
       return 0;
     }
     </pre>

   <p>It is worth nothing that rotating a viewport, by specifying a nonzero
value for <code>ROTATION</code>, does not change the position of its four
corners.  Rather, any graphics that are drawn are rotated within&nbsp;it. 
If&nbsp;the viewport is rectangular rather than square, this `rotation'
necessarily includes a rescaling.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Animated%20GIFs">Animated GIFs</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#X%20Animations">X Animations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Drawing%20on%20a%20Page">Drawing on a Page</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.7 Animated GIFs in C</h4>

<p>Using GNU <code>libplot</code> to create pseudo-GIF files, including animated
pseudo-GIFs, is straightforward.  A&nbsp;GIF Plotter is a Plotter like
any other, and it supports the same drawing operations.  However, it has
two special properties.  (1)&nbsp;It can draw only a single page of
graphics, i.e., only the graphics contained in the first
<code>openpl</code><small class="dots">...</small><code>closepl</code> pair appear in the output file. 
In&nbsp;this, it resembles other Plotters that do not plot in real time. 
(2)&nbsp;Within this page, each invocation of <code>erase</code> is normally
treated as the beginning of a new image in the output file.  There is an
exception to this: the first invocation of <code>erase</code> begins a new
image only if something has already been drawn.

   <p>The reason for the exception is that many programmers who use
<code>libplot</code> are in the habit of invoking <code>erase</code> immediately
after a Plotter is opened.  That is not a bad habit, since a few types
of Plotter (e.g., X&nbsp;Drawable and Tektronix Plotters) are
`persistent' in the sense that previously drawn graphics remain visible.

   <p>The following program creates a simple animated pseudo-GIF, 150 pixels
wide and 100 pixels high.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     
     int main()
     {
       plPlotter *plotter;
       plPlotterParams *plotter_params;
       int i;
     
       /* set Plotter parameters */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "BITMAPSIZE", "150x100");
       pl_setplparam (plotter_params, "BG_COLOR", "orange");
       pl_setplparam (plotter_params, "TRANSPARENT_COLOR", "orange");
       pl_setplparam (plotter_params, "GIF_ITERATIONS", "100");
       pl_setplparam (plotter_params, "GIF_DELAY", "5");
     
       /* create a GIF Plotter with the specified parameters */
       plotter = pl_newpl_r ("gif", stdin, stdout, stderr, plotter_params);
     
       pl_openpl_r (plotter);                 /* begin page of graphics */
       pl_fspace_r (plotter,
                    -0.5, -0.5, 149.5, 99.5); /* set user coor system */
     
       pl_pencolorname_r (plotter, "red");    /* use red pen */
       pl_linewidth_r (plotter, 5);           /* set line thickness */
       pl_filltype_r (plotter, 1);            /* objects will be filled */
       pl_fillcolorname_r (plotter, "black"); /* set the fill color */
     
       for (i = 0; i &lt; 180 ; i += 15)
         {
           pl_erase_r (plotter);              /* begin new GIF image */
           pl_ellipse_r (plotter, 75, 50, 40, 20, i); /* draw an ellipse */
         }
     
       pl_closepl_r (plotter);                /* end page of graphics */
       pl_deletepl_r (plotter);               /* delete Plotter */
       return 0;
     }
     </pre>

   <p>The animated pseudo-GIF will be written to standard output.  It&nbsp;will
consist of twelve images, showing the counterclockwise rotation of a
black-filled red ellipse through 180 degrees.  The pseudo-GIF will be
`looped' (see below), so the ellipse will rotate repeatedly.

   <p>The parameters of the ellipse are expressed in terms of user
coordinates, not pixel coordinates.  But the call to <code>pl_fspace_r</code>
defines user coordinates that are effectively the same as pixel
coordinates.  In the user coordinate system, the lower left corner of
the rectangle mapped into the 150x100 pseudo-GIF image is given
coordinates (-0.5,-0.5), and the upper right corner is
given coordinates (149.5,99.5).  So individual pixels may be addressed
in terms of integer user coordinates.  For&nbsp;example, invoking
<code>pl_point_r(plotter,0,0)</code> and <code>pl_point_r(plotter,149,99)</code>
would set the pixels in the lower left and upper right corners of the
image to the current pen color.

   <p>Besides <code>BITMAPSIZE</code> and <code>BG_COLOR</code>, there are several
important GIF Plotter parameters that may be set with the
<code>pl_setplparam</code> function.  The <code>TRANSPARENT_COLOR</code> parameter
may be set to the name of a color.  Pixels in a pseudo-GIF that have
that color will be treated as transparent by most software.  This is
usually used to create a transparent background.  In&nbsp;the example
above, the background color is specified as orange, but the transparent
color is also specified as orange.  So&nbsp;the background will not
actually be displayed.

   <p>The <code>GIF_ITERATIONS</code> parameter, if&nbsp;set, specifies the number of
times that a multi-frame pseudo-GIF should be looped.  The
<code>GIF_DELAY</code> parameter specifies the number of hundredths of a
seconds that should elapse between successive images.

   <p>The <code>INTERLACE</code> parameter is sometimes useful.  If it is set to
"yes", the pseudo-GIF will be interlaced.  This is of greatest value for
single-frame GIFs.  For full details on Plotter parameters, see
<a href="#Plotter%20Parameters">Plotter Parameters</a>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="X%20Animations">X Animations</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#X%20Programming">X Programming</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Animated%20GIFs">Animated GIFs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.8 X Window System animations in C</h4>

<p>You may use GNU <code>libplot</code> to produce vector graphics animations on
any Plotter that does real-time plotting (i.e., an&nbsp;X, X&nbsp;Drawable, ReGIS, Tektronix, or Metafile Plotter).  By definition, the
`frames' in any page of graphics are separated by invocations of
<code>erase</code>.  So&nbsp;the graphics display will be cleared after each
frame.  If successive frames differ only slightly, a&nbsp;smooth
animation will result.

   <p>The following is a sample application, written in&nbsp;C, that produces
an animation for the X&nbsp;Window System.  It&nbsp;displays a `drifting
eye'.  As&nbsp;the eye drifts across a popped-up window from left to
right, it slowly rotates.  After the eye has drifted across twice, the
window will vanish.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     
     int main ()
     {
       plPlotter *plotter;
       plPlotterParams *plotter_params;
       int i = 0, j;
     
       /* set Plotter parameters */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "BITMAPSIZE", "300x150");
       pl_setplparam (plotter_params, "VANISH_ON_DELETE", "yes");
       pl_setplparam (plotter_params, "USE_DOUBLE_BUFFERING", "yes");
     
       /* create an X Plotter with the specified parameters */
       if ((plotter = pl_newpl_r ("X", stdin, stdout, stderr,
                                  plotter_params)) == NULL)
         {
           fprintf (stderr, "Couldn't create Plotter\n");
           return 1;
         }
     
       if (pl_openpl_r (plotter) &lt; 0)         /* open Plotter */
         {
           fprintf (stderr, "Couldn't open Plotter\n");
           return 1;
         }
       pl_fspace_r (plotter,
                    -0.5, -0.5, 299.5, 149.5);  /* set user coor system */
       pl_linewidth_r (plotter, 8);           /* set line thickness */
       pl_filltype_r (plotter, 1);            /* objects will be filled */
       pl_bgcolorname_r (plotter, "saddle brown"); /* set background color */
       for (j = 0; j &lt; 300; j++)
         {
           pl_erase_r (plotter);                 /* erase window */
           pl_pencolorname_r (plotter, "red");   /* use red pen */
           pl_fillcolorname_r (plotter, "cyan"); /* use cyan filling */
           pl_ellipse_r (plotter, i, 75, 35, 50, i);  /* draw an ellipse */
           pl_colorname_r (plotter, "black"); /* use black pen and filling */
           pl_circle_r (plotter, i, 75, 12);  /* draw a circle [the pupil] */
           i = (i + 2) % 300;                 /* shift rightwards */
         }
       if (pl_closepl_r (plotter) &lt; 0)        /* close Plotter */
         {
           fprintf (stderr, "Couldn't close Plotter\n");
           return 1;
         }
     
       if (pl_deletepl_r (plotter) &lt; 0)       /* delete Plotter */
         {
           fprintf (stderr, "Couldn't delete Plotter\n");
           return 1;
         }
       return 0;
     }
     </pre>

   <p>As you can see, this application begins by calling <code>pl_setplparam</code>
several times to set Plotter parameters, and then calls
<code>pl_newpl_r</code> to create an X&nbsp;Plotter.  The X&nbsp;Plotter window
will have size 300x150 pixels.  This window will vanish when the Plotter
is deleted.  If&nbsp;the <code>VANISH_ON_DELETE</code> parameter were not set
to "yes", the window would remain on the screen until removed by the
user (by&nbsp;typing <code>q</code> in&nbsp;it, or by clicking with a mouse).

   <p>Setting the parameter <code>USE_DOUBLE_BUFFERING</code> to "yes" requests that
double buffering be used.  This is very important if you wish to produce
a smooth animation, with no jerkiness.  Normally, an X&nbsp;Plotter draws
graphics into a window in real time, and erases the window when
<code>pl_erase_r</code> is called.  But if double buffering is used, each
frame of graphics is written into an off-screen buffer, and is copied
into the window, pixel by pixel, when <code>pl_erase_r</code> is called or the
Plotter is closed.  This is a bit counterintuitive, but is exactly what
is needed for smooth animation.

   <p>After the Plotter is created, it is selected for use and opened.  When
<code>pl_openpl_r</code> is called, the window pops&nbsp;up, and the animation
begins.  In the body of the <tt>for</tt> loop there is a call to
<code>pl_erase_r</code>, and also a sequence of <code>libplot</code> operations that
draws the eye.  The pen color and fill color are changed twice with each
passage through the loop.  You may wish to experiment with the animation
parameters to produce the best effects on your video hardware.

   <p>The positions of the objects that are plotted in the animation are
expressed in terms of user coordinates, not pixel coordinates.  But the
call to <code>pl_fspace_r</code> defines user and pixel coordinates to be
effectively the same.  User coordinates are chosen so that the lower
left corner of the rectangle mapped to the X&nbsp;window is
(-0.5,-0.5) and the upper right corner is (299.5,149.5). 
Since this agrees with the window size, individual pixels may be
addressed in terms of integer user coordinates.  For&nbsp;example,
<code>pl_point_r(plotter,299,149)</code> would set the pixel in the upper
right corner of the window to the current pen color.

   <p>The following is another sample animation, this time of a rotating
letter&nbsp;`A'.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     
     int main()
     {
       plPlotter *plotter;
       plPlotterParams *plotter_params;
       int angle = 0;
     
       /* set Plotter parameters */
       plotter_params = pl_newplparams ();
       pl_setplparam (plotter_params, "BITMAPSIZE", "300x300");
       pl_setplparam (plotter_params, "USE_DOUBLE_BUFFERING", "yes");
       pl_setplparam (plotter_params, "BG_COLOR", "blue");
     
       /* create an X Plotter with the specified parameters */
       plotter = pl_newpl_r ("X", stdin, stdout, stderr, plotter_params);
     
       /* open X Plotter, initialize coordinates, pen, and font */
       pl_openpl_r (plotter);
       pl_fspace_r (plotter, 0.0, 0.0, 1.0, 1.0);  /* use normalized coors */
       pl_pencolorname_r (plotter, "white");
       pl_ffontsize_r (plotter, 1.0);
       pl_fontname_r (plotter, "NewCenturySchlbk-Roman");
     
       pl_fmove_r (plotter, 0.5, 0.5);        /* move to center */
       while (1)                              /* loop endlessly */
         {
           pl_erase_r (plotter);
           pl_textangle_r (plotter, angle++); /* set new rotation angle */
           pl_alabel_r (plotter, 'c', 'c', "A"); /* draw a centered `A' */
         }
       pl_closepl_r (plotter);                /* close Plotter */
     
       pl_deletepl_r (plotter);               /* delete Plotter */
       return 0;
     }
     </pre>

   <p>This animation serves as a good test of the capabilities of an X&nbsp;Window System display.  On&nbsp;a modern X11R6 display, animation will
be smooth and fast.  That is because X11R6 displays can rasterize
individual characters from a font without rasterizing the entire font. 
If&nbsp;your X&nbsp;display does not support the "NewCenturySchlbk-Roman"
font, you may substitute any other scalable font, such as the widely
available "utopia-medium-r-normal".  For the format of font names, see
<a href="#Text%20Fonts%20in%20X">Text Fonts in X</a>.  If&nbsp;the X&nbsp;Plotter is unable to retrieve
the font you specify, it will first attempt to use a default scalable
font ("Helvetica").  If&nbsp;that too fails, it will use a default
Hershey vector font ("HersheySerif") instead.

   <p>Animations that use Hershey fonts are normally faster than ones that use
Postscript fonts or other X&nbsp;Window System fonts, since the Hershey
fonts are constructed from line segments.  Rasterizing line segments can
be done rapidly.  But if you use a scalable font such as
"NewCenturySchlbk-Roman" or "utopia-medium-r-normal", you will notice
that the rotation speeds&nbsp;up after the letter `A' has rotated through
360 degrees.  That is because the `A' at angles past 360 degrees has
already been rasterized.

   <p>If you are writing an application that performs a lengthy sequence of
drawing operations on an X&nbsp;Plotter, you may find it useful to set
the Plotter parameter <code>X_AUTO_FLUSH</code> to "no".  By default, an X&nbsp;Plotter flushes all graphics to its X&nbsp;Window System display after
each drawing operation.  This flushing ensures that graphics are visible
to the user immediately after they are drawn.  However, it sometimes
considerably slows down the rendering process.  For additional details
on Plotter parameters, see <a href="#Plotter%20Parameters">Plotter Parameters</a>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="X%20Programming">X Programming</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#X%20Animations">X Animations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C%20Programming">C Programming</a>
<br>
</div>

<h3 class="subsection">9.2.9 Advanced X Window System programming</h4>

<p>Applications that run under the X Window System are often built using
Xt, the X&nbsp;Toolkit.  In&nbsp;Xt, an application is constructed from
`widgets' such as text entry fields, buttons, sliders, drawing areas,
etc.  When the application starts&nbsp;up, each widget is configured to
respond appropriately to `events', which include key presses and mouse
clicks.  After the widgets are configured, control is transferred to the
Xt&nbsp;event loop.

   <p>GNU <code>libplot</code> can be used within the Xt event loop to draw vector
graphics.  For this, it would use one or more X&nbsp;Drawable Plotters. 
An X&nbsp;Drawable Plotter is a Plotter that can plot into an off-screen
pixmap or an on-screen window, such as a window associated with a
widget.

   <p>The following sample application shows how an X&nbsp;Drawable Plotter
would be used.  The application draws a `C'&nbsp;curve, as defined in a
previous section, in a popped-up window.  The usual Xt command-line
options may be used: the window background color is specified with the
<code>-bg</code> option, the window geometry with <code>-geometry</code>, etc.  The
curve is initially drawn in red, but clicking once with the mouse will
redraw it in green.  A&nbsp;second mouse click will redraw it in red, and
so&nbsp;forth.  The application will terminate when <code>q</code> is typed.

<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;plot.h&gt;
     #include &lt;X11/Xlib.h&gt;
     #include &lt;X11/Intrinsic.h&gt;
     #include &lt;X11/Shell.h&gt;
     #include &lt;X11/StringDefs.h&gt;
     #include &lt;X11/Core.h&gt;
     
     plPlotter *plotter;
     int green = 0;                  /* draw in green, not red? */
     
     #define MAXORDER 12
     void draw_c_curve (double dx, double dy, int order)
     {
       if (order &gt;= MAXORDER)
         /* continue path along (dx, dy) */
         pl_fcontrel_r (plotter, dx, dy);
       else
         {
           draw_c_curve (0.5 * (dx - dy), 0.5 * (dx + dy), order + 1);
           draw_c_curve (0.5 * (dx + dy), 0.5 * (dy - dx), order + 1);
         }
     }
     
     void Redraw (Widget w, XEvent *ev, String *params, Cardinal *n_params)
     {
       /* draw C curve */
       pl_erase_r (plotter);
       pl_pencolorname_r (plotter, green ? "green" : "red");
       pl_fmove_r (plotter, 600.0, 300.0);
       draw_c_curve (0.0, 400.0, 0);
       pl_endpath_r (plotter);
     }
     
     void Toggle (Widget w, XEvent *ev, String *params, Cardinal *n_params)
     {
       green = (green ? 0 : 1);
       Redraw (w, ev, params, n_params);
     }
     
     void Quit (Widget w, XEvent *ev, String *params, Cardinal *n_params)
     {
       exit (0);
     }
     
     /* mapping of events to actions */
     static const String translations =
     "&lt;Expose&gt;:      redraw()\n\
     &lt;Btn1Down&gt;:     toggle()\n\
     &lt;Key&gt;q:         quit()";
     
     /* mapping of actions to subroutines */
     static XtActionsRec actions[] =
     {
       {"redraw",            Redraw},
       {"toggle",            Toggle},
       {"quit",              Quit},
     };
     
     /* default parameters for widgets */
     static String default_resources[] =
     {
       "Example*geometry:      250x250",
       (String)NULL
     };
     
     int main (int argc, char *argv[])
     {
       plPlotterParams *plotter_params;
       Arg wargs[10];                /* storage of widget args */
       Display *display;             /* X display */
       Widget shell, canvas;         /* toplevel widget; child */
       Window window;                /* child widget's window */
       XtAppContext app_con;         /* application context */
       int i;
       char *bg_colorname = "white";
     
       /* take background color from command line */
       for (i = 0; i &lt; argc - 1; i++)
         if (strcmp (argv[i], "-bg") == 0)
           bg_colorname = argv[i + 1];
       /* create toplevel shell widget */
       shell = XtAppInitialize (&amp;app_con,
                                (String)"Example", /* app class */
                                NULL,              /* options */
                                (Cardinal)0,       /* num of options */
                                &amp;argc,             /* command line */
                                argv,              /* command line */
                                default_resources,
                                NULL,              /* ArgList */
                                (Cardinal)0        /* num of Args */
                                );
       /* set default widget parameters (including window size) */
       XtAppSetFallbackResources (app_con, default_resources);
       /* map actions to subroutines */
       XtAppAddActions (app_con, actions, XtNumber (actions));
       /* create canvas widget as child of shell widget; realize both */
       XtSetArg(wargs[0], XtNargc, argc);
       XtSetArg(wargs[1], XtNargv, argv);
       canvas = XtCreateManagedWidget ((String)"", coreWidgetClass,
                                       shell, wargs, (Cardinal)2);
       XtRealizeWidget (shell);
       /* for the canvas widget, map events to actions */
       XtSetArg (wargs[0], XtNtranslations,
                 XtParseTranslationTable (translations));
       XtSetValues (canvas, wargs, (Cardinal)1);
     
       /* initialize GNU libplot */
       plotter_params = pl_newplparams ();
       display = XtDisplay (canvas);
       window = XtWindow (canvas);
       pl_setplparam (plotter_params, "XDRAWABLE_DISPLAY", display);
       pl_setplparam (plotter_params, "XDRAWABLE_DRAWABLE1", &amp;window);
       pl_setplparam (plotter_params, "BG_COLOR", bg_colorname);
       plotter = pl_newpl_r ("Xdrawable", NULL, NULL, stderr,
                             plotter_params);
       pl_openpl_r (plotter);
       pl_fspace_r (plotter, 0.0, 0.0, 1000.0, 1000.0);
       pl_flinewidth_r (plotter, 0.25);
     
       /* transfer control to X Toolkit event loop (doesn't return) */
       XtAppMainLoop (app_con);
     
       return 1;
     }
     </pre>

   <p>Even if you are not familiar with X&nbsp;Window System programming, the
structure of this application should be clear.  It&nbsp;defines three
callbacks: <code>Redraw</code>, <code>Toggle</code>, and <code>Quit</code>.  They are
invoked respectively in response to (1)&nbsp;a window expose event or
mouse click, (2)&nbsp;a mouse click, and (3)&nbsp;a typed&nbsp;<code>q</code>. 
The first drawing of the `C'&nbsp;curve (in&nbsp;red) takes place because
the window receives an initial expose event.

   <p>This example could be extended to take window resizing into account. 
Actually, X&nbsp;Drawable Plotters are usually used to draw vector
graphics in off-screen pixmaps rather than on-screen windows.  Pixmaps,
unlike windows, are never resized.

<div class="node">
<p><hr>
Node:&nbsp;<a name="C++%20Programming">C++ Programming</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Functions">Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C%20Programming">C Programming</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#libplot">libplot</a>
<br>
</div>

<h3 class="section">9.3 C++ Programming with <code>libplotter</code></h3>

<ul class="menu">
<li><a accesskey="1" href="#The%20Plotter%20Class">The Plotter Class</a>:            The Plotter class
<li><a accesskey="2" href="#C++%20Compiling%20and%20Linking">C++ Compiling and Linking</a>:    C++ compiling and linking
<li><a accesskey="3" href="#Sample%20C++%20Drawings">Sample C++ Drawings</a>:          Sample drawings in C++
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="The%20Plotter%20Class">The Plotter Class</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#C++%20Compiling%20and%20Linking">C++ Compiling and Linking</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C++%20Programming">C++ Programming</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C++%20Programming">C++ Programming</a>
<br>
</div>

<h3 class="subsection">9.3.1 The <code>Plotter</code> class</h4>

<p>The C++ binding for <code>libplot</code> is provided by a class library named
<code>libplotter</code>.  This library implements a <code>Plotter</code> class of&nbsp;which all Plotters are instances.  Actually, a Plotter would normally
be an instance of an appropriate derived class, determined by the
Plotter's output format.  Derived classes include <code>XPlotter</code>,
<code>XDrawablePlotter</code>, <code>PNGPlotter</code>, <code>PNMPlotter</code>,
<code>GIFPlotter</code>, <code>AIPlotter</code>, <code>PSPlotter</code>,
<code>CGMPlotter</code>, <code>FigPlotter</code>, <code>PCLPlotter</code>,
<code>HPGLPlotter</code>, <code>ReGISPlotter</code>, <code>TekPlotter</code>, and
<code>MetaPlotter</code>.  The names should be self-explanatory.  The
operations that may be applied to any Plotter (e.g., the <code>openpl</code>
operation, which begins a page of graphics) are implemented as public
function members of the <code>Plotter</code> class.

   <p>At the time a Plotter is created, its input, output, and error streams
must be specified, along with a PlotterParams object that optionally
contains other Plotter parameters.  (The input stream is ignored, since
at&nbsp;present, all Plotters are write-only.)  The streams may be
specified either as iostreams or as <code>FILE</code> pointers.  That is, the
two constructors

<pre class="example">       Plotter(istream&amp; instream, ostream&amp; outstream, ostream&amp; errstream,
               PlotterParams &amp;params);
       Plotter(FILE *infile, FILE *outfile, FILE *errfile,
               PlotterParams &amp;params);
     </pre>

<p>are provided for the base Plotter class, and similarly for each of its
derived classes.  So, for example, both

<pre class="example">     PSPlotter plotter(cin, cout, cerr, params);
     </pre>

<p>and

<pre class="example">     PSPlotter plotter(stdin, stdout, stderr, params);
     </pre>

<p>are possible declarations of a Postscript Plotter that writes to
standard output.  In the iostream case, an ostream with a null stream
buffer may be specified as the output stream and/or the error stream, to
request that no output take place.  In&nbsp;the <code>FILE</code> pointer case,
specifying a null <code>FILE</code> pointer would accomplish the same thing. 
Instances of the <code>XPlotter</code> and <code>XDrawablePlotter</code> classes
always ignore the output stream argument, since they write graphics to
an X&nbsp;Display rather than to a stream.

   <p>The <code>PlotterParams</code> class supports copying and assignment, but has
only a single public function member, <code>setplparam</code>.  The following
is a formal description.

     <dl>
<dt>int <tt>PlotterParams::setplparam</tt> (const char *<var>parameter</var>, void *<var>value</var>);
     <dd>Set the value of the Plotter parameter <var>parameter</var> to <var>value</var>. 
For most parameters, <var>value</var> should be a <code>char *</code>, i.e., a
string.  Unrecognized parameters are ignored.  For a list of the
recognized parameters and their meaning, see <a href="#Plotter%20Parameters">Plotter Parameters</a>. 
</dl>

   <p>Like the <code>plPlotterParams</code> datatype and the function
<code>pl_setplparam</code> of the C binding, the <code>PlotterParams</code> class
and the <code>PlotterParams::setplparam</code> function of the C++ binding
give the programmer fine control over the parameters of subsequently
created Plotters.  The parameter values used by any Plotter are constant
over the lifetime of the Plotter, and are those that were specified when
the Plotter was created.  If&nbsp;at Plotter creation time a parameter
has <em>not</em> been set in the specified <code>PlotterParams</code> object,
its default value will be used, unless the parameter is string-valued
and there is an environment variable of the same name, in which case the
value of that environment variable will be used.

   <p>Once set in a PlotterParams object, a&nbsp;parameter may be unset by the
programmer by invoking <code>PlotterParams::setplparam</code> with a value
argument of NULL.  This further increases flexibility.

   <p>There is an alternative (older) way of constructing a Plotter, which is
deprecated but still supported.  By using either of

<pre class="example">       Plotter(istream&amp; instream, ostream&amp; outstream, ostream&amp; errstream);
       Plotter(FILE *infile, FILE *outfile, FILE *errfile);
     </pre>

<p>one may construct a Plotter without specifying a PlotterParams object. 
In&nbsp;this case the parameter values for the Plotter are copied from
static storage.  A&nbsp;parameter may be set in static storage by
invoking a static member function of the Plotter class,
<code>Plotter::parampl</code>, which has declaration

     <dl>
int <tt>PlotterParams::parampl</tt> (const char *<var>parameter</var>, void *<var>value</var>);
</dl>

<p>This alternative way of creating a Plotter is not thread-safe, which is
why it is deprecated.

<div class="node">
<p><hr>
Node:&nbsp;<a name="C++%20Compiling%20and%20Linking">C++ Compiling and Linking</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Sample%20C++%20Drawings">Sample C++ Drawings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The%20Plotter%20Class">The Plotter Class</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C++%20Programming">C++ Programming</a>
<br>
</div>

<h3 class="subsection">9.3.2 C++ compiling and linking</h4>

<p>The source code for a graphics application written in C++, if it is to
use <code>libplotter</code>, must contain the line

<pre class="example">     #include &lt;plotter.h&gt;
     </pre>

<p>The header file <code>plotter.h</code> is distributed with <code>libplotter</code>,
and should have been installed on your system where your C++&nbsp;compiler will find it.  It&nbsp;declares the <code>Plotter</code> class and
its derived classes, and also contains some miscellaneous definitions. 
It&nbsp;includes the header files <code>&lt;iostream.h&gt;</code> and
<code>&lt;stdio.h&gt;</code>, so you do not need to include them separately.

   <p>To link your application with <code>libplotter</code>, you would use the
appropriate <code>-l</code> option(s) on the command line when compiling it. 
You would use

<pre class="example">     -lplotter -lXaw -lXmu -lXt -lXext -lX11 -lpng -lz -lm
     </pre>

<p>or, in recent releases of the X&nbsp;Window System,

<pre class="example">     -lplotter -lXaw -lXmu -lXt -lSM -lICE -lXext -lX11 -lpng -lz -lm
     </pre>

<p>These linking options assume that your version of <code>libplotter</code> has
been compiled with PNG support; if&nbsp;not, you would omit the
<code>-lpng -lz</code> options.

   <p>As an alternative to the preceding, you may need to use <code>-lplotter
-lXm -lXt -lXext -lX11 -lpng -lz -lm</code>, <code>-lplotter -lXm -lXt -lXext
-lX11 -lpng -lz -lm -lc -lgen</code>, or <code>-lplotter -lXm -lXt -lXext
-lX11 -lpng -lz -lm -lc -lPW</code>, on systems that provide Motif widgets
instead of Athena widgets.  In recent releases of the X&nbsp;Window
System, you would insert <code>-lSM -lICE</code>.  Recent releases of Motif
require <code>-lXp</code> and possibly <code>-lXpm</code> as&nbsp;well.)

   <p>On some platforms, the directories in which <code>libplotter</code> or the
other libraries are stored must be specified on the command line. 
For&nbsp;example, the options <code>-lXaw -lXmu -lXt -lSM -lICE -lXext
-lX11</code>, which specify X&nbsp;Window System libraries, may need to be
preceded by an option like <code>-L/usr/X11/lib</code>.

   <p>On most systems <code>libplotter</code> is installed as a shared library. 
This means that the linking with your application will take place at run
time rather than compile time.  The environment variable
<code>LD_LIBRARY_PATH</code> lists the directories which will be searched for
shared libraries at run time.  For your application to be executable,
this environment variable should include the directory in which
<code>libplotter</code> is stored.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Sample%20C++%20Drawings">Sample C++ Drawings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C++%20Compiling%20and%20Linking">C++ Compiling and Linking</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#C++%20Programming">C++ Programming</a>
<br>
</div>

<h3 class="subsection">9.3.3 Sample drawings in C++</h4>

<p>In a previous section, there are several sample C&nbsp;programs that show
how to draw vector graphics using <code>libplot</code>'s C&nbsp;binding. 
See <a href="#Sample%20C%20Drawings">Sample C Drawings</a>.  In&nbsp;this section, we give a modified
version of one of the C programs, showing how <code>libplot</code>'s C++
binding, i.e., <code>libplotter</code>, can be used similarly.

   <p>The following C++ program draws an intricate and beautiful path (Bill
Gosper's "C"&nbsp;curve).

<pre class="example">     #include &lt;plotter.h&gt;
     const int maxorder = 12;
     
     void draw_c_curve (Plotter&amp; plotter, double dx, double dy, int order)
     {
       if (order &gt;= maxorder)
         plotter.fcontrel (dx, dy);	// continue path along (dx, dy)
       else
         {
           draw_c_curve (plotter,
                         0.5 * (dx - dy), 0.5 * (dx + dy), order + 1);
           draw_c_curve (plotter,
                         0.5 * (dx + dy), 0.5 * (dy - dx), order + 1);
         }
     }
     
     int main ()
     {
       // set a Plotter parameter
       PlotterParams params;
       params.setplparam ("PAGESIZE", (char *)"letter");
     
       PSPlotter plotter(cin, cout, cerr, params); // declare Plotter
       if (plotter.openpl () &lt; 0)                  // open Plotter
         {
           cerr &lt;&lt; "Couldn't open Plotter\n";
           return 1;
         }
     
       plotter.fspace (0.0, 0.0, 1000.0, 1000.0); // specify user coor system
       plotter.flinewidth (0.25);       // line thickness in user coordinates
       plotter.pencolorname ("red");    // path will be drawn in red
       plotter.erase ();                // erase Plotter's graphics display
       plotter.fmove (600.0, 300.0);    // position the graphics cursor
       draw_c_curve (plotter, 0.0, 400.0, 0);
       if (plotter.closepl () &lt; 0)      // close Plotter
         {
           cerr &lt;&lt; "Couldn't close Plotter\n";
           return 1;
         }
       return 0;
     }
     </pre>

   <p>The above is a straightforward translation of the corresponding C&nbsp;program.  Here, <code>plotter</code> is declared as an instance of the
<code>PSPlotter</code> class, which will write Postscript graphics to the
output stream <code>cout</code>.  The graphics are drawn by invoking member
functions.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Functions">Functions</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Plotter%20Parameters">Plotter Parameters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#C++%20Programming">C++ Programming</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#libplot">libplot</a>
<br>
</div>

<h3 class="section">9.4 The functions in <code>libplot</code>: A detailed listing</h3>

<p>In the current release of GNU <code>libplot</code>, any Plotter supports 97
distinct operations.  A&nbsp;language binding for <code>libplot</code>
necessarily includes 97 functions that correspond to these operations. 
In&nbsp;the C binding, these 97 functions belong to the C&nbsp;API
(application programming interface).  The name of each function begins
with the prefix "pl_" and ends with the suffix&nbsp;"_r".  In&nbsp;the C++
binding, the 97 functions are implemented as public members of the
<code>Plotter</code> class.  No&nbsp;prefix or suffix is used.

   <p>A&nbsp;language binding may also include functions for creating,
selecting, and deleting Plotters.  For example, the C&nbsp;binding
includes the additional functions <code>pl_newpl_r</code> and
<code>pl_deletepl_r</code>.  See <a href="#The%20C%20API">The C API</a>.

   <p>The 97 functions that operate on a specified Plotter are divided into
the four sets tabulated below.

   <p>Many functions come in two versions: integer and double precision
floating point.  Internally, <code>libplot</code> uses double precision
floating point.  The integer versions are provided for backward
compatibility.  If&nbsp;there are two versions of a function, the name of
the floating point version begins with the letter&nbsp;<code>f</code>.

   <p>Many functions come in both absolute and relative versions, also.  The
latter use relative coordinates (i.e., coordinates relative to the
current position of the graphics cursor), and their names end in
<code>rel</code>.

   <p>Currently, only a few of the 97 functions have meaningful return values.

<ul class="menu">
<li><a accesskey="1" href="#Control%20Functions">Control Functions</a>:    Functions that open, initialize or close a Plotter
<li><a accesskey="2" href="#Drawing%20Functions">Drawing Functions</a>:    Functions that draw objects
<li><a accesskey="3" href="#Attribute%20Functions">Attribute Functions</a>:  Functions that affect drawing attributes
<li><a accesskey="4" href="#Mapping%20Functions">Mapping Functions</a>:    Functions affecting the user -&gt; device coordinate map
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Control%20Functions">Control Functions</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Drawing%20Functions">Drawing Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Functions">Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>
<br>
</div>

<h3 class="subsection">9.4.1 Control functions</h4>

<p>The following are the "control functions" in <code>libplot</code>.  They are
the basic functions that open, initialize, or close an already-created
Plotter.  They are listed in the approximate order in which they would
be called.

   <p>In the current C&nbsp;binding, each of these functions takes a pointer to
a <code>plPlotter</code> as its first argument.  Also in the current C&nbsp;binding, the name of each function begins with "pl_" and ends with&nbsp;"_r".  ("_r"&nbsp;stands for `revised' or `reentrant'.)  For information
on older C&nbsp;bindings, see <a href="#Older%20C%20APIs">Older C APIs</a>.  In&nbsp;the C++
binding, these are member functions of the <code>Plotter</code> class and its
subclasses, and the prefix and suffix are not used.

     <dl>
<dt>int <tt>openpl</tt> ();
     <dd><tt>openpl</tt> opens a Plotter, i.e., begins a page of graphics.  This
resets the Plotter's drawing attributes to their default values.  A&nbsp;negative return value indicates the Plotter could not be opened.

     <p>Currently, an X Plotter pops&nbsp;up a new window on an X&nbsp;Window
System display for each page of graphics, i.e., with each invocation of
<code>openpl</code>.  Future releases may support window re-use.

     <br><dt>int <tt>bgcolor</tt> (int <var>red</var>, int <var>green</var>, int <var>blue</var>);
     <dd><tt>bgcolor</tt> sets the background color for the Plotter's graphics
display, using a 48-bit RGB color model.  The arguments <var>red</var>,
<var>green</var> and <var>blue</var> specify the red, green and blue intensities
of the background color.  Each is an integer in the range
<tt>0x0000</tt><small class="dots">...</small><tt>0xffff</tt>, i.e., 0<small class="dots">...</small>65535.  The choice (0,&nbsp;0,&nbsp;0) signifies black, and the choice (65535, 65535, 65535) signifies
white.

     <p><tt>bgcolor</tt> affects only Plotters that have a notion of background
color, i.e., X&nbsp;Plotters, X Drawable Plotters, PNG Plotters, PNM
Plotters, and GIF Plotters (all of which produce bitmaps), CGM Plotters,
ReGIS Plotters and Metafile Plotters.  Its effect is simple: the next
time the <tt>erase</tt> operation is invoked on such a Plotter, its display
will be filled with the specified color.

     <br><dt>int <tt>bgcolorname</tt> (const char *<var>name</var>);
     <dd><tt>bgcolorname</tt> sets the background color for the the graphics display
to be <var>name</var>.  Unrecognized colors are interpreted as "white".  For
information on what color names are recognized, see <a href="#Color%20Names">Color Names</a>. 
A&nbsp;24-bit RGB color may also be specified as a six-digit hexadecimal
string, e.g., "#c0c0c0".

     <p><tt>bgcolorname</tt> affects only Plotters that have a notion of background
color, i.e., X&nbsp;Plotters, X&nbsp;Drawable Plotters, PNG Plotters, PNM
Plotters, and GIF Plotters (all of which produce bitmaps), CGM Plotters,
ReGIS Plotters, and Metafile Plotters.  Its effect is simple: the next
time the <tt>erase</tt> operation is invoked on such a Plotter, its display
will be filled with the specified color.

     <p>SVG Plotters and CGM Plotters support "none" as a value for the
background color.  It will turn&nbsp;off the background: the drawn
objects will not be backed by anything.  This is useful when the
generated SVG or WebCGM file is to be placed on a Web page.

     <br><dt>int <tt>erase</tt> ();
     <dd><tt>erase</tt> begins the next frame of a multiframe page, by clearing all
previously plotted objects from the graphics display, and filling it
with the background color (if&nbsp;any).

     <p>It is frequently useful to invoke <tt>erase</tt> at the beginning of each
page, i.e., immediately after invoking <tt>openpl</tt>.  That is because some
Plotters are persistent, in the sense that objects drawn within an
<code>openpl</code><small class="dots">...</small><code>closepl</code> pair remain on the graphics display
even after a new page is begun by a subsequent invocation of
<code>openpl</code>.  Currently, only X&nbsp;Drawable Plotters and Tektronix
Plotters are persistent.  Future releases may support optional
persistence for X&nbsp;Plotters also.

     <p>On X Plotters and X Drawable Plotters the effects of invoking <tt>erase</tt>
will be altogether different if the Plotter parameter
<code>USE_DOUBLE_BUFFERING</code> is set to "yes".  In&nbsp;this case, objects
will be written to an off-screen buffer rather than to the graphics
display, and invoking <tt>erase</tt> will (1)&nbsp;copy the contents of this
buffer to the display, and (2)&nbsp;erase the buffer by filling it with
the background color.  This `double buffering' feature facilitates
smooth animation.  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>space</tt> (int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>);
     <dd><dt>int <tt>fspace</tt> (double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>);
     <dd><tt>space</tt> and <tt>fspace</tt> take two pairs of arguments, specifying the
positions of the lower left and upper right corners of a rectangular
window in the user coordinate system that will be mapped to the
`viewport': the rectangular portion of the output device that graphics
will be drawn&nbsp;in.  The default window is a square, with opposite
corners (0,0) and&nbsp;(1,1).

     <p>In mathematical terms, calling <tt>space</tt> or <tt>fspace</tt> sets the affine
transformation from user coordinates to device coordinates.  That is, it
sets the transformation matrix attribute for each object subsequently
drawn on the display.  Either <tt>space</tt> or <tt>fspace</tt> would usually be
invoked at the beginning of each page of graphics, i.e., immediately
after the call to <tt>openpl</tt>.  Additional calls to <tt>space</tt> or
<tt>fspace</tt> are allowed, and there are several "mapping functions" that
also affect the transformation matrix attribute.  See <a href="#Mapping%20Functions">Mapping Functions</a>.

     <p>Note that the size and location of the viewport depend on the type of
Plotter, and on the Plotter parameters that are specified at Plotter
creation time.  For example, the default viewport used by any
Illustrator, Postscript, Fig, PCL, and HP-GL Plotter is a square whose
size depends on the Plotter's page type.  See <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

     <br><dt>int <tt>space2</tt> (int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>, int <var>x2</var>, int <var>y2</var>);
     <dd><dt>int <tt>fspace2</tt> (double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>, double <var>x2</var>, double <var>y2</var>);
     <dd><tt>space2</tt> and <tt>fspace2</tt> are extended versions of <tt>space</tt> and
<tt>fspace</tt>.  Their arguments are the three defining vertices of an
parallelogram-shaped window in the user coordinate system.  The
specified vertices are the lower left, the lower right, and the upper
left.  This window will be mapped affinely onto the viewport: the
rectangular portion of the output device that graphics will be drawn&nbsp;in.

     <br><dt>int <tt>havecap</tt> (const char *<var>s</var>);
     <dd><tt>havecap</tt> is not really a control function: it is a query function. 
It&nbsp;tests whether or not a Plotter, which need not be open, has a
specified capability.  The return value is 0,&nbsp;1, or&nbsp;2,
signifying no/yes/maybe.  For unrecognized capabilities the return value
is zero.  Recognized capabilities include "WIDE_LINES" (i.e., the
ability to draw lines with a non-default thickness), "DASH_ARRAY" (the
ability to draw in arbitrary dashing styles, as requested by the
<tt>linedash</tt> function), "SETTABLE_BACKGROUND" (the ability to set the
color of the background), and "SOLID_FILL".  The "HERSHEY_FONTS",
"PS_FONTS", "PCL_FONTS", and "STICK_FONTS" capabilities indicate whether
or not fonts of a particular class are supported.  See <a href="#Text%20Fonts">Text Fonts</a>.

     <p>All Plotters except Tektronix Plotters have the "SOLID_FILL" capability,
meaning they can fill paths with solid color.  Each such Plotter has at
least one of the "EVEN_ODD_FILL" and "NONZERO_WINDING_NUMBER_FILL"
capabilities.  These indicate the supported rules for determining the
`inside' of a path.

     <p>The `maybe' value is returned for most capabilities by Metafile
Plotters, which do no drawing themselves.  The output of a Metafile
Plotter must be translated to another format, or displayed, by invoking
<code>plot</code>.

     <br><dt>int <tt>flushpl</tt> ();
     <dd><tt>flushpl</tt> flushes (i.e., pushes onward) all previously plotted objects
to the graphics display.  This is useful only if the affected Plotter is
one that does real-time plotting (X&nbsp;Plotters, X&nbsp;Drawable
Plotters, ReGIS Plotters, Tektronix Plotters, and Metafile Plotters). 
It&nbsp;ensures that all previously plotted objects are visible to the
user.  On&nbsp;Plotters that do not do real-time plotting, this operation
has no effect.

     <br><dt>int <tt>closepl</tt> ();
     <dd><tt>closepl</tt> closes a Plotter, i.e., ends a page of graphics.  If a path
is in progress, it is first ended and plotted, as if <tt>endpath</tt> had
been called.  A&nbsp;negative return value indicates the Plotter could
not be closed.

     <p>In the present release of <code>libplot</code>, some Plotters output each page
of graphics immediately after it is plotted, i.e., when <tt>closepl</tt> is
invoked to end the page.  That is the case with PCL and HP-GL Plotters,
in particular.  Plotters that can output only a single page of graphics
(PNG, PNM, GIF, SVG, Illustrator, and Fig Plotters) do so immediately
after the first page is plotted, i.e., when <tt>closepl</tt> is invoked for
the first time.  Postscript and CGM Plotters store all pages of graphics
internally, and do not produce output until they are deleted. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Drawing%20Functions">Drawing Functions</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Attribute%20Functions">Attribute Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Control%20Functions">Control Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>
<br>
</div>

<h3 class="subsection">9.4.2 Object-drawing functions</h4>

<p>The following are the "drawing functions" in <code>libplot</code>.  When
invoked on a Plotter, these functions cause it to draw objects (paths,
text strings, marker symbols, and points [i.e., pixels]) on the
associated graphics display.

   <p>Paths may be simple or compound.  A&nbsp;simple path is a sequence of
contiguous line segments, arc segments (either circular or elliptic),
and/or Bezier curve segments (either quadratic or cubic).  Such simple
paths are drawn incrementally, one segment at a time.  A&nbsp;simple path
may also be a circle, rectangle, or ellipse.  A&nbsp;compound path
consists of multiple simple paths, which must be nested.

   <p>You do not need to begin a path by calling any special function.  You
should, at&nbsp;least in theory, end a path under construction, and
request that it be drawn on the graphics display, by calling
<code>endpath</code>.  But the <code>endpath</code> function is automatically called
when any other object is drawn, and at the end of each page of graphics. 
It&nbsp;is also called automatically when any path-related attribute is
changed: for example, when <code>move</code> is called to change the graphics
cursor position.  So <code>endpath</code> seldom needs to be invoked
explicitly.

   <p>When drawing a compound path, you would end each of its constituent
simple paths by calling <code>endsubpath</code>, and the compound path as a
whole by calling <code>endpath</code>.  After each call to <code>endsubpath</code>,
you are allowed to call <code>move</code> to reposition the graphics cursor,
prior to beginning the next simple path.  Such a call to <code>move</code>
will not automatically invoke <code>endpath</code>.  This is an exception to
the above rule.

   <p>In the current C&nbsp;binding, each of these functions takes a pointer to
a <code>plPlotter</code> as its first argument.  Also in the current C&nbsp;binding, the name of each function begins with "pl_" and ends with&nbsp;"_r".  ("_r"&nbsp;stands for `revised' or `reentrant'.)  For information
on older C&nbsp;bindings, see <a href="#Older%20C%20APIs">Older C APIs</a>.  In&nbsp;the C++
binding, these are member functions of the <code>Plotter</code> class and its
subclasses, and the prefix and suffix are not used.

     <dl>
<dt>int <tt>alabel</tt> (int <var>horiz_justify</var>, int <var>vert_justify</var>, const char *<var>s</var>);
     <dd><tt>alabel</tt> takes three arguments <var>horiz_justify</var>,
<var>vert_justify</var>, and <var>s</var>, which specify an `adjusted label,'
i.e., a justified text string.  The path under construction (if&nbsp;any)
is ended and drawn, as if <tt>endpath</tt> had been called, and the string
<var>s</var> is drawn according to the specified justifications.  If
<var>horiz_justify</var> is equal to <code>l</code>, <code>c</code>, or <code>r</code>, then
the string will be drawn with left, center or right justification,
relative to the current graphics cursor position.  If <var>vert_justify</var>
is equal to <code>b</code>, <code>x</code>, <code>c</code>, <code>C</code>, or <code>t</code>, then
the bottom, baseline, center, cap line, or top of the string will be
placed even with the current graphics cursor position.  The graphics
cursor is moved to the right end of the string if left justification is
specified, and to the left end if right justification is specified.

     <p>The string may contain escape sequences of various sorts (see <a href="#Text%20String%20Format">Text String Format</a>), though it should not contain line feeds or carriage
returns.  In&nbsp;fact it should include only printable characters, from
the byte ranges <tt>0x20</tt><small class="dots">...</small><tt>0x7e</tt> and <tt>0xa0</tt><small class="dots">...</small><tt>0xff</tt>. 
The string may be plotted at a nonzero angle, if <code>textangle</code> has
been called.

     <br><dt>int <tt>arc</tt> (int <var>xc</var>, int <var>yc</var>, int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>);
     <dd><dt>int <tt>farc</tt> (double <var>xc</var>, double <var>yc</var>, double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>);
     <dd><dt>int <tt>arcrel</tt> (int <var>xc</var>, int <var>yc</var>, int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>);
     <dd><dt>int <tt>farcrel</tt> (double <var>xc</var>, double <var>yc</var>, double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>);
     <dd><tt>arc</tt> and <tt>farc</tt> take six arguments specifying the beginning
(<var>x0</var>, <var>y0</var>), end (<var>x1</var>, <var>y1</var>), and center (<var>xc</var>,
<var>yc</var>) of a circular arc.  If&nbsp;the graphics cursor is at
(<var>x0</var>, <var>y0</var>) and a path is under construction, then the arc is
added to the path.  Otherwise the current path (if&nbsp;any) is ended and
drawn, as if <tt>endpath</tt> had been called, and the arc begins a new
path.  In all cases the graphics cursor is moved to (<var>x1</var>,
<var>y1</var>).

     <p>The direction of the arc (clockwise or counterclockwise) is determined
by the convention that the arc, centered at (<var>xc</var>, <var>yc</var>), sweep
through an angle of at most 180 degrees.  If&nbsp;the three points appear
to be collinear, the direction is taken to be counterclockwise.  If
(<var>xc</var>, <var>yc</var>) is not equidistant from (<var>x0</var>, <var>y0</var>) and
(<var>x1</var>, <var>y1</var>) as it should&nbsp;be, it&nbsp;is corrected by being
moved to the closest point on the perpendicular bisector of the line
segment joining (<var>x0</var>, <var>y0</var>) and (<var>x1</var>, <var>y1</var>). 
<tt>arcrel</tt> and <tt>farcrel</tt> are similar to <code>arc</code> and <code>farc</code>,
but use cursor-relative coordinates.

     <br><dt>int <tt>bezier2</tt> (int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>, int <var>x2</var>, int <var>y2</var>);
     <dd><dt>int <tt>fbezier2</tt> (double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>, double <var>x2</var>, double <var>y2</var>);
     <dd><dt>int <tt>bezier2rel</tt> (int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>, int <var>x2</var>, int <var>y2</var>);
     <dd><dt>int <tt>fbezier2rel</tt> (double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>, double <var>x2</var>, double <var>y2</var>);
     <dd><tt>bezier2</tt> and <tt>fbezier2</tt> take six arguments specifying the beginning
<code>p0</code>=(<var>x0</var>, <var>y0</var>) and end <code>p2</code>=(<var>x2</var>, <var>y2</var>) of
a quadratic Bezier curve, and its intermediate control point
<code>p1</code>=(<var>x1</var>, <var>y1</var>).  If&nbsp;the graphics cursor is at&nbsp;<code>p0</code> and a path is under construction, then the curve is added to
the path.  Otherwise the current path (if&nbsp;any) is ended and drawn,
as if <tt>endpath</tt> had been called, and the curve begins a new path. 
In&nbsp;all cases the graphics cursor is moved to&nbsp;<code>p2</code>. 
<tt>bezier2rel</tt> and <tt>fbezier2rel</tt> are similar to <code>bezier2</code> and
<code>fbezier2</code>, but use cursor-relative coordinates.

     <p>The quadratic Bezier curve is tangent at <code>p0</code> to the line segment
joining <code>p0</code> to&nbsp;<code>p1</code>, and is tangent at&nbsp;<code>p2</code> to
the line segment joining <code>p1</code> to&nbsp;<code>p2</code>.  So&nbsp;it fits
snugly into a triangle with vertices <code>p0</code>, <code>p1</code>, and&nbsp;<code>p2</code>.

     <p>When using a PCL Plotter to draw Bezier curves on a LaserJet III, you
should set the parameter <code>PCL_BEZIERS</code> to "no".  That is because
the LaserJet III, which was Hewlett-Packard's first PCL&nbsp;5 printer,
does not recognize the Bezier instructions supported by later PCL&nbsp;5
printers.  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>bezier3</tt> (int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>, int <var>x2</var>, int <var>y2</var>, int <var>x3</var>, int <var>y3</var>);
     <dd><dt>int <tt>fbezier3</tt> (double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>, double <var>x2</var>, double <var>y2</var>, double <var>x3</var>, double <var>y3</var>);
     <dd><dt>int <tt>bezier3rel</tt> (int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>, int <var>x2</var>, int <var>y2</var>, int <var>x3</var>, int <var>y3</var>);
     <dd><dt>int <tt>fbezier3rel</tt> (double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>, double <var>x2</var>, double <var>y2</var>, double <var>x3</var>, double <var>y3</var>);
     <dd><tt>bezier3</tt> and <tt>fbezier3</tt> take eight arguments specifying the
beginning <code>p0</code>=(<var>x0</var>, <var>y0</var>) and end <code>p3</code>=(<var>x3</var>,
<var>y3</var>) of a cubic Bezier curve, and its intermediate control points
<code>p1</code>=(<var>x1</var>, <var>y1</var>) and <code>p2</code>=(<var>x2</var>, <var>y2</var>). 
If&nbsp;the graphics cursor is at&nbsp;<code>p0</code> and a path is under
construction, then the curve is added to the path.  Otherwise the
current path (if&nbsp;any) is ended and drawn, as if <tt>endpath</tt> had been
called, and the curve begins a new path.  In&nbsp;all cases the graphics
cursor is moved to&nbsp;<code>p3</code>.  <tt>bezier3rel</tt> and <tt>fbezier3rel</tt>
are similar to <code>bezier3</code> and <code>fbezier3</code>, but use
cursor-relative coordinates.

     <p>The cubic Bezier curve is tangent at <code>p0</code> to the line segment
joining <code>p0</code> to&nbsp;<code>p1</code>, and is tangent at&nbsp;<code>p3</code> to
the line segment joining <code>p2</code> to&nbsp;<code>p3</code>.  So&nbsp;it fits
snugly into a quadrangle with vertices <code>p0</code>, <code>p1</code>, <code>p2</code>,
and&nbsp;<code>p3</code>.

     <p>When using a PCL Plotter to draw Bezier curves on a LaserJet III, you
should set the parameter <code>PCL_BEZIERS</code> to "no".  That is because
the LaserJet III, which was Hewlett-Packard's first PCL&nbsp;5 printer,
does not recognize the Bezier instructions supported by later PCL&nbsp;5
printers.  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>box</tt> (int <var>x1</var>, int y<var>1</var>, int <var>x2</var>, int <var>y2</var>);
     <dd><dt>int <tt>fbox</tt> (double <var>x1</var>, double <var>y1</var>, double <var>x2</var>, double <var>y2</var>);
     <dd><dt>int <tt>boxrel</tt> (int <var>x1</var>, int y<var>1</var>, int <var>x2</var>, int <var>y2</var>);
     <dd><dt>int <tt>fboxrel</tt> (double <var>x1</var>, double y<var>1</var>, double <var>x2</var>, double <var>y2</var>);
     <dd><tt>box</tt> and <tt>fbox</tt> take four arguments specifying the starting corner
(<var>x1</var>, <var>y1</var>) and opposite corner (<var>x2</var>, <var>y2</var>) of a
`box', or rectangle.  The path under construction (if&nbsp;any) is ended,
and the box is drawn as a new path.  This path is also ended, and the
graphics cursor is moved to the midpoint of the box.  <tt>boxrel</tt> and
<tt>fboxrel</tt> are similar to <tt>box</tt> and <tt>fbox</tt>, but use cursor-relative
coordinates.

     <br><dt>int <tt>circle</tt> (int <var>xc</var>, int <var>yc</var>, int <var>r</var>);
     <dd><dt>int <tt>fcircle</tt> (double <var>xc</var>, double <var>yc</var>, double <var>r</var>);
     <dd><dt>int <tt>circlerel</tt> (int <var>xc</var>, int <var>yc</var>, int <var>r</var>);
     <dd><dt>int <tt>fcirclerel</tt> (double <var>xc</var>, double <var>yc</var>, double <var>r</var>);
     <dd><tt>circle</tt> and <tt>fcircle</tt> take three arguments specifying the center
(<var>xc</var>, <var>yc</var>) and radius (<var>r</var>) of a circle.  The path under
construction (if&nbsp;any) is ended, and the circle is drawn as a new
path.  This path is also ended, and the graphics cursor is moved to
(<var>xc</var>, <var>yc</var>).  <tt>circlerel</tt> and <tt>fcirclerel</tt> are similar to
<tt>circle</tt> and <tt>fcircle</tt>, but use cursor-relative coordinates for
<var>xc</var> and <var>yc</var>.

     <br><dt>int <tt>cont</tt> (int <var>x</var>, int <var>y</var>);
     <dd><dt>int <tt>fcont</tt> (double <var>x</var>, double <var>y</var>);
     <dd><dt>int <tt>contrel</tt> (int <var>x</var>, int <var>y</var>);
     <dd><dt>int <tt>fcontrel</tt> (double <var>x</var>, double <var>y</var>);
     <dd><tt>cont</tt> and <tt>fcont</tt> take two arguments specifying the coordinates
(<var>x</var>, <var>y</var>) of a point.  If a path is under construction, the
line segment from the current graphics cursor position to the point
(<var>x</var>, <var>y</var>) is added to it.  Otherwise the line segment begins a
new path.  In all cases the graphics cursor is moved to (<var>x</var>,
<var>y</var>).  <tt>contrel</tt> and <tt>fcontrel</tt> are similar to <tt>cont</tt> and
<tt>fcont</tt>, but use cursor-relative coordinates.

     <br><dt>int <tt>ellarc</tt> (int <var>xc</var>, int <var>yc</var>, int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>);
     <dd><dt>int <tt>fellarc</tt> (double <var>xc</var>, double <var>yc</var>, double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>);
     <dd><dt>int <tt>ellarcrel</tt> (int <var>xc</var>, int <var>yc</var>, int <var>x0</var>, int <var>y0</var>, int <var>x1</var>, int <var>y1</var>);
     <dd><dt>int <tt>fellarcrel</tt> (double <var>xc</var>, double <var>yc</var>, double <var>x0</var>, double <var>y0</var>, double <var>x1</var>, double <var>y1</var>);
     <dd><tt>ellarc</tt> and <tt>fellarc</tt> take six arguments specifying the three
points <code>pc</code>=(<var>xc</var>,<var>yc</var>), <code>p0</code>=(<var>x0</var>,<var>y0</var>), and
<code>p1</code>=(<var>x1</var>,<var>y1</var>) that define a so-called quarter ellipse. 
This is an elliptic arc from <code>p0</code> to <code>p1</code> with center&nbsp;<code>pc</code>.  If&nbsp;the graphics cursor is at point <code>p0</code> and a path
is under construction, the quarter-ellipse is added to it.  Otherwise
the path under construction (if&nbsp;any) is ended and drawn, as if
<tt>endpath</tt> had been called, and the quarter-ellipse begins a new path. 
In&nbsp;all cases the graphics cursor is moved to <code>p1</code>.

     <p>The quarter-ellipse is an affinely transformed version of a quarter
circle.  It&nbsp;is drawn so as to have control points <code>p0</code>,
<code>p1</code>, and <code>p0</code>+<code>p1</code>-<code>pc</code>.  This means that it
is tangent at <code>p0</code> to the line segment joining <code>p0</code> to
<code>p0</code>+<code>p1</code>-<code>pc</code>, and is tangent at <code>p1</code> to the
line segment joining <code>p1</code> to <code>p0</code>+<code>p1</code>-<code>pc</code>. 
So&nbsp;it fits snugly into a triangle with these three control points as
vertices.  Notice that the third control point is the reflection of
<code>pc</code> through the line joining <code>p0</code> and&nbsp;<code>p1</code>. 
<tt>ellarcrel</tt> and <tt>fellarcrel</tt> are similar to <tt>ellarc</tt> and
<tt>fellarc</tt>, but use cursor-relative coordinates.

     <br><dt>int <tt>ellipse</tt> (int <var>xc</var>, int <var>yc</var>, int <var>rx</var>, int <var>ry</var>, int <var>angle</var>);
     <dd><dt>int <tt>fellipse</tt> (double <var>xc</var>, double <var>yc</var>, double <var>rx</var>, double <var>ry</var>, double <var>angle</var>);
     <dd><dt>int <tt>ellipserel</tt> (int <var>xc</var>, int <var>yc</var>, int <var>rx</var>, int <var>ry</var>, int <var>angle</var>);
     <dd><dt>int <tt>fellipserel</tt> (double <var>xc</var>, double <var>yc</var>, double <var>rx</var>, double <var>ry</var>, double <var>angle</var>);
     <dd><tt>ellipse</tt> and <tt>fellipse</tt> take five arguments specifying the center
(<var>xc</var>, <var>yc</var>) of an ellipse, the lengths of its semiaxes
(<var>rx</var> and <var>ry</var>), and the inclination of the first semiaxis in
the counterclockwise direction from the x&nbsp;axis in the user
coordinate system.  The path under construction (if&nbsp;any) is ended,
and the ellipse is drawn as a new path.  This path is also ended, and
the graphics cursor is moved to (<var>xc</var>, <var>yc</var>).  <tt>ellipserel</tt>
and <tt>fellipserel</tt> are similar to <tt>ellipse</tt> and <tt>fellipse</tt>, but use
cursor-relative coordinates.

     <br><dt>int <tt>endpath</tt> ();
     <dd><tt>endpath</tt> terminates the path under construction, if&nbsp;any, and
draws&nbsp;it.  It&nbsp;also removes the path from the current graphics
context, so that a new path may be constructed.

     <p>The path under construction may be a simple path, or a compound path
constructed with the aid of <tt>endsubpath</tt> (see below).  A&nbsp;simple
path is constructed by one or more successive calls to <tt>cont</tt>,
<tt>line</tt>, <tt>arc</tt>, <tt>ellarc</tt>, <tt>bezier2</tt>, <tt>bezier3</tt>, and/or their
floating point counterparts.  A&nbsp;simple path may also be constructed
by a single call to <tt>circle</tt>, <tt>ellipse</tt>, or <tt>box</tt>.

     <p>It is often not necessary to call <tt>endpath</tt> explicitly, since it is
frequently called automatically.  It will be called if any non-path
object is drawn, if any path-related drawing attribute is set, or if
<tt>move</tt> or <tt>fmove</tt> is invoked to set the cursor position.  It&nbsp;will also be called if <tt>restorestate</tt> is called to pop a graphics
context off the stack, and if <tt>closepl</tt> is called to end a page of
graphics.  So it is seldom necessary to call <tt>endpath</tt> explicitly. 
However, if a Plotter plots objects in real time, calling <tt>endpath</tt>
will ensure that a completed path is drawn on the graphics display
without delay.

     <br><dt>int <tt>endsubpath</tt> ();
     <dd><tt>endsubpath</tt> terminates the simple path under construction, if&nbsp;any, and signals that the construction of the next simple path in a
compound path is to begin.  Immediately after <tt>endsubpath</tt> is called,
it is permissible to call <tt>move</tt> or <tt>fmove</tt> to reposition the
graphics cursor.  (At other times in the drawing of a compound path,
calling <tt>move</tt> or <tt>fmove</tt> would force a premature end to the path,
by automatically invoking <tt>endpath</tt>.)

     <br><dt>int <tt>label</tt> (const char *<var>s</var>);
     <dd><tt>label</tt> takes a single string argument <var>s</var> and draws the text
contained in <var>s</var> at the current graphics cursor position.  The text
is left justified, and the graphics cursor is moved to the right end of
the string.  This function is provided for backward compatibility; the
function call <tt>label</tt>(<var>s</var>) is equivalent to <tt>alabel</tt>(`l',`x',<var>s</var>).

     <br><dt>int <tt>labelwidth</tt> (const char *<var>s</var>);
     <dd><dt>double <tt>flabelwidth</tt> (const char *<var>s</var>);
     <dd><tt>labelwidth</tt> and <tt>flabelwidth</tt> are not really object-drawing
functions: they are query functions.  They compute and return the width
of a string in the current font, in the user coordinate system.  The
string is not drawn.

     <br><dt>int <tt>line</tt> (int <var>x1</var>, int <var>y1</var>, int <var>x2</var>, int <var>y2</var>);
     <dd><dt>int <tt>fline</tt> (double <var>x1</var>, double y<var>1</var>, double <var>x2</var>, double <var>y2</var>);
     <dd><dt>int <tt>linerel</tt> (int <var>x1</var>, int y<var>1</var>, int <var>x2</var>, int <var>y2</var>);
     <dd><dt>int <tt>flinerel</tt> (double <var>x1</var>, double y<var>1</var>, double <var>x2</var>, double <var>y2</var>);
     <dd><tt>line</tt> and <tt>fline</tt> take four arguments specifying the start point
(<var>x1</var>, <var>y1</var>) and end point (<var>x2</var>, <var>y2</var>) of a line
segment.  If&nbsp;the graphics cursor is at (<var>x1</var>, <var>y1</var>) and a
path is under construction, the line segment is added to it.  Otherwise
the path under construction (if&nbsp;any) is ended and drawn, as if
<tt>endpath</tt> had been called, and the line segment begins a new path. 
In&nbsp;all cases the graphics cursor is moved to (<var>x2</var>, <var>y2</var>). 
<tt>linerel</tt> and <tt>flinerel</tt> are similar to <tt>line</tt> and <tt>fline</tt>, but
use cursor-relative coordinates.

     <br><dt>int <tt>marker</tt> (int <var>x</var>, int <var>y</var>, int <var>type</var>, int <var>size</var>);
     <dd><dt>int <tt>fmarker</tt> (double <var>x</var>, double <var>y</var>, int <var>type</var>, double <var>size</var>);
     <dd><dt>int <tt>markerrel</tt> (int <var>x</var>, int <var>y</var>, int <var>type</var>, int <var>size</var>);
     <dd><dt>int <tt>fmarkerrel</tt> (double <var>x</var>, double <var>y</var>, int <var>type</var>, double <var>size</var>);
     <dd><tt>marker</tt> and <tt>fmarker</tt> take four arguments specifying the position
(<var>x</var>,<var>y</var>) of a marker symbol, its type, and its font size in
user coordinates.  The path under construction (if&nbsp;any) is ended and
drawn, as if <tt>endpath</tt> had been called, and the marker symbol is
plotted.  The graphics cursor is moved to (<var>x</var>,<var>y</var>). 
<tt>markerrel</tt> and <tt>fmarkerrel</tt> are similar to <tt>marker</tt> and
<tt>fmarker</tt>, but use cursor-relative coordinates for the position
(<var>x</var>,<var>y</var>).

     <p>A marker symbol is a visual representation of a point, which is visible
on all types of Plotter.  In&nbsp;this it differs from the points
produced by the <tt>point</tt> function (see below).  Marker symbol types
0<small class="dots">...</small>31 are taken from a standard set, and marker symbol types 32 and
above are interpreted as the index of a character in the current text
font.  See <a href="#Marker%20Symbols">Marker Symbols</a>.

     <br><dt>int <tt>point</tt> (int <var>x</var>, int <var>y</var>);
     <dd><dt>int <tt>fpoint</tt> (double <var>x</var>, double <var>y</var>);
     <dd><dt>int <tt>pointrel</tt> (int <var>x</var>, int <var>y</var>);
     <dd><dt>int <tt>fpointrel</tt> (double <var>x</var>, double <var>y</var>);
     <dd><tt>point</tt> and <tt>fpoint</tt> take two arguments specifying the coordinates
(<var>x</var>, <var>y</var>) of a point.  The path under construction (if&nbsp;any)
is ended and drawn, as if <tt>endpath</tt> had been called, and the point is
plotted.  The graphics cursor is moved to (<var>x</var>, <var>y</var>). 
<tt>pointrel</tt> and <tt>fpointrel</tt> are similar to <tt>point</tt> and <tt>fpoint</tt>,
but use cursor-relative coordinates.

     <p>`Point' is a misnomer.  Any Plotter that produces a bitmap, i.e., an
X&nbsp;Plotter, an X&nbsp;Drawable Plotter, a&nbsp;PNG Plotter, a&nbsp;PNM
Plotter, or a&nbsp;GIF Plotter, draws a point as a single pixel.  Most
other Plotters draw a point as a small solid circle, usually so&nbsp;small as&nbsp;to be invisible.  So&nbsp;<tt>point</tt> should really be called
<tt>pixel</tt>. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Attribute%20Functions">Attribute Functions</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Mapping%20Functions">Mapping Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Drawing%20Functions">Drawing Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>
<br>
</div>

<h3 class="subsection">9.4.3 Attribute-setting functions</h4>

<p>The following are the "attribute functions" in <code>libplot</code>.  When
invoked on a Plotter, these functions set its drawing attributes, or
save them or restore them.  Path-related attributes include graphics
cursor position, pen color, fill color, fill rule, line thickness, line
style, cap style, join style, miter limit, and transformation matrix. 
Text-related attributes include pen color, font name, font size, text
angle, and transformation matrix.

   <p>Setting any path-related drawing attribute automatically terminates and
draws the path under construction (if&nbsp;any), as&nbsp;if the
<code>endpath</code> operation had been invoked.  The `orientation' attribute
(clockwise/counterclockwise), which affects circles, ellipses, and
boxes, is an exception to this.  The exception allows a compound path to
include circles, ellipses, and boxes with different orientations.

   <p>In the current C&nbsp;binding, each of these functions takes a pointer to
a <code>plPlotter</code> as its first argument.  Also in the current C&nbsp;binding, the name of each function begins with "pl_" and ends with&nbsp;"_r".  ("_r"&nbsp;stands for `revised' or `reentrant'.)  For information
on older C&nbsp;bindings, see <a href="#Older%20C%20APIs">Older C APIs</a>.  In&nbsp;the C++
binding, these are member functions of the <code>Plotter</code> class and its
subclasses, and the prefix and suffix are not used.

     <dl>
<dt>int <tt>capmod</tt> (const char *<var>s</var>);
     <dd><tt>capmod</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the cap mode (i.e.,
cap style) for all paths subsequently drawn on the graphics display. 
Recognized styles are "butt" (the default), "round", and "projecting". 
The three styles are visibly distinct only if the line thickness is
fairly large.  Butt caps do&nbsp;not extend beyond the end of the path. 
The other two kinds do, however.  Round caps are filled semicircles, and
projecting caps are filled rectangular regions that extend a distance
equal to half the line width beyond the end of the path.

     <p>PNG, PNM, GIF, PCL, and HP-GL Plotters support a fourth cap mode,
"triangular".  (For all but PCL and HP-GL Plotters, the support is
currently only partial.)  Plotters other than these treat "triangular"
as equivalent to "round".

     <p>This function has no effect on ReGIS or Tektronix Plotters.  Also, it
has no effect on HP-GL Plotters if the parameter <code>HPGL_VERSION</code> is
set to a value less than&nbsp;"2" (the default), or on CGM Plotters if
the parameter <code>CGM_MAX_VERSION</code> is set to a value less than&nbsp;"3".  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>color</tt> (int <var>red</var>, int <var>green</var>, int <var>blue</var>);
     <dd><tt>color</tt> is a convenience function.  Calling <tt>color</tt> is equivalent to
calling both <tt>pencolor</tt> and <tt>fillcolor</tt>, to set both the the pen
color and fill color of all objects subsequently drawn on the graphics
display.  Note that the physical fill color depends also on the fill
level, which is specified by calling <tt>filltype</tt>.

     <br><dt>int <tt>colorname</tt> (const char *<var>name</var>);
     <dd><tt>colorname</tt> is a convenience function.  Calling <tt>colorname</tt> is
equivalent to calling both <tt>pencolorname</tt> and <tt>fillcolorname</tt>, to
set both the the pen color and fill color of all objects subsequently
drawn on the graphics display.  Note that the physical fill color
depends also on the fill level, which is specified by calling
<tt>filltype</tt>.

     <br><dt>int <tt>fillcolor</tt> (int <var>red</var>, int <var>green</var>, int <var>blue</var>);
     <dd><tt>fillcolor</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the fill color for
all paths subsequently drawn on the graphics display, using a 48-bit RGB
color model.  The arguments <var>red</var>, <var>green</var> and <var>blue</var>
specify the red, green and blue intensities of the fill color.  Each is
an integer in the range <tt>0x0000</tt><small class="dots">...</small><tt>0xffff</tt>, i.e.,
0<small class="dots">...</small>65535.  The choice (0,&nbsp;0,&nbsp;0) signifies black, and the choice
(65535, 65535, 65535) signifies white.  Note that the physical fill
color depends also on the fill level, which is specified by calling
<tt>filltype</tt>.

     <br><dt>int <tt>fillcolorname</tt> (const char *<var>name</var>);
     <dd><tt>fillcolorname</tt> sets the fill color of all paths subsequently drawn on
the graphics display to be <var>name</var>.  Unrecognized colors are
interpreted as "black".  For information on what color names are
recognized, see <a href="#Color%20Names">Color Names</a>.  A&nbsp;24-bit RGB color may also be
specified as a six-digit hexadecimal string, e.g., "#c0c0c0".

     <p>Note that the physical fill color depends also on the fill level, which
is specified by calling <tt>filltype</tt>.

     <br><dt>int <tt>fillmod</tt> (const char *<var>s</var>);
     <dd><tt>fillmod</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the fill mode, i.e.,
fill rule, for all paths subsequently drawn on the graphics display. 
The fill rule affects only compound paths and self-intersecting simple
paths: it determines which points are `inside'.  Two rules are
supported: "even-odd" (the default for all Plotters), and
"nonzero-winding".  For the distinction, see the <cite>Postscript
Language Reference Manual</cite>.  "alternate" is an alias for "even-odd" and
"winding" is an alias for "nonzero-winding".

     <p>CGM, Fig, and ReGIS Plotters do not support the "nonzero-winding" rule,
because the CGM, Fig, and ReGIS vector graphics formats do not
support&nbsp;it.  Also, HP-GL Plotters do not support "nonzero-winding"
if <code>HPGL_VERSION</code> is set to a value less than "2" (the default). 
See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <p>The LaserJet III, which was Hewlett-Packard's first PCL&nbsp;5 printer,
did not support the nonzero-winding fill rule.  However, all later
PCL&nbsp;5 printers from Hewlett-Packard support&nbsp;it.

     <br><dt>int <tt>filltype</tt> (int <var>level</var>);
     <dd><tt>filltype</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the fill level for
all subsequently drawn paths.  A&nbsp;value of&nbsp;0 for <var>level</var>
specifies no filling.  This is the default.  A&nbsp;value of&nbsp;1
specifies 100% filling: the fill color will be the color previously
specified by calling <tt>fillcolor</tt> or <tt>fillcolorname</tt>.

     <p>As a convenience to the user, <var>level</var> may be set to any value in the
range <tt>0x0000</tt><small class="dots">...</small><tt>0xffff</tt>, i.e., 0<small class="dots">...</small>65535.  Any nonzero
value will produce filling.  If <var>level</var>=<tt>0xffff</tt>, the fill color
will be white.  Values in the range <tt>0x0001</tt><small class="dots">...</small><tt>0xffff</tt> are
interpreted as specifying a desaturation, or gray level.  For&nbsp;example, <tt>0x8000</tt> specifies 50% filling (the fill color will be
half-way between the color specified by calling <tt>fillcolor</tt> or
<tt>fillcolorname</tt>, and white).

     <p>To draw the region bounded by a path in an edgeless way, you would call
<tt>filltype</tt> to turn&nbsp;on the filling of the interior, and <tt>pentype</tt>
to turn&nbsp;off the drawing of the boundary.

     <p>Tektronix Plotters do not support filling, and HP-GL Plotters support
filling of arbitrary paths only if the parameter <code>HPGL_VERSION</code> is
equal to "1.5" or&nbsp;"2" (the default).  (If the version is&nbsp;"1"
then only circles and rectangles aligned with the coordinate axes may be
filled.)  <em>Opaque</em> filling, including white filling, is supported
only if the parameter <code>HPGL_VERSION</code> is&nbsp;"2" and the parameter
<code>HPGL_OPAQUE_MODE</code> is "yes" (the default).  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>fmiterlimit</tt> (double <var>limit</var>);
     <dd><tt>fmiterlimit</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the miter limit for
all paths subsequently drawn on the graphics display.  The miter limit
controls the treatment of corners, if the join mode is set to "miter"
(the default).  At&nbsp;a join point of a path, the `miter length' is
defined to be the distance between the inner corner and the outer
corner.  The miter limit is the maximum value that will be tolerated for
the miter length divided by the line thickness.  If this value is
exceeded, the miter will be cut&nbsp;off: the "bevel" join mode will be
used instead.

     <p>Examples of typical values for <var>limit</var> are 10.43 (the default, which
cuts off miters if the join angle is less than 11 degrees), 2.0 (the
same, for 60 degrees), and 1.414 (the same, for 90 degrees).  In&nbsp;general, the miter limit is the cosecant of one-half the minimum angle
for mitered joins.  The minimum meaningful value for <var>limit</var> is&nbsp;1.0, which converts all mitered joins to beveled joins, irrespective of
join angle.  Specifying a value less than 1.0 resets the limit to the
default.

     <p>This function has no effect on X&nbsp;Drawable Plotters or X&nbsp;Plotters, since the X&nbsp;Window System miter limit, which is also
10.43, cannot be altered.  It also has no effect on Tektronix, ReGIS, or
Fig Plotters, or on HP-GL Plotters if the parameter <code>HPGL_VERSION</code>
is set to a value less than&nbsp;"2" (the default).  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.  The miter limit used by HP-GL or PCL Plotters is always
rounded to the closest integer, downward.

     <br><dt>int <tt>fontname</tt> (const char *<var>font_name</var>);
     <dd><dt>double <tt>ffontname</tt> (const char *<var>font_name</var>);
     <dd><tt>fontname</tt> and <tt>ffontname</tt> take a single case-insensitive string
argument, <var>font_name</var>, specifying the name of the font to be used
for all text strings subsequently drawn on the graphics display.  (The
font for plotting strings is fully specified by calling <tt>fontname</tt>,
<tt>fontsize</tt>, and <tt>textangle</tt>.)  The size of the font in user
coordinates is returned.

     <p>The default font name depends on the type of Plotter.  It&nbsp;is
"Helvetica" for all Plotters except for PCL Plotters, for which it is
"Univers", and PNG, PNM, GIF, HP-GL, ReGIS, Tektronix and Metafile
Plotters, for which it is "HersheySerif".  If&nbsp;the argument
<var>font_name</var> is NULL or the empty string, or the font is not
available, the default font name will be used.  Which fonts are
available also depends on the type of Plotter; for a list of all
available fonts, see <a href="#Text%20Fonts">Text Fonts</a>.

     <br><dt>int <tt>fontsize</tt> (int <var>size</var>);
     <dd><dt>double <tt>ffontsize</tt> (double <var>size</var>);
     <dd><tt>fontsize</tt> and <tt>ffontsize</tt> take a single argument, interpreted as
the size, in the user coordinate system, of the font to be used for all
text strings subsequently drawn on the graphics display.  (The font for
plotting strings is fully specified by calling <tt>fontname</tt>,
<tt>fontsize</tt>, and <tt>textangle</tt>.)  The size of the font in user
coordinates is returned.

     <p>A&nbsp;negative value for <var>size</var> sets the size to the default, which
depends on the type of Plotter.  Typically, the default font size is
1/50 times the size (i.e., minimum dimension) of the display.  The
interpretation of zero font size is also Plotter-dependent (most
Plotters do not draw text strings if the font size is zero).

     <br><dt>int <tt>joinmod</tt> (const char *<var>s</var>);
     <dd><tt>joinmod</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the join mode (i.e.,
join style) for all paths subsequently drawn on the graphics display. 
Recognized styles are "miter" (the default), "round", and "bevel".  The
three styles are visibly distinct only if the line thickness is fairly
large.  Mitered joins are sharp, rounded joins are round, and beveled
joins are squared&nbsp;off.  However, unusually sharp joins are never
mitered: instead, they are beveled.  The angle at which beveling
replaces mitering may be specified by calling <tt>fmiterlimit</tt>.

     <p>PNG, PNM, GIF, PCL, and HP-GL Plotters support a fourth join mode,
"triangular".  Other Plotters treat "triangular" as equivalent to
"round".

     <p>This function has no effect on ReGIS or Tektronix Plotters.  Also, it
has no effect on HP-GL Plotters if the parameter <code>HPGL_VERSION</code> is
set to a value less than&nbsp;"2" (the default), or on CGM Plotters if
the parameter <code>CGM_MAX_VERSION</code> is set to a value less than&nbsp;"3".  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>linedash</tt> (int <var>n</var>, const int *<var>dashes</var>, int <var>offset</var>);
     <dd><dt>int <tt>flinedash</tt> (int <var>n</var>, const double *<var>dashes</var>, double <var>offset</var>);
     <dd><tt>linedash</tt> and <tt>flinedash</tt> terminate and draw the path under
construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and set
the line style for all paths subsequently drawn on the graphics display. 
They provide much finer control of dash patterns than the <tt>linemod</tt>
function (see below) provides.  <var>dashes</var> should be an array of
length&nbsp;<var>n</var>.  Its elements, which should be positive, are
interpreted as distances in the user coordinate system.  Along any path,
circle, or ellipse, the elements
<var>dashes</var>[0]<small class="dots">...</small><var>dashes</var>[<var>n</var>-1] alternately specify the
length of a dash and the length of a gap between dashes.  When the end
of the array is reached, the reading of the array wraps around to the
beginning.  If the array is empty, i.e., <var>n</var> equals zero, there is
no dashing: the drawn line is solid.

     <p>The <var>offset</var> argument specifies the `phase' of the dash pattern
relative to the start of the path.  It is interpreted as the distance
into the dash pattern at which the dashing should begin.  For example,
if <var>offset</var> equals zero then the path will begin with a dash, of
length <var>dashes</var>[0] in user space.  If&nbsp;<var>offset</var> equals
<var>dashes</var>[0] then the path will begin with a gap of length
<var>dashes</var>[1], and so&nbsp;forth.  <var>offset</var> is allowed to be
negative.

     <p>Not all Plotters fully support <tt>linedash</tt> and <tt>flinedash</tt>.  PCL and
HP-GL Plotters cannot dash with a nonzero offset, and in the dash
patterns used by X&nbsp;and X&nbsp;Drawable Plotters, each dash or gap has
a maximum length of 255 pixels.  <tt>linedash</tt> and <tt>flinedash</tt> have no
effect at&nbsp;all on Tektronix, ReGIS, and Fig Plotters.  Also, they
have no effect on HP-GL Plotters for which the parameter
<code>HPGL_VERSION</code> is less than&nbsp;"2" (the default), or on CGM
Plotters for which the parameter <code>CGM_MAX_VERSION</code> is less than&nbsp;"3".  For information on Plotter parameters, see <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <p><strong>Warning</strong>: If the transformation from the user coordinate system
to the device coordinate system is anisotropic, each dash pattern should
ideally be drawn on the graphics display with a length that depends on
its direction.  But currently, only SVG and Postscript Plotters do&nbsp;this.  Other Plotters always draw any specified dash pattern with the
same length, irrespective of its direction.  The length that is used is
the minimum length, in the device coordinate system, that can correspond
to the specified dash pattern length in the user coordinate system.

     <br><dt>int <tt>linemod</tt> (const char *<var>s</var>);
     <dd><tt>linemod</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the line style for
all paths subsequently drawn on the graphics display.  The supported
line styles are "solid", "dotted", "dotdashed", "shortdashed",
"longdashed", "dotdotdashed", "dotdotdotdashed", and "disconnected". 
The first seven correspond to the following dash patterns:

     <pre class="example">          "solid"             --------------------------------
          "dotted"            -   -   -   -   -   -   -   -
          "dotdashed"         ----   -   ----   -   ----   -
          "shortdashed"       ----    ----    ----    ----
          "longdashed"        -------    -------    -------
          "dotdotdashed"      ----   -   -   ----   -   -
          "dotdotdotdashed"   ----   -   -   -   ----   -   -   -
          </pre>

     <p>In&nbsp;the preceding patterns, each hyphen stands for one line
thickness.  This is the case for sufficiently thick lines, at&nbsp;least. 
So&nbsp;for sufficiently thick lines, the distance over which a dash
pattern repeats is scaled proportionately to the line thickness.

     <p>The "disconnected" line style is special.  A "disconnected" path is
rendered as a set of filled circles, each of which has diameter equal to
the nominal line thickness.  One of these circles is centered on each of
the juncture points of the path (i.e., the endpoints of the line
segments or arcs from which it is constructed).  Circles and ellipses
with "disconnected" line style are invisible.  Disconnected paths are
not filled; this includes circles and ellipses.

     <p>All line styles are supported by all Plotters, with the following
exceptions.  HP-GL Plotters do not support the "dotdotdotdashed" style
unless the parameter <code>HPGL_VERSION</code> is set to "2" (the default). 
Tektronix Plotters do not support the "dotdotdotdashed" style, and do
not support the "dotdotdashed" style unless the parameter <code>TERM</code> is
set to "kermit".  See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>linewidth</tt> (int <var>size</var>);
     <dd><dt>int <tt>flinewidth</tt> (double <var>size</var>);
     <dd><tt>linewidth</tt> and <tt>flinewidth</tt> terminate and draws the path under
construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and set
the thickness, in the user coordinate system, of all paths subsequently
drawn on the graphics display.  A&nbsp;negative value resets the
thickness to the default.  The default thickness depends on the type of
Plotter.  For most Plotters, it is 1/850 times the size of the viewport,
i.e., the drawn-on portion of the display.  (Here `size' means minimum
dimension.)  But for Plotters that produce bitmaps, i.e., X&nbsp;Plotters, X&nbsp;Drawable Plotters, PNG Plotters, PNM Plotters, and GIF
Plotters, it&nbsp;is zero.

     <p>By convention, a zero-thickness line is the thinnest line that can be
drawn.  However, the drawing editors <code>idraw</code> and <code>xfig</code> treat
zero-thickness lines as invisible.  So&nbsp;when producing editable
graphics with a Postscript or Fig Plotter, using a zero line thickness
may not be desirable.

     <p>Tektronix and ReGIS Plotters do not support drawing with other than a
default thickness, and HP-GL Plotters do not support doing so if the
parameter <code>HPGL_VERSION</code> is set to a value less than&nbsp;"2" (the
default; see <a href="#Plotter%20Parameters">Plotter Parameters</a>).

     <p><strong>Warning</strong>: If the transformation from the user coordinate system
to the device coordinate system is anisotropic, each line segment in a
polygonal path should ideally be drawn on the graphics display with a
thickness that depends on its direction.  But currently, only SVG and
Postscript Plotters do&nbsp;this.  Other Plotters draw all line segments
in a path with the same thickness.  The thickness that is used is the
minimum thickness, in the device coordinate system, that can correspond
to the specified line thickness in the user coordinate system.

     <br><dt>int <tt>move</tt> (int <var>x</var>, int <var>y</var>);
     <dd><dt>int <tt>fmove</tt> (double <var>x</var>, double <var>y</var>);
     <dd><dt>int <tt>moverel</tt> (int <var>x</var>, int <var>y</var>);
     <dd><dt>int <tt>fmoverel</tt> (double <var>x</var>, double <var>y</var>);
     <dd><tt>move</tt> and <tt>fmove</tt> take two arguments specifying the coordinates
(<var>x</var>, <var>y</var>) of a point to which the graphics cursor should be
moved.  The path under construction (if&nbsp;any) is ended and drawn, as
if <tt>endpath</tt> had been called, and the graphics cursor is moved to
(<var>x</var>, <var>y</var>).  This is equivalent to lifting the pen on a plotter
and moving it to a new position, without drawing any line.  <tt>moverel</tt>
and <tt>fmoverel</tt> are similar to <tt>move</tt> and <tt>fmove</tt>, but use
cursor-relative coordinates.

     <p>When a new page of graphics is begun by invoking <tt>openpl</tt>, the cursor
is initially at the point (0,0) in user space.  Most of the drawing
functions reposition the cursor.  See <a href="#Drawing%20Functions">Drawing Functions</a>.

     <br><dt>int <tt>orientation</tt> (int <var>direction</var>);
     <dd><tt>orientation</tt> sets the orientation for all circles, ellipses, and
boxes subsequently drawn on the graphics display.  <var>direction</var> must
be&nbsp;1, meaning counterclockwise, or&nbsp;-1, meaning clockwise. 
The default is&nbsp;1.

     <p><tt>orientation</tt> will have a visible effect on a circle, ellipse, or box
only if it is dashed, or if it is one of the simple paths in a filled
compound path.  Its effects on filling, when the "nonzero-winding" fill
rule is used, are dramatic, since it is the orientation of each simple
path in a compound path that determines which points are `inside' and
which are `outside'.

     <br><dt>int <tt>pencolor</tt> (int <var>red</var>, int <var>green</var>, int <var>blue</var>);
     <dd><tt>pencolor</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the pen color for all
objects subsequently drawn on the graphics display, using a 48-bit RGB
color model.  The arguments <var>red</var>, <var>green</var> and <var>blue</var>
specify the red, green and blue intensities of the pen color.  Each is
an integer in the range <tt>0x0000</tt><small class="dots">...</small><tt>0xffff</tt>, i.e.,
0<small class="dots">...</small>65535.  The choice (0,&nbsp;0,&nbsp;0) signifies black, and the choice
(65535, 65535, 65535) signifies white.

     <p>HP-GL Plotters support drawing with a white pen only if the value of the
parameter <code>HPGL_VERSION</code> is&nbsp;"2" (the default), and the value of
the parameter <code>HPGL_OPAQUE_MODE</code> is "yes" (the default). 
See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>pencolorname</tt> (const char *<var>name</var>);
     <dd><tt>pencolorname</tt> sets the pen color of all objects subsequently drawn on
the graphics display to be <var>name</var>.  Unrecognized colors are
interpreted as "black".  For information on what color names are
recognized, see <a href="#Color%20Names">Color Names</a>.  A&nbsp;24-bit RGB color may also be
specified as a six-digit hexadecimal string, e.g., "#c0c0c0".

     <p>HP-GL Plotters support drawing with a white pen only if the value of the
parameter <code>HPGL_VERSION</code> is&nbsp;"2" (the default) and the value of
the parameter <code>HPGL_OPAQUE_MODE</code> is "yes" (the default). 
See <a href="#Plotter%20Parameters">Plotter Parameters</a>.

     <br><dt>int <tt>pentype</tt> (int <var>level</var>);
     <dd><tt>pentype</tt> terminates and draws the path under construction (if&nbsp;any), as if <tt>endpath</tt> had been called, and sets the pen level for all
subsequently drawn paths.  A&nbsp;value of&nbsp;1 for <var>level</var>
specifies that an outline of each of these objects should be drawn, in
the color previously specified by calling <tt>pencolor</tt> or
<tt>pencolorname</tt>.  This is the default.  A&nbsp;value of&nbsp;0 specifies
that outlines should not be drawn.

     <p>To draw the region bounded by a path in an edgeless way, you would call
<tt>pentype</tt> to turn&nbsp;off the drawing of the boundary, and
<tt>filltype</tt> to turn&nbsp;on the filling of the interior.

     <p><tt>pentype</tt> also affects the drawing of marker symbols and points, i.e.,
pixels.  A&nbsp;value of&nbsp;0 specifies that they should not be drawn.

     <p><strong>Note</strong>: In future releases, <tt>pentype</tt> may also affect the
drawing of text strings (a&nbsp;value of&nbsp;0 will specify that they
should not be drawn).  It&nbsp;already affects text strings that are
rendered using Hershey fonts, since they are drawn using polygonal
paths.

     <br><dt>int <tt>restorestate</tt> ();
     <dd><tt>restorestate</tt> pops the current graphics context off the stack of
drawing states.  The graphics context consists largely of
<code>libplot</code>'s drawing attributes, which are set by the attribute
functions documented in this section.  So popping&nbsp;off the graphics
context restores the drawing attributes to values they previously had. 
A&nbsp;path under construction is regarded as part of the graphics
context.  For this reason, calling <tt>restorestate</tt> automatically calls
<tt>endpath</tt> to terminate and draw the path under construction, if&nbsp;any.  All graphics contexts on the stack are popped&nbsp;off when
<code>closepl</code> is called, as&nbsp;if <code>restorestate</code> had been called
repeatedly.

     <br><dt>int <tt>savestate</tt> ();
     <dd><tt>savestate</tt> pushes the current graphics context onto the stack of
drawing states.  The graphics context consists largely of
<code>libplot</code>'s drawing attributes, which are set by the attribute
functions documented in this section.  A&nbsp;path under construction,
if&nbsp;any, is regarded as part of the graphics context.  That is
because paths may be drawn incrementally, one line segment or arc at a
time.  The new graphics context created by <tt>savestate</tt> will contain no
path.  When the previous graphics context is returned&nbsp;to by calling
<tt>restorestate</tt>, the path previously under construction may be
continued.

     <br><dt>int <tt>textangle</tt> (int <var>angle</var>);
     <dd><dt>double <tt>ftextangle</tt> (double <var>angle</var>);
     <dd><tt>textangle</tt> and <tt>ftextangle</tt> take one argument, which specifies the
angle in degrees counterclockwise from the x (horizontal) axis in
the user coordinate system, for text strings subsequently drawn on the
graphics display.  The default angle is zero.  (The font for plotting
strings is fully specified by calling <tt>fontname</tt>, <tt>fontsize</tt>, and
<tt>textangle</tt>.)  The size of the font for plotting strings, in user
coordinates, is returned. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Mapping%20Functions">Mapping Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Attribute%20Functions">Attribute Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>
<br>
</div>

<h3 class="subsection">9.4.4 Mapping functions</h4>

<p>The following are the "mapping functions" in <code>libplot</code>.  When
invoked on a Plotter, they affect the affine transformation it employs
to map the user coordinate system to the device coordinate system. 
That&nbsp;is, they affect the transformation matrix attribute of objects
subsequently drawn on the graphics display.

   <p>The names of these functions resemble those of the corresponding
functions in the Postscript language.  For information on how to use
them to draw graphics efficiently, consult any good book on Postscript
programming, or the <cite>Postscript Language Reference Manual</cite>.

   <p>Each of these functions, if called, terminates and draws the path under
construction (if&nbsp;any), as if <tt>endpath</tt> had been called.

   <p>In the current C&nbsp;binding, each of these functions takes a pointer to
a <code>plPlotter</code> as its first argument.  Also in the current C&nbsp;binding, the name of each function begins with "pl_" and ends with&nbsp;"_r".  ("_r"&nbsp;stands for `revised' or `reentrant'.)  For information
on older C&nbsp;bindings, see <a href="#Older%20C%20APIs">Older C APIs</a>.  In&nbsp;the C++
binding, these are member functions of the <code>Plotter</code> class and its
subclasses, and the prefix and suffix are not used.

     <dl>
<dt>int <tt>fsetmatrix</tt> (double <var>m0</var>, double <var>m1</var>, double <var>m2</var>, double <var>m3</var>, double <var>tx</var>, double <var>ty</var>);
     <dd>Use the Postscript-style transformation matrix [<var>m0</var> <var>m1</var>
<var>m2</var> <var>m3</var> <var>tx</var> <var>ty</var>] as the transformation matrix from
user space to NDC (normalized device coordinate) space.  This matrix
determines the transformation matrix from user space to unnormalized
device space, i.e., sets the transformation matrix attribute that will
be used when subsequently drawing objects on the graphics display.

     <p>In NDC space, the graphics display (i.e., viewport) has corners
<code>(0,0)</code>, <code>(1,0)</code>, <code>(1,1)</code>, and <code>(0,1)</code>.  For
information on the size of the graphics display in physical units, see
<a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.

     <p>The default transformation matrix from user space to NDC space is
[1&nbsp;0&nbsp;0&nbsp;1&nbsp;0&nbsp;0], which means that by default, user coordinates are the
same as NDC coordinates.  This transformation matrix is also altered by
<tt>space</tt>, <tt>fspace</tt>, <tt>space2</tt>, and <tt>fspace2</tt>, and by the following
functions.

     <br><dt>int <tt>fconcat</tt> (double <var>m0</var>, double <var>m1</var>, double <var>m2</var>, double <var>m3</var>, double <var>tx</var>, double <var>ty</var>);
     <dd>Modify the transformation matrix from user space to NDC space by
pre-multiplying it by the matrix [<var>m0</var> <var>m1</var> <var>m2</var> <var>m3</var>
<var>tx</var> <var>ty</var>].  Equivalently, apply the linear transformation
defined by the two-by-two matrix [<var>m0</var> <var>m1</var> <var>m2</var> <var>m3</var>]
to the user coordinate system, and then translate by <var>tx</var> units in
the x&nbsp;direction and <var>ty</var>&nbsp;units in the y&nbsp;direction.

     <p><tt>fconcat</tt> is a wrapper around the more fundamental <tt>fsetmatrix</tt>
function.  The following three functions (<tt>frotate</tt>, <tt>fscale</tt>,
<tt>ftranslate</tt>) are convenience functions that are special cases of
<tt>fconcat</tt>.

     <br><dt>int <tt>frotate</tt> (double <var>theta</var>);
     <dd>Modify the transformation matrix from user space to NDC space by
pre-multiplying it by the matrix [cos(<var>theta</var>) sin(<var>theta</var>)
-sin(<var>theta</var>) cos(<var>theta</var>) 0 0].  Equivalently, rotate
the user coordinate system axes about their origin by <var>theta</var>
degrees counterclockwise, with respect to their former orientation.  The
position of the user coordinate origin and the size of the x
and&nbsp;y units remain unchanged.

     <br><dt>int <tt>fscale</tt> (double <var>sx</var>, double <var>sy</var>);
     <dd>Modify the transformation matrix from user space to NDC space by
pre-multiplying it by the matrix [<var>sx</var> 0 0 <var>sy</var> 0 0]. 
Equivalently, make the x and y units in the user
coordinate system be the size of <var>sx</var> and <var>sy</var> units in the
former user coordinate system.  The position of the user coordinate
origin and the orientation of the coordinate axes are unchanged.

     <br><dt>int <tt>ftranslate</tt> (double <var>tx</var>, double <var>ty</var>);
     <dd>Modify the transformation matrix from user space to NDC space by
pre-multiplying it by the matrix [0 0 0 0 <var>tx</var> <var>ty</var>]. 
Equivalently, move the origin of the user coordinate system by <var>tx</var>
units in the x&nbsp;direction and <var>ty</var>&nbsp;units in the
y&nbsp;direction, relative to the former user coordinate system. 
The size of the x and y&nbsp;units and the orientation of
the coordinate axes are unchanged. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Plotter%20Parameters">Plotter Parameters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Functions">Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#libplot">libplot</a>
<br>
</div>

<h3 class="section">9.5 Plotter parameters</h3>

<p>In designing the <code>libplot</code> library, every effort was made to make
the Plotter interface independent of the type of Plotter.  To&nbsp;the
extent that Plotters display individual (i.e., instance-specific)
behavior, that behavior is captured by a manageable number of
<em>Plotter parameters</em>.  Each parameter has a value that is allowed
to be a generic pointer (a&nbsp;<code>void&nbsp;*</code>).  For most parameters, the
value is a string (a&nbsp;<code>char&nbsp;*</code>).

   <p>The parameter values of any Plotter are constant over the lifetime of
the Plotter, and are specified when the Plotter is created.  In the C&nbsp;binding, a&nbsp;value for any parameter is specified by calling the
<code>pl_setplparam</code> function.  The <code>pl_setplparam</code> function acts
on a <code>plPlotterParams</code> object, which encapsulates Plotter
parameters.  When a Plotter is created by calling <code>pl_newpl_r</code>,
a&nbsp;pointer to a <code>plPlotterParams</code> object is passed as the final
argument.

   <p>If at Plotter creation time a parameter is <em>not</em> specified, its
default value will be used, unless the parameter is string-valued and
there is an environment variable of the same name, in which case the
value of that environment variable will be used.  This rule increases
run-time flexibility: an&nbsp;application programmer may allow
non-critical Plotter parameters to be specified by the user via
environment variables.

   <p>In the C++ binding, the <code>PlotterParams</code> class and
<code>PlotterParams::setplparam</code>, a&nbsp;member function, are the
analogues of the <code>plPlotterParams</code> datatype and the function
<code>pl_setplparam</code>.

   <p>The following are the currently recognized parameters (unrecognized ones
are ignored).  The most important ones are <code>DISPLAY</code>, which affects
X&nbsp;Plotters, <code>BITMAPSIZE</code>, which affects X&nbsp;Plotters, PNG
Plotters, PNM Plotters, and GIF Plotters, <code>PAGESIZE</code>, which affects
Illustrator, Postscript, CGM, Fig, and HP-GL Plotters, and
<code>ROTATION</code>, which affects all Plotters except Metafile Plotters. 
These four parameters are listed first and the others alphabetically. 
Most of the remaining parameters, such as the several whose names begin
with "HPGL", affect only a single type of Plotter.

     <dl>
<dt><code></code><tt>DISPLAY</tt><code></code>
     <dd>(Default NULL.)  The X&nbsp;Window System display on which the graphics
display will be popped&nbsp;up, as an X&nbsp;window.  This is relevant
only to X&nbsp;Plotters.

     <br><dt><code>BITMAPSIZE</code>
     <dd>(Default "570x570".)  The size of the graphics display (i.e., the
viewport) in terms of pixels.  This is relevant only to X&nbsp;Plotters,
PNG Plotters, PNM Plotters, and GIF Plotters.  For X&nbsp;Plotters, the
value of this parameter will automatically, if it is not set, be taken
from the X&nbsp;resource <code>Xplot.geometry</code>.  That is for backward
compatibility.

     <p>X Plotters support precise positioning of the graphics display.  For
example, if <code>BITMAPSIZE</code> is "570x570+0+0" then it will be
positioned in the upper left corner of the X&nbsp;Window System display.

     <br><dt><code>PAGESIZE</code>
     <dd>(Default "letter".)  The page type, which determines the size of the
graphics display (i.e., the viewport) used by the Plotter.  This is
relevant only to SVG, Illustrator, Postscript, CGM, Fig, PCL, and HP-GL
Plotters.  "letter" means an 8.5in by 11in page.  Any ISO
page size in the range "a0"<small class="dots">...</small>"a4" or ANSI page size in the range
"a"<small class="dots">...</small>"e" may be specified ("letter" is an alias for&nbsp;"a" and
"tabloid" is an alias for&nbsp;"b").  "legal", "ledger", and&nbsp;"b5" are
recognized page sizes also.

     <p>For Illustrator, Postscript, PCL and Fig Plotters, the graphics display
will be, by default, a square region centered on the specified page. 
(For example, it will be a centered 8in square if <code>PAGESIZE</code>
is "letter".)  For HP-GL Plotters, it will be a square region of the
same size, but will not by&nbsp;default be centered.  SVG format and
WebCGM format have no notion of the Web page on which the graphics
display will ultimately be positioned.  They do have a notion of default
display size, though this will normally be overridden when the SVG or
WebCGM file is placed on a Web page.  For the default display size, SVG
and CGM Plotters will use the graphics display size that is used by
other Plotters.

     <p>For the default size and location of the graphics display for each page
type, see <a href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>.  You do not need to use the
default graphics display, since either or both of its dimensions can be
specified explicitly.  For example, <code>PAGESIZE</code> could be specified
as "letter,xsize=4in", or "a4,xsize=10cm,ysize=15cm".  The dimensions
are allowed to be negative (a&nbsp;negative dimension results in a
reflection).

     <p>For Plotters other than SVG and CGM Plotters, the position of the
graphics display on the page, relative to its default position, can be
adjusted by specifying an offset vector.  For example, <code>PAGESIZE</code>
could be specified as "letter,yoffset=1.2in", or
"a4,xoffset=-5mm,yoffset=2.0cm".  Inches, centimeters, and
millimeters are the supported units.

     <p>It&nbsp;is also possible to position the graphics display precisely, by
specifying the location of its lower left corner relative to the lower
left corner of the page.  For example, <code>PAGESIZE</code> could be
specified as "letter,xorigin=2in,yorigin=3in", or
"a4,xorigin=0.5cm,yorigin=0.5cm".  The preceding options may be
intermingled.  SVG and WebCGM Plotters ignore the "xoffset", "yoffset",
"xorigin", and "yorigin" options, since SVG format and WebCGM format
have no notion of the Web page on which the graphics display will
ultimately be positioned.

     <br><dt><code>ROTATION</code>
     <dd>(Default "0".)  Relevant to all Plotters other than Metafile Plotters,
which have no output device.  The angle, in degrees, by which the
graphics display (i.e., the viewport) should be rotated, relative to its
default orientation.  Recognized values are "0", "90", "180", and "270";
"no"&nbsp;and "yes" are equivalent to "0"&nbsp;and&nbsp;"90" respectively.  The
rotation is counterclockwise.

     <p>A rotated viewport does not change the position of its four corners. 
Rather, the graphics are rotated within&nbsp;it.  If&nbsp;the viewport is
rectangular rather than square, this `rotation' necessarily includes a
rescaling.

     <p>This parameter is useful for switching between portrait and landscape
orientations.  Internally, it determines the affine transformation from
NDC (normalized device coordinate) space to device space.

     <br><dt><code>BG_COLOR</code>
     <dd>(Default "white".)  The initial background color of the graphics
display, when drawing each page of graphics.  This is relevant to X&nbsp;Plotters, PNG Plotters, PNM Plotters, GIF Plotters, CGM Plotters, ReGIS
Plotters, and Metafile Plotters; also to X&nbsp;Drawable&nbsp;Plotters (for
the last, the background color shows&nbsp;up only if <code>erase</code> is
invoked).  For information on what color names are recognized, see
<a href="#Color%20Names">Color Names</a>.  The background color may be changed at any later
time by invoking the <tt>bgcolor</tt> (or <tt>bgcolorname</tt>) and <tt>erase</tt>
operations.

     <p>SVG Plotters and CGM Plotters support "none" as a value for the
background color.  It will turn&nbsp;off the background: the drawn
objects will not be backed by anything.  This is useful when the
generated SVG or WebCGM file is to be placed on a Web page.

     <br><dt><code>CGM_ENCODING</code>
     <dd>(Default "binary".)  Relevant only to CGM Plotters.  "binary" means that
the CGM output should use the binary encoding.  "clear_text" means that
the CGM output should use a human-readable encoding.  The WebCGM profile
requires that the binary encoding be used, but many CGM viewers and
interpreters can also parse the clear text encoding.  The third standard
CGM encoding, "character", is not currently supported.

     <br><dt><code>CGM_MAX_VERSION</code>
     <dd>(Default "4".)  Relevant only to CGM Plotters.  An upper bound on the
version number of CGM format that is produced.  Many older CGM
interpreters and viewers, such as the ones built into Microsoft Office
and other commercial software, only support version&nbsp;1 CGM files. 
For fully adequate handling of fonts and line styles, version&nbsp;3 is
necessary.  By default, the present release of <code>libplot</code> produces
version&nbsp;3 CGM files, i.e., it does not use version&nbsp;4 features.

     <br><dt><code>EMULATE_COLOR</code>
     <dd>(Default "no".)  Relevant to all Plotters.  "yes" means that each color
in the output should be replaced by an appropriate shade of gray.  The
well known formula for CIE luminance, namely 0.212671R + 0.715160G
+ 0.072169B, is used.

     <p>This parameter is seldom useful, except when using a PCL Plotter to
prepare output for a monochrome PCL&nbsp;5 device.  Many monochrome
PCL&nbsp;5 devices, such as monochrome LaserJets, do a poor job of
emulating color on their own.  They usually map HP-GL/2's seven standard
pen colors, including even yellow, to black.

     <br><dt><code>GIF_ANIMATION</code>
     <dd>(Default "yes".)  Relevant only to GIF Plotters.  "yes" means that the
<code>erase</code> operation will have special semantics: with the exception
of its first invocation, it will act as a separator between successive
images in the written-out pseudo-GIF file.  "no"&nbsp;means that
<code>erase</code> should act as it does on other Plotters that do not write
graphics in real time, i.e., it&nbsp;should erase the image under
construction by filling it with the background color.  If&nbsp;"no" is
specified, the pseudo-GIF file will contain only a single image.

     <br><dt><code>GIF_DELAY</code>
     <dd>(Default "0".)  Relevant only to GIF Plotters.  The delay, in hundredths
of a second, after each image in a written-out animated pseudo-GIF file. 
The value should be an integer in the range "0"<small class="dots">...</small>"65535".

     <br><dt><code>GIF_ITERATIONS</code>
     <dd>(Default "0".)  Relevant only to GIF Plotters.  The number of times that
an animated pseudo-GIF file should be `looped'.  The value should be an
integer in the range "0"<small class="dots">...</small>"65535".

     <br><dt><code>HPGL_ASSIGN_COLORS</code>
     <dd>(Default "no".)  Relevant only to HP-GL Plotters, and only if the value
of <code>HPGL_VERSION</code> is&nbsp;"2".  "no"&nbsp;means to draw with a fixed
set of pens, specified by setting the <code>HPGL_PENS</code> parameter.  "yes"
means that pen colors will not restricted to the palette specified in
<code>HPGL_PENS</code>: colors will be assigned to "logical pens" in the
range #1<small class="dots">...</small>#31, as&nbsp;needed.  Other than color LaserJet printers
and DesignJet plotters, not many HP-GL/2 devices allow the assignment of
colors to logical pens.  In particular, HP-GL/2 pen plotters do not. 
So&nbsp;this parameter should be used with caution.

     <br><dt><code>HPGL_OPAQUE_MODE</code>
     <dd>(Default "yes".)  Relevant only to HP-GL Plotters, and only if the value
of <code>HPGL_VERSION</code> is&nbsp;"2".  "yes" means that the HP-GL/2 output
device should be switched into opaque mode, rather than transparent
mode.  This allows objects to be filled with opaque white and other
opaque colors.  It&nbsp;also allows the drawing of visible white lines,
which by convention are drawn with pen&nbsp;#0.  Not all HP-GL/2 devices
support opaque mode or the use of pen&nbsp;#0 to draw visible white
lines.  In particular, HP-GL/2 pen plotters do&nbsp;not.  Some older
HP-GL/2 devices reportedly malfunction if asked to switch into opaque
mode.  If&nbsp;the output of an HP-GL Plotter is to be sent to such a
device, a&nbsp;"no" value is recommended.

     <br><dt><code>HPGL_PENS</code>
     <dd>(Default "1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan" if the
value of <code>HPGL_VERSION</code> is "1.5" or&nbsp;"2" and "1=black" if the
value of <code>HPGL_VERSION</code> is&nbsp;"1".  Relevant only to HP-GL
Plotters.  The set of available pens; the format should be
self-explanatory.  The color for any pen in the range #1<small class="dots">...</small>#31 may
be specified.  For information on what color names are recognized, see
<a href="#Color%20Names">Color Names</a>.  Pen&nbsp;#1 must always be present, though it need
not be black.  Any other pen in the range #1<small class="dots">...</small>#31 may be omitted.

     <br><dt><code>HPGL_ROTATE</code>
     <dd>(Default "0".)  Relevant only to HP-GL Plotters.  The angle, in degrees,
by which the graphics display (i.e., the viewport) should be rotated on
the page relative to the default orientation.  Recognized values are
"0", "90", "180", and "270"; "no"&nbsp;and "yes" are equivalent to "0"&nbsp;and&nbsp;"90" respectively.  "180" and "270" are supported only if
<code>HPGL_VERSION</code> is&nbsp;"2".

     <p>The rotation requested by <code>HPGL_ROTATE</code> is different from the sort
requested by the <code>ROTATION</code> parameter.  <code>ROTATION</code> rotates the
graphics display in&nbsp;place, but <code>HPGL_ROTATE</code> both rotates the
graphics display and moves its lower left corner toward another corner
of the page.  Altering the plotting area in such a way is supported by
the HP-GL language.

     <p>The <code>HPGL_ROTATE</code> parameter facilitates switching between portrait
and landscape orientations.  For HP-GL devices that is frequently a
concern, since some HP-GL devices ("plotters") draw with a default
landscape orientation, while others ("printers") draw with a default
portrait orientation.  There is no programmatic way of determining which
is which.

     <br><dt><code>HPGL_VERSION</code>
     <dd>(Default "2".)  Relevant only to HP-GL Plotters.  "1"&nbsp;means that the
output should be generic HP-GL, "1.5"&nbsp;means that the output should
be suitable for the HP7550A graphics plotter and the HP758x, HP7595A and
HP7596A drafting plotters (HP-GL with some HP-GL/2 extensions), and
"2"&nbsp;means that the output should be modern HP-GL/2.  If&nbsp;the
version is less than "2" then the only available fonts will be vector
fonts, and all paths will be drawn with a default thickness, so that
invoking <tt>linewidth</tt>, <tt>capmod</tt>, <tt>joinmod</tt>, and <tt>fmiterlimit</tt>
will have no effect.  Also, the `nonzero winding number rule' will not
be supported when filling paths, so invoking <tt>fillmod</tt> will have no
effect.  Additionally, if the version is&nbsp;"1" then the filling of
arbitrary paths will not be supported (circles and rectangles aligned
with the coordinate axes may be filled, however).

     <br><dt><code>INTERLACE</code>
     <dd>(Default "no".)  Relevant only to PNG and GIF Plotters.  If the value is
"yes", the output file will be interlaced.  That means it will be
displayed in an interlaced (nonlinear) way by many applications.

     <br><dt><code>MAX_LINE_LENGTH</code>
     <dd>(Default "500".)  The maximum number of defining points that a path may
have, before it is flushed to the output device.  If this flushing
occurs, the path will be split into two or more sub-paths, though the
splitting should not be noticeable.  Splitting will not be performed if
the path is to be filled.

     <p>This parameter is relevant to all Plotters except Tektronix and Metafile
Plotters.  The reason for splitting long paths is that some display
devices (e.g., old Postscript printers and HP-GL pen plotters) have
limited buffer sizes.  It&nbsp;is not relevant to Tektronix or Metafile
Plotters, since they draw paths in real time and have no buffer
limitations.

     <br><dt><code>META_PORTABLE</code>
     <dd>(Default "no".)  Relevant only to Metafile Plotters.  "yes" means that
the output metafile should use a portable (human-readable) encoding of
graphics, rather than the default (binary) encoding.  See <a href="#Metafiles">Metafiles</a>.

     <br><dt><code>PCL_ASSIGN_COLORS</code>
     <dd>(Default "no".)  Relevant only to PCL Plotters.  "no"&nbsp;means to draw
with a fixed set of pens.  "yes" means that pen colors will not
restricted to this palette: colors will be assigned to "logical pens",
as&nbsp;needed.  Other than color LaserJet printers, not many PCL&nbsp;5
devices allow the assignment of colors to logical pens.  So&nbsp;this
parameter should be used with caution.

     <br><dt><code>PCL_BEZIERS</code>
     <dd>(Default "yes".)  Relevant only to PCL Plotters.  "yes"&nbsp;means that
when drawing Bezier curves, the special `Bezier instructions' will be
used.  "no"&nbsp;means that these instructions will not be used. 
Instead, each Bezier curve will be approximated and drawn as a polygonal
line.  Other than the LaserJet III, which was Hewlett-Packard's first
PCL&nbsp;5 printer, all Hewlett-Packard's PCL&nbsp;5 printers support the
Bezier instructions.

     <br><dt><code>PNM_PORTABLE</code>
     <dd>(Default "no".)  Relevant only to PNM Plotters.  "yes" means that the
output should be in a portable (human-readable) version of PBM/PGM/PPM
format, rather than the default (binary) version.  `Portable' is
something of a misnomer, since binary PBM/PGM/PPM files are also
portable, in the sense that they are machine-independent.

     <br><dt><code>TERM</code>
     <dd>(Default NULL.)  Relevant only to Tektronix Plotters.  If the value is
a string beginning with "xterm", "nxterm", or "kterm", it&nbsp;is taken
as a sign that the current application is running in an X&nbsp;Window
System VT100 terminal emulator: an&nbsp;<code>xterm</code>, <code>nxterm</code>, or
<code>kterm</code>.  Before drawing graphics, a Tektronix Plotter will emit an
escape sequence that causes the terminal emulator's auxiliary Tektronix
window, which is normally hidden, to pop&nbsp;up.  After the graphics are
drawn, an escape sequence that returns control to the original VT100
window will be emitted.  The Tektronix window will remain on the screen.

     <p>If the value is a string beginning with "kermit", "ansi.sys", or
"nansi.sys", it&nbsp;is taken as a sign that the current application is
running in the VT100 terminal emulator provided by the MS-DOS version of
<code>kermit</code>.  Before drawing graphics, a Tektronix Plotter will emit
an escape sequence that switches the terminal emulator to Tektronix
mode.  Also, some of the Tektronix control codes emitted by the Plotter
will be <code>kermit</code>-specific.  There will be a limited amount of color
support, which is not normally the case (the 16 <code>ansi.sys</code> colors
will be supported).  The "dotdotdashed" line style will be supported,
which is also not normally the case.  After drawing graphics, the
Plotter will emit an escape sequence that returns the emulator to VT100
mode.  The key sequence `ALT&nbsp;minus' may be employed manually within
<code>kermit</code> to switch between the two modes.

     <br><dt><code>TRANSPARENT_COLOR</code>
     <dd>(Default "none".)  Relevant only to PNG and GIF Plotters.  If the value
is a recognized color name, that color, if it appears in the output
file, will be treated as transparent by most applications.  For
information on what names are recognized, see <a href="#Color%20Names">Color Names</a>.

     <p>If <code>TRANSPARENT_COLOR</code> is set and an animated pseudo-GIF file is
produced, the `restore to background' disposal method will be used for
each image in the file.  Otherwise, the `unspecified' disposal method
will be used.

     <br><dt><code>USE_DOUBLE_BUFFERING</code>
     <dd>(Default "no".)  Relevant only to X Plotters and X Drawable Plotters. 
If&nbsp;the value is "yes", a double buffering scheme will be used when
drawing graphics.  Each frame of graphics, within a
<tt>openpl</tt><small class="dots">...</small><tt>closepl</tt> pair, will be written to an off-screen
buffer rather than to the Plotter's display.  When <tt>erase</tt> is invoked
to end a frame, or when <tt>closepl</tt> is invoked, the contents of the
off-screen buffer will be copied to the Plotter's display, pixel by
pixel.  If successive frames differ only slightly, this will create the
illusion of smooth animation.

     <p>Some X displays provide special hardware support for double buffering. 
If&nbsp;this support is available, the X&nbsp;Plotter will detect its
presence, and will draw graphics using the appropriate extension to the
X11 protocol (either DBE or MBX).  In this case the animation will be
significantly faster; on high-end graphics hardware, at&nbsp;least.

     <br><dt><code>VANISH_ON_DELETE</code>
     <dd>(Default "no".)  Relevant only to X Plotters.  If the value is "yes",
when a Plotter is deleted, the window or windows that it has popped&nbsp;up will vanish.  Otherwise, each such window will remain on the screen
until it is removed by the user (by typing <code>q</code> in&nbsp;it, or by
clicking with a mouse).

     <br><dt><code>XDRAWABLE_COLORMAP</code>
     <dd>(Default NULL.)  Relevant only to X&nbsp;Drawable&nbsp;Plotters.  If the
value is non-NULL, it should be a <code>Colormap *</code>, a&nbsp;pointer to a
colormap from which colors should be allocated.  NULL indicates that the
colormap to be used should be the default colormap of the default screen
of the X&nbsp;display.

     <br><dt><code>XDRAWABLE_DISPLAY</code>
     <dd>(Default NULL.)  Relevant only to X Drawable Plotters.  The value
should be a <code>Display *</code>, a&nbsp;pointer to the X&nbsp;display with
which the drawable(s) to be drawn&nbsp;in are associated.

     <br><dt><code>XDRAWABLE_DRAWABLE1</code>
     <dd><dt><code>XDRAWABLE_DRAWABLE2</code>
     <dd>(Default NULL.)  Relevant only to X Drawable Plotters.  If set, the
value of each of these parameters should be a <code>Drawable *</code>, a
pointer to a drawable to be drawn&nbsp;in.  A&nbsp;`drawable' is either a
window or a pixmap.  At the time an X&nbsp;Drawable Plotter is created,
at&nbsp;least one of the two parameters must be set.

     <p>X&nbsp;Drawable Plotters support simultaneous drawing in two drawables
because it is often useful to be able to draw graphics simultaneously in
both an X&nbsp;window and its background pixmap.  If two drawables are
specified, they must have the same dimensions and depth, and be
associated with the same screen of the X&nbsp;display.

     <br><dt><code>XDRAWABLE_VISUAL</code>
     <dd>(Default NULL.)  Relevant only to X&nbsp;Drawable&nbsp;Plotters.  If set, the
value should be a <code>Visual *</code>, a&nbsp;pointer to the `visual' with
which the colormap (see above) is associated.  Setting this parameter is
not required, but it is recommended that it be set if
<code>XDRAWABLE_COLORMAP</code> is set.  Under some circumstances, that will
speed&nbsp;up color cell allocation.

     <br><dt><code>X_AUTO_FLUSH</code>
     <dd>(Default "yes".)  Relevant only to X Plotters.  If the value is "yes",
an <code>XFlush</code> operation is performed after each drawing operation. 
That ensures that graphics are flushed to the X&nbsp;Window System
display, and are visible to the user, immediately after they are drawn. 
However, it slows down rendering considerably.  If&nbsp;the value is
"no", drawing is faster, since it does not take place in real time. 
</dl>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Appendices">Appendices</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#libplot">libplot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>
<br>
</div>

   <p>The following appendices contain supplementary information on the GNU
plotting utilities and the GNU <code>libplot</code> library.

<ul class="menu">
<li><a accesskey="1" href="#Text%20and%20Markers">Text and Markers</a>:          Text fonts, text strings, and marker symbols
<li><a accesskey="2" href="#Color%20Names">Color Names</a>:               Specifying colors by name
<li><a accesskey="3" href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>:   Specifying the size of an output page
<li><a accesskey="4" href="#Metafiles">Metafiles</a>:                 The device-independent GNU metafile format
<li><a accesskey="5" href="#Auxiliary%20Software">Auxiliary Software</a>:        How to obtain auxiliary software
<li><a accesskey="6" href="#History%20and%20Acknowledgements">History and Acknowledgements</a>:     The contributors
<li><a accesskey="7" href="#Reporting%20Bugs">Reporting Bugs</a>:            How to report bugs
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Text%20and%20Markers">Text and Markers</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Color%20Names">Color Names</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Appendices">Appendices</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Appendices">Appendices</a>
<br>
</div>

<h2 class="appendix">Appendix A Fonts, Strings, and Symbols</h2>

<p>The GNU <code>libplot</code> graphics library and applications built on&nbsp;it, such as <code>graph</code>, <code>plot</code>, <code>pic2plot</code>,
<code>tek2plot</code>, and <code>plotfont</code>, can draw text strings in a wide
variety of fonts.  Text strings may include characters from more than
one font in a typeface, and may include superscripts, subscripts, and
square roots.  A&nbsp;wide variety of marker symbols can also be drawn. 
The following sections explain how to use these features.

<ul class="menu">
<li><a accesskey="1" href="#Text%20Fonts">Text Fonts</a>:           Available text fonts
<li><a accesskey="2" href="#Cyrillic%20and%20Japanese">Cyrillic and Japanese</a>:   The Cyrillic and Japanese fonts
<li><a accesskey="3" href="#Text%20Fonts%20in%20X">Text Fonts in X</a>:      Available text fonts in the X Window System
<li><a accesskey="4" href="#Text%20String%20Format">Text String Format</a>:   Text string formatting (with escape sequences)
<li><a accesskey="5" href="#Marker%20Symbols">Marker Symbols</a>:       Available marker symbols
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="Text%20Fonts">Text Fonts</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Cyrillic%20and%20Japanese">Cyrillic and Japanese</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Text%20and%20Markers">Text and Markers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Text%20and%20Markers">Text and Markers</a>
<br>
</div>

<h3 class="appendixsec">A.1 Available text fonts</h3>

<p>The GNU <code>libplot</code> library and applications built on&nbsp;it, such as
<code>graph</code>, <code>plot</code>, <code>pic2plot</code>, <code>tek2plot</code>, and
<code>plotfont</code>, can use many fonts.  These include 22 Hershey vector
fonts, 35 Postscript fonts, 45 PCL&nbsp;5 fonts, and 18 Hewlett-Packard
vector fonts.  We&nbsp;call these 120 supported fonts the `built-in'
fonts.  The Hershey fonts are constructed from stroked characters
digitized c.&nbsp;1967 by Dr. Allen&nbsp;V. Hershey at the U.S. Naval
Surface Weapons Center in Dahlgren,&nbsp;VA.  The 35 Postscript fonts
are the outline fonts resident in all modern Postscript printers, and
the 45 PCL&nbsp;5 fonts are the outline fonts resident in modern
Hewlett-Packard LaserJet printers and plotters.  (Of the PCL&nbsp;5
fonts, the old LaserJet III, which was Hewlett-Packard's first PCL&nbsp;5 printer, supported only eight: the Univers and CGTimes fonts.)  The
18 Hewlett-Packard vector fonts are fonts that are resident in
Hewlett-Packard printers and plotters (mostly the latter).

   <p>The Hershey fonts can be used by all types of Plotter supported by
<code>libplot</code>, and the Postscript fonts can be used by X, SVG,
Illustrator, Postscript, and Fig Plotters.  So, for example, all
variants of <code>graph</code> can use the Hershey fonts, and <code>graph
-T&nbsp;X</code>, <code>graph -T svg</code>, <code>graph -T ai</code>, <code>graph -T ps</code>,
<code>graph -T cgm</code> and <code>graph -T fig</code> can use the Postscript
fonts.  The PCL&nbsp;5 fonts can be used by by SVG, Illustrator, PCL, and
HP-GL Plotters, and by <code>graph -T svg</code>, <code>graph -T ai</code>,
<code>graph -T pcl</code>, and <code>graph -T hpgl</code>.  The Hewlett-Packard
vector fonts can be used by PCL and HP-GL Plotters, and by <code>graph
-T pcl</code> and <code>graph -T hpgl</code>.  X&nbsp;Plotters and <code>graph -T&nbsp;X</code> are not restricted to the built-in Hershey and Postscript fonts. 
They can use any X&nbsp;Window System font.

   <p>The <code>plotfont</code> utility, which accepts the <code>-T</code> option, will
print a character map of any font that is available in the specified
output format.  See <a href="#plotfont">plotfont</a>.

   <p>For the purpose of plotting text strings (see <a href="#Text%20String%20Format">Text String Format</a>),
the 120 built-in fonts are divided into typefaces.  As you can see from
the following tables, our convention is that in any typeface with more
than a single font, font #1 is the normal font, font #2 is italic or
oblique, font #3 is bold, and font #4 is bold italic or bold oblique. 
Additional variants (if&nbsp;any) are numbered #5 and higher.

   <p>The 22 Hershey fonts are divided into typefaces as follows.

     <ul>
<li>HersheySerif

          <ol type=1 start=1>
<li>HersheySerif
<li>HersheySerif-Italic
<li>HersheySerif-Bold
<li>HersheySerif-BoldItalic
<li>HersheyCyrillic
<li>HersheyCyrillic-Oblique
<li>HersheyEUC
          </ol>

     <li>HersheySans

          <ol type=1 start=1>
<li>HersheySans
<li>HersheySans-Oblique
<li>HersheySans-Bold
<li>HersheySans-BoldOblique
          </ol>

     <li>HersheyScript

          <ol type=1 start=1>
<li>HersheyScript
<li>HersheyScript
<li>HersheyScript-Bold
<li>HersheyScript-Bold
          </ol>

     <li>HersheyGothicEnglish
<li>HersheyGothicGerman
<li>HersheyGothicItalian

     <li>HersheySerifSymbol
          <ol type=1 start=1>
<li>HersheySerifSymbol
<li>HersheySerifSymbol-Oblique
<li>HersheySerifSymbol-Bold
<li>HersheySerifSymbol-BoldOblique
          </ol>

     <li>HersheySansSymbol
          <ol type=1 start=1>
<li>HersheySansSymbol
<li>HersheySansSymbol-Oblique
          </ol>
</ul>

<p>Nearly all Hershey fonts except the Symbol fonts use the ISO-Latin-1
encoding, which is a superset of ASCII.  The Symbol fonts consist of
Greek characters and mathematical symbols, and use the symbol font
encoding documented in the <cite>Postscript Language Reference Manual</cite>. 
By convention, each Hershey typeface contains a symbol font
(HersheySerifSymbol or HersheySansSymbol, as appropriate) as font&nbsp;#0.

   <p>HersheyCyrillic, HersheyCyrillic-Oblique, and HersheyEUC (which is a
Japanese font) are the only non-Symbol Hershey fonts that do not use the
ISO-Latin-1 encoding.  For their encodings, see <a href="#Cyrillic%20and%20Japanese">Cyrillic and Japanese</a>.

   <p>The 35 Postscript fonts are divided into typefaces as follows.

     <ul>
<li>Helvetica

          <ol type=1 start=1>
<li>Helvetica
<li>Helvetica-Oblique
<li>Helvetica-Bold
<li>Helvetica-BoldOblique
          </ol>

     <li>Helvetica-Narrow

          <ol type=1 start=1>
<li>Helvetica-Narrow
<li>Helvetica-Narrow-Oblique
<li>Helvetica-Narrow-Bold
<li>Helvetica-Narrow-BoldOblique
          </ol>

     <li>Times

          <ol type=1 start=1>
<li>Times-Roman
<li>Times-Italic
<li>Times-Bold
<li>Times-BoldItalic
          </ol>

     <li>AvantGarde

          <ol type=1 start=1>
<li>AvantGarde-Book
<li>AvantGarde-BookOblique
<li>AvantGarde-Demi
<li>AvantGarde-DemiOblique
          </ol>

     <li>Bookman

          <ol type=1 start=1>
<li>Bookman-Light
<li>Bookman-LightItalic
<li>Bookman-Demi
<li>Bookman-DemiItalic
          </ol>

     <li>Courier

          <ol type=1 start=1>
<li>Courier
<li>Courier-Oblique
<li>Courier-Bold
<li>Courier-BoldOblique
          </ol>

     <li>NewCenturySchlbk

          <ol type=1 start=1>
<li>NewCenturySchlbk-Roman
<li>NewCenturySchlbk-Italic
<li>NewCenturySchlbk-Bold
<li>NewCenturySchlbk-BoldItalic
          </ol>

     <li>Palatino

          <ol type=1 start=1>
<li>Palatino-Roman
<li>Palatino-Italic
<li>Palatino-Bold
<li>Palatino-BoldItalic
          </ol>

     <li>ZapfChancery-MediumItalic
<li>ZapfDingbats
<li>Symbol
</ul>

<p>All Postscript fonts except the ZapfDingbats and Symbol fonts use the
ISO-Latin-1 encoding.  The encodings used by the ZapfDingbats and Symbol
fonts are documented in the <cite>Postscript Language Reference Manual</cite>. 
By convention, each Postscript typeface contains the Symbol font as
font&nbsp;#0.

   <p>The 45 PCL&nbsp;5 fonts are divided into typefaces as follows.

     <ul>
<li>Univers

          <ol type=1 start=1>
<li>Univers
<li>Univers-Oblique
<li>Univers-Bold
<li>Univers-BoldOblique
          </ol>

     <li>UniversCondensed

          <ol type=1 start=1>
<li>UniversCondensed
<li>UniversCondensed-Oblique
<li>UniversCondensed-Bold
<li>UniversCondensed-BoldOblique
          </ol>

     <li>CGTimes

          <ol type=1 start=1>
<li>CGTimes-Roman
<li>CGTimes-Italic
<li>CGTimes-Bold
<li>CGTimes-BoldItalic
          </ol>

     <li>Albertus

          <ol type=1 start=1>
<li>AlbertusMedium
<li>AlbertusMedium
<li>AlbertusExtraBold
<li>AlbertusExtraBold
          </ol>

     <li>AntiqueOlive

          <ol type=1 start=1>
<li>AntiqueOlive
<li>AntiqueOlive-Italic
<li>AntiqueOlive-Bold
          </ol>

     <li>Arial

          <ol type=1 start=1>
<li>Arial-Roman
<li>Arial-Italic
<li>Arial-Bold
<li>Arial-BoldItalic
          </ol>

     <li>ClarendonCondensed
<li>Coronet
<li>Courier

          <ol type=1 start=1>
<li>Courier
<li>Courier-Italic
<li>Courier-Bold
<li>Courier-BoldItalic
          </ol>

     <li>Garamond

          <ol type=1 start=1>
<li>Garamond
<li>Garamond-Italic
<li>Garamond-Bold
<li>Garamond-BoldItalic
          </ol>

     <li>LetterGothic

          <ol type=1 start=1>
<li>LetterGothic-Roman
<li>LetterGothic-Italic
<li>LetterGothic-Bold
<li>LetterGothic-BoldItalic
          </ol>

     <li>Marigold
<li>CGOmega

          <ol type=1 start=1>
<li>CGOmega-Roman
<li>CGOmega-Italic
<li>CGOmega-Bold
<li>CGOmega-BoldItalic
          </ol>

     <li>TimesNewRoman

          <ol type=1 start=1>
<li>TimesNewRoman
<li>TimesNewRoman-Italic
<li>TimesNewRoman-Bold
<li>TimesNewRoman-BoldItalic
          </ol>

     <li>Wingdings
<li>Symbol
</ul>

<p>All PCL 5 fonts except the Wingdings and Symbol fonts use the
ISO-Latin-1 encoding.  The encoding used by the Symbol font is the
symbol font encoding documented in the <cite>Postscript Language
Reference Manual</cite>.  By convention, each PCL typeface contains the Symbol
font as font&nbsp;#0.

   <p>The 18 Hewlett-Packard vector fonts are divided into typefaces as
follows.

     <ul>
<li>Arc

          <ol type=1 start=1>
<li>Arc
<li>Arc-Oblique
<li>Arc-Bold
<li>Arc-BoldOblique
          </ol>

     <li>Stick

          <ol type=1 start=1>
<li>Stick
<li>Stick-Oblique
<li>Stick-Bold
<li>Stick-BoldOblique
          </ol>

     <li>ArcANK

          <ol type=1 start=1>
<li>ArcANK*
<li>ArcANK-Oblique*
<li>ArcANK-Bold*
<li>ArcANK-BoldOblique*
          </ol>

     <li>StickANK

          <ol type=1 start=1>
<li>StickANK*
<li>StickANK-Oblique*
<li>StickANK-Bold*
<li>StickANK-BoldOblique*
          </ol>

     <li>ArcSymbol*

     <li>StickSymbol*

   </ul>

<p>The Hewlett-Packard vector fonts with an asterisk (the ANK and Symbol
fonts) are only available when producing HP-GL/2 graphics, or HP-GL
graphics for the HP7550A graphics plotter and the HP758x, HP7595A and
HP7596A drafting plotters.  That is, they are available only if
<code>HPGL_VERSION</code> is&nbsp;"2" (the default) or&nbsp;"1.5".  The ANK
fonts are Japanese fonts (see <a href="#Cyrillic%20and%20Japanese">Cyrillic and Japanese</a>), and the Symbol
fonts contain a few miscellaneous mathematical symbols.

   <p>All Hewlett-Packard vector fonts except the ANK and Symbol fonts use
the ISO-Latin-1 encoding.  The Arc fonts are proportional
(variable-width) fonts, and the Stick fonts are fixed-width fonts.  If
HP-GL/2 or HP-GL output is selected, the Arc fonts are assumed to be
kerned via device-resident kerning tables.  But when producing PCL&nbsp;5
output, it is assumed that the display device will do no kerning. 
Apparently Hewlett-Packard dropped support for device-resident kerning
tables when emulating HP-GL/2 from within PCL&nbsp;5.  For information
about Hewlett-Packard vector fonts and the way in which they are kerned
(in&nbsp;HP-GL pen plotters, at&nbsp;least), see the article by
L.&nbsp;W.  Hennessee et&nbsp;al. in the Nov. 1981 issue of the
<cite>Hewlett-Packard Journal</cite>.

   <p>To what extent do the fonts supported by <code>libplot</code> contain
ligatures?  The Postscript fonts, the PCL&nbsp;5 fonts, and the
Hewlett-Packard vector fonts, at&nbsp;least as implemented in
<code>libplot</code>, do&nbsp;not contain ligatures.  However, six of the 22
Hershey fonts contain ligatures.  The character combinations "fi", "ff",
"fl", "ffi", and "ffl" are automatically drawn as ligatures in
HersheySerif and HersheySerif-Italic.  (Also in the two HersheyCyrillic
fonts and HersheyEUC, since insofar as printable ASCII characters are
concerned, they are identical [or almost identical] to HersheySerif.) 
In&nbsp;addition, "tz" and "ch" are ligatures in HersheyGothicGerman. 
The German double-s character&nbsp;`&szlig;', which is called an `eszet',
is not treated as a ligature in any font.  To&nbsp;obtain an eszet, you
must either request one with the escape sequence&nbsp;"\ss" (see <a href="#Text%20String%20Format">Text String Format</a>), or, if you have an 8-bit keyboard, type an eszet
explicitly.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Cyrillic%20and%20Japanese">Cyrillic and Japanese</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Text%20Fonts%20in%20X">Text Fonts in X</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Text%20Fonts">Text Fonts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Text%20and%20Markers">Text and Markers</a>
<br>
</div>

<h3 class="appendixsec">A.2 Cyrillic and Japanese fonts</h3>

<p>The built-in fonts discussed in the previous section include Cyrillic
and Japanese vector fonts.  This section explains how these fonts are
encoded, i.e., how their character maps are laid&nbsp;out.  You may use
the <code>plotfont</code> utility to display the character map for any font,
including the Cyrillic and Japanese vector fonts.  See <a href="#plotfont">plotfont</a>.

   <p>The HersheyCyrillic and HersheyCyrillic-Oblique fonts use an encoding
called KOI8-R, a superset of ASCII that has become the de&nbsp;facto
standard for Unix and networking applications in the former Soviet
Union.  Insofar as printable ASCII characters go, they resemble the
HersheySerif vector font.  But their upper halves are different.  The
byte range <tt>0xc0</tt><small class="dots">...</small><tt>0xdf</tt> contains lower-case Cyrillic
characters and the byte range <tt>0xe0</tt><small class="dots">...</small><tt>0xff</tt> contains upper
case Cyrillic characters.  Additional Cyrillic characters are located at
<tt>0xa3</tt> and&nbsp;<tt>0xb3</tt>.  For more on the encoding scheme, see
<a href="http://www.nagual.pp.ru/~ache/koi8.html">the official KOI8-R Web page</a> and Internet RFC 1489, which is available from the
<a href="http://www.isi.edu">Information Sciences Institute</a>.

   <p>The HersheyEUC font is a vector font that is used for displaying
Japanese text.  It uses the 8-bit EUC-JP encoding.  EUC stands for
`extended Unix code', which is a scheme for encoding Japanese, and also
other character sets (e.g., Greek and Cyrillic) as multibyte character
strings.  The format of EUC strings is explained in Ken Lunde's
<cite>Understanding Japanese Information Processing</cite> (O'Reilly, 1993),
which contains much additional information on Japanese text processing. 
See also <a href="http://www.ora.com/people/authors/lunde/cjk_inf.html">his on-line supplement</a>, and his more recent book <cite>CJKV Information
Processing</cite> (O'Reilly, 1999).

   <p>In the HersheyEUC font, characters in the printable ASCII range,
<tt>0x20</tt><small class="dots">...</small><tt>0x7e</tt>, are similar to HersheySerif (their encoding is
`JIS Roman', an ASCII variant standardized by the Japanese Industrial
Standards Committee).  Also, each successive pair of bytes in the
<code>0xa1</code><small class="dots">...</small><code>0xfe</code> range defines a single character in the
JIS X0208 standard.  The characters in the JIS X0208 standard include
Japanese syllabic characters (Hiragana and Katakana), ideographic
characters (Kanji), Roman, Greek, and Cyrillic alphabets, punctuation
marks, and miscellaneous symbols.  For example, the JIS X0208 standard
indexes the 83 Hiragana as <code>0x2421</code><small class="dots">...</small><code>0x2473</code>.  To&nbsp;obtain the EUC code for any JIS X0208 character, you would add
<code>0x80</code> to each byte (i.e., `set the high bit' on each byte).  So&nbsp;the first of the 83 Hiragana (<code>0x2421</code>) would be encoded as the
successive pair of bytes <code>0xa4</code> and&nbsp;<code>0xa1</code>.

   <p>The implementation of the JIS X0208 standard in the HersheyEUC font is
based on Dr.&nbsp;Hershey's digitizations, and is complete enough to be
useful.  All 83 Hiragana and 86 Katakana are available, though the
little-used `half-width Katakana' are not supported.  Also, 603 Kanji
are available, including 596 of the 2965 JIS Level&nbsp;1 (i.e.,
frequently used) Kanji.  The Hiragana, the Katakana, and the available
Kanji all have the same width.  The file <code>kanji.doc</code>, which on most
systems is installed in <code>/usr/share/libplot</code> or
<code>/usr/local/share/libplot</code>, lists the 603 available Kanji.  Each
JIS X0208 character that is unavailable will be drawn as an `undefined
character' glyph (a&nbsp;bundle of horizontal lines).

   <p>The eight Hewlett-Packard vector fonts in the ArcANK and StickANK
typefaces are also used for displaying Japanese text.  They are
available when producing HP-GL/2 output, or HP-GL output for the HP7550A
graphics plotter and the HP758x, HP7595A and HP7596A drafting plotters. 
That is, they are available only if <code>HPGL_VERSION</code> is&nbsp;"2" (the
default) or&nbsp;"1.5".

   <p>ANK stands for Alphabet, Numerals, and Katakana.  The ANK fonts use a
special mixed encoding.  The lower half of each font uses the JIS Roman
encoding, and the upper half contains half-width Katakana.  Half-width
Katakana are simplified Katakana that may need to be equipped with
diacritical marks.  The diacritical marks are included in the encoding
as separate characters.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Text%20Fonts%20in%20X">Text Fonts in X</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Text%20String%20Format">Text String Format</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Cyrillic%20and%20Japanese">Cyrillic and Japanese</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Text%20and%20Markers">Text and Markers</a>
<br>
</div>

<h3 class="appendixsec">A.3 Available text fonts for the X Window System</h3>

<p>The command-line graphics programs <code>graph -T&nbsp;X</code>, <code>plot
-T&nbsp;X</code>, <code>pic2plot -T&nbsp;X</code>, <code>tek2plot -T&nbsp;X</code>, and
<code>plotfont -T&nbsp;X</code>, and the <code>libplot</code> library that they are
built&nbsp;on, can draw text on an X&nbsp;Window System display in a wide
variety of fonts.  This includes the 22 built-in Hershey vector fonts. 
They can use the 35 built-in Postscript fonts too, if those fonts are
available on the X&nbsp;display.  Most releases of the plotting utilities
include freely distributable versions of the 35 Postscript fonts, in
Type&nbsp;1 format, that are easily installed on any X&nbsp;display.

   <p>In fact, the plotting utilities can use most fonts that are available on
the current X&nbsp;display.  This includes all scalable fonts that have a
so-called XLFD (X&nbsp;Logical Font Description) name.  For example, the
"CharterBT-Roman" font is available on many X&nbsp;displays.  It has a
formal XLFD name, namely
"-bitstream-charter-medium-r-normal-0-0-0-0-p-0-iso8859-1".  The
plotting utilities would refer to it as "charter-medium-r-normal".  The
command

<pre class="example">     echo 0 0 1 1 2 0 | graph -T X -F charter-medium-r-normal
     </pre>

<p>would draw a plot in a popped-up X&nbsp;window, in which all axis ticks
are labeled in this font.

   <p>You may determine which fonts are available on an X&nbsp;display by using
the <code>xlsfonts</code> command.  Fonts whose names end in
"-0-0-0-0-p-0-iso8859-1" or "-0-0-0-0-m-0-iso8859-1" are scalable
ISO-Latin-1 fonts that can be used by <code>libplot</code>'s X&nbsp;Plotters
and by the plotting utilities that are built on <code>libplot</code>.  The two
sorts of font are variable-width and fixed-width fonts, respectively. 
Fonts whose names end in "iso8859-2", etc., and "adobe-fontspecific",
may also be used, even though they do not employ the standard
ISO-Latin-1 encoding.

   <p>The escape sequences that provide access to the non-ASCII `8-bit'
characters in the built-in ISO-Latin-1 fonts may be employed when using
any ISO-Latin-1 X&nbsp;Window System font.  For more on escape sequences,
see <a href="#Text%20String%20Format">Text String Format</a>.  As an example, "\Po" will yield the
British pounds sterling symbol&nbsp;`&pound;'.  The command

<pre class="example">     echo 0 0 1 1 | graph -T X -F charter-medium-r-normal -L "A \Po1 Plot"
     </pre>

<p>shows how this symbol could be used in a graph label.  In the same way,
the escape sequences that provide access to mathematical symbols and
Greek characters may be employed when using any X&nbsp;Window System
font, whether or not it is an ISO-Latin-1 font.

   <p>The plotting utilities, including <code>graph</code>, support a
<code>--bitmap-size</code> option.  If&nbsp;the <code>-T&nbsp;X</code> option is used,
it&nbsp;sets the size of the popped-up X&nbsp;Window.  You may use it to
obtain some interesting visual effects.  Each of the plotting utilities
assumes that it is drawing in a square region, so if you use the
<code>--bitmap-size 800x400</code> option, your plot will be scaled
anisotropically, by a larger factor in the horizontal direction than in
the vertical direction.  The fonts in the plot will be scaled in the
same way.  Actually, this requires a modern (X11R6) display.  If&nbsp;your X&nbsp;display cannot scale a font, a&nbsp;default scalable font
(such&nbsp;as "HersheySerif") will be substituted.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Text%20String%20Format">Text String Format</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Marker%20Symbols">Marker Symbols</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Text%20Fonts%20in%20X">Text Fonts in X</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Text%20and%20Markers">Text and Markers</a>
<br>
</div>

<h3 class="appendixsec">A.4 Text string format and escape sequences</h3>

<p>Text strings that are drawn by the GNU <code>libplot</code> library and by
applications built on&nbsp;it, such as <code>graph</code>, <code>plot</code>,
<code>pic2plot</code>, <code>tek2plot</code>, and <code>plotfont</code>, must consist of
printable characters.  No&nbsp;embedded control characters, such as
newlines or carriage returns, are allowed.  Technically, a character is
`printable' if it comes from either of the two byte ranges
<tt>0x20</tt><small class="dots">...</small><tt>0x7e</tt> and <tt>0xa0</tt><small class="dots">...</small><tt>0xff</tt>.  The former is the
printable ASCII range and the latter is the printable `8-bit' range.

   <p>Text strings may, however, include embedded `escape sequences' that
shift the font, append subscripts or superscripts, or include non-ASCII
characters and mathematical symbols.  As a consequence, the axis labels
on a plot prepared with <code>graph</code> may include such features.  So may
the text strings that <code>pic2plot</code> uses to label objects.

   <p>The format of the escape sequences should look familiar to anyone who is
familiar with the TeX, <code>troff</code>, or <code>groff</code> document
formatters.  Each escape sequence consists of three characters: a&nbsp;backslash and two additional characters.  The most frequently used
escape sequences are as follows.

     <dl>
<dt>"\sp"
     <dd>start superscript mode
<br><dt>"\ep"
     <dd>end superscript mode
<br><dt>"\sb"
     <dd>start subscript mode
<br><dt>"\eb"
     <dd>end subscript mode
<br><dt>"\mk"
     <dd>mark position
<br><dt>"\rt"
     <dd>return to marked position
</dl>

<p>For example, the string "x\sp2\ep" would be interpreted as `x squared'. 
Subscripts on subscripts, etc., are allowed.  Subscripts and
superscripts may be vertically aligned by judicious use of the "\mk" and
"\rt" escape sequences.  For example, "a\mk\sbi\eb\rt\sp2\ep" produces
"a sub i squared", with the exponent `2' placed immediately above the
subscript.

   <p>There are also escape sequences that switch from font to font within a
typeface.  For an enumeration of the fonts within each typeface, see
<a href="#Text%20Fonts">Text Fonts</a>.  Suppose for&nbsp;example that the current font is
Times-Roman, which is font #1 in the `Times' typeface.  The string "A
\f2very\f1 well labeled axis" would be a string in which the word `very'
appears in Times-Italic rather than Times-Roman.  That is because
Times-Italic is the #2 font in the typeface.  Font-switching escape
sequences are of the form "\f<var>n</var>", where <var>n</var> is the number of
the font to be switched&nbsp;to.  For compatibility with <code>troff</code> and
<code>groff</code>, "\fR", "\fI", "\fB" are equivalent to "\f1", "\f2", "\f3",
respectively.  "\fP" will switch the font to the previously used font
(only one font is remembered).  There is currently no support for
switching between fonts in different typefaces.

   <p>There are also a few escape sequences for horizontal shifts, which are
useful for improving horizontal alignment, such as when shifting between
italic and non-italic fonts.  "\r1", "\r2", "\r4", "\r6", "\r8", and
"\r^" are escape sequences that shift right by 1 em, 1/2 em, 1/4 em, 1/6
em, 1/8 em, and 1/12 em, respectively.  "\l1", "\l2", "\l4", "\l6",
"\l8", and "\l^" are similar, but shift left instead of right. 
"A \fIvery\r^\fP well labeled axis" would look slightly better than
"A \fIvery\fP well labeled axis".

   <p>Square roots are handled with the aid of a special pair of escape
sequences, together with the "\mk" and "\rt" sequences discussed above. 
A square root symbol is begun with "\sr", and continued arbitrarily far
to the right with the overbar (`run') escape sequence, "\rn".  For
example, the string "\sr\mk\rn\rn\rtab" would be plotted as `the square
root of ab'.  To&nbsp;adjust the length of the overbar, you may need to
experiment with the number of times "\rn" appears.

   <p>To underline a string, you would use "\ul", the underline escape
sequence, one or more times.  The "\mk"<small class="dots">...</small>"\rt" trick would be
employed in the same way.  So, for example, "\mk\ul\ul\ul\rtabc" would
yield an underlined "abc".  To adjust the length of the underline, you
may need to experiment with the number of times "\ul" appears.  You may
also need to use one or more of the abovementioned horizontal shifts. 
For&nbsp;example, if the "HersheySerif" font were used,
"\mk\ul\ul\l8\ul\rtabc" would yield a better underline than
"\mk\ul\ul\ul\rtabc".

   <p>Besides the preceding escape sequences, there are also escape sequences
for the printable non-ASCII characters in each of the built-in
ISO-Latin-1 fonts (which means in every built-in font, except for the
symbol fonts, the HersheyCyrillic fonts, HersheyEUC, and ZapfDingbats). 
The useful non-ASCII characters include accented characters among
others.  Such `8-bit' characters, in the <tt>0xa0</tt><small class="dots">...</small><tt>0xff</tt> byte
range, may be included directly in a text string.  But if your terminal
does not permit this, you may use the escape sequences for them instead.

   <p>There are escape sequences for the mathematical symbols and Greek
characters in the symbol fonts, as&nbsp;well.  This is how the symbol
fonts are usually accessed.  Which symbol font the mathematical symbols
and Greek characters are taken from depends on whether your current font
is a Hershey font or a non-Hershey font.  They are taken from the
HersheySerifSymbol font or the HersheySansSymbol font in the former
case, and from the Symbol font in the latter.

   <p>The following are the escape sequences that provide access to the
non-ASCII characters of the current font, provided that it is an
ISO-Latin-1 font.  Each escape sequence is followed by the position of
the corresponding character in the ISO-Latin-1 encoding (in decimal),
and the official Postscript name of the character.  Most names should be
self-explanatory.  For&nbsp;example, `eacute' is a lower-case `e',
equipped with an acute accent.

     <dl>
<dt>"\r!"
     <dd>[161] exclamdown
<br><dt>"\ct"
     <dd>[162] cent
<br><dt>"\Po"
     <dd>[163] sterling
<br><dt>"\Cs"
     <dd>[164] currency
<br><dt>"\Ye"
     <dd>[165] yen
<br><dt>"\bb"
     <dd>[166] brokenbar
<br><dt>"\sc"
     <dd>[167] section
<br><dt>"\ad"
     <dd>[168] dieresis
<br><dt>"\co"
     <dd>[169] copyright
<br><dt>"\Of"
     <dd>[170] ordfeminine
<br><dt>"\Fo"
     <dd>[171] guillemotleft
<br><dt>"\no"
     <dd>[172] logicalnot
<br><dt>"\hy"
     <dd>[173] hyphen
<br><dt>"\rg"
     <dd>[174] registered
<br><dt>"\a-"
     <dd>[175] macron
<br><dt>"\de"
     <dd>[176] degree
<br><dt>"\+-"
     <dd>[177] plusminus
<br><dt>"\S2"
     <dd>[178] twosuperior
<br><dt>"\S3"
     <dd>[179] threesuperior
<br><dt>"\aa"
     <dd>[180] acute
<br><dt>"\*m"
     <dd>[181] mu
<br><dt>"\ps"
     <dd>[182] paragraph
<br><dt>"\md"
     <dd>[183] periodcentered
<br><dt>"\ac"
     <dd>[184] cedilla
<br><dt>"\S1"
     <dd>[185] onesuperior
<br><dt>"\Om"
     <dd>[186] ordmasculine
<br><dt>"\Fc"
     <dd>[187] guillemotright
<br><dt>"\14"
     <dd>[188] onequarter
<br><dt>"\12"
     <dd>[189] onehalf
<br><dt>"\34"
     <dd>[190] threequarters
<br><dt>"\r?"
     <dd>[191] questiondown
<br><dt>"\`A"
     <dd>[192] Agrave
<br><dt>"\'A"
     <dd>[193] Aacute
<br><dt>"\^A"
     <dd>[194] Acircumflex
<br><dt>"\~A"
     <dd>[195] Atilde
<br><dt>"\:A"
     <dd>[196] Adieresis
<br><dt>"\oA"
     <dd>[197] Aring
<br><dt>"\AE"
     <dd>[198] AE
<br><dt>"\,C"
     <dd>[199] Ccedilla
<br><dt>"\`E"
     <dd>[200] Egrave
<br><dt>"\'E"
     <dd>[201] Eacute
<br><dt>"\^E"
     <dd>[202] Ecircumflex
<br><dt>"\:E"
     <dd>[203] Edieresis
<br><dt>"\`I"
     <dd>[204] Igrave
<br><dt>"\'I"
     <dd>[205] Iacute
<br><dt>"\^I"
     <dd>[206] Icircumflex
<br><dt>"\:I"
     <dd>[207] Idieresis
<br><dt>"\-D"
     <dd>[208] Eth
<br><dt>"\~N"
     <dd>[209] Ntilde
<br><dt>"\'O"
     <dd>[210] Ograve
<br><dt>"\'O"
     <dd>[211] Oacute
<br><dt>"\^O"
     <dd>[212] Ocircumflex
<br><dt>"\~O"
     <dd>[213] Otilde
<br><dt>"\:O"
     <dd>[214] Odieresis
<br><dt>"\mu"
     <dd>[215] multiply
<br><dt>"\/O"
     <dd>[216] Oslash
<br><dt>"\`U"
     <dd>[217] Ugrave
<br><dt>"\'U"
     <dd>[218] Uacute
<br><dt>"\^U"
     <dd>[219] Ucircumflex
<br><dt>"\:U"
     <dd>[220] Udieresis
<br><dt>"\'Y"
     <dd>[221] Yacute
<br><dt>"\TP"
     <dd>[222] Thorn
<br><dt>"\ss"
     <dd>[223] germandbls
<br><dt>"\`a"
     <dd>[224] agrave
<br><dt>"\'a"
     <dd>[225] aacute
<br><dt>"\^a"
     <dd>[226] acircumflex
<br><dt>"\~a"
     <dd>[227] atilde
<br><dt>"\:a"
     <dd>[228] adieresis
<br><dt>"\oa"
     <dd>[229] aring
<br><dt>"\ae"
     <dd>[230] ae
<br><dt>"\,c"
     <dd>[231] ccedilla
<br><dt>"\`e"
     <dd>[232] egrave
<br><dt>"\'e"
     <dd>[233] eacute
<br><dt>"\^e"
     <dd>[234] ecircumflex
<br><dt>"\:e"
     <dd>[235] edieresis
<br><dt>"\`i"
     <dd>[236] igrave
<br><dt>"\'i"
     <dd>[237] iacute
<br><dt>"\^i"
     <dd>[238] icircumflex
<br><dt>"\:i"
     <dd>[239] idieresis
<br><dt>"\Sd"
     <dd>[240] eth
<br><dt>"\~n"
     <dd>[241] ntilde
<br><dt>"\`o"
     <dd>[242] ograve
<br><dt>"\'o"
     <dd>[243] oacute
<br><dt>"\^o"
     <dd>[244] ocircumflex
<br><dt>"\~o"
     <dd>[245] otilde
<br><dt>"\:o"
     <dd>[246] odieresis
<br><dt>"\di"
     <dd>[247] divide
<br><dt>"\/o"
     <dd>[248] oslash
<br><dt>"\`u"
     <dd>[249] ugrave
<br><dt>"\'u"
     <dd>[250] uacute
<br><dt>"\^u"
     <dd>[251] ucircumflex
<br><dt>"\:u"
     <dd>[252] udieresis
<br><dt>"\'y"
     <dd>[253] yacute
<br><dt>"\Tp"
     <dd>[254] thorn
<br><dt>"\:y"
     <dd>[255] ydieresis
</dl>

   <p>The following are the escape sequences that provide access to
mathematical symbols and Greek characters in the current symbol font,
whether HersheySerifSymbol or HersheySansSymbol (for Hershey fonts) or
Symbol (for Postscript fonts).  Each escape sequence is followed by the
position (in octal) of the corresponding character in the symbol
encoding, and the official Postscript name of the character.  Many
escape sequences and names should be self-explanatory.  "\*a" represents
a lower-case Greek alpha, for&nbsp;example.  For a table displaying each
of the characters below, see the <cite>Postscript Language Reference
Manual</cite>.

     <dl>
<dt>"\fa"
     <dd>[0042] universal
<br><dt>"\te"
     <dd>[0044] existential
<br><dt>"\st"
     <dd>[0047] suchthat
<br><dt>"\**"
     <dd>[0052] asteriskmath
<br><dt>"\=~"
     <dd>[0100] congruent
<br><dt>"\*A"
     <dd>[0101] Alpha
<br><dt>"\*B"
     <dd>[0102] Beta
<br><dt>"\*X"
     <dd>[0103] Chi
<br><dt>"\*D"
     <dd>[0104] Delta
<br><dt>"\*E"
     <dd>[0105] Epsilon
<br><dt>"\*F"
     <dd>[0106] Phi
<br><dt>"\*G"
     <dd>[0107] Gamma
<br><dt>"\*Y"
     <dd>[0110] Eta
<br><dt>"\*I"
     <dd>[0111] Iota
<br><dt>"\+h"
     <dd>[0112] theta1
<br><dt>"\*K"
     <dd>[0113] Kappa
<br><dt>"\*L"
     <dd>[0114] Lambda
<br><dt>"\*M"
     <dd>[0115] Mu
<br><dt>"\*N"
     <dd>[0116] Nu
<br><dt>"\*O"
     <dd>[0117] Omicron
<br><dt>"\*P"
     <dd>[0120] Pi
<br><dt>"\*H"
     <dd>[0121] Theta
<br><dt>"\*R"
     <dd>[0122] Rho
<br><dt>"\*S"
     <dd>[0123] Sigma
<br><dt>"\*T"
     <dd>[0124] Tau
<br><dt>"\*U"
     <dd>[0125] Upsilon
<br><dt>"\ts"
     <dd>[0126] sigma1
<br><dt>"\*W"
     <dd>[0127] Omega
<br><dt>"\*C"
     <dd>[0130] Xi
<br><dt>"\*Q"
     <dd>[0131] Psi
<br><dt>"\*Z"
     <dd>[0132] Zeta
<br><dt>"\tf"
     <dd>[0134] therefore
<br><dt>"\pp"
     <dd>[0136] perpendicular
<br><dt>"\ul"
     <dd>[0137] underline
<br><dt>"\rx"
     <dd>[0140] radicalex
<br><dt>"\*a"
     <dd>[0141] alpha
<br><dt>"\*b"
     <dd>[0142] beta
<br><dt>"\*x"
     <dd>[0143] chi
<br><dt>"\*d"
     <dd>[0144] delta
<br><dt>"\*e"
     <dd>[0145] epsilon
<br><dt>"\*f"
     <dd>[0146] phi
<br><dt>"\*g"
     <dd>[0147] gamma
<br><dt>"\*y"
     <dd>[0150] eta
<br><dt>"\*i"
     <dd>[0151] iota
<br><dt>"\+f"
     <dd>[0152] phi1
<br><dt>"\*k"
     <dd>[0153] kappa
<br><dt>"\*l"
     <dd>[0154] lambda
<br><dt>"\*m"
     <dd>[0155] mu
<br><dt>"\*n"
     <dd>[0156] nu
<br><dt>"\*o"
     <dd>[0157] omicron
<br><dt>"\*p"
     <dd>[0160] pi
<br><dt>"\*h"
     <dd>[0161] theta
<br><dt>"\*r"
     <dd>[0162] rho
<br><dt>"\*s"
     <dd>[0163] sigma
<br><dt>"\*t"
     <dd>[0164] tau
<br><dt>"\*u"
     <dd>[0165] upsilon
<br><dt>"\+p"
     <dd>[0166] omega1
<br><dt>"\*w"
     <dd>[0167] omega
<br><dt>"\*c"
     <dd>[0170] xi
<br><dt>"\*q"
     <dd>[0171] psi
<br><dt>"\*z"
     <dd>[0172] zeta
<br><dt>"\ap"
     <dd>[0176] similar
<br><dt>"\+U"
     <dd>[0241] Upsilon1
<br><dt>"\fm"
     <dd>[0242] minute
<br><dt>"\&lt;="
     <dd>[0243] lessequal
<br><dt>"\f/"
     <dd>[0244] fraction
<br><dt>"\if"
     <dd>[0245] infinity
<br><dt>"\Fn"
     <dd>[0246] florin
<br><dt>"\CL"
     <dd>[0247] club
<br><dt>"\DI"
     <dd>[0250] diamond
<br><dt>"\HE"
     <dd>[0251] heart
<br><dt>"\SP"
     <dd>[0252] spade
<br><dt>"\&lt;&gt;"
     <dd>[0253] arrowboth
<br><dt>"\&lt;-"
     <dd>[0254] arrowleft
<br><dt>"\ua"
     <dd>[0255] arrowup
<br><dt>"\-&gt;"
     <dd>[0256] arrowright
<br><dt>"\da"
     <dd>[0257] arrowdown
<br><dt>"\de"
     <dd>[0260] degree
<br><dt>"\+-"
     <dd>[0261] plusminus
<br><dt>"\sd"
     <dd>[0262] second
<br><dt>"\&gt;="
     <dd>[0263] greaterequal
<br><dt>"\mu"
     <dd>[0264] multiply
<br><dt>"\pt"
     <dd>[0265] proportional
<br><dt>"\pd"
     <dd>[0266] partialdiff
<br><dt>"\bu"
     <dd>[0267] bullet
<br><dt>"\di"
     <dd>[0270] divide
<br><dt>"\!="
     <dd>[0271] notequal
<br><dt>"\=="
     <dd>[0272] equivalence
<br><dt>"\~~"
     <dd>[0273] approxequal
<br><dt>"\.."
     <dd>[0274] ellipsis
<br><dt>NONE
     <dd>[0275] arrowvertex
<br><dt>"\an"
     <dd>[0276] arrowhorizex
<br><dt>"\CR"
     <dd>[0277] carriagereturn
<br><dt>"\Ah"
     <dd>[0300] aleph
<br><dt>"\Im"
     <dd>[0301] Ifraktur
<br><dt>"\Re"
     <dd>[0302] Rfraktur
<br><dt>"\wp"
     <dd>[0303] weierstrass
<br><dt>"\c*"
     <dd>[0304] circlemultiply
<br><dt>"\c+"
     <dd>[0305] circleplus
<br><dt>"\es"
     <dd>[0306] emptyset
<br><dt>"\ca"
     <dd>[0307] cap
<br><dt>"\cu"
     <dd>[0310] cup
<br><dt>"\SS"
     <dd>[0311] superset
<br><dt>"\ip"
     <dd>[0312] reflexsuperset
<br><dt>"\n&lt;"
     <dd>[0313] notsubset
<br><dt>"\SB"
     <dd>[0314] subset
<br><dt>"\ib"
     <dd>[0315] reflexsubset
<br><dt>"\mo"
     <dd>[0316] element
<br><dt>"\nm"
     <dd>[0317] notelement
<br><dt>"\/_"
     <dd>[0320] angle
<br><dt>"\gr"
     <dd>[0321] nabla
<br><dt>"\rg"
     <dd>[0322] registerserif
<br><dt>"\co"
     <dd>[0323] copyrightserif
<br><dt>"\tm"
     <dd>[0324] trademarkserif
<br><dt>"\PR"
     <dd>[0325] product
<br><dt>"\sr"
     <dd>[0326] radical
<br><dt>"\md"
     <dd>[0327] dotmath
<br><dt>"\no"
     <dd>[0330] logicalnot
<br><dt>"\AN"
     <dd>[0331] logicaland
<br><dt>"\OR"
     <dd>[0332] logicalor
<br><dt>"\hA"
     <dd>[0333] arrowdblboth
<br><dt>"\lA"
     <dd>[0334] arrowdblleft
<br><dt>"\uA"
     <dd>[0335] arrowdblup
<br><dt>"\rA"
     <dd>[0336] arrowdblright
<br><dt>"\dA"
     <dd>[0337] arrowdbldown
<br><dt>"\lz"
     <dd>[0340] lozenge
<br><dt>"\la"
     <dd>[0341] angleleft
<br><dt>"\RG"
     <dd>[0342] registersans
<br><dt>"\CO"
     <dd>[0343] copyrightsans
<br><dt>"\TM"
     <dd>[0344] trademarksans
<br><dt>"\SU"
     <dd>[0345] summation
<br><dt>NONE
     <dd>[0346] parenlefttp
<br><dt>NONE
     <dd>[0347] parenleftex
<br><dt>NONE
     <dd>[0350] parenleftbt
<br><dt>"\lc"
     <dd>[0351] bracketlefttp
<br><dt>NONE
     <dd>[0352] bracketleftex
<br><dt>"\lf"
     <dd>[0353] bracketleftbt
<br><dt>"\lt"
     <dd>[0354] bracelefttp
<br><dt>"\lk"
     <dd>[0355] braceleftmid
<br><dt>"\lb"
     <dd>[0356] braceleftbt
<br><dt>"\bv"
     <dd>[0357] braceex
<br><dt>"\eu"
     <dd>[0360] euro
<br><dt>"\ra"
     <dd>[0361] angleright
<br><dt>"\is"
     <dd>[0362] integral
<br><dt>NONE
     <dd>[0363] integraltp
<br><dt>NONE
     <dd>[0364] integralex
<br><dt>NONE
     <dd>[0365] integralbt
<br><dt>NONE
     <dd>[0366] parenrighttp
<br><dt>NONE
     <dd>[0367] parenrightex
<br><dt>NONE
     <dd>[0370] parenrightbt
<br><dt>"\rc"
     <dd>[0371] bracketrighttp
<br><dt>NONE
     <dd>[0372] bracketrightex
<br><dt>"\rf"
     <dd>[0373] bracketrightbt
<br><dt>"\RT"
     <dd>[0374] bracerighttp
<br><dt>"\rk"
     <dd>[0375] bracerightmid
<br><dt>"\rb"
     <dd>[0376] bracerightbt
</dl>

   <p>Finally, there are escape sequences that apply only if the current font
is a Hershey font.  Most of these escape sequences provide access to
special symbols that belong to no font, and are accessible by no other
means.  These symbols are of two sorts: miscellaneous, and astronomical
or zodiacal.  The escape sequences for the miscellaneous symbols are as
follows.

     <dl>
<dt>"\dd"
     <dd>daggerdbl
<br><dt>"\dg"
     <dd>dagger
<br><dt>"\hb"
     <dd>hbar
<br><dt>"\li"
     <dd>lineintegral
<br><dt>"\IB"
     <dd>interbang
<br><dt>"\Lb"
     <dd>lambdabar
<br><dt>"\~-"
     <dd>modifiedcongruent
<br><dt>"\-+"
     <dd>minusplus
<br><dt>"\||"
     <dd>parallel
<br><dt>"\s-"
     <dd>[variant form of s]
</dl>

<p>The final escape sequence in the table above, "\s-", yields a letter
rather than a symbol.  It&nbsp;is provided because in some Hershey fonts,
the shape of the lower-case letter&nbsp;`s' differs if it is the last
letter in a word.  This is the case for HersheyGothicGerman.  The German
word "besonders", for example, should be written as "besonder\s-" if it
is to be rendered correctly in this font.  The same is true for the two
Hershey symbol fonts, with their Greek alphabets (in Greek text,
lower-case final&nbsp;`s' is different from lower-case non-final&nbsp;`s').  In&nbsp;Hershey fonts where there is no distinction between final
and non-final&nbsp;`s', "s"&nbsp;and&nbsp;"\s-" are equivalent.

   <p>The escape sequences for the astronomical symbols, including the signs
for the twelve constellations of the zodiac, are listed in the following
table.  We stress that that like the preceding miscellaneous escape
sequences, they apply only if the current font is a Hershey font.

     <dl>
<dt>"\SO"
     <dd>sun
<br><dt>"\ME"
     <dd>mercury
<br><dt>"\VE"
     <dd>venus
<br><dt>"\EA"
     <dd>earth
<br><dt>"\MA"
     <dd>mars
<br><dt>"\JU"
     <dd>jupiter
<br><dt>"\SA"
     <dd>saturn
<br><dt>"\UR"
     <dd>uranus
<br><dt>"\NE"
     <dd>neptune
<br><dt>"\PL"
     <dd>pluto
<br><dt>"\LU"
     <dd>moon
<br><dt>"\CT"
     <dd>comet
<br><dt>"\ST"
     <dd>star
<br><dt>"\AS"
     <dd>ascendingnode
<br><dt>"\DE"
     <dd>descendingnode
<br><dt>"\AR"
     <dd>aries
<br><dt>"\TA"
     <dd>taurus
<br><dt>"\GE"
     <dd>gemini
<br><dt>"\CA"
     <dd>cancer
<br><dt>"\LE"
     <dd>leo
<br><dt>"\VI"
     <dd>virgo
<br><dt>"\LI"
     <dd>libra
<br><dt>"\SC"
     <dd>scorpio
<br><dt>"\SG"
     <dd>sagittarius
<br><dt>"\CP"
     <dd>capricornus
<br><dt>"\AQ"
     <dd>aquarius
<br><dt>"\PI"
     <dd>pisces
</dl>

   <p>The preceding miscellaneous and astronomical symbols are not the only
special non-font symbols that can be used if the current font is a
Hershey font.  The entire library of glyphs digitized by Allen Hershey
is built into GNU <code>libplot</code>.  So&nbsp;text strings may include any
Hershey glyph.  Each of the available Hershey glyphs is identified by a
four-digit number.  Standard Hershey glyph&nbsp;#1 would be specified as
"\#H0001".  The standard Hershey glyphs range from "\#H0001" to
"\#H3999", with a number of gaps.  Some additional glyphs designed by
others appear in the "\#H4000"<small class="dots">...</small>"\#H4194" range.  Syllabic Japanese
characters (Kana) are located in the "\#H4195"<small class="dots">...</small>"\#H4399" range.

   <p>You may order a table of nearly all the Hershey glyphs in the
"\#H0001"<small class="dots">...</small>"\#H3999" range from the U.S. National Technical
Information Service, at +1&nbsp;703 487 4650.  Ask for item number
PB251845; the current price is about US$40.  By way of example, the
string

<pre class="example">     "\#H0744\#H0745\#H0001\#H0002\#H0003\#H0869\#H0907\#H2330\#H2331"
     </pre>

<p>when drawn will display a shamrock, a fleur-de-lys, cartographic (small)
letters A,&nbsp;B,&nbsp;C, a&nbsp;bell, a&nbsp;large circle, a&nbsp;treble
clef, and a&nbsp;bass clef.  Again, this assumes that the current font is
a Hershey font.

   <p>You may also use Japanese syllabic characters (Hiragana and Katakana)
and ideographic characters (Kanji) when drawing strings in any Hershey
font.  In&nbsp;all, 603 Kanji are available; these are the same Kanji
that are available in the HersheyEUC font.  The Japanese characters are
indexed according to the JIS X0208 standard for Japanese typography,
which represents each character by a two-byte sequence.  The file
<code>kanji.doc</code>, which is distributed along with the GNU plotting
utilities, lists the available Kanji.  On&nbsp;most systems it is
installed in <code>/usr/share/libplot</code> or
<code>/usr/local/share/libplot</code>.

   <p>Each JIS X0208 character would be specified by an escape sequence which
expresses this two-byte sequence as four hexadecimal digits, such as
"\#J357e".  Both bytes must be in the <code>0x21</code><small class="dots">...</small><code>0x7e</code>
range in order to define a JIS X0208 character.  Kanji are located at
"\#J3021" and above.  Characters appearing elsewhere in the JIS X0208
encoding may be accessed similarly.  For example, Hiragana and Katakana
are located in the "\#J2421"<small class="dots">...</small>"\#J257e" range, and Roman characters
in the "\#J2321"<small class="dots">...</small>"\#J237e" range.  The file <code>kana.doc</code>, which
is installed in the same directory as <code>kanji.doc</code>, lists the
encodings of the Hiragana and Katakana.  For more on the JIS X0208
standard, see Ken Lunde's <cite>Understanding Japanese Information
Processing</cite> (O'Reilly, 1993), and
<a href="http://www.ora.com/people/authors/lunde/cjk_inf.html">his on-line supplement</a>.

   <p>The Kanji numbering used in A.&nbsp;N. Nelson's <cite>Modern Reader's
Japanese-English Character Dictionary</cite>, a&nbsp;longtime standard, is also
supported.  (This dictionary is published by C.&nbsp;E. Tuttle and Co.,
with ISBN 0-8048-0408-7.  A&nbsp;revised edition [ISBN 0-8048-2036-8]
appeared in 1997, but uses a different numbering.)  `Nelson' escape
sequences for Kanji are similar to JIS X0208 escape sequences, but use
four decimal instead of four hexadecimal digits.  The file
<code>kanji.doc</code> gives the correspondence between the JIS numbering
scheme and the Nelson numbering scheme.  For&nbsp;example, "\#N0001" is
equivalent to "\#J306c".  It&nbsp;also gives the positions of the
available Kanji in the Unicode encoding.

   <p>All available Kanji have the same width, which is the same as that of
the syllabic Japanese characters (Hiragana and Katakana).  Each Kanji
that is not available will print as an `undefined character' glyph (a&nbsp;bundle of horizontal lines).  The same is true for non-Kanji JIS X0208
characters that are not available.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Marker%20Symbols">Marker Symbols</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Text%20String%20Format">Text String Format</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Text%20and%20Markers">Text and Markers</a>
<br>
</div>

<h3 class="appendixsec">A.5 Available marker symbols</h3>

<p>The GNU <code>libplot</code> library supports a standard set of marker
symbols, numbered 0<small class="dots">...</small>31.  A&nbsp;marker symbol is a visual
representation of a point.  The <code>libplot</code> marker symbols are the
symbols that the <code>graph</code> program will plot at each point of a
dataset, if the <code>-S</code> option is specified.

   <p>Like a text string, a marker symbol has a font size.  In&nbsp;any output
format, a&nbsp;marker symbol is guaranteed to be visible if its font size
is sufficiently large.  Marker symbol #0 is an exception to this: by
convention, symbol&nbsp;#0 means no symbol at&nbsp;all.  Marker symbols in
the range 1<small class="dots">...</small>31 are defined as&nbsp;follows.

     <ol type=1 start=1>
<li>dot
<li>plus (+)
<li>asterisk (*)
<li>circle
<li>cross
<li>square
<li>triangle
<li>diamond
<li>star
<li>inverted triangle
<li>starburst
<li>fancy plus
<li>fancy cross
<li>fancy square
<li>fancy diamond
<li>filled circle
<li>filled square
<li>filled triangle
<li>filled diamond
<li>filled inverted triangle
<li>filled fancy square
<li>filled fancy diamond
<li>half filled circle
<li>half filled square
<li>half filled triangle
<li>half filled diamond
<li>half filled inverted triangle
<li>half filled fancy square
<li>half filled fancy diamond
<li>octagon
<li>filled octagon
        </ol>

<p>The interpretation of marker symbols 1 through 5 is the same as in the
well&nbsp;known Graphical Kernel System (GKS).

   <p>By convention, symbols 32 and&nbsp;up are interpreted as characters in a
certain text font.  For <code>libplot</code>, this is simply the current font. 
But for the <code>graph</code> program, it&nbsp;is the symbol font selected
with the <code>--symbol-font-name</code> option.  By&nbsp;default, the symbol
font is the ZapfDingbats font except in <code>graph -T png</code>, <code>graph
-T pnm</code>, <code>graph -T gif</code>, <code>graph -T pcl</code>, <code>graph -T hpgl</code>
and <code>graph -T tek</code>.  Those variants of <code>graph</code> normally have
no access to ZapfDingbats and other Postscript fonts, so they use the
HersheySerif font instead.

   <p>Many of the characters in the ZapfDingbats font are suitable for use as
marker symbols.  For example, character #74 is the Texas star.  Doing

<pre class="example">     echo 0 0 1 2 2 1 3 2 4 0 | graph -T ps -m 0 -S 74 0.1 &gt; plot.ps
     </pre>

<p>will produce a Postscript plot consisting of five data points, not
joined by line segments.  Each data point will be marked by a Texas
star, of a large font size (0.1&nbsp;times the width of the plotting
box).

   <p>If you are using <code>graph -T pcl</code> or <code>graph -T hpgl</code> and wish to
use font characters as marker symbols, you should consider using the
Wingdings font, which is available when producing PCL&nbsp;5 or HP-GL/2
output.  Doing

<pre class="example">     echo 0 0 1 2 2 1 3 2 4 0 |
         graph -T pcl -m 0 --symbol-font Wingdings -S 181 0.1 &gt; plot.pcl
     </pre>

<p>will produce a PCL&nbsp;5 plot that is similar to the preceding
Postscript plot.  The Wingdings font has the Texas star in location
#181.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Color%20Names">Color Names</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Text%20and%20Markers">Text and Markers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Appendices">Appendices</a>
<br>
</div>

<h2 class="appendix">Appendix B Specifying Colors by Name</h2>

<p>The GNU <code>libplot</code> library allows colors to be specified by the
user.  It includes the <code>bgcolorname</code>, <code>pencolorname</code>, and
<code>fillcolorname</code> functions, each of which takes a color as an
argument.

   <p>The command-line graphics programs built on <code>libplot</code>, namely
<code>graph</code>, <code>plot</code>, <code>pic2plot</code>, <code>tek2plot</code>, and
<code>plotfont</code>, allow colors to be specified on the command line.  Each
of them supports a <code>--bg-color</code> option, and each of them, other
than <code>graph</code>, supports a <code>--pen-color</code> option.  (<code>graph</code>
supports a more complicated <code>--pen-colors</code> option, and a
<code>--frame-color</code> option.)

   <p>In any of these contexts, a color may be specified precisely as a
hexadecimal string that gives by its 48-bit RGB representation.  For
example, "#c0c0c0" is a silvery gray, and "#ffffff" is white.  Also,
colors may be specified by name.  665 distinct names are recognized,
including familiar ones like "red", "green", and "blue", and obscure
ones like "dark magenta", "forest green", and "olive drab".  Color names
are case-insensitive, and spaces are ignored.  So, for&nbsp;example,
"RosyBrown" is equivalent to "rosy brown", and "DarkGoldenrod3" to "dark
goldenrod 3".

   <p>The file <code>colors.txt</code>, which is distributed along with the GNU
plotting utilities, lists the 665 recognized color names.  On&nbsp;most
systems it is installed in <code>/usr/share/libplot</code> or
<code>/usr/local/share/libplot</code>.  The names are essentially those
recognized by recent releases of the X&nbsp;Window System, which on most
machines are listed in the file <code>/usr/lib/X11/rgb.txt</code>.  However,
for every color name containing the string "gray", a&nbsp;version
containing "grey" has been included.  For&nbsp;example, both "dark slate
gray 4" and "dark slate grey 4" are recognized color names.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Metafiles">Metafiles</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Color%20Names">Color Names</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Appendices">Appendices</a>
<br>
</div>

<h2 class="appendix">Appendix C Page Sizes and Viewport Sizes</h2>

<p>When producing output in such formats as Illustrator, Postscript, PCL&nbsp;5, HP-GL, and Fig, it is important to specify the size of the page on
which the output will be printed.  The GNU <code>libplot</code> library allows
the user to specify a <code>PAGESIZE</code> parameter, which can be used for
this.  The command-line graphics programs <code>graph</code>, <code>plot</code>,
<code>pic2plot</code>, <code>tek2plot</code>, and <code>plotfont</code>, which are
built&nbsp;on <code>libplot</code>, support a <code>PAGESIZE</code> environment
variable and a <code>--page-size</code> option.

   <p>Graphics drawn by <code>libplot</code> are nominally drawn within a graphics
display, or `viewport'.  When producing such raster formats as PNG, PNM,
and pseudo-GIF, it&nbsp;will use a square or rectangular bitmap as its
viewport.  But when producing Illustrator, Postscript, PCL&nbsp;5, HP-GL,
and Fig format, it will use a square or rectangular region on the page
as its viewport.  Except in the HP-GL case, the viewport will by&nbsp;default be centered on the page.  Graphics will not be clipped to the
viewport, so the entire page will in&nbsp;principle be imageable.

   <p>Either or both of the dimensions of the graphics display can be
specified explicitly.  For example, the page size could be specified as
"letter,xsize=4in", or "a4,xsize=10cm,ysize=15cm".  The dimensions of
the graphics display are allowed to be negative (a&nbsp;negative
dimension results in a reflection).  Inches, centimeters, and
millimeters are the supported units.

   <p>It&nbsp;is also possible to position the graphics display precisely, by
specifying the location of its lower left corner relative to the lower
left corner of the page.  For example, the page size could be specified
not merely as "letter" or&nbsp;"a4", but as
"letter,xorigin=2in,yorigin=3in", or "a4,xorigin=0.5cm,yorigin=0.5cm". 
In all cases, the viewport position may be adjusted by specifying an
offset vector.  For example, the page size could be specified as
"letter,yoffset=1.2in", or "a4,xoffset=-5mm,yoffset=2.0cm".  The
viewport may also be rotated, by setting the <code>ROTATION</code> parameter
or environment variable, or (in&nbsp;the case of the graphics programs)
by using the <code>--rotation</code> option.  A rotated viewport does not
change the position of its four corners.  Rather, the graphics are
rotated within&nbsp;it.  If&nbsp;the viewport is rectangular rather than
square, this `rotation' necessarily includes a rescaling.

   <p>Any ISO page size in the range "a0"<small class="dots">...</small>"a4" or ANSI page size in the
range "a"<small class="dots">...</small>"e" may be specified.  ("letter" is an alias for&nbsp;"a", which is the default, and "tabloid" is an alias for&nbsp;"b"). 
"legal", "ledger", and the JIS [Japanese Industrial Standard] size "b5"
are recognized also.  The following are the supported page sizes and the
default square viewport size that corresponds to each.

     <dl>
<dt>"a" (or "letter"; 8.5in by 11.0in)
     <dd>8.0in

     <br><dt>"b" (or "tabloid"; 11.0in by 17.0in)
     <dd>10.0in

     <br><dt>"c" (17.0in by 22.0in)
     <dd>16.0in

     <br><dt>"d" (22.0in by 34.0in)
     <dd>20.0in

     <br><dt>"e" (34.0in by 44.0in)
     <dd>32.0in

     <br><dt>"legal" (8.5in by 14.0in)
     <dd>8.0in

     <br><dt>"ledger" (17.0in by 11.0in)
     <dd>10.0in

     <br><dt>"a4" (21.0cm by 29.7cm)
     <dd>19.81cm

     <br><dt>"a3" (29.7cm by 42.0cm)
     <dd>27.18cm

     <br><dt>"a2" (42.0cm by 59.4cm)
     <dd>39.62cm

     <br><dt>"a1" (59.4cm by 84.1cm)
     <dd>56.90cm

     <br><dt>"a0" (84.1cm by 118.9cm)
     <dd>81.79cm

     <br><dt>"b5" (18.2cm by 25.7cm)
     <dd>16.94cm
</dl>

   <p>SVG format and WebCGM format have no notion of the Web page on which the
viewport will ultimately be positioned.  They do have a notion of
default viewport size, though this will normally be overridden when the
output file is placed on a Web page.  When producing SVG or WebCGM
output, this default viewport size is set by <code>PAGESIZE</code>, or (in&nbsp;the case of the graphics programs) the <code>--page-size</code> option.  The
"xorigin", "yorigin", "xoffset", and "yoffset" specifiers, if included,
are ignored.

   <p>For a similar reason, the "xorigin" and "yorigin" specifiers are ignored
when producing HP-GL or HP-GL/2 output.  The lower left corner of the
viewport is positioned at the HP-GL `scaling point'&nbsp;P1, whose
location is device-dependent.  The "xoffset" and "yoffset" specifiers
are respected, however, and may be used to reposition the viewport.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Metafiles">Metafiles</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Auxiliary%20Software">Auxiliary Software</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Page%20and%20Viewport%20Sizes">Page and Viewport Sizes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Appendices">Appendices</a>
<br>
</div>

<h2 class="appendix">Appendix D The Graphics Metafile Format</h2>

<p>A GNU graphics metafile is produced by any application that uses the
Metafile Plotter support contained in GNU <code>libplot</code>.  That includes
the raw variants of <code>graph</code>, <code>plot</code>, <code>pic2plot</code>,
<code>tek2plot</code>, and <code>plotfont</code>.  A&nbsp;metafile is a sort of audit
trail, which specifies a sequence of Plotter operations.  Each operation
is represented by an `op&nbsp;code': a&nbsp;single ASCII character.  The
arguments of the operation, if&nbsp;any, immediately follow the op&nbsp;code.

   <p>A metafile may use either of two encodings: binary (the default) or
portable (human-readable).  Metafiles in the binary encoding begin with
the magic string "#PLOT&nbsp;1\n", and metafiles in the portable encoding
with the magic string "#PLOT&nbsp;2\n".  If&nbsp;you intend to transfer
metafiles between machines of different types, you should use the
portable rather than the binary encoding.  Portable metafiles are
produced by Metafile Plotters if the <code>META_PORTABLE</code> parameter is
set to "yes", and by the raw variants of GNU <code>graph</code> and the other
command-line graphics programs if the <code>-O</code> option is specified. 
Both binary and portable metafiles can be translated to other formats by
GNU <code>plot</code>.  See <a href="#plot">plot</a>.

   <p>In the portable encoding, the arguments of each operation (integers,
floating point numbers, or strings) are printed in a human-readable
form, separated by spaces, and each argument list ends with a newline. 
In&nbsp;the binary encoding, the arguments are represented as integers,
single precision floating point numbers, or newline-terminated ASCII
strings.  Using the newline character as a terminator is acceptable
because each Plotter operation includes a maximum of one string among
its arguments, and such a string may not include a newline.  Also, the
string must come last among the arguments.

   <p>There are 97 Plotter operations in all.  The most important are
<code>openpl</code> and <code>closepl</code>, which open and close a Plotter, i.e.,
begin and end a page of graphics.  They are represented by the op&nbsp;codes <code>o</code>&nbsp;and&nbsp;<code>x</code>, respectively.  The <code>erase</code>
operation, if present, separates frames within a page.  On real-time
display devices, it&nbsp;is interpreted as a screen erasure.  It&nbsp;is
represented by the op&nbsp;code&nbsp;<code>e</code>.

   <p>Each of the 94 other Plotter operations has a corresponding op&nbsp;code,
with 12 exceptions.  These 12 exceptions are (1)&nbsp;the control
operation <code>flushpl</code>, (2)&nbsp;the operations <code>havecap</code>,
<code>labelwidth</code>, and <code>flabelwidth</code>, which merely return
information, (3)&nbsp;the <code>color</code>, <code>colorname</code>,
<code>pencolorname</code>, <code>fillcolorname</code>, and <code>bgcolorname</code>
operations, which are internally mapped to <code>pencolor</code>,
<code>fillcolor</code>, and <code>bgcolor</code>, (4)&nbsp;the <code>frotate</code>,
<code>fscale</code>, and <code>ftranslate</code> operations, which are internally
mapped to <code>fconcat</code>, and (5)&nbsp;the <code>ffontname</code> operation,
which in a metafile would be indistinguishable from <code>fontname</code>. 
So&nbsp;besides <code>o</code>&nbsp;and&nbsp;<code>x</code>, there are 83 possible op&nbsp;codes, for a total of&nbsp;85.  The following table lists 10 of the
op&nbsp;codes other than <code>o</code>&nbsp;and&nbsp;<code>x</code>, followed by the
Plotter operation they stand&nbsp;for.

     <dl>
<dt>Op Code
     <dd>Operation
<br><dt><code>a</code>
     <dd><code>arc</code>
<br><dt><code>c</code>
     <dd><code>circle</code>
<br><dt><code>e</code>
     <dd><code>erase</code>
<br><dt><code>f</code>
     <dd><code>linemod</code>
<br><dt><code>l</code>
     <dd><code>line</code>
<br><dt><code>m</code>
     <dd><code>move</code>
<br><dt><code>n</code>
     <dd><code>cont</code>
<br><dt><code>p</code>
     <dd><code>point</code>
<br><dt><code>s</code>
     <dd><code>space</code>
<br><dt><code>t</code>
     <dd><code>label</code>
</dl>

<p>The full set of 85 op&nbsp;codes is listed in the <code>libplot</code> header
file <code>plot.h</code> and the <code>libplotter</code> header file
<code>plotter.h</code>, which are distributed along with the plotting
utilities.  On&nbsp;most systems they are installed in
<code>/usr/include</code> or <code>/usr/local/include</code>.

   <p>The 10 op codes in the table above are actually the op&nbsp;codes of the
traditional `plot(5)' format produced by pre-GNU versions of
<code>graph</code> and <code>libplot</code>.  The use of these op&nbsp;codes make GNU
metafile format compatible with plot(5) format.  The absence of a magic
string, and the absence of the <code>o</code>&nbsp;and&nbsp;<code>x</code> op&nbsp;codes,
makes it possible to distinguish files in plot(5) format from GNU
metafiles in the binary encoding.  GNU <code>plot</code> can convert files in
plot(5) format to GNU metafiles in either the binary or the portable
encoding.  See <a href="#plot">plot</a>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Auxiliary%20Software">Auxiliary Software</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#History%20and%20Acknowledgements">History and Acknowledgements</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Metafiles">Metafiles</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Appendices">Appendices</a>
<br>
</div>

<h2 class="appendix">Appendix E Obtaining Auxiliary Software</h2>

<ul class="menu">
<li><a accesskey="1" href="#idraw">idraw</a>:        Obtaining the idraw drawing editor
<li><a accesskey="2" href="#xfig">xfig</a>:         Obtaining the xfig drawing editor
</ul>

<div class="node">
<p><hr>
Node:&nbsp;<a name="idraw">idraw</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#xfig">xfig</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Auxiliary%20Software">Auxiliary Software</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Auxiliary%20Software">Auxiliary Software</a>
<br>
</div>

<h3 class="section">E.1 How to get <code>idraw</code></h3>

<p>The <code>idraw</code> utility mentioned several times in this documentation
is a freely distributable interactive drawing editor for the X&nbsp;Window System.  It&nbsp;can display and edit the output of any
application that uses the Postscript Plotter support contained in GNU
<code>libplot</code>.  That includes <code>graph -T ps</code>, <code>plot -T ps</code>,
<code>pic2plot -T ps</code>, <code>tek2plot -T ps</code>, and <code>plotfont -T ps</code>.

   <p>The current version of <code>idraw</code> is maintained by Vectaport, Inc.,
and is available at <a href="http://www.vectaport.com">their Web site</a>. 
It&nbsp;is part of the <code>ivtools</code> package, which is a framework for
building custom drawing editors.  <code>idraw</code> was originally part of
the <code>InterViews</code> package, developed by Stanford University and
Silicon Graphics.  The <code>InterViews</code> package is available at
<a href="ftp://interviews.stanford.edu">a distribution site</a>, but is
no&nbsp;longer supported.  Retrieving the <code>ivtools</code> package instead
is recommended.

   <p>Also available at <a href="http://www.vectaport.com">Vectaport's Web site</a>
is an enhanced version of <code>idraw</code> called <code>drawtool</code>. 
<code>drawtool</code> can import additional graphics in TIFF and PBM/PGM/PPM
formats, besides the X11 bitmaps that <code>idraw</code> can import.

<div class="node">
<p><hr>
Node:&nbsp;<a name="xfig">xfig</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#idraw">idraw</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Auxiliary%20Software">Auxiliary Software</a>
<br>
</div>

<h3 class="section">E.2 How to get <code>xfig</code></h3>

<p>The <code>xfig</code> utility mentioned several times in this documentation is
a freely distributable interactive drawing editor for the X&nbsp;Window
System.  It&nbsp;can display and edit the output of any application that
uses the Fig Plotter support contained in GNU <code>libplot</code>.  That
includes <code>graph -T fig</code>, <code>plot -T fig</code>, <code>pic2plot -T
fig</code>, <code>tek2plot -T fig</code>, and <code>plotfont -T fig</code>.

   <p>The current version is available at
<a href="ftp://ftp.x.org/contrib/applications/drawing_tools/">ftp://ftp.x.org/contrib/applications/drawing_tools/</a>.  It can
import additional graphics in GIF, X11 bitmap, and Postscript formats. 
Accompanying the editor is a package called <code>transfig</code>, which
allows <code>xfig</code> graphics to be exported in many formats.  GIF, X11
bitmap, LaTeX, and Postscript formats are supported.

   <p>There is <a href="http://duke.usask.ca/~macphed/soft/fig">a Web page on Fig format</a>, which discusses application software that can interoperate with
<code>xfig</code>.

<div class="node">
<p><hr>
Node:&nbsp;<a name="History%20and%20Acknowledgements">History and Acknowledgements</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="#Reporting%20Bugs">Reporting Bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Auxiliary%20Software">Auxiliary Software</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Appendices">Appendices</a>
<br>
</div>

<h2 class="unnumbered">History and Acknowledgements</h2>

<p>Several of the GNU plotting utilities were inspired by Unix plotting
utilities.  A <code>graph</code> utility and various plot filters were present
in the first releases of Unix from Bell Laboratories, going at&nbsp;least
as far back as the Version&nbsp;4 distribution (1973).  The first
supported display device was a Tektronix 611 storage scope.  Most of the
work on tying the plot filters together and breaking out
device-dependent versions of <code>libplot</code> was performed by
<a href="mailto:llc@research.att.com">Lorinda Cherry</a>. 
By&nbsp;the time of Version&nbsp;7 Unix (1979) and the subsequent Berkeley
releases, the package consisting of <code>graph</code>, <code>plot</code>,
<code>spline</code>, and several device-dependent versions of <code>libplot</code>
was a standard Unix feature.  Supported devices by the early 1980's
included Tektronix storage scopes, early graphics terminals,
200dpi electrostatic printer/plotters from Versatec and Varian,
and pen plotters from Hewlett-Packard.

   <p>In 1989, <a href="mailto:rich@freebsd.org">Rich Murphey</a> wrote the first GNU
versions of <code>graph</code>, <code>plot</code>, and <code>spline</code>, and the
earliest documentation.  Richard Stallman further directed development
of the programs and provided editorial support for the documentation. 
<a href="mailto:interran@uluru.stanford.edu">John Interrante</a>, then of the
InterViews team at Stanford, generously provided the <code>idraw</code>
Postscript prologue now included in <code>libplot</code>, and helpful
comments.  The package as it stood in 1991 was distributed under the
name `GNU graphics'.

   <p>In 1995 <a href="mailto:rsm@math.arizona.edu">Robert S. Maier</a> took over
development of the package, and designed and wrote the current,
maximally device-independent, standalone version of <code>libplot</code>. 
He also rewrote <code>graph</code> from scratch, turning it into a real-time
filter that would use the new library.  He fleshed out <code>spline</code>
too, by adding support for splines in tension, periodicity, and cubic
Bessel interpolation.

   <p><code>libplot</code> now incorporates the X&nbsp;Window System code for filling
polygons and drawing wide polygonal lines and arcs.  The code is used
when producing output in bitmap formats (e.g., PNG, PNM, and
pseudo-GIF).  It&nbsp;was written by Brian Kelleher, Joel McCormack,
Todd Newman, Keith Packard, Robert Scheifler and Ken Whaley, who worked
for Digital Equipment Corp., MIT, and/or the X&nbsp;Consortium, and is
copyright &copy; 1985-89 by the X&nbsp;Consortium.

   <p>The pseudo-GIF support now in <code>libplot</code> uses the `miGIF' run-length
encoding routines developed by
<a href="mailto:mouse@rodents.montreal.qc.ca">der Maus</a> and
<a href="mailto:ivo@hasc.com">ivo</a>, which are copyright &copy; 1998
by <a href="http://www.hasc.com">Hutchison Avenue Software Corporation</a>. 
The copyright notice and permission notice for the miGIF routines
are distributed with the source code distribution of the plotting utilities.

   <p>Most development work on <code>ode</code> was performed by
<a href="mailto:nbt@reed.edu">Nick Tufillaro</a> in 1978-1994, on a sequence of
platforms that extended back to a PDP-11 running Version&nbsp;4 Unix.  In
1997 Robert Maier modified his 1994 version to agree with GNU
conventions on coding and command-line parsing, extended it to support
the full set of special functions supported by <code>gnuplot</code>, and
extended the exception handling.

   <p>Many other people aided the development of the plotting utilities
package along the way.  The Hershey vector fonts now in <code>libplot</code>
are of&nbsp;course based on the characters digitized in the mid to late
1960's by Allen&nbsp;V. Hershey, who deserves a vote of thanks. 
Additional characters and/or marker symbols were taken from the SLAC
Unified Graphics System developed by Robert&nbsp;C. Beach in the
mid-1970's, and from the fonts designed by
<a href="mailto:wolff@inf.fu-berlin.de">Thomas Wolff</a> for Ghostscript.  The
interpolation algorithms used in <code>spline</code> are based on the
algorithms of <a href="mailto:cline@cs.utexas.edu">Alan&nbsp;K. Cline</a>, as
described in his papers in the Apr. 1974 issue of <cite>Communications
of the ACM</cite>.  The table-driven parser used in <code>tek2plot</code> was
written at Berkeley in the mid-1980's by <a href="mailto:moy@parc.xerox.com">Edward Moy</a>.  The `sagitta' algorithm used in an extended form in
<code>libplot</code> for drawing circular and elliptic arcs was developed by
Peter Karow of URW and <a href="mailto:turk@apple.com">Ken Turkowski</a> of Apple. 
<a href="mailto:toy@rtp.ericsson.se">Raymond Toy</a>
helped with the tick mark
spacing code in <code>graph</code> and was the first to incorporate GNU
<code>getopt</code>.  Arthur Smith, formerly of LASSP at Cornell, provided
code for his <code>xplot</code> utility. 
<a href="mailto:beebe@math.utah.edu">Nelson Beebe</a>
exhaustively tested the package installation process.

   <p>Robert Maier wrote the documentation, which now incorporates Nick
Tufillaro's <code>ode</code> manual.  Julie Sussmann checked over the
documentation for style and clarity.

<div class="node">
<p><hr>
Node:&nbsp;<a name="Reporting%20Bugs">Reporting Bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#History%20and%20Acknowledgements">History and Acknowledgements</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Appendices">Appendices</a>
<br>
</div>

<h2 class="unnumbered">Reporting Bugs</h2>

<p>Please report all bugs in the GNU plotting utilities to
<a href="mailto:bug-gnu-utils@gnu.org">bug-gnu-utils@gnu.org</a>.  Be&nbsp;sure to say which version of the
plotting utilities package you have.  Each command-line program
announces the package version if you use the <code>--version</code> argument.

   <p>If you installed the plotting utilities from scratch, be sure to say
what compiler (and compiler version) you used.  If&nbsp;your problems
are installation-related, be sure to give all relevant information.


<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Plotutils%20Intro" href="#Plotutils%20Intro">1 The GNU Plotting Utilities</a>
<li><a name="toc_graph" href="#graph">2 The <code>graph</code> Application</a>
<ul>
<li><a href="#Simple%20Examples">2.1 Simple examples using <code>graph</code></a>
<li><a href="#Non-Square%20Plots">2.2 Non-square, displaced, and rotated plots</a>
<li><a href="#Multiple%20Datasets">2.3 Preparing a plot from more than one dataset</a>
<li><a href="#Multiplotting">2.4 Multiplotting: placing multiple plots on a single page</a>
<li><a href="#Data%20Formats">2.5 Reading binary and other data formats</a>
<li><a href="#graph%20Invocation">2.6 <code>graph</code> command-line options</a>
<ul>
<li><a href="#Plot%20Options">2.6.1 Plot options</a>
<li><a href="#Dataset%20Options">2.6.2 Dataset options</a>
<li><a href="#Multiplot%20Options">2.6.3 Multiplot options</a>
<li><a href="#Raw%20graph%20Options">2.6.4 Raw <code>graph</code> options</a>
<li><a href="#Info%20Options">2.6.5 Informational options</a>
</li></ul>
<li><a href="#graph%20Environment">2.7 Environment variables</a>
</li></ul>
<li><a name="toc_plot" href="#plot">3 The <code>plot</code> Program</a>
<ul>
<li><a href="#plot%20Examples">3.1 How to use <code>plot</code></a>
<li><a href="#plot%20Invocation">3.2 <code>plot</code> command-line options</a>
<li><a href="#plot%20Environment">3.3 Environment variables</a>
</li></ul>
<li><a name="toc_pic2plot" href="#pic2plot">4 The <code>pic2plot</code> Program</a>
<ul>
<li><a href="#pic2plot%20Introduction">4.1 What <code>pic2plot</code> is used for</a>
<li><a href="#pic2plot%20Invocation">4.2 <code>pic2plot</code> command-line options</a>
<li><a href="#pic2plot%20Environment">4.3 Environment variables</a>
</li></ul>
<li><a name="toc_tek2plot" href="#tek2plot">5 The <code>tek2plot</code> Program</a>
<ul>
<li><a href="#tek2plot%20Introduction">5.1 What <code>tek2plot</code> is used for</a>
<li><a href="#tek2plot%20Invocation">5.2 <code>tek2plot</code> command-line options</a>
<li><a href="#tek2plot%20Environment">5.3 Environment variables</a>
</li></ul>
<li><a name="toc_plotfont" href="#plotfont">6 The <code>plotfont</code> Utility</a>
<ul>
<li><a href="#plotfont%20Examples">6.1 How to use <code>plotfont</code></a>
<li><a href="#plotfont%20Invocation">6.2 <code>plotfont</code> command-line options</a>
<li><a href="#plotfont%20Environment">6.3 Environment variables</a>
</li></ul>
<li><a name="toc_spline" href="#spline">7 The <code>spline</code> Program</a>
<ul>
<li><a href="#spline%20Examples">7.1 How to use <code>spline</code></a>
<li><a href="#Advanced%20Use%20of%20spline">7.2 Advanced use of <code>spline</code></a>
<li><a href="#spline%20Invocation">7.3 <code>spline</code> command-line options</a>
</li></ul>
<li><a name="toc_ode" href="#ode">8 The <code>ode</code> Program</a>
<ul>
<li><a href="#Basic%20Math">8.1 Mathematical basics</a>
<li><a href="#Simple%20ode%20Examples">8.2 Simple examples using <code>ode</code></a>
<li><a href="#Additional%20ode%20Examples">8.3 Additional examples using <code>ode</code></a>
<li><a href="#ode%20Invocation">8.4 <code>ode</code> command-line options</a>
<li><a href="#Diagnostics">8.5 Diagnostic messages</a>
<li><a href="#Numerical%20Error">8.6 Numerical error and how to avoid it</a>
<li><a href="#Running%20Time">8.7 Running time</a>
<li><a href="#Input%20Language">8.8 The <code>ode</code> input language formally specified</a>
<li><a href="#ODE%20Bibliography">8.9 Bibliography on <code>ode</code> and solving differential equations</a>
</li></ul>
<li><a name="toc_libplot" href="#libplot">9 <code>libplot</code>, a 2-D Vector Graphics Library</a>
<ul>
<li><a href="#libplot%20Overview">9.1 Programming with <code>libplot</code>: An overview</a>
<li><a href="#C%20Programming">9.2 C Programming with <code>libplot</code></a>
<ul>
<li><a href="#The%20C%20API">9.2.1 The C application programming interface</a>
<li><a href="#Older%20C%20APIs">9.2.2 Older C application programming interfaces</a>
<li><a href="#C%20Compiling%20and%20Linking">9.2.3 C compiling and linking</a>
<li><a href="#Sample%20C%20Drawings">9.2.4 Sample drawings in C</a>
<li><a href="#Paths%20and%20Subpaths">9.2.5 Simple paths and compound paths</a>
<li><a href="#Drawing%20on%20a%20Page">9.2.6 Drawing on a physical page</a>
<li><a href="#Animated%20GIFs">9.2.7 Animated GIFs in C</a>
<li><a href="#X%20Animations">9.2.8 X Window System animations in C</a>
<li><a href="#X%20Programming">9.2.9 Advanced X Window System programming</a>
</li></ul>
<li><a href="#C++%20Programming">9.3 C++ Programming with <code>libplotter</code></a>
<ul>
<li><a href="#The%20Plotter%20Class">9.3.1 The <code>Plotter</code> class</a>
<li><a href="#C++%20Compiling%20and%20Linking">9.3.2 C++ compiling and linking</a>
<li><a href="#Sample%20C++%20Drawings">9.3.3 Sample drawings in C++</a>
</li></ul>
<li><a href="#Functions">9.4 The functions in <code>libplot</code>: A detailed listing</a>
<ul>
<li><a href="#Control%20Functions">9.4.1 Control functions</a>
<li><a href="#Drawing%20Functions">9.4.2 Object-drawing functions</a>
<li><a href="#Attribute%20Functions">9.4.3 Attribute-setting functions</a>
<li><a href="#Mapping%20Functions">9.4.4 Mapping functions</a>
</li></ul>
<li><a href="#Plotter%20Parameters">9.5 Plotter parameters</a>
</li></ul>
<li><a name="toc_Text%20and%20Markers" href="#Text%20and%20Markers">Appendix A Fonts, Strings, and Symbols</a>
<ul>
<li><a href="#Text%20Fonts">A.1 Available text fonts</a>
<li><a href="#Cyrillic%20and%20Japanese">A.2 Cyrillic and Japanese fonts</a>
<li><a href="#Text%20Fonts%20in%20X">A.3 Available text fonts for the X Window System</a>
<li><a href="#Text%20String%20Format">A.4 Text string format and escape sequences</a>
<li><a href="#Marker%20Symbols">A.5 Available marker symbols</a>
</li></ul>
<li><a name="toc_Color%20Names" href="#Color%20Names">Appendix B Specifying Colors by Name</a>
<li><a name="toc_Page%20and%20Viewport%20Sizes" href="#Page%20and%20Viewport%20Sizes">Appendix C Page Sizes and Viewport Sizes</a>
<li><a name="toc_Metafiles" href="#Metafiles">Appendix D The Graphics Metafile Format</a>
<li><a name="toc_Auxiliary%20Software" href="#Auxiliary%20Software">Appendix E Obtaining Auxiliary Software</a>
<ul>
<li><a href="#idraw">E.1 How to get <code>idraw</code></a>
<li><a href="#xfig">E.2 How to get <code>xfig</code></a>
</li></ul>
<li><a name="toc_History%20and%20Acknowledgements" href="#History%20and%20Acknowledgements">History and Acknowledgements</a>
<li><a name="toc_Reporting%20Bugs" href="#Reporting%20Bugs">Reporting Bugs</a>
</li></ul>
</div>

   </body></html>

