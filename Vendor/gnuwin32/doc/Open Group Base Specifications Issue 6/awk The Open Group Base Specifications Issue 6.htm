<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0064)http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html -->
<HTML><HEAD><TITLE>awk</TITLE>
<META content="MSHTML 6.00.2900.2523" name=GENERATOR>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="awk_bestanden/style.css" type=text/css rel=stylesheet><!-- Generated by The Open Group's rhtm tool v1.2.1 --><!-- Copyright (c) 2001-2004 IEEE and The Open Group, All Rights Reserved --></HEAD>
<BODY bgColor=white>
<SCRIPT language=JavaScript src="awk_bestanden/codes.js" 
type=text/javascript>
</SCRIPT>
<BASEFONT><A name=awk></A><A name=tag_04_06></A><!-- awk --><!--header start-->
<CENTER><FONT size=2>The Open Group Base Specifications Issue 6<BR>IEEE Std 
1003.1, 2004 Edition<BR>Copyright © 2001-2004 The IEEE and The Open Group, All 
Rights reserved.</FONT></CENTER><!--header end-->
<HR noShade SIZE=2>

<H4><A name=tag_04_06_01></A>NAME</H4>
<BLOCKQUOTE>awk - pattern scanning and processing language</BLOCKQUOTE>
<H4><A name=tag_04_06_02></A>SYNOPSIS</H4>
<BLOCKQUOTE class=synopsis>
  <P><CODE><TT>awk</TT> <B>[</B><TT>-F</TT> <I>ERE</I><B>][</B><TT>-v</TT> 
  <I>assignment</I><B>]</B> <TT>...</TT> <I>program</I> <B>[</B><I>argument</I> 
  <TT>...</TT><B>]</B><TT><BR><BR>awk</TT> <B>[</B><TT>-F</TT> 
  <I>ERE</I><B>]</B> <TT>-f</TT> <I>progfile</I> <TT>...</TT> 
  <B>[</B><TT>-v</TT> <I>assignment</I><B>]</B> 
  <TT>...</TT><B>[</B><I>argument</I> 
  <TT>...</TT><B>]</B><TT><BR></TT></CODE></P></BLOCKQUOTE>
<H4><A name=tag_04_06_03></A>DESCRIPTION</H4>
<BLOCKQUOTE>
  <P>The <I>awk</I> utility shall execute programs written in the <I>awk</I> 
  programming language, which is specialized for textual data manipulation. An 
  <I>awk</I> program is a sequence of patterns and corresponding actions. When 
  input is read that matches a pattern, the action associated with that pattern 
  is carried out.</P>
  <P>Input shall be interpreted as a sequence of records. By default, a record 
  is a line, less its terminating &lt;newline&gt;, but this can be changed by 
  using the <B>RS</B> built-in variable. Each record of input shall be matched 
  in turn against each pattern in the program. For each pattern matched, the 
  associated action shall be executed.</P>
  <P>The <I>awk</I> utility shall interpret each input record as a sequence of 
  fields where, by default, a field is a string of non- &lt;blank&gt;s. This 
  default white-space field delimiter can be changed by using the <B>FS</B> 
  built-in variable or <B>-F</B> <I>ERE</I>. The <I>awk</I> utility shall denote 
  the first field in a record $1, the second $2, and so on. The symbol $0 shall 
  refer to the entire record; setting any other field causes the re-evaluation 
  of $0. Assigning to $0 shall reset the values of all other fields and the 
  <B>NF</B> built-in variable.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_04></A>OPTIONS</H4>
<BLOCKQUOTE>
  <P>The <I>awk</I> utility shall conform to the Base Definitions volume of 
  IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html#tag_12_02">Section 
  12.2, Utility Syntax Guidelines</A>.</P>
  <P>The following options shall be supported:</P>
  <DL compact>
    <DT><B>-F&nbsp;</B> <I>ERE</I> 
    <DD>Define the input field separator to be the extended regular expression 
    <I>ERE</I>, before any input is read; see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_04">Regular 
    Expressions</A>. 
    <DT><B>-f&nbsp;</B> <I>progfile</I> 
    <DD>Specify the pathname of the file <I>progfile</I> containing an 
    <I>awk</I> program. If multiple instances of this option are specified, the 
    concatenation of the files specified as <I>progfile</I> in the order 
    specified shall be the <I>awk</I> program. The <I>awk</I> program can 
    alternatively be specified in the command line as a single argument. 
    <DT><B>-v&nbsp;</B> <I>assignment</I> 
    <DD>The application shall ensure that the <I>assignment</I> argument is in 
    the same form as an <I>assignment</I> operand. The specified variable 
    assignment shall occur prior to executing the <I>awk</I> program, including 
    the actions associated with <B>BEGIN</B> patterns (if any). Multiple 
    occurrences of this option can be specified. </DD></DL></BLOCKQUOTE>
<H4><A name=tag_04_06_05></A>OPERANDS</H4>
<BLOCKQUOTE>
  <P>The following operands shall be supported:</P>
  <DL compact>
    <DT><I>program</I> 
    <DD>If no <B>-f</B> option is specified, the first operand to <I>awk</I> 
    shall be the text of the <I>awk</I> program. The application shall supply 
    the <I>program</I> operand as a single argument to <I>awk</I>. If the text 
    does not end in a &lt;newline&gt;, <I>awk</I> shall interpret the text as if 
    it did. 
    <DT><I>argument</I> 
    <DD>Either of the following two types of <I>argument</I> can be intermixed: 
    <DL compact>
      <DT><I>file</I> 
      <DD>A pathname of a file that contains the input to be read, which is 
      matched against the set of patterns in the program. If no <I>file</I> 
      operands are specified, or if a <I>file</I> operand is <TT>'-'</TT>, the 
      standard input shall be used. 
      <DT><I>assignment</I> 
      <DD>An operand that begins with an underscore or alphabetic character from 
      the portable character set (see the table in the Base Definitions volume 
      of IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
      href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap06.html#tag_06_01">Section 
      6.1, Portable Character Set</A>), followed by a sequence of underscores, 
      digits, and alphabetics from the portable character set, followed by the 
      <TT>'='</TT> character, shall specify a variable assignment rather than a 
      pathname. The characters before the <TT>'='</TT> represent the name of an 
      <I>awk</I> variable; if that name is an <I>awk</I> reserved word (see <A 
      href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>) 
      the behavior is undefined. The characters following the equal sign shall 
      be interpreted as if they appeared in the <I>awk</I> program preceded and 
      followed by a double-quote ( <TT>' )'</TT> character, as a <B>STRING</B> 
      token (see <A 
      href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>), 
      except that if the last character is an unescaped backslash, it shall be 
      interpreted as a literal backslash rather than as the first character of 
      the sequence <TT>"\""</TT>. The variable shall be assigned the value of 
      that <B>STRING</B> token and, if appropriate, shall be considered a 
      <I>numeric string</I> (see <A 
      href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
      in awk</A>), the variable shall also be assigned its numeric value. Each 
      such variable assignment shall occur just prior to the processing of the 
      following <I>file</I>, if any. Thus, an assignment before the first 
      <I>file</I> argument shall be executed after the <B>BEGIN</B> actions (if 
      any), while an assignment after the last <I>file</I> argument shall occur 
      before the <B>END</B> actions (if any). If there are no <I>file</I> 
      arguments, assignments shall be executed before processing the standard 
      input. </DD></DL></DD></DL></BLOCKQUOTE>
<H4><A name=tag_04_06_06></A>STDIN</H4>
<BLOCKQUOTE>
  <P>The standard input shall be used only if no <I>file</I> operands are 
  specified, or if a <I>file</I> operand is <TT>'-'</TT> ; see the INPUT FILES 
  section. If the <I>awk</I> program contains no actions and no patterns, but is 
  otherwise a valid <I>awk</I> program, standard input and any <I>file</I> 
  operands shall not be read and <I>awk</I> shall exit with a return status of 
  zero.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_07></A>INPUT FILES</H4>
<BLOCKQUOTE>
  <P>Input files to the <I>awk</I> program from any of the following sources 
  shall be text files:</P>
  <UL>
    <LI>
    <P>Any <I>file</I> operands or their equivalents, achieved by modifying the 
    <I>awk</I> variables <B>ARGV</B> and <B>ARGC</B></P>
    <LI>
    <P>Standard input in the absence of any <I>file</I> operands</P>
    <LI>
    <P>Arguments to the <B>getline</B> function</P></LI></UL>
  <P>Whether the variable <B>RS</B> is set to a value other than a 
  &lt;newline&gt; or not, for these files, implementations shall support records 
  terminated with the specified separator up to {LINE_MAX} bytes and may support 
  longer records.</P>
  <P>If <B>-f</B> <I>progfile</I> is specified, the application shall ensure 
  that the files named by each of the <I>progfile</I> option-arguments are text 
  files and their concatenation, in the same order as they appear in the 
  arguments, is an <I>awk</I> program.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_08></A>ENVIRONMENT VARIABLES</H4>
<BLOCKQUOTE>
  <P>The following environment variables shall affect the execution of 
  <I>awk</I>:</P>
  <DL compact>
    <DT><I>LANG</I> 
    <DD>Provide a default value for the internationalization variables that are 
    unset or null. (See the Base Definitions volume of 
    IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
    href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html#tag_08_02">Section 
    8.2, Internationalization Variables</A> for the precedence of 
    internationalization variables used to determine the values of locale 
    categories.) 
    <DT><I>LC_ALL</I> 
    <DD>If set to a non-empty string value, override the values of all the other 
    internationalization variables. 
    <DT><I>LC_COLLATE</I> 
    <DD>Determine the locale for the behavior of ranges, equivalence classes, 
    and multi-character collating elements within regular expressions and in 
    comparisons of string values. 
    <DT><I>LC_CTYPE</I> 
    <DD>Determine the locale for the interpretation of sequences of bytes of 
    text data as characters (for example, single-byte as opposed to multi-byte 
    characters in arguments and input files), the behavior of character classes 
    within regular expressions, the identification of characters as letters, and 
    the mapping of uppercase and lowercase characters for the <B>toupper</B> and 
    <B>tolower</B> functions. 
    <DT><I>LC_MESSAGES</I> 
    <DD>Determine the locale that should be used to affect the format and 
    contents of diagnostic messages written to standard error. 
    <DT><I>LC_NUMERIC</I> 
    <DD>Determine the radix character used when interpreting numeric input, 
    performing conversions between numeric and string values, and formatting 
    numeric output. Regardless of locale, the period character (the 
    decimal-point character of the POSIX locale) is the decimal-point character 
    recognized in processing <I>awk</I> programs (including assignments in 
    command line arguments). 
    <DT><I>NLSPATH</I> 
    <DD><SUP>[<A href="javascript:open_code('XSI')">XSI</A>]</SUP> <IMG 
    alt="[Option Start]" src="awk_bestanden/opt-start.gif" border=0> Determine 
    the location of message catalogs for the processing of <I>LC_MESSAGES .</I> 
    <IMG alt="[Option End]" src="awk_bestanden/opt-end.gif" border=0> 
    <DT><I>PATH</I> 
    <DD>Determine the search path when looking for commands executed by 
    <I>system</I>(<I>expr</I>), or input and output pipes; see the Base 
    Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
    href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html">Chapter 
    8, Environment Variables</A>. </DD></DL>
  <P>In addition, all environment variables shall be visible via the <I>awk</I> 
  variable <B>ENVIRON</B>.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_09></A>ASYNCHRONOUS EVENTS</H4>
<BLOCKQUOTE>
  <P>Default.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_10></A>STDOUT</H4>
<BLOCKQUOTE>
  <P>The nature of the output files depends on the <I>awk</I> 
program.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_11></A>STDERR</H4>
<BLOCKQUOTE>
  <P>The standard error shall be used only for diagnostic 
messages.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_12></A>OUTPUT FILES</H4>
<BLOCKQUOTE>
  <P>The nature of the output files depends on the <I>awk</I> 
program.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_13></A>EXTENDED DESCRIPTION</H4>
<BLOCKQUOTE>
  <H5><A name=tag_04_06_13_01></A>Overall Program Structure</H5>
  <P>An <I>awk</I> program is composed of pairs of the form:</P><PRE><I>pattern</I> <TT>{</TT> <I>action</I> <TT>}
</TT>
</PRE>
  <P>Either the pattern or the action (including the enclosing brace characters) 
  can be omitted.</P>
  <P>A missing pattern shall match any record of input, and a missing action 
  shall be equivalent to:</P><PRE><TT>{ print }
</TT>
</PRE>
  <P>Execution of the <I>awk</I> program shall start by first executing the 
  actions associated with all <B>BEGIN</B> patterns in the order they occur in 
  the program. Then each <I>file</I> operand (or standard input if no files were 
  specified) shall be processed in turn by reading data from the file until a 
  record separator is seen ( &lt;newline&gt; by default). Before the first 
  reference to a field in the record is evaluated, the record shall be split 
  into fields, according to the rules in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_04">Regular 
  Expressions</A> , using the value of <B>FS</B> that was current at the time 
  the record was read. Each pattern in the program then shall be evaluated in 
  the order of occurrence, and the action associated with each pattern that 
  matches the current record executed. The action for a matching pattern shall 
  be executed before evaluating subsequent patterns. Finally, the actions 
  associated with all <B>END</B> patterns shall be executed in the order they 
  occur in the program.</P>
  <H5><A name=tag_04_06_13_02></A>Expressions in awk</H5>
  <P>Expressions describe computations used in <I>patterns</I> and 
  <I>actions</I>. In the following table, valid expression operations are given 
  in groups from highest precedence first to lowest precedence last, with 
  equal-precedence operators grouped between horizontal lines. In expression 
  evaluation, where the grammar is formally ambiguous, higher precedence 
  operators shall be evaluated before lower precedence operators. In this table 
  <I>expr</I>, <I>expr1</I>, <I>expr2</I>, and <I>expr3</I> represent any 
  expression, while lvalue represents any entity that can be assigned to (that 
  is, on the left side of an assignment operator). The precise syntax of 
  expressions is given in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>.</P>
  <CENTER><A name=tagtcjh_10></A><B>Table: Expressions in Decreasing Precedence 
  in <I>awk</I></B></CENTER>
  <CENTER>
  <TABLE cellPadding=3 align=center border=1>
    <TBODY>
    <TR vAlign=top>
      <TH align=middle>
        <P class=tent><B>Syntax</B></P></TH>
      <TH align=middle>
        <P class=tent><B>Name</B></P></TH>
      <TH align=middle>
        <P class=tent><B>Type of Result</B></P></TH>
      <TH align=middle>
        <P class=tent><B>Associativity</B></P></TH></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>( <I>expr</I> )</P></TD>
      <TD align=left>
        <P class=tent>Grouping</P></TD>
      <TD align=left>
        <P class=tent>Type of <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>$<I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Field reference</P></TD>
      <TD align=left>
        <P class=tent>String</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>++ lvalue</P></TD>
      <TD align=left>
        <P class=tent>Pre-increment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>-- lvalue</P></TD>
      <TD align=left>
        <P class=tent>Pre-decrement</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue ++</P></TD>
      <TD align=left>
        <P class=tent>Post-increment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue --</P></TD>
      <TD align=left>
        <P class=tent>Post-decrement</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> ^ <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Exponentiation</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>! <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Logical not</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>+ <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Unary plus</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>- <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Unary minus</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>N/A</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> * <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Multiplication</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> / <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Division</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> % <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Modulus</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> + <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Addition</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> - <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Subtraction</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>String concatenation</P></TD>
      <TD align=left>
        <P class=tent>String</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> &lt; <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Less than</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> &lt;= <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Less than or equal to</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> != <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Not equal to</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> == <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Equal to</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> &gt; <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Greater than</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> &gt;= <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Greater than or equal to</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> ˜ <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>ERE match</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> !˜ <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>ERE non-match</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>None</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> in array</P></TD>
      <TD align=left>
        <P class=tent>Array membership</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>( <I>index</I> ) in <I>array</I></P></TD>
      <TD align=left>
        <P class=tent>Multi-dimension array</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>&nbsp;</P></TD>
      <TD align=left>
        <P class=tent>membership</P></TD>
      <TD align=left>
        <P class=tent>&nbsp;</P></TD>
      <TD align=left>
        <P class=tent>&nbsp;</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> &amp;&amp; <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Logical AND</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr</I> || <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Logical OR</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Left</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent><I>expr1</I> ? <I>expr2</I> : <I>expr3</I></P></TD>
      <TD align=left>
        <P class=tent>Conditional expression</P></TD>
      <TD align=left>
        <P class=tent>Type of selected</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>&nbsp;</P></TD>
      <TD align=left>
        <P class=tent>&nbsp;</P></TD>
      <TD align=left>
        <P class=tent><I>expr2</I> or <I>expr3</I></P></TD>
      <TD align=left>
        <P class=tent>&nbsp;</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue ^= <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Exponentiation assignment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue %= <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Modulus assignment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue *= <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Multiplication assignment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue /= <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Division assignment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue += <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Addition assignment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue -= <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Subtraction assignment</P></TD>
      <TD align=left>
        <P class=tent>Numeric</P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>lvalue = <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Assignment</P></TD>
      <TD align=left>
        <P class=tent>Type of <I>expr</I></P></TD>
      <TD align=left>
        <P class=tent>Right</P></TD></TR></TBODY></TABLE></CENTER>
  <P>Each expression shall have either a string value, a numeric value, or both. 
  Except as stated for specific contexts, the value of an expression shall be 
  implicitly converted to the type needed for the context in which it is used. A 
  string value shall be converted to a numeric value by the equivalent of the 
  following calls to functions defined by the ISO&nbsp;C standard:</P><PRE><TT>setlocale(LC_NUMERIC, "");
</TT><I>numeric_value</I> <TT>= atof(</TT><I>string_value</I><TT>);
</TT>
</PRE>
  <P>A numeric value that is exactly equal to the value of an integer (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_07_02"><I>Concepts 
  Derived from the ISO C Standard</I></A>) shall be converted to a string by the 
  equivalent of a call to the <B>sprintf</B> function (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_13">String 
  Functions</A>) with the string <TT>"%d"</TT> as the <I>fmt</I> argument and 
  the numeric value being converted as the first and only <I>expr</I> argument. 
  Any other numeric value shall be converted to a string by the equivalent of a 
  call to the <B>sprintf</B> function with the value of the variable 
  <B>CONVFMT</B> as the <I>fmt</I> argument and the numeric value being 
  converted as the first and only <I>expr</I> argument. The result of the 
  conversion is unspecified if the value of <B>CONVFMT</B> is not a 
  floating-point format specification. This volume of 
  IEEE&nbsp;Std&nbsp;1003.1-2001 specifies no explicit conversions between 
  numbers and strings. An application can force an expression to be treated as a 
  number by adding zero to it, or can force it to be treated as a string by 
  concatenating the null string ( <TT>""</TT> ) to it.</P>
  <P>A string value shall be considered a <I>numeric string</I> if it comes from 
  one of the following:</P>
  <OL>
    <LI>
    <P>Field variables</P>
    <LI>
    <P>Input from the <I>getline</I>() function</P>
    <LI>
    <P><B>FILENAME</B></P>
    <LI>
    <P><B>ARGV</B> array elements</P>
    <LI>
    <P><B>ENVIRON</B> array elements</P>
    <LI>
    <P>Array elements created by the <I>split</I>() function</P>
    <LI>
    <P>A command line variable assignment</P>
    <LI>
    <P>Variable assignment from another numeric string variable</P></LI></OL>
  <P>and after all the following conversions have been applied, the resulting 
  string would lexically be recognized as a <B>NUMBER</B> token as described by 
  the lexical conventions in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A> 
  :</P>
  <UL>
    <LI>
    <P>All leading and trailing &lt;blank&gt;s are discarded.</P>
    <LI>
    <P>If the first non- &lt;blank&gt; is <TT>'+'</TT> or <TT>'-'</TT>, it is 
    discarded.</P>
    <LI>
    <P>Changing each occurrence of the decimal point character from the current 
    locale to a period.</P></LI></UL>
  <P>If a <TT>'-'</TT> character is ignored in the preceding description, the 
  numeric value of the <I>numeric string</I> shall be the negation of the 
  numeric value of the recognized <B>NUMBER</B> token. Otherwise, the numeric 
  value of the <I>numeric string</I> shall be the numeric value of the 
  recognized <B>NUMBER</B> token. Whether or not a string is a <I>numeric 
  string</I> shall be relevant only in contexts where that term is used in this 
  section.</P>
  <P>When an expression is used in a Boolean context, if it has a numeric value, 
  a value of zero shall be treated as false and any other value shall be treated 
  as true. Otherwise, a string value of the null string shall be treated as 
  false and any other value shall be treated as true. A Boolean context shall be 
  one of the following:</P>
  <UL>
    <LI>
    <P>The first subexpression of a conditional expression</P>
    <LI>
    <P>An expression operated on by logical NOT, logical AND, or logical OR</P>
    <LI>
    <P>The second expression of a <B>for</B> statement</P>
    <LI>
    <P>The expression of an <B>if</B> statement</P>
    <LI>
    <P>The expression of the <B>while</B> clause in either a <B>while</B> or 
    <B>do</B>... <B>while</B> statement</P>
    <LI>
    <P>An expression used as a pattern (as in Overall Program 
  Structure)</P></LI></UL>
  <P>All arithmetic shall follow the semantics of floating-point arithmetic as 
  specified by the ISO&nbsp;C standard (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_07_02"><I>Concepts 
  Derived from the ISO C Standard</I></A>).</P>
  <P>The value of the expression:</P><PRE><I>expr1</I> <TT>^</TT> <I>expr2</I>
</PRE>
  <P>shall be equivalent to the value returned by the ISO&nbsp;C standard 
  function call:</P><PRE><TT>pow(</TT><I>expr1</I><TT>,</TT> <I>expr2</I><TT>)
</TT>
</PRE>
  <P>The expression:</P><PRE><TT>lvalue ^=</TT> <I>expr</I>
</PRE>
  <P>shall be equivalent to the ISO&nbsp;C standard expression:</P><PRE><TT>lvalue = pow(lvalue,</TT> <I>expr</I><TT>)
</TT>
</PRE>
  <P>except that lvalue shall be evaluated only once. The value of the 
  expression:</P><PRE><I>expr1</I> <TT>%</TT> <I>expr2</I>
</PRE>
  <P>shall be equivalent to the value returned by the ISO&nbsp;C standard 
  function call:</P><PRE><TT>fmod(</TT><I>expr1</I><TT>,</TT> <I>expr2</I><TT>)
</TT>
</PRE>
  <P>The expression:</P><PRE><TT>lvalue %=</TT> <I>expr</I>
</PRE>
  <P>shall be equivalent to the ISO&nbsp;C standard expression:</P><PRE><TT>lvalue = fmod(lvalue,</TT> <I>expr</I><TT>)
</TT>
</PRE>
  <P>except that lvalue shall be evaluated only once.</P>
  <P>Variables and fields shall be set by the assignment statement:</P><PRE><TT>lvalue =</TT> <I>expression</I>
</PRE>
  <P>and the type of <I>expression</I> shall determine the resulting variable 
  type. The assignment includes the arithmetic assignments ( <TT>"+="</TT>, 
  <TT>"-="</TT>, <TT>"*="</TT>, <TT>"/="</TT>, <TT>"%="</TT>, <TT>"^="</TT>, 
  <TT>"++"</TT>, <TT>"--"</TT> ) all of which shall produce a numeric result. 
  The left-hand side of an assignment and the target of increment and decrement 
  operators can be one of a variable, an array with index, or a field 
  selector.</P>
  <P>The <I>awk</I> language supplies arrays that are used for storing numbers 
  or strings. Arrays need not be declared. They shall initially be empty, and 
  their sizes shall change dynamically. The subscripts, or element identifiers, 
  are strings, providing a type of associative array capability. An array name 
  followed by a subscript within square brackets can be used as an lvalue and 
  thus as an expression, as described in the grammar; see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>. 
  Unsubscripted array names can be used in only the following contexts:</P>
  <UL>
    <LI>
    <P>A parameter in a function definition or function call</P>
    <LI>
    <P>The <B>NAME</B> token following any use of the keyword <B>in</B> as 
    specified in the grammar (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>); 
    if the name used in this context is not an array name, the behavior is 
    undefined</P></LI></UL>
  <P>A valid array <I>index</I> shall consist of one or more comma-separated 
  expressions, similar to the way in which multi-dimensional arrays are indexed 
  in some programming languages. Because <I>awk</I> arrays are really 
  one-dimensional, such a comma-separated list shall be converted to a single 
  string by concatenating the string values of the separate expressions, each 
  separated from the other by the value of the <B>SUBSEP</B> variable. Thus, the 
  following two index operations shall be equivalent:</P><PRE><I>var</I><B>[</B><I>expr1</I><TT>,</TT> <I>expr2</I><TT>, ...</TT> <I>exprn</I><B>]
<BR>
</B><I>var</I><B>[</B><I>expr1</I> <TT>SUBSEP</TT> <I>expr2</I> <TT>SUBSEP ... SUBSEP</TT> <I>exprn</I><B>]</B>
</PRE>
  <P>The application shall ensure that a multi-dimensioned <I>index</I> used 
  with the <B>in</B> operator is parenthesized. The <B>in</B> operator, which 
  tests for the existence of a particular array element, shall not cause that 
  element to exist. Any other reference to a nonexistent array element shall 
  automatically create it.</P>
  <P>Comparisons (with the <TT>'&lt;'</TT>, <TT>"&lt;="</TT>, <TT>"!="</TT>, 
  <TT>"=="</TT>, <TT>'&gt;'</TT>, and <TT>"&gt;="</TT> operators) shall be made 
  numerically if both operands are numeric, if one is numeric and the other has 
  a string value that is a numeric string, or if one is numeric and the other 
  has the uninitialized value. Otherwise, operands shall be converted to strings 
  as required and a string comparison shall be made using the locale-specific 
  collation sequence. The value of the comparison expression shall be 1 if the 
  relation is true, or 0 if the relation is false.</P>
  <H5><A name=tag_04_06_13_03></A>Variables and Special Variables</H5>
  <P>Variables can be used in an <I>awk</I> program by referencing them. With 
  the exception of function parameters (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_15">User-Defined 
  Functions</A>), they are not explicitly declared. Function parameter names 
  shall be local to the function; all other variable names shall be global. The 
  same name shall not be used as both a function parameter name and as the name 
  of a function or a special <I>awk</I> variable. The same name shall not be 
  used both as a variable name with global scope and as the name of a function. 
  The same name shall not be used within the same scope both as a scalar 
  variable and as an array. Uninitialized variables, including scalar variables, 
  array elements, and field variables, shall have an uninitialized value. An 
  uninitialized value shall have both a numeric value of zero and a string value 
  of the empty string. Evaluation of variables with an uninitialized value, to 
  either string or numeric, shall be determined by the context in which they are 
  used.</P>
  <P>Field variables shall be designated by a <TT>'$'</TT> followed by a number 
  or numerical expression. The effect of the field number <I>expression</I> 
  evaluating to anything other than a non-negative integer is unspecified; 
  uninitialized variables or string values need not be converted to numeric 
  values in this context. New field variables can be created by assigning a 
  value to them. References to nonexistent fields (that is, fields after 
  $<B>NF</B>), shall evaluate to the uninitialized value. Such references shall 
  not create new fields. However, assigning to a nonexistent field (for example, 
  $(<B>NF</B>+2)=5) shall increase the value of <B>NF</B>; create any 
  intervening fields with the uninitialized value; and cause the value of $0 to 
  be recomputed, with the fields being separated by the value of <B>OFS</B>. 
  Each field variable shall have a string value or an uninitialized value when 
  created. Field variables shall have the uninitialized value when created from 
  $0 using <B>FS</B> and the variable does not contain any characters. If 
  appropriate, the field variable shall be considered a numeric string (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
  in awk</A>).</P>
  <P>Implementations shall support the following other special variables that 
  are set by <I>awk</I>:</P>
  <DL compact>
    <DT><B>ARGC</B> 
    <DD>The number of elements in the <B>ARGV</B> array. 
    <DT><B>ARGV</B> 
    <DD>An array of command line arguments, excluding options and the 
    <I>program</I> argument, numbered from zero to <B>ARGC</B>-1. 
    <P>The arguments in <B>ARGV</B> can be modified or added to; <B>ARGC</B> can 
    be altered. As each input file ends, <I>awk</I> shall treat the next 
    non-null element of <B>ARGV</B>, up to the current value of <B>ARGC</B>-1, 
    inclusive, as the name of the next input file. Thus, setting an element of 
    <B>ARGV</B> to null means that it shall not be treated as an input file. The 
    name <TT>'-'</TT> indicates the standard input. If an argument matches the 
    format of an <I>assignment</I> operand, this argument shall be treated as an 
    <I>assignment</I> rather than a <I>file</I> argument.</P>
    <DT><B>CONVFMT</B> 
    <DD>The <B>printf</B> format for converting numbers to strings (except for 
    output statements, where <B>OFMT</B> is used); <TT>"%.6g"</TT> by default. 
    <DT><B>ENVIRON</B> 
    <DD>An array representing the value of the environment, as described in the 
    <I>exec</I> functions defined in the System Interfaces volume of 
    IEEE&nbsp;Std&nbsp;1003.1-2001. The indices of the array shall be strings 
    consisting of the names of the environment variables, and the value of each 
    array element shall be a string consisting of the value of that variable. If 
    appropriate, the environment variable shall be considered a <I>numeric 
    string</I> (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
    in awk</A>); the array element shall also have its numeric value. 
    <P>In all cases where the behavior of <I>awk</I> is affected by environment 
    variables (including the environment of any commands that <I>awk</I> 
    executes via the <B>system</B> function or via pipeline redirections with 
    the <B>print</B> statement, the <B>printf</B> statement, or the 
    <B>getline</B> function), the environment used shall be the environment at 
    the time <I>awk</I> began executing; it is implementation-defined whether 
    any modification of <B>ENVIRON</B> affects this environment.</P>
    <DT><B>FILENAME</B> 
    <DD>A pathname of the current input file. Inside a <B>BEGIN</B> action the 
    value is undefined. Inside an <B>END</B> action the value shall be the name 
    of the last input file processed. 
    <DT><B>FNR</B> 
    <DD>The ordinal number of the current record in the current file. Inside a 
    <B>BEGIN</B> action the value shall be zero. Inside an <B>END</B> action the 
    value shall be the number of the last record processed in the last file 
    processed. 
    <DT><B>FS</B> 
    <DD>Input field separator regular expression; a &lt;space&gt; by default. 
    <DT><B>NF</B> 
    <DD>The number of fields in the current record. Inside a <B>BEGIN</B> 
    action, the use of <B>NF</B> is undefined unless a <B>getline</B> function 
    without a <I>var</I> argument is executed previously. Inside an <B>END</B> 
    action, <B>NF</B> shall retain the value it had for the last record read, 
    unless a subsequent, redirected, <B>getline</B> function without a 
    <I>var</I> argument is performed prior to entering the <B>END</B> action. 
    <DT><B>NR</B> 
    <DD>The ordinal number of the current record from the start of input. Inside 
    a <B>BEGIN</B> action the value shall be zero. Inside an <B>END</B> action 
    the value shall be the number of the last record processed. 
    <DT><B>OFMT</B> 
    <DD>The <B>printf</B> format for converting numbers to strings in output 
    statements (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_10">Output 
    Statements</A>); <TT>"%.6g"</TT> by default. The result of the conversion is 
    unspecified if the value of <B>OFMT</B> is not a floating-point format 
    specification. 
    <DT><B>OFS</B> 
    <DD>The <B>print</B> statement output field separation; &lt;space&gt; by 
    default. 
    <DT><B>ORS</B> 
    <DD>The <B>print</B> statement output record separator; a &lt;newline&gt; by 
    default. 
    <DT><B>RLENGTH</B> 
    <DD>The length of the string matched by the <B>match</B> function. 
    <DT><B>RS</B> 
    <DD>The first character of the string value of <B>RS</B> shall be the input 
    record separator; a &lt;newline&gt; by default. If <B>RS</B> contains more 
    than one character, the results are unspecified. If <B>RS</B> is null, then 
    records are separated by sequences consisting of a &lt;newline&gt; plus one 
    or more blank lines, leading or trailing blank lines shall not result in 
    empty records at the beginning or end of the input, and a &lt;newline&gt; 
    shall always be a field separator, no matter what the value of <B>FS</B> is. 

    <DT><B>RSTART</B> 
    <DD>The starting position of the string matched by the <B>match</B> 
    function, numbering from 1. This shall always be equivalent to the return 
    value of the <B>match</B> function. 
    <DT><B>SUBSEP</B> 
    <DD>The subscript separator string for multi-dimensional arrays; the default 
    value is implementation-defined. </DD></DL>
  <H5><A name=tag_04_06_13_04></A>Regular Expressions</H5>
  <P>The <I>awk</I> utility shall make use of the extended regular expression 
  notation (see the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, 
  <A 
  href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html#tag_09_04">Section 
  9.4, Extended Regular Expressions</A>) except that it shall allow the use of 
  C-language conventions for escaping special characters within the EREs, as 
  specified in the table in the Base Definitions volume of 
  IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap05.html">Chapter 
  5, File Format Notation</A> ( <TT>'\\'</TT>, <TT>'\a'</TT>, <TT>'\b'</TT>, 
  <TT>'\f'</TT>, <TT>'\n'</TT>, <TT>'\r'</TT>, <TT>'\t'</TT> , <TT>'\v'</TT> ) 
  and the following table; these escape sequences shall be recognized both 
  inside and outside bracket expressions. Note that records need not be 
  separated by &lt;newline&gt;s and string constants can contain 
  &lt;newline&gt;s, so even the <TT>"\n"</TT> sequence is valid in <I>awk</I> 
  EREs. Using a slash character within an ERE requires the escaping shown in the 
  following table.<BR></P>
  <CENTER><B>Table: Escape Sequences in <I>awk</I></B></CENTER>
  <CENTER>
  <TABLE cellPadding=3 align=center border=1>
    <TBODY>
    <TR vAlign=top>
      <TH align=middle>
        <P class=tent><B>Escape</B></P></TH>
      <TH align=middle>
        <P class=tent><B></B>&nbsp;</P></TH>
      <TH align=middle>
        <P class=tent><B></B>&nbsp;</P></TH></TR>
    <TR vAlign=top>
      <TH align=middle>
        <P class=tent><B>Sequence</B></P></TH>
      <TH align=middle>
        <P class=tent><B>Description</B></P></TH>
      <TH align=middle>
        <P class=tent><B>Meaning</B></P></TH></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>\"</P></TD>
      <TD align=left>
        <P class=tent>Backslash quotation-mark</P></TD>
      <TD align=left>
        <P class=tent>Quotation-mark character</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>\/</P></TD>
      <TD align=left>
        <P class=tent>Backslash slash</P></TD>
      <TD align=left>
        <P class=tent>Slash character</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>\ddd</P></TD>
      <TD align=left>
        <P class=tent>A backslash character followed by the longest sequence of 
        one, two, or three octal-digit characters (01234567). If all of the 
        digits are 0 (that is, representation of the NUL character), the 
        behavior is undefined.</P></TD>
      <TD align=left>
        <P class=tent>The character whose encoding is represented by the one, 
        two, or three-digit octal integer. Multi-byte characters require 
        multiple, concatenated escape sequences of this type, including the 
        leading <TT>'\'</TT> for each byte.</P></TD></TR>
    <TR vAlign=top>
      <TD align=left>
        <P class=tent>\c</P></TD>
      <TD align=left>
        <P class=tent>A backslash character followed by any character not 
        described in this table or in the table in the Base Definitions volume 
        of IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
        href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap05.html">Chapter 
        5, File Format Notation</A> ( <TT>'\\'</TT> , <TT>'\a'</TT>, 
        <TT>'\b'</TT>, <TT>'\f'</TT>, <TT>'\n'</TT>, <TT>'\r'</TT>, 
        <TT>'\t'</TT>, <TT>'\v'</TT> ).</P></TD>
      <TD align=left>
        <P class=tent>Undefined</P></TD></TR></TBODY></TABLE></CENTER>
  <P>A regular expression can be matched against a specific field or string by 
  using one of the two regular expression matching operators, <TT>'˜'</TT> and 
  <TT>"!˜"</TT>. These operators shall interpret their right-hand operand as a 
  regular expression and their left-hand operand as a string. If the regular 
  expression matches the string, the <TT>'˜'</TT> expression shall evaluate to a 
  value of 1, and the <TT>"!˜"</TT> expression shall evaluate to a value of 0. 
  (The regular expression matching operation is as defined by the term matched 
  in the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html#tag_09_01">Section 
  9.1, Regular Expression Definitions</A>, where a match occurs on any part of 
  the string unless the regular expression is limited with the circumflex or 
  dollar sign special characters.) If the regular expression does not match the 
  string, the <TT>'˜'</TT> expression shall evaluate to a value of 0, and the 
  <TT>"!˜"</TT> expression shall evaluate to a value of 1. If the right-hand 
  operand is any expression other than the lexical token <B>ERE</B>, the string 
  value of the expression shall be interpreted as an extended regular 
  expression, including the escape conventions described above. Note that these 
  same escape conventions shall also be applied in determining the value of a 
  string literal (the lexical token <B>STRING</B>), and thus shall be applied a 
  second time when a string literal is used in this context.</P>
  <P>When an <B>ERE</B> token appears as an expression in any context other than 
  as the right-hand of the <TT>'˜'</TT> or <TT>"!˜"</TT> operator or as one of 
  the built-in function arguments described below, the value of the resulting 
  expression shall be the equivalent of:</P><PRE><TT>$0 ˜ /</TT><I>ere</I><TT>/
</TT>
</PRE>
  <P>The <I>ere</I> argument to the <B>gsub</B>, <B>match</B>, <B>sub</B> 
  functions, and the <I>fs</I> argument to the <B>split</B> function (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_13">String 
  Functions</A>) shall be interpreted as extended regular expressions. These can 
  be either <B>ERE</B> tokens or arbitrary expressions, and shall be interpreted 
  in the same manner as the right-hand side of the <TT>'˜'</TT> or <TT>"!˜"</TT> 
  operator.</P>
  <P>An extended regular expression can be used to separate fields by using the 
  <B>-F</B> <I>ERE</I> option or by assigning a string containing the expression 
  to the built-in variable <B>FS</B>. The default value of the <B>FS</B> 
  variable shall be a single &lt;space&gt;. The following describes <B>FS</B> 
  behavior:</P>
  <OL>
    <LI>
    <P>If <B>FS</B> is a null string, the behavior is unspecified.</P>
    <LI>
    <P>If <B>FS</B> is a single character:</P>
    <OL type=a>
      <LI>
      <P>If <B>FS</B> is &lt;space&gt;, skip leading and trailing 
      &lt;blank&gt;s; fields shall be delimited by sets of one or more 
      &lt;blank&gt;s.</P>
      <LI>
      <P>Otherwise, if <B>FS</B> is any other character <I>c</I>, fields shall 
      be delimited by each single occurrence of <I>c</I>.</P></LI></OL>
    <LI>
    <P>Otherwise, the string value of <B>FS</B> shall be considered to be an 
    extended regular expression. Each occurrence of a sequence matching the 
    extended regular expression shall delimit fields.</P></LI></OL>
  <P>Except for the <TT>'˜'</TT> and <TT>"!˜"</TT> operators, and in the 
  <B>gsub</B>, <B>match</B>, <B>split</B>, and <B>sub</B> built-in functions, 
  ERE matching shall be based on input records; that is, record separator 
  characters (the first character of the value of the variable <B>RS</B>, 
  &lt;newline&gt; by default) cannot be embedded in the expression, and no 
  expression shall match the record separator character. If the record separator 
  is not &lt;newline&gt;, &lt;newline&gt;s embedded in the expression can be 
  matched. For the <TT>'˜'</TT> and <TT>"!˜"</TT> operators, and in those four 
  built-in functions, ERE matching shall be based on text strings; that is, any 
  character (including &lt;newline&gt; and the record separator) can be embedded 
  in the pattern, and an appropriate pattern shall match any character. However, 
  in all <I>awk</I> ERE matching, the use of one or more NUL characters in the 
  pattern, input record, or text string produces undefined results.</P>
  <H5><A name=tag_04_06_13_05></A>Patterns</H5>
  <P>A <I>pattern</I> is any valid <I>expression</I>, a range specified by two 
  expressions separated by a comma, or one of the two special patterns 
  <B>BEGIN</B> or <B>END</B>.</P>
  <H5><A name=tag_04_06_13_06></A>Special Patterns</H5>
  <P>The <I>awk</I> utility shall recognize two special patterns, <B>BEGIN</B> 
  and <B>END</B>. Each <B>BEGIN</B> pattern shall be matched once and its 
  associated action executed before the first record of input is read (except 
  possibly by use of the <B>getline</B> function-see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_14">Input/Output 
  and General Functions</A> - in a prior <B>BEGIN</B> action) and before command 
  line assignment is done. Each <B>END</B> pattern shall be matched once and its 
  associated action executed after the last record of input has been read. These 
  two patterns shall have associated actions.</P>
  <P><B>BEGIN</B> and <B>END</B> shall not combine with other patterns. Multiple 
  <B>BEGIN</B> and <B>END</B> patterns shall be allowed. The actions associated 
  with the <B>BEGIN</B> patterns shall be executed in the order specified in the 
  program, as are the <B>END</B> actions. An <B>END</B> pattern can precede a 
  <B>BEGIN</B> pattern in a program.</P>
  <P>If an <I>awk</I> program consists of only actions with the pattern 
  <B>BEGIN</B>, and the <B>BEGIN</B> action contains no <B>getline</B> function, 
  <I>awk</I> shall exit without reading its input when the last statement in the 
  last <B>BEGIN</B> action is executed. If an <I>awk</I> program consists of 
  only actions with the pattern <B>END</B> or only actions with the patterns 
  <B>BEGIN</B> and <B>END</B>, the input shall be read before the statements in 
  the <B>END</B> actions are executed.</P>
  <H5><A name=tag_04_06_13_07></A>Expression Patterns</H5>
  <P>An expression pattern shall be evaluated as if it were an expression in a 
  Boolean context. If the result is true, the pattern shall be considered to 
  match, and the associated action (if any) shall be executed. If the result is 
  false, the action shall not be executed.</P>
  <H5><A name=tag_04_06_13_08></A>Pattern Ranges</H5>
  <P>A pattern range consists of two expressions separated by a comma; in this 
  case, the action shall be performed for all records between a match of the 
  first expression and the following match of the second expression, inclusive. 
  At this point, the pattern range can be repeated starting at input records 
  subsequent to the end of the matched range.</P>
  <H5><A name=tag_04_06_13_09></A>Actions</H5>
  <P>An action is a sequence of statements as shown in the grammar in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>. 
  Any single statement can be replaced by a statement list enclosed in braces. 
  The application shall ensure that statements in a statement list are separated 
  by &lt;newline&gt;s or semicolons. Statements in a statement list shall be 
  executed sequentially in the order that they appear.</P>
  <P>The <I>expression</I> acting as the conditional in an <B>if</B> statement 
  shall be evaluated and if it is non-zero or non-null, the following statement 
  shall be executed; otherwise, if <B>else</B> is present, the statement 
  following the <B>else</B> shall be executed.</P>
  <P>The <B>if</B>, <B>while</B>, <B>do</B>... <B>while</B>, <B>for</B>, 
  <B>break</B>, and <B>continue</B> statements are based on the ISO&nbsp;C 
  standard (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_07_02"><I>Concepts 
  Derived from the ISO C Standard</I></A>), except that the Boolean expressions 
  shall be treated as described in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
  in awk</A> , and except in the case of:</P><PRE><TT>for (</TT><I>variable</I> <TT>in</TT> <I>array</I><TT>)
</TT>
</PRE>
  <P>which shall iterate, assigning each <I>index</I> of <I>array</I> to 
  <I>variable</I> in an unspecified order. The results of adding new elements to 
  <I>array</I> within such a <B>for</B> loop are undefined. If a <B>break</B> or 
  <B>continue</B> statement occurs outside of a loop, the behavior is 
  undefined.</P>
  <P>The <B>delete</B> statement shall remove an individual array element. Thus, 
  the following code deletes an entire array:</P><PRE><TT>for (index in array)
    delete array[index]
</TT>
</PRE>
  <P>The <B>next</B> statement shall cause all further processing of the current 
  input record to be abandoned. The behavior is undefined if a <B>next</B> 
  statement appears or is invoked in a <B>BEGIN</B> or <B>END</B> action.</P>
  <P>The <B>exit</B> statement shall invoke all <B>END</B> actions in the order 
  in which they occur in the program source and then terminate the program 
  without reading further input. An <B>exit</B> statement inside an <B>END</B> 
  action shall terminate the program without further execution of <B>END</B> 
  actions. If an expression is specified in an <B>exit</B> statement, its 
  numeric value shall be the exit status of <I>awk</I>, unless subsequent errors 
  are encountered or a subsequent <B>exit</B> statement with an expression is 
  executed.</P>
  <H5><A name=tag_04_06_13_10></A>Output Statements</H5>
  <P>Both <B>print</B> and <B>printf</B> statements shall write to standard 
  output by default. The output shall be written to the location specified by 
  <I>output_redirection</I> if one is supplied, as follows:</P><PRE><TT>&gt;</TT> <I>expression</I><TT>&gt;&gt;</TT> <I>expression</I><TT>|</TT> <I>expression</I>
</PRE>
  <P>In all cases, the <I>expression</I> shall be evaluated to produce a string 
  that is used as a pathname into which to write (for <TT>'&gt;'</TT> or 
  <TT>"&gt;&gt;"</TT> ) or as a command to be executed (for <TT>'|'</TT> ). 
  Using the first two forms, if the file of that name is not currently open, it 
  shall be opened, creating it if necessary and using the first form, truncating 
  the file. The output then shall be appended to the file. As long as the file 
  remains open, subsequent calls in which <I>expression</I> evaluates to the 
  same string value shall simply append output to the file. The file remains 
  open until the <B>close</B> function (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_14">Input/Output 
  and General Functions</A>) is called with an expression that evaluates to the 
  same string value.</P>
  <P>The third form shall write output onto a stream piped to the input of a 
  command. The stream shall be created if no stream is currently open with the 
  value of <I>expression</I> as its command name. The stream created shall be 
  equivalent to one created by a call to the <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/popen.html"><I>popen</I>()</A> 
  function defined in the System Interfaces volume of 
  IEEE&nbsp;Std&nbsp;1003.1-2001 with the value of <I>expression</I> as the 
  <I>command</I> argument and a value of <I>w</I> as the <I>mode</I> argument. 
  As long as the stream remains open, subsequent calls in which 
  <I>expression</I> evaluates to the same string value shall write output to the 
  existing stream. The stream shall remain open until the <B>close</B> function 
  (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_14">Input/Output 
  and General Functions</A>) is called with an expression that evaluates to the 
  same string value. At that time, the stream shall be closed as if by a call to 
  the <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/pclose.html"><I>pclose</I>()</A> 
  function defined in the System Interfaces volume of 
  IEEE&nbsp;Std&nbsp;1003.1-2001.</P>
  <P>As described in detail by the grammar in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A> 
  , these output statements shall take a comma-separated list of 
  <I>expression</I>s referred to in the grammar by the non-terminal symbols 
  <B>expr_list</B>, <B>print_expr_list</B>, or <B>print_expr_list_opt</B>. This 
  list is referred to here as the <I>expression list</I>, and each member is 
  referred to as an <I>expression argument</I>.</P>
  <P>The <B>print</B> statement shall write the value of each expression 
  argument onto the indicated output stream separated by the current output 
  field separator (see variable <B>OFS</B> above), and terminated by the output 
  record separator (see variable <B>ORS</B> above). All expression arguments 
  shall be taken as strings, being converted if necessary; this conversion shall 
  be as described in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
  in awk</A> , with the exception that the <B>printf</B> format in <B>OFMT</B> 
  shall be used instead of the value in <B>CONVFMT</B>. An empty expression list 
  shall stand for the whole input record ($0).</P>
  <P>The <B>printf</B> statement shall produce output based on a notation 
  similar to the File Format Notation used to describe file formats in this 
  volume of IEEE&nbsp;Std&nbsp;1003.1-2001 (see the Base Definitions volume of 
  IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap05.html">Chapter 
  5, File Format Notation</A>). Output shall be produced as specified with the 
  first <I>expression</I> argument as the string <I>format</I> and subsequent 
  <I>expression</I> arguments as the strings <I>arg1</I> to <I>argn</I>, 
  inclusive, with the following exceptions:</P>
  <OL>
    <LI>
    <P>The <I>format</I> shall be an actual character string rather than a 
    graphical representation. Therefore, it cannot contain empty character 
    positions. The &lt;space&gt; in the <I>format</I> string, in any context 
    other than a <I>flag</I> of a conversion specification, shall be treated as 
    an ordinary character that is copied to the output.</P>
    <LI>
    <P>If the character set contains a <TT>'<IMG src="awk_bestanden/delta.gif" 
    border=0>'</TT> character and that character appears in the <I>format</I> 
    string, it shall be treated as an ordinary character that is copied to the 
    output.</P>
    <LI>
    <P>The <I>escape sequences</I> beginning with a backslash character shall be 
    treated as sequences of ordinary characters that are copied to the output. 
    Note that these same sequences shall be interpreted lexically by <I>awk</I> 
    when they appear in literal strings, but they shall not be treated specially 
    by the <B>printf</B> statement.</P>
    <LI>
    <P>A <I>field width</I> or <I>precision</I> can be specified as the 
    <TT>'*'</TT> character instead of a digit string. In this case the next 
    argument from the expression list shall be fetched and its numeric value 
    taken as the field width or precision.</P>
    <LI>
    <P>The implementation shall not precede or follow output from the <TT>d</TT> 
    or <TT>u</TT> conversion specifier characters with &lt;blank&gt;s not 
    specified by the <I>format</I> string.</P>
    <LI>
    <P>The implementation shall not precede output from the <TT>o</TT> 
    conversion specifier character with leading zeros not specified by the 
    <I>format</I> string.</P>
    <LI>
    <P>For the <TT>c</TT> conversion specifier character: if the argument has a 
    numeric value, the character whose encoding is that value shall be output. 
    If the value is zero or is not the encoding of any character in the 
    character set, the behavior is undefined. If the argument does not have a 
    numeric value, the first character of the string value shall be output; if 
    the string does not contain any characters, the behavior is undefined.</P>
    <LI>
    <P>For each conversion specification that consumes an argument, the next 
    expression argument shall be evaluated. With the exception of the <TT>c</TT> 
    conversion specifier character, the value shall be converted (according to 
    the rules specified in <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
    in awk</A>) to the appropriate type for the conversion specification.</P>
    <LI>
    <P>If there are insufficient expression arguments to satisfy all the 
    conversion specifications in the <I>format</I> string, the behavior is 
    undefined.</P>
    <LI>
    <P>If any character sequence in the <I>format</I> string begins with a 
    <TT>'%'</TT> character, but does not form a valid conversion specification, 
    the behavior is unspecified.</P></LI></OL>
  <P>Both <B>print</B> and <B>printf</B> can output at least {LINE_MAX} 
  bytes.</P>
  <H5><A name=tag_04_06_13_11></A>Functions</H5>
  <P>The <I>awk</I> language has a variety of built-in functions: arithmetic, 
  string, input/output, and general.</P>
  <H5><A name=tag_04_06_13_12></A>Arithmetic Functions</H5>
  <P>The arithmetic functions, except for <B>int</B>, shall be based on the 
  ISO&nbsp;C standard (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_07_02"><I>Concepts 
  Derived from the ISO C Standard</I></A>). The behavior is undefined in cases 
  where the ISO&nbsp;C standard specifies that an error be returned or that the 
  behavior is undefined. Although the grammar (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>) 
  permits built-in functions to appear with no arguments or parentheses, unless 
  the argument or parentheses are indicated as optional in the following list 
  (by displaying them within the <TT>"[]"</TT> brackets), such use is 
  undefined.</P>
  <DL compact>
    <DT><B>atan2</B>(<I>y</I>,<I>x</I>) 
    <DD>Return arctangent of <I>y</I>/<I>x</I> in radians in the range [-<IMG 
    src="awk_bestanden/pi.gif" border=0>,<IMG src="awk_bestanden/pi.gif" 
    border=0>]. 
    <DT><B>cos</B>(<I>x</I>) 
    <DD>Return cosine of <I>x</I>, where <I>x</I> is in radians. 
    <DT><B>sin</B>(<I>x</I>) 
    <DD>Return sine of <I>x</I>, where <I>x</I> is in radians. 
    <DT><B>exp</B>(<I>x</I>) 
    <DD>Return the exponential function of <I>x</I>. 
    <DT><B>log</B>(<I>x</I>) 
    <DD>Return the natural logarithm of <I>x</I>. 
    <DT><B>sqrt</B>(<I>x</I>) 
    <DD>Return the square root of <I>x</I>. 
    <DT><B>int</B>(<I>x</I>) 
    <DD>Return the argument truncated to an integer. Truncation shall be toward 
    0 when <I>x</I>&gt;0. 
    <DT><B>rand</B>() 
    <DD>Return a random number <I>n</I>, such that 0&lt;=<I>n</I>&lt;1. 
    <DT><B>srand</B>(<B>[</B><I>expr</I><B>]</B>) 
    <DD>Set the seed value for <I>rand</I> to <I>expr</I> or use the time of day 
    if <I>expr</I> is omitted. The previous seed value shall be returned. 
  </DD></DL>
  <H5><A name=tag_04_06_13_13></A>String Functions</H5>
  <P>The string functions in the following list shall be supported. Although the 
  grammar (see <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A> 
  ) permits built-in functions to appear with no arguments or parentheses, 
  unless the argument or parentheses are indicated as optional in the following 
  list (by displaying them within the <TT>"[]"</TT> brackets), such use is 
  undefined.</P>
  <DL compact>
    <DT><B>gsub</B>(<I>ere</I>,&nbsp;<I>repl</I><B>[</B>,&nbsp;<I>in</I><B>]</B>) 

    <DD>Behave like <B>sub</B> (see below), except that it shall replace all 
    occurrences of the regular expression (like the <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/ed.html"><I>ed</I></A> 
    utility global substitute) in $0 or in the <I>in</I> argument, when 
    specified. 
    <DT><B>index</B>(<I>s</I>,&nbsp;<I>t</I>) 
    <DD>Return the position, in characters, numbering from 1, in string <I>s</I> 
    where string <I>t</I> first occurs, or zero if it does not occur at all. 
    <DT><B>length[</B>(<B>[</B><I>s</I><B>]</B>)<B>]</B> 
    <DD>Return the length, in characters, of its argument taken as a string, or 
    of the whole record, $0, if there is no argument. 
    <DT><B>match</B>(<I>s</I>,&nbsp;<I>ere</I>) 
    <DD>Return the position, in characters, numbering from 1, in string <I>s</I> 
    where the extended regular expression <I>ere</I> occurs, or zero if it does 
    not occur at all. RSTART shall be set to the starting position (which is the 
    same as the returned value), zero if no match is found; RLENGTH shall be set 
    to the length of the matched string, -1 if no match is found. 
    <DT><B>split</B>(<I>s</I>,&nbsp;<I>a</I><B>[</B>,&nbsp;<I>fs&nbsp;</I> 
    <B>]</B>) 
    <DD>Split the string <I>s</I> into array elements <I>a</I>[1], <I>a</I>[2], 
    ..., <I>a</I>[<I>n</I>], and return <I>n</I>. All elements of the array 
    shall be deleted before the split is performed. The separation shall be done 
    with the ERE <I>fs</I> or with the field separator <B>FS</B> if <I>fs</I> is 
    not given. Each array element shall have a string value when created and, if 
    appropriate, the array element shall be considered a numeric string (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
    in awk</A>). The effect of a null string as the value of <I>fs</I> is 
    unspecified. 
    <DT><B>sprintf</B>(<I>fmt</I>,&nbsp;<I>expr</I>,&nbsp;<I>expr</I>,&nbsp;...) 

    <DD>Format the expressions according to the <B>printf</B> format given by 
    <I>fmt</I> and return the resulting string. 
    <DT><B>sub(</B><I>ere</I>,&nbsp;<I>repl</I><B>[</B>,&nbsp;<I>in&nbsp;</I> 
    <B>]</B>) 
    <DD>Substitute the string <I>repl</I> in place of the first instance of the 
    extended regular expression <I>ERE</I> in string <I>in</I> and return the 
    number of substitutions. An ampersand ( <TT>'&amp;'</TT> ) appearing in the 
    string <I>repl</I> shall be replaced by the string from <I>in</I> that 
    matches the ERE. An ampersand preceded with a backslash ( <TT>'\'</TT> ) 
    shall be interpreted as the literal ampersand character. An occurrence of 
    two consecutive backslashes shall be interpreted as just a single literal 
    backslash character. Any other occurrence of a backslash (for example, 
    preceding any other character) shall be treated as a literal backslash 
    character. Note that if <I>repl</I> is a string literal (the lexical token 
    <B>STRING</B>; see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_16">Grammar</A>), 
    the handling of the ampersand character occurs after any lexical processing, 
    including any lexical backslash escape sequence processing. If <I>in</I> is 
    specified and it is not an lvalue (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
    in awk</A>), the behavior is undefined. If <I>in</I> is omitted, <I>awk</I> 
    shall use the current record ($0) in its place. 
    <DT><B>substr</B>(<I>s</I>,&nbsp;<I>m</I><B>[</B>,&nbsp;<I>n&nbsp;</I> 
    <B>]</B>) 
    <DD>Return the at most <I>n</I>-character substring of <I>s</I> that begins 
    at position <I>m</I>, numbering from 1. If <I>n</I> is omitted, or if 
    <I>n</I> specifies more characters than are left in the string, the length 
    of the substring shall be limited by the length of the string <I>s</I>. 
    <DT><B>tolower</B>(<I>s</I>) 
    <DD>Return a string based on the string <I>s</I>. Each character in <I>s</I> 
    that is an uppercase letter specified to have a <B>tolower</B> mapping by 
    the <I>LC_CTYPE</I> category of the current locale shall be replaced in the 
    returned string by the lowercase letter specified by the mapping. Other 
    characters in <I>s</I> shall be unchanged in the returned string. 
    <DT><B>toupper</B>(<I>s</I>) 
    <DD>Return a string based on the string <I>s</I>. Each character in <I>s</I> 
    that is a lowercase letter specified to have a <B>toupper</B> mapping by the 
    <I>LC_CTYPE</I> category of the current locale is replaced in the returned 
    string by the uppercase letter specified by the mapping. Other characters in 
    <I>s</I> are unchanged in the returned string. </DD></DL>
  <P>All of the preceding functions that take <I>ERE</I> as a parameter expect a 
  pattern or a string valued expression that is a regular expression as defined 
  in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_04">Regular 
  Expressions</A>.</P>
  <H5><A name=tag_04_06_13_14></A>Input/Output and General Functions</H5>
  <P>The input/output and general functions are:</P>
  <DL compact>
    <DT><B>close</B>(<I>expression</I>) 
    <DD>Close the file or pipe opened by a <B>print</B> or <B>printf</B> 
    statement or a call to <B>getline</B> with the same string-valued 
    <I>expression</I>. The limit on the number of open <I>expression</I> 
    arguments is implementation-defined. If the close was successful, the 
    function shall return zero; otherwise, it shall return non-zero. 
    <DT><I>expression&nbsp;|&nbsp;</I> <B>getline&nbsp;[</B><I>var</I><B>]</B> 
    <DD>Read a record of input from a stream piped from the output of a command. 
    The stream shall be created if no stream is currently open with the value of 
    <I>expression</I> as its command name. The stream created shall be 
    equivalent to one created by a call to the <A 
    href="http://www.opengroup.org/onlinepubs/009695399/functions/popen.html"><I>popen</I>()</A> 
    function with the value of <I>expression</I> as the <I>command</I> argument 
    and a value of <I>r</I> as the <I>mode</I> argument. As long as the stream 
    remains open, subsequent calls in which <I>expression</I> evaluates to the 
    same string value shall read subsequent records from the stream. The stream 
    shall remain open until the <B>close</B> function is called with an 
    expression that evaluates to the same string value. At that time, the stream 
    shall be closed as if by a call to the <A 
    href="http://www.opengroup.org/onlinepubs/009695399/functions/pclose.html"><I>pclose</I>()</A> 
    function. If <I>var</I> is omitted, $0 and <B>NF</B> shall be set; 
    otherwise, <I>var</I> shall be set and, if appropriate, it shall be 
    considered a numeric string (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
    in awk</A>). 
    <P>The <B>getline</B> operator can form ambiguous constructs when there are 
    unparenthesized operators (including concatenate) to the left of the 
    <TT>'|'</TT> (to the beginning of the expression containing <B>getline</B>). 
    In the context of the <TT>'$'</TT> operator, <TT>'|'</TT> shall behave as if 
    it had a lower precedence than <TT>'$'</TT>. The result of evaluating other 
    operators is unspecified, and conforming applications shall parenthesize 
    properly all such usages.</P>
    <DT><B>getline</B> 
    <DD>Set $0 to the next input record from the current input file. This form 
    of <B>getline</B> shall set the <B>NF</B>, <B>NR</B>, and <B>FNR</B> 
    variables. 
    <DT><B>getline&nbsp;</B> <I>var</I> 
    <DD>Set variable <I>var</I> to the next input record from the current input 
    file and, if appropriate, <I>var</I> shall be considered a numeric string 
    (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
    in awk</A>). This form of <B>getline</B> shall set the <B>FNR</B> and 
    <B>NR</B> variables. 
    <DT><B>getline&nbsp;[</B><I>var</I><B>]&nbsp;</B> 
    &lt;&nbsp;<I>expression</I> 
    <DD>Read the next record of input from a named file. The <I>expression</I> 
    shall be evaluated to produce a string that is used as a pathname. If the 
    file of that name is not currently open, it shall be opened. As long as the 
    stream remains open, subsequent calls in which <I>expression</I> evaluates 
    to the same string value shall read subsequent records from the file. The 
    file shall remain open until the <B>close</B> function is called with an 
    expression that evaluates to the same string value. If <I>var</I> is 
    omitted, $0 and <B>NF</B> shall be set; otherwise, <I>var</I> shall be set 
    and, if appropriate, it shall be considered a numeric string (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_02">Expressions 
    in awk</A>). 
    <P>The <B>getline</B> operator can form ambiguous constructs when there are 
    unparenthesized binary operators (including concatenate) to the right of the 
    <TT>'&lt;'</TT> (up to the end of the expression containing the 
    <B>getline</B>). The result of evaluating such a construct is unspecified, 
    and conforming applications shall parenthesize properly all such usages.</P>
    <DT><B>system</B>(<I>expression</I>) 
    <DD>Execute the command given by <I>expression</I> in a manner equivalent to 
    the <A 
    href="http://www.opengroup.org/onlinepubs/009695399/functions/system.html"><I>system</I>()</A> 
    function defined in the System Interfaces volume of 
    IEEE&nbsp;Std&nbsp;1003.1-2001 and return the exit status of the command. 
    </DD></DL>
  <P>All forms of <B>getline</B> shall return 1 for successful input, zero for 
  end-of-file, and -1 for an error.</P>
  <P>Where strings are used as the name of a file or pipeline, the application 
  shall ensure that the strings are textually identical. The terminology "same 
  string value" implies that "equivalent strings", even those that differ only 
  by &lt;space&gt;s, represent different files.</P>
  <H5><A name=tag_04_06_13_15></A>User-Defined Functions</H5>
  <P>The <I>awk</I> language also provides user-defined functions. Such 
  functions can be defined as:</P><PRE><TT>function</TT> <I>name</I><TT>(</TT><B>[</B><I>parameter</I><TT>, ...</TT><B>]</B><TT>) {</TT> <I>statements</I> <TT>}
</TT>
</PRE>
  <P>A function can be referred to anywhere in an <I>awk</I> program; in 
  particular, its use can precede its definition. The scope of a function is 
  global.</P>
  <P>Function parameters, if present, can be either scalars or arrays; the 
  behavior is undefined if an array name is passed as a parameter that the 
  function uses as a scalar, or if a scalar expression is passed as a parameter 
  that the function uses as an array. Function parameters shall be passed by 
  value if scalar and by reference if array name.</P>
  <P>The number of parameters in the function definition need not match the 
  number of parameters in the function call. Excess formal parameters can be 
  used as local variables. If fewer arguments are supplied in a function call 
  than are in the function definition, the extra parameters that are used in the 
  function body as scalars shall evaluate to the uninitialized value until they 
  are otherwise initialized, and the extra parameters that are used in the 
  function body as arrays shall be treated as uninitialized arrays where each 
  element evaluates to the uninitialized value until otherwise initialized.</P>
  <P>When invoking a function, no white space can be placed between the function 
  name and the opening parenthesis. Function calls can be nested and recursive 
  calls can be made upon functions. Upon return from any nested or recursive 
  function call, the values of all of the calling function's parameters shall be 
  unchanged, except for array parameters passed by reference. The <B>return</B> 
  statement can be used to return a value. If a <B>return</B> statement appears 
  outside of a function definition, the behavior is undefined.</P>
  <P>In the function definition, &lt;newline&gt;s shall be optional before the 
  opening brace and after the closing brace. Function definitions can appear 
  anywhere in the program where a <I>pattern-action</I> pair is allowed.</P>
  <H5><A name=tag_04_06_13_16></A>Grammar</H5>
  <P>The grammar in this section and the lexical conventions in the following 
  section shall together describe the syntax for <I>awk</I> programs. The 
  general conventions for this style of grammar are described in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_10"><I>Grammar 
  Conventions</I></A>. A valid program can be represented as the non-terminal 
  symbol <I>program</I> in the grammar. This formal syntax shall take precedence 
  over the preceding text syntax description.</P><PRE><TT>%token NAME NUMBER STRING ERE
%token FUNC_NAME   /* Name followed by '(' without white space. */
<BR>
/* Keywords  */
%token       Begin   End
/*          'BEGIN' 'END'                            */
<BR>
%token       Break   Continue   Delete   Do   Else
/*          'break' 'continue' 'delete' 'do' 'else'  */
<BR>
%token       Exit   For   Function   If   In
/*          'exit' 'for' 'function' 'if' 'in'        */
<BR>
%token       Next   Print   Printf   Return   While
/*          'next' 'print' 'printf' 'return' 'while' */
<BR>
/* Reserved function names */
%token BUILTIN_FUNC_NAME
            /* One token for the following:
             * atan2 cos sin exp log sqrt int rand srand
             * gsub index length match split sprintf sub
             * substr tolower toupper close system
             */
%token GETLINE
            /* Syntactically different from other built-ins. */
<BR>
/* Two-character tokens. */
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN
/*     '+='       '-='       '*='       '/='       '%='       '^=' */
<BR>
%token OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND
/*     '||' '&amp;&amp;' '!˜' '==' '&lt;=' '&gt;=' '!=' '++'  '--'  '&gt;&gt;'   */
<BR>
/* One-character tokens. */
%token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE
%token '+' '-' '*' '%' '^' '!' '&gt;' '&lt;' '|' '?' ':' '˜' '$' '='
<BR>
%start program
%%
<BR>
program          : item_list
                 | actionless_item_list
                 ;
<BR>
item_list        : newline_opt
                 | actionless_item_list item terminator
                 | item_list            item terminator
                 | item_list          action terminator
                 ;
<BR>
actionless_item_list : item_list            pattern terminator
                 | actionless_item_list pattern terminator
                 ;
<BR>
item             : pattern action
                 | Function NAME      '(' param_list_opt ')'
                       newline_opt action
                 | Function FUNC_NAME '(' param_list_opt ')'
                       newline_opt action
                 ;
<BR>
param_list_opt   : /* empty */
                 | param_list
                 ;
<BR>
param_list       : NAME
                 | param_list ',' NAME
                 ;
<BR>
pattern          : Begin
                 | End
                 | expr
                 | expr ',' newline_opt expr
                 ;
<BR>
action           : '{' newline_opt                             '}'
                 | '{' newline_opt terminated_statement_list   '}'
                 | '{' newline_opt unterminated_statement_list '}'
                 ;
<BR>
terminator       : terminator ';'
                 | terminator NEWLINE
                 |            ';'
                 |            NEWLINE
                 ;
<BR>
terminated_statement_list : terminated_statement
                 | terminated_statement_list terminated_statement
                 ;
<BR>
unterminated_statement_list : unterminated_statement
                 | terminated_statement_list unterminated_statement
                 ;
<BR>
terminated_statement : action newline_opt
                 | If '(' expr ')' newline_opt terminated_statement
                 | If '(' expr ')' newline_opt terminated_statement
                       Else newline_opt terminated_statement
                 | While '(' expr ')' newline_opt terminated_statement
                 | For '(' simple_statement_opt ';'
                      expr_opt ';' simple_statement_opt ')' newline_opt
                      terminated_statement
                 | For '(' NAME In NAME ')' newline_opt
                      terminated_statement
                 | ';' newline_opt
                 | terminatable_statement NEWLINE newline_opt
                 | terminatable_statement ';'     newline_opt
                 ;
<BR>
unterminated_statement : terminatable_statement
                 | If '(' expr ')' newline_opt unterminated_statement
                 | If '(' expr ')' newline_opt terminated_statement
                      Else newline_opt unterminated_statement
                 | While '(' expr ')' newline_opt unterminated_statement
                 | For '(' simple_statement_opt ';'
                  expr_opt ';' simple_statement_opt ')' newline_opt
                      unterminated_statement
                 | For '(' NAME In NAME ')' newline_opt
                      unterminated_statement
                 ;
<BR>
terminatable_statement : simple_statement
                 | Break
                 | Continue
                 | Next
                 | Exit expr_opt
                 | Return expr_opt
                 | Do newline_opt terminated_statement While '(' expr ')'
                 ;
<BR>
simple_statement_opt : /* empty */
                 | simple_statement
                 ;
<BR>
simple_statement : Delete NAME '[' expr_list ']'
                 | expr
                 | print_statement
                 ;
<BR>
print_statement  : simple_print_statement
                 | simple_print_statement output_redirection
                 ;
<BR>
simple_print_statement : Print  print_expr_list_opt
                 | Print  '(' multiple_expr_list ')'
                 | Printf print_expr_list
                 | Printf '(' multiple_expr_list ')'
                 ;
<BR>
output_redirection : '&gt;'    expr
                 | APPEND expr
                 | '|'    expr
                 ;
<BR>
expr_list_opt    : /* empty */
                 | expr_list
                 ;
<BR>
expr_list        : expr
                 | multiple_expr_list
                 ;
<BR>
multiple_expr_list : expr ',' newline_opt expr
                 | multiple_expr_list ',' newline_opt expr
                 ;
<BR>
expr_opt         : /* empty */
                 | expr
                 ;
<BR>
expr             : unary_expr
                 | non_unary_expr
                 ;
<BR>
unary_expr       : '+' expr
                 | '-' expr
                 | unary_expr '^'      expr
                 | unary_expr '*'      expr
                 | unary_expr '/'      expr
                 | unary_expr '%'      expr
                 | unary_expr '+'      expr
                 | unary_expr '-'      expr
                 | unary_expr          non_unary_expr
                 | unary_expr '&lt;'      expr
                 | unary_expr LE       expr
                 | unary_expr NE       expr
                 | unary_expr EQ       expr
                 | unary_expr '&gt;'      expr
                 | unary_expr GE       expr
                 | unary_expr '˜'      expr
                 | unary_expr NO_MATCH expr
                 | unary_expr In NAME
                 | unary_expr AND newline_opt expr
                 | unary_expr OR  newline_opt expr
                 | unary_expr '?' expr ':' expr
                 | unary_input_function
                 ;
<BR>
non_unary_expr   : '(' expr ')'
                 | '!' expr
                 | non_unary_expr '^'      expr
                 | non_unary_expr '*'      expr
                 | non_unary_expr '/'      expr
                 | non_unary_expr '%'      expr
                 | non_unary_expr '+'      expr
                 | non_unary_expr '-'      expr
                 | non_unary_expr          non_unary_expr
                 | non_unary_expr '&lt;'      expr
                 | non_unary_expr LE       expr
                 | non_unary_expr NE       expr
                 | non_unary_expr EQ       expr
                 | non_unary_expr '&gt;'      expr
                 | non_unary_expr GE       expr
                 | non_unary_expr '˜'      expr
                 | non_unary_expr NO_MATCH expr
                 | non_unary_expr In NAME
                 | '(' multiple_expr_list ')' In NAME
                 | non_unary_expr AND newline_opt expr
                 | non_unary_expr OR  newline_opt expr
                 | non_unary_expr '?' expr ':' expr
                 | NUMBER
                 | STRING
                 | lvalue
                 | ERE
                 | lvalue INCR
                 | lvalue DECR
                 | INCR lvalue
                 | DECR lvalue
                 | lvalue POW_ASSIGN expr
                 | lvalue MOD_ASSIGN expr
                 | lvalue MUL_ASSIGN expr
                 | lvalue DIV_ASSIGN expr
                 | lvalue ADD_ASSIGN expr
                 | lvalue SUB_ASSIGN expr
                 | lvalue '=' expr
                 | FUNC_NAME '(' expr_list_opt ')'
                      /* no white space allowed before '(' */
                 | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                 | BUILTIN_FUNC_NAME
                 | non_unary_input_function
                 ;
<BR>
print_expr_list_opt : /* empty */
                 | print_expr_list
                 ;
<BR>
print_expr_list  : print_expr
                 | print_expr_list ',' newline_opt print_expr
                 ;
<BR>
print_expr       : unary_print_expr
                 | non_unary_print_expr
                 ;
<BR>
unary_print_expr : '+' print_expr
                 | '-' print_expr
                 | unary_print_expr '^'      print_expr
                 | unary_print_expr '*'      print_expr
                 | unary_print_expr '/'      print_expr
                 | unary_print_expr '%'      print_expr
                 | unary_print_expr '+'      print_expr
                 | unary_print_expr '-'      print_expr
                 | unary_print_expr          non_unary_print_expr
                 | unary_print_expr '˜'      print_expr
                 | unary_print_expr NO_MATCH print_expr
                 | unary_print_expr In NAME
                 | unary_print_expr AND newline_opt print_expr
                 | unary_print_expr OR  newline_opt print_expr
                 | unary_print_expr '?' print_expr ':' print_expr
                 ;
<BR>
non_unary_print_expr : '(' expr ')'
                 | '!' print_expr
                 | non_unary_print_expr '^'      print_expr
                 | non_unary_print_expr '*'      print_expr
                 | non_unary_print_expr '/'      print_expr
                 | non_unary_print_expr '%'      print_expr
                 | non_unary_print_expr '+'      print_expr
                 | non_unary_print_expr '-'      print_expr
                 | non_unary_print_expr          non_unary_print_expr
                 | non_unary_print_expr '˜'      print_expr
                 | non_unary_print_expr NO_MATCH print_expr
                 | non_unary_print_expr In NAME
                 | '(' multiple_expr_list ')' In NAME
                 | non_unary_print_expr AND newline_opt print_expr
                 | non_unary_print_expr OR  newline_opt print_expr
                 | non_unary_print_expr '?' print_expr ':' print_expr
                 | NUMBER
                 | STRING
                 | lvalue
                 | ERE
                 | lvalue INCR
                 | lvalue DECR
                 | INCR lvalue
                 | DECR lvalue
                 | lvalue POW_ASSIGN print_expr
                 | lvalue MOD_ASSIGN print_expr
                 | lvalue MUL_ASSIGN print_expr
                 | lvalue DIV_ASSIGN print_expr
                 | lvalue ADD_ASSIGN print_expr
                 | lvalue SUB_ASSIGN print_expr
                 | lvalue '=' print_expr
                 | FUNC_NAME '(' expr_list_opt ')'
                     /* no white space allowed before '(' */
                 | BUILTIN_FUNC_NAME '(' expr_list_opt ')'
                 | BUILTIN_FUNC_NAME
                 ;
<BR>
lvalue           : NAME
                 | NAME '[' expr_list ']'
                 | '$' expr
                 ;
<BR>
non_unary_input_function : simple_get
                 | simple_get '&lt;' expr
                 | non_unary_expr '|' simple_get
                 ;
<BR>
unary_input_function : unary_expr '|' simple_get
                 ;
<BR>
simple_get       : GETLINE
                 | GETLINE lvalue
                 ;
<BR>
newline_opt      : /* empty */
                 | newline_opt NEWLINE
                 ;
</TT>
</PRE>
  <P>This grammar has several ambiguities that shall be resolved as follows:</P>
  <UL>
    <LI>
    <P>Operator precedence and associativity shall be as described in <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tagtcjh_10">Expressions 
    in Decreasing Precedence in <I>awk</I></A>.</P>
    <LI>
    <P>In case of ambiguity, an <B>else</B> shall be associated with the most 
    immediately preceding <B>if</B> that would satisfy the grammar.</P>
    <LI>
    <P>In some contexts, a slash ( <TT>'/'</TT> ) that is used to surround an 
    ERE could also be the division operator. This shall be resolved in such a 
    way that wherever the division operator could appear, a slash is assumed to 
    be the division operator. (There is no unary division operator.)</P></LI></UL>
  <P>One convention that might not be obvious from the formal grammar is where 
  &lt;newline&gt;s are acceptable. There are several obvious placements such as 
  terminating a statement, and a backslash can be used to escape 
  &lt;newline&gt;s between any lexical tokens. In addition, &lt;newline&gt;s 
  without backslashes can follow a comma, an open brace, logical AND operator ( 
  <TT>"&amp;&amp;"</TT> ), logical OR operator ( <TT>"||"</TT> ), the <B>do</B> 
  keyword, the <B>else</B> keyword, and the closing parenthesis of an <B>if</B>, 
  <B>for</B>, or <B>while</B> statement. For example:</P><PRE><TT>{ print  $1,
         $2 }
</TT>
</PRE>
  <H5><A name=tag_04_06_13_17></A>Lexical Conventions</H5>
  <P>The lexical conventions for <I>awk</I> programs, with respect to the 
  preceding grammar, shall be as follows:</P>
  <OL>
    <LI>
    <P>Except as noted, <I>awk</I> shall recognize the longest possible token or 
    delimiter beginning at a given point.</P>
    <LI>
    <P>A comment shall consist of any characters beginning with the number sign 
    character and terminated by, but excluding the next occurrence of, a 
    &lt;newline&gt;. Comments shall have no effect, except to delimit lexical 
    tokens.</P>
    <LI>
    <P>The &lt;newline&gt; shall be recognized as the token <B>NEWLINE</B>.</P>
    <LI>
    <P>A backslash character immediately followed by a &lt;newline&gt; shall 
    have no effect.</P>
    <LI>
    <P>The token <B>STRING</B> shall represent a string constant. A string 
    constant shall begin with the character <TT>' .'</TT> Within a string 
    constant, a backslash character shall be considered to begin an escape 
    sequence as specified in the table in the Base Definitions volume of 
    IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
    href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap05.html">Chapter 
    5, File Format Notation</A> ( <TT>'\\'</TT>, <TT>'\a'</TT>, <TT>'\b'</TT>, 
    <TT>'\f'</TT>, <TT>'\n'</TT>, <TT>'\r'</TT>, <TT>'\t'</TT>, <TT>'\v'</TT> ). 
    In addition, the escape sequences in <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tagtcjh_10">Expressions 
    in Decreasing Precedence in <I>awk</I></A> shall be recognized. A 
    &lt;newline&gt; shall not occur within a string constant. A string constant 
    shall be terminated by the first unescaped occurrence of the character 
    <TT>''</TT> after the one that begins the string constant. The value of the 
    string shall be the sequence of all unescaped characters and values of 
    escape sequences between, but not including, the two delimiting <TT>''</TT> 
    characters.</P>
    <LI>
    <P>The token <B>ERE</B> represents an extended regular expression constant. 
    An ERE constant shall begin with the slash character. Within an ERE 
    constant, a backslash character shall be considered to begin an escape 
    sequence as specified in the table in the Base Definitions volume of 
    IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
    href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap05.html">Chapter 
    5, File Format Notation</A>. In addition, the escape sequences in <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tagtcjh_10">Expressions 
    in Decreasing Precedence in <I>awk</I></A> shall be recognized. The 
    application shall ensure that a &lt;newline&gt; does not occur within an ERE 
    constant. An ERE constant shall be terminated by the first unescaped 
    occurrence of the slash character after the one that begins the ERE 
    constant. The extended regular expression represented by the ERE constant 
    shall be the sequence of all unescaped characters and values of escape 
    sequences between, but not including, the two delimiting slash 
    characters.</P>
    <LI>
    <P>A &lt;blank&gt; shall have no effect, except to delimit lexical tokens or 
    within <B>STRING</B> or <B>ERE</B> tokens.</P>
    <LI>
    <P>The token <B>NUMBER</B> shall represent a numeric constant. Its form and 
    numeric value shall be equivalent to either of the tokens 
    <B>floating-constant</B> or <B>integer-constant</B> as specified by the 
    ISO&nbsp;C standard, with the following exceptions:</P>
    <OL type=a>
      <LI>
      <P>An integer constant cannot begin with 0x or include the hexadecimal 
      digits <TT>'a'</TT>, <TT>'b'</TT>, <TT>'c'</TT>, <TT>'d'</TT>, 
      <TT>'e'</TT>, <TT>'f'</TT>, <TT>'A'</TT>, <TT>'B'</TT>, <TT>'C'</TT>, 
      <TT>'D'</TT>, <TT>'E'</TT>, or <TT>'F'</TT>.</P>
      <LI>
      <P>The value of an integer constant beginning with 0 shall be taken in 
      decimal rather than octal.</P>
      <LI>
      <P>An integer constant cannot include a suffix ( <TT>'u'</TT>, 
      <TT>'U'</TT>, <TT>'l'</TT>, or <TT>'L'</TT> ).</P>
      <LI>
      <P>A floating constant cannot include a suffix ( <TT>'f'</TT>, 
      <TT>'F'</TT>, <TT>'l'</TT>, or <TT>'L'</TT> ).</P></LI></OL>
    <P>If the value is too large or too small to be representable (see <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_07_02"><I>Concepts 
    Derived from the ISO C Standard</I></A>), the behavior is undefined.</P>
    <LI>
    <P>A sequence of underscores, digits, and alphabetics from the portable 
    character set (see the Base Definitions volume of 
    IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
    href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap06.html#tag_06_01">Section 
    6.1, Portable Character Set</A>), beginning with an underscore or 
    alphabetic, shall be considered a word.</P>
    <LI>
    <P>The following words are keywords that shall be recognized as individual 
    tokens; the name of the token is the same as the keyword:</P>
    <BLOCKQUOTE>
      <TABLE cellPadding=3>
        <TBODY>
        <TR vAlign=top>
          <TD align=left>
            <P class=tent><B><BR>BEGIN<BR>break<BR>continue<BR></B></P></TD>
          <TD align=left>
            <P class=tent><B><BR>delete<BR>do<BR>else<BR></B></P></TD>
          <TD align=left>
            <P class=tent><B><BR>END<BR>exit<BR>for<BR></B></P></TD>
          <TD align=left>
            <P class=tent><B><BR>function<BR>getline<BR>if<BR></B></P></TD>
          <TD align=left>
            <P class=tent><B><BR>in<BR>next<BR>print<BR></B></P></TD>
          <TD align=left>
            <P 
        class=tent><B><BR>printf<BR>return<BR>while<BR></B></P></TD></TR></TBODY></TABLE></BLOCKQUOTE>
    <LI>
    <P>The following words are names of built-in functions and shall be 
    recognized as the token <B>BUILTIN_FUNC_NAME</B>:</P>
    <BLOCKQUOTE>
      <TABLE cellPadding=3>
        <TBODY>
        <TR vAlign=top>
          <TD align=left>
            <P class=tent><B><BR>atan2<BR>close<BR>cos<BR>exp<BR></B></P></TD>
          <TD align=left>
            <P class=tent><B><BR>gsub<BR>index<BR>int<BR>length<BR></B></P></TD>
          <TD align=left>
            <P class=tent><B><BR>log<BR>match<BR>rand<BR>sin<BR></B></P></TD>
          <TD align=left>
            <P 
class=tent><B><BR>split<BR>sprintf<BR>sqrt<BR>srand<BR></B></P></TD>
          <TD align=left>
            <P 
          class=tent><B><BR>sub<BR>substr<BR>system<BR>tolower<BR></B></P></TD>
          <TD align=left>
            <P 
    class=tent><B><BR>toupper<BR></B></P></TD></TR></TBODY></TABLE></BLOCKQUOTE>
    <P>The above-listed keywords and names of built-in functions are considered 
    reserved words.</P>
    <LI>
    <P>The token <B>NAME</B> shall consist of a word that is not a keyword or a 
    name of a built-in function and is not followed immediately (without any 
    delimiters) by the <TT>'('</TT> character.</P>
    <LI>
    <P>The token <B>FUNC_NAME</B> shall consist of a word that is not a keyword 
    or a name of a built-in function, followed immediately (without any 
    delimiters) by the <TT>'('</TT> character. The <TT>'('</TT> character shall 
    not be included as part of the token.</P>
    <LI>
    <P>The following two-character sequences shall be recognized as the named 
    tokens:</P>
    <CENTER>
    <TABLE cellPadding=3 align=center border=1>
      <TBODY>
      <TR vAlign=top>
        <TH align=middle>
          <P class=tent><B>Token Name</B></P></TH>
        <TH align=middle>
          <P class=tent><B>Sequence</B></P></TH>
        <TH align=middle>
          <P class=tent><B>Token Name</B></P></TH>
        <TH align=middle>
          <P class=tent><B>Sequence</B></P></TH></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>ADD_ASSIGN</B></P></TD>
        <TD align=middle>
          <P class=tent>+=</P></TD>
        <TD align=left>
          <P class=tent><B>NO_MATCH</B></P></TD>
        <TD align=middle>
          <P class=tent>!˜</P></TD></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>SUB_ASSIGN</B></P></TD>
        <TD align=middle>
          <P class=tent>-=</P></TD>
        <TD align=left>
          <P class=tent><B>EQ</B></P></TD>
        <TD align=middle>
          <P class=tent>==</P></TD></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>MUL_ASSIGN</B></P></TD>
        <TD align=middle>
          <P class=tent>*=</P></TD>
        <TD align=left>
          <P class=tent><B>LE</B></P></TD>
        <TD align=middle>
          <P class=tent>&lt;=</P></TD></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>DIV_ASSIGN</B></P></TD>
        <TD align=middle>
          <P class=tent>/=</P></TD>
        <TD align=left>
          <P class=tent><B>GE</B></P></TD>
        <TD align=middle>
          <P class=tent>&gt;=</P></TD></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>MOD_ASSIGN</B></P></TD>
        <TD align=middle>
          <P class=tent>%=</P></TD>
        <TD align=left>
          <P class=tent><B>NE</B></P></TD>
        <TD align=middle>
          <P class=tent>!=</P></TD></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>POW_ASSIGN</B></P></TD>
        <TD align=middle>
          <P class=tent>^=</P></TD>
        <TD align=left>
          <P class=tent><B>INCR</B></P></TD>
        <TD align=middle>
          <P class=tent>++</P></TD></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>OR</B></P></TD>
        <TD align=middle>
          <P class=tent>||</P></TD>
        <TD align=left>
          <P class=tent><B>DECR</B></P></TD>
        <TD align=middle>
          <P class=tent>--</P></TD></TR>
      <TR vAlign=top>
        <TD align=left>
          <P class=tent><B>AND</B></P></TD>
        <TD align=middle>
          <P class=tent>&amp;&amp;</P></TD>
        <TD align=left>
          <P class=tent><B>APPEND</B></P></TD>
        <TD align=middle>
          <P class=tent>&gt;&gt;</P></TD></TR></TBODY></TABLE></CENTER>
    <LI>
    <P>The following single characters shall be recognized as tokens whose names 
    are the character:</P><PRE><TT>&lt;newline&gt; { } ( ) [ ] , ; + - * % ^ ! &gt; &lt; | ? : ˜ $ =
</TT>
</PRE></LI></OL>
  <P>There is a lexical ambiguity between the token <B>ERE</B> and the tokens 
  <TT>'/'</TT> and <B>DIV_ASSIGN</B>. When an input sequence begins with a slash 
  character in any syntactic context where the token <TT>'/'</TT> or 
  <B>DIV_ASSIGN</B> could appear as the next token in a valid program, the 
  longer of those two tokens that can be recognized shall be recognized. In any 
  other syntactic context where the token <B>ERE</B> could appear as the next 
  token in a valid program, the token <B>ERE</B> shall be 
recognized.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_14></A>EXIT STATUS</H4>
<BLOCKQUOTE>
  <P>The following exit values shall be returned:</P>
  <DL compact>
    <DT>&nbsp;0 
    <DD>All input files were processed successfully. 
    <DT>&gt;0 
    <DD>An error occurred. </DD></DL>
  <P>The exit status can be altered within the program by using an <B>exit</B> 
  expression.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_15></A>CONSEQUENCES OF ERRORS</H4>
<BLOCKQUOTE>
  <P>If any <I>file</I> operand is specified and the named file cannot be 
  accessed, <I>awk</I> shall write a diagnostic message to standard error and 
  terminate without any further action.</P>
  <P>If the program specified by either the <I>program</I> operand or a 
  <I>progfile</I> operand is not a valid <I>awk</I> program (as specified in the 
  EXTENDED DESCRIPTION section), the behavior is undefined.</P></BLOCKQUOTE>
<HR>

<DIV class=box><EM>The following sections are informative.</EM></DIV>
<H4><A name=tag_04_06_16></A>APPLICATION USAGE</H4>
<BLOCKQUOTE>
  <P>The <B>index</B>, <B>length</B>, <B>match</B>, and <B>substr</B> functions 
  should not be confused with similar functions in the ISO&nbsp;C standard; the 
  <I>awk</I> versions deal with characters, while the ISO&nbsp;C standard deals 
  with bytes.</P>
  <P>Because the concatenation operation is represented by adjacent expressions 
  rather than an explicit operator, it is often necessary to use parentheses to 
  enforce the proper evaluation precedence.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_17></A>EXAMPLES</H4>
<BLOCKQUOTE>
  <P>The <I>awk</I> program specified in the command line is most easily 
  specified within single-quotes (for example, '<I>program</I>') for 
  applications using <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/sh.html"><I>sh</I></A>, 
  because <I>awk</I> programs commonly contain characters that are special to 
  the shell, including double-quotes. In the cases where an <I>awk</I> program 
  contains single-quote characters, it is usually easiest to specify most of the 
  program as strings within single-quotes concatenated by the shell with quoted 
  single-quote characters. For example:</P><PRE><TT>awk '/'\''/ { print "quote:", $0 }'
</TT>
</PRE>
  <P>prints all lines from the standard input containing a single-quote 
  character, prefixed with <I>quote</I>:.</P>
  <P>The following are examples of simple <I>awk</I> programs:</P>
  <OL>
    <LI>
    <P>Write to the standard output all input lines for which field 3 is greater 
    than 5:</P><PRE><TT>$3 &gt; 5
</TT>
</PRE>
    <LI>
    <P>Write every tenth line:</P><PRE><TT>(NR % 10) == 0
</TT>
</PRE>
    <LI>
    <P>Write any line with a substring matching the regular expression:</P><PRE><TT>/(G|D)(2[0-9][[:alpha:]]*)/
</TT>
</PRE>
    <LI>
    <P>Print any line with a substring containing a <TT>'G'</TT> or 
    <TT>'D'</TT>, followed by a sequence of digits and characters. This example 
    uses character classes <B>digit</B> and <B>alpha</B> to match 
    language-independent digit and alphabetic characters respectively:</P><PRE><TT>/(G|D)([[:digit:][:alpha:]]*)/
</TT>
</PRE>
    <LI>
    <P>Write any line in which the second field matches the regular expression 
    and the fourth field does not:</P><PRE><TT>$2 ˜ /xyz/ &amp;&amp; $4 !˜ /xyz/
</TT>
</PRE>
    <LI>
    <P>Write any line in which the second field contains a backslash:</P><PRE><TT>$2 ˜ /\\/
</TT>
</PRE>
    <LI>
    <P>Write any line in which the second field contains a backslash. Note that 
    backslash escapes are interpreted twice; once in lexical processing of the 
    string and once in processing the regular expression:</P><PRE><TT>$2 ˜ "\\\\"
</TT>
</PRE>
    <LI>
    <P>Write the second to the last and the last field in each line. Separate 
    the fields by a colon:</P><PRE><TT>{OFS=":";print $(NF-1), $NF}
</TT>
</PRE>
    <LI>
    <P>Write the line number and number of fields in each line. The three 
    strings representing the line number, the colon, and the number of fields 
    are concatenated and that string is written to standard output:</P><PRE><TT>{print NR ":" NF}
</TT>
</PRE>
    <LI>
    <P>Write lines longer than 72 characters:</P><PRE><TT>length($0) &gt; 72
</TT>
</PRE>
    <LI>
    <P>Write the first two fields in opposite order separated by <B>OFS</B>:</P><PRE><TT>{ print $2, $1 }
</TT>
</PRE>
    <LI>
    <P>Same, with input fields separated by a comma or &lt;space&gt;s and 
    &lt;tab&gt;s, or both:</P><PRE><TT>BEGIN { FS = ",[ \t]*|[ \t]+" }
      { print $2, $1 }
</TT>
</PRE>
    <LI>
    <P>Add up the first column, print sum, and average:</P><PRE><TT>     {s += $1 }
END   {print "sum is ", s, " average is", s/NR}
</TT>
</PRE>
    <LI>
    <P>Write fields in reverse order, one per line (many lines out for each line 
    in):</P><PRE><TT>{ for (i = NF; i &gt; 0; --i) print $i }
</TT>
</PRE>
    <LI>
    <P>Write all lines between occurrences of the strings <B>start</B> and 
    <B>stop</B>:</P><PRE><TT>/start/, /stop/
</TT>
</PRE>
    <LI>
    <P>Write all lines whose first field is different from the previous one:</P><PRE><TT>$1 != prev { print; prev = $1 }
</TT>
</PRE>
    <LI>
    <P>Simulate <A 
    href="http://www.opengroup.org/onlinepubs/009695399/utilities/echo.html"><I>echo</I></A>:</P><PRE><TT>BEGIN  {
        for (i = 1; i &lt; ARGC; ++i)
        printf("%s%s", ARGV[i], i==ARGC-1?"\n":" ")
}
</TT>
</PRE>
    <LI>
    <P>Write the path prefixes contained in the <I>PATH</I> environment 
    variable, one per line:</P><PRE><TT>BEGIN  {
        n = split (ENVIRON["PATH"], path, ":")
        for (i = 1; i &lt;= n; ++i)
        print path[i]
}
</TT>
</PRE>
    <LI>
    <P>If there is a file named <B>input</B> containing page headers of the 
    form:</P>
    <BLOCKQUOTE><PRE>Page #
</PRE></BLOCKQUOTE>
    <P>and a file named <B>program</B> that contains:</P><PRE><TT>/Page/   { $2 = n++; }
         { print }
</TT>
</PRE>
    <P>then the command line:</P><PRE><TT>awk -f program n=5 input
</TT>
</PRE>
    <P>prints the file <B>input</B>, filling in page numbers starting at 
    5.</P></LI></OL></BLOCKQUOTE>
<H4><A name=tag_04_06_18></A>RATIONALE</H4>
<BLOCKQUOTE>
  <P>This description is based on the new <I>awk</I>, "nawk", (see the 
  referenced <I>The AWK Programming Language</I>), which introduced a number of 
  new features to the historical <I>awk</I>:</P>
  <OL>
    <LI>
    <P>New keywords: <B>delete</B>, <B>do</B>, <B>function</B>, 
<B>return</B></P>
    <LI>
    <P>New built-in functions: <B>atan2</B>, <B>close</B>, <B>cos</B>, 
    <B>gsub</B>, <B>match</B>, <B>rand</B>, <B>sin</B>, <B>srand</B>, 
    <B>sub</B>, <B>system</B></P>
    <LI>
    <P>New predefined variables: <B>FNR</B>, <B>ARGC</B>, <B>ARGV</B>, 
    <B>RSTART</B>, <B>RLENGTH</B>, <B>SUBSEP</B></P>
    <LI>
    <P>New expression operators: <B>?</B>, <B>:</B>, <B>,</B>, <B>^</B></P>
    <LI>
    <P>The <B>FS</B> variable and the third argument to <B>split</B>, now 
    treated as extended regular expressions.</P>
    <LI>
    <P>The operator precedence, changed to more closely match the C language. 
    Two examples of code that operate differently are:</P><PRE><TT>while ( n /= 10 &gt; 1) ...
if (!"wk" ˜ /bwk/) ...
</TT>
</PRE></LI></OL>
  <P>Several features have been added based on newer implementations of 
  <I>awk</I>:</P>
  <UL>
    <LI>
    <P>Multiple instances of <B>-f</B> <I>progfile</I> are permitted.</P>
    <LI>
    <P>The new option <B>-v</B> <I>assignment.</I></P>
    <LI>
    <P>The new predefined variable <B>ENVIRON</B>.</P>
    <LI>
    <P>New built-in functions <B>toupper</B> and <B>tolower</B>.</P>
    <LI>
    <P>More formatting capabilities are added to <B>printf</B> to match the 
    ISO&nbsp;C standard.</P></LI></UL>
  <P>The overall <I>awk</I> syntax has always been based on the C language, with 
  a few features from the shell command language and other sources. Because of 
  this, it is not completely compatible with any other language, which has 
  caused confusion for some users. It is not the intent of the standard 
  developers to address such issues. A few relatively minor changes toward 
  making the language more compatible with the ISO&nbsp;C standard were made; 
  most of these changes are based on similar changes in recent implementations, 
  as described above. There remain several C-language conventions that are not 
  in <I>awk</I>. One of the notable ones is the comma operator, which is 
  commonly used to specify multiple expressions in the C language <B>for</B> 
  statement. Also, there are various places where <I>awk</I> is more restrictive 
  than the C language regarding the type of expression that can be used in a 
  given context. These limitations are due to the different features that the 
  <I>awk</I> language does provide.</P>
  <P>Regular expressions in <I>awk</I> have been extended somewhat from 
  historical implementations to make them a pure superset of extended regular 
  expressions, as defined by IEEE&nbsp;Std&nbsp;1003.1-2001 (see the Base 
  Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html#tag_09_04">Section 
  9.4, Extended Regular Expressions</A>). The main extensions are 
  internationalization features and interval expressions. Historical 
  implementations of <I>awk</I> have long supported backslash escape sequences 
  as an extension to extended regular expressions, and this extension has been 
  retained despite inconsistency with other utilities. The number of escape 
  sequences recognized in both extended regular expressions and strings has 
  varied (generally increasing with time) among implementations. The set 
  specified by IEEE&nbsp;Std&nbsp;1003.1-2001 includes most sequences known to 
  be supported by popular implementations and by the ISO&nbsp;C standard. One 
  sequence that is not supported is hexadecimal value escapes beginning with 
  <TT>'\x'</TT>. This would allow values expressed in more than 9 bits to be 
  used within <I>awk</I> as in the ISO&nbsp;C standard. However, because this 
  syntax has a non-deterministic length, it does not permit the subsequent 
  character to be a hexadecimal digit. This limitation can be dealt with in the 
  C language by the use of lexical string concatenation. In the <I>awk</I> 
  language, concatenation could also be a solution for strings, but not for 
  extended regular expressions (either lexical ERE tokens or strings used 
  dynamically as regular expressions). Because of this limitation, the feature 
  has not been added to IEEE&nbsp;Std&nbsp;1003.1-2001.</P>
  <P>When a string variable is used in a context where an extended regular 
  expression normally appears (where the lexical token ERE is used in the 
  grammar) the string does not contain the literal slashes.</P>
  <P>Some versions of <I>awk</I> allow the form:</P><PRE><TT>func name(args, ... ) { statements }
</TT>
</PRE>
  <P>This has been deprecated by the authors of the language, who asked that it 
  not be specified.</P>
  <P>Historical implementations of <I>awk</I> produce an error if a <B>next</B> 
  statement is executed in a <B>BEGIN</B> action, and cause <I>awk</I> to 
  terminate if a <B>next</B> statement is executed in an <B>END</B> action. This 
  behavior has not been documented, and it was not believed that it was 
  necessary to standardize it.</P>
  <P>The specification of conversions between string and numeric values is much 
  more detailed than in the documentation of historical implementations or in 
  the referenced <I>The AWK Programming Language</I>. Although most of the 
  behavior is designed to be intuitive, the details are necessary to ensure 
  compatible behavior from different implementations. This is especially 
  important in relational expressions since the types of the operands determine 
  whether a string or numeric comparison is performed. From the perspective of 
  an application writer, it is usually sufficient to expect intuitive behavior 
  and to force conversions (by adding zero or concatenating a null string) when 
  the type of an expression does not obviously match what is needed. The intent 
  has been to specify historical practice in almost all cases. The one exception 
  is that, in historical implementations, variables and constants maintain both 
  string and numeric values after their original value is converted by any use. 
  This means that referencing a variable or constant can have unexpected side 
  effects. For example, with historical implementations the following 
  program:</P><PRE><TT>{
    a = "+2"
    b = 2
    if (NR % 2)
        c = a + b
    if (a == b)
        print "numeric comparison"
    else
        print "string comparison"
}
</TT>
</PRE>
  <P>would perform a numeric comparison (and output numeric comparison) for each 
  odd-numbered line, but perform a string comparison (and output string 
  comparison) for each even-numbered line. IEEE&nbsp;Std&nbsp;1003.1-2001 
  ensures that comparisons will be numeric if necessary. With historical 
  implementations, the following program:</P><PRE><TT>BEGIN {
    OFMT = "%e"
    print 3.14
    OFMT = "%f"
    print 3.14
}
</TT>
</PRE>
  <P>would output <TT>"3.140000e+00"</TT> twice, because in the second 
  <B>print</B> statement the constant <TT>"3.14"</TT> would have a string value 
  from the previous conversion. IEEE&nbsp;Std&nbsp;1003.1-2001 requires that the 
  output of the second <B>print</B> statement be <TT>"3.140000"</TT>. The 
  behavior of historical implementations was seen as too unintuitive and 
  unpredictable.</P>
  <P>It was pointed out that with the rules contained in early drafts, the 
  following script would print nothing:</P><PRE><TT>BEGIN {
    y[1.5] = 1
    OFMT = "%e"
    print y[1.5]
}
</TT>
</PRE>
  <P>Therefore, a new variable, <B>CONVFMT</B>, was introduced. The <B>OFMT</B> 
  variable is now restricted to affecting output conversions of numbers to 
  strings and <B>CONVFMT</B> is used for internal conversions, such as 
  comparisons or array indexing. The default value is the same as that for 
  <B>OFMT</B>, so unless a program changes <B>CONVFMT</B> (which no historical 
  program would do), it will receive the historical behavior associated with 
  internal string conversions.</P>
  <P>The POSIX <I>awk</I> lexical and syntactic conventions are specified more 
  formally than in other sources. Again the intent has been to specify 
  historical practice. One convention that may not be obvious from the formal 
  grammar as in other verbal descriptions is where &lt;newline&gt;s are 
  acceptable. There are several obvious placements such as terminating a 
  statement, and a backslash can be used to escape &lt;newline&gt;s between any 
  lexical tokens. In addition, &lt;newline&gt;s without backslashes can follow a 
  comma, an open brace, a logical AND operator ( <TT>"&amp;&amp;"</TT> ), a 
  logical OR operator ( <TT>"||"</TT> ), the <B>do</B> keyword, the <B>else</B> 
  keyword, and the closing parenthesis of an <B>if</B>, <B>for</B>, or 
  <B>while</B> statement. For example:</P><PRE><TT>{ print $1,
        $2 }
</TT>
</PRE>
  <P>The requirement that <I>awk</I> add a trailing &lt;newline&gt; to the 
  program argument text is to simplify the grammar, making it match a text file 
  in form. There is no way for an application or test suite to determine whether 
  a literal &lt;newline&gt; is added or whether <I>awk</I> simply acts as if it 
  did.</P>
  <P>IEEE&nbsp;Std&nbsp;1003.1-2001 requires several changes from historical 
  implementations in order to support internationalization. Probably the most 
  subtle of these is the use of the decimal-point character, defined by the 
  <I>LC_NUMERIC</I> category of the locale, in representations of floating-point 
  numbers. This locale-specific character is used in recognizing numeric input, 
  in converting between strings and numeric values, and in formatting output. 
  However, regardless of locale, the period character (the decimal-point 
  character of the POSIX locale) is the decimal-point character recognized in 
  processing <I>awk</I> programs (including assignments in command line 
  arguments). This is essentially the same convention as the one used in the 
  ISO&nbsp;C standard. The difference is that the C language includes the <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/setlocale.html"><I>setlocale</I>()</A> 
  function, which permits an application to modify its locale. Because of this 
  capability, a C application begins executing with its locale set to the C 
  locale, and only executes in the environment-specified locale after an 
  explicit call to <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/setlocale.html"><I>setlocale</I>()</A>. 
  However, adding such an elaborate new feature to the <I>awk</I> language was 
  seen as inappropriate for IEEE&nbsp;Std&nbsp;1003.1-2001. It is possible to 
  execute an <I>awk</I> program explicitly in any desired locale by setting the 
  environment in the shell.</P>
  <P>The undefined behavior resulting from NULs in extended regular expressions 
  allows future extensions for the GNU <I>gawk</I> program to process binary 
  data.</P>
  <P>The behavior in the case of invalid <I>awk</I> programs (including lexical, 
  syntactic, and semantic errors) is undefined because it was considered overly 
  limiting on implementations to specify. In most cases such errors can be 
  expected to produce a diagnostic and a non-zero exit status. However, some 
  implementations may choose to extend the language in ways that make use of 
  certain invalid constructs. Other invalid constructs might be deemed worthy of 
  a warning, but otherwise cause some reasonable behavior. Still other 
  constructs may be very difficult to detect in some implementations. Also, 
  different implementations might detect a given error during an initial parsing 
  of the program (before reading any input files) while others might detect it 
  when executing the program after reading some input. Implementors should be 
  aware that diagnosing errors as early as possible and producing useful 
  diagnostics can ease debugging of applications, and thus make an 
  implementation more usable.</P>
  <P>The unspecified behavior from using multi-character <B>RS</B> values is to 
  allow possible future extensions based on extended regular expressions used 
  for record separators. Historical implementations take the first character of 
  the string and ignore the others.</P>
  <P>Unspecified behavior when <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/split.html"><I>split</I></A>( 
  <I>string</I>, <I>array</I>, &lt;null&gt;) is used is to allow a proposed 
  future extension that would split up a string into an array of individual 
  characters.</P>
  <P>In the context of the <B>getline</B> function, equally good arguments for 
  different precedences of the <B>|</B> and <B>&lt;</B> operators can be made. 
  Historical practice has been that:</P><PRE><TT>getline &lt; "a" "b"
</TT>
</PRE>
  <P>is parsed as:</P><PRE><TT>( getline &lt; "a" ) "b"
</TT>
</PRE>
  <P>although many would argue that the intent was that the file <B>ab</B> 
  should be read. However:</P><PRE><TT>getline &lt; "x" + 1
</TT>
</PRE>
  <P>parses as:</P><PRE><TT>getline &lt; ( "x" + 1 )
</TT>
</PRE>
  <P>Similar problems occur with the <B>|</B> version of <B>getline</B>, 
  particularly in combination with <B>$</B>. For example:</P><PRE><TT>$"echo hi" | getline
</TT>
</PRE>
  <P>(This situation is particularly problematic when used in a <B>print</B> 
  statement, where the <B>|getline</B> part might be a redirection of the 
  <B>print</B>.)</P>
  <P>Since in most cases such constructs are not (or at least should not) be 
  used (because they have a natural ambiguity for which there is no conventional 
  parsing), the meaning of these constructs has been made explicitly 
  unspecified. (The effect is that a conforming application that runs into the 
  problem must parenthesize to resolve the ambiguity.) There appeared to be few 
  if any actual uses of such constructs.</P>
  <P>Grammars can be written that would cause an error under these 
  circumstances. Where backwards-compatibility is not a large consideration, 
  implementors may wish to use such grammars.</P>
  <P>Some historical implementations have allowed some built-in functions to be 
  called without an argument list, the result being a default argument list 
  chosen in some "reasonable" way. Use of <B>length</B> as a synonym for 
  <B>length($0)</B> is the only one of these forms that is thought to be widely 
  known or widely used; this particular form is documented in various places 
  (for example, most historical <I>awk</I> reference pages, although not in the 
  referenced <I>The AWK Programming Language</I>) as legitimate practice. With 
  this exception, default argument lists have always been undocumented and 
  vaguely defined, and it is not at all clear how (or if) they should be 
  generalized to user-defined functions. They add no useful functionality and 
  preclude possible future extensions that might need to name functions without 
  calling them. Not standardizing them seems the simplest course. The standard 
  developers considered that <B>length</B> merited special treatment, however, 
  since it has been documented in the past and sees possibly substantial use in 
  historical programs. Accordingly, this usage has been made legitimate, but 
  Issue&nbsp;5 removed the obsolescent marking for XSI-conforming 
  implementations and many otherwise conforming applications depend on this 
  feature.</P>
  <P>In <B>sub</B> and <B>gsub</B>, if <I>repl</I> is a string literal (the 
  lexical token <B>STRING</B>), then two consecutive backslash characters should 
  be used in the string to ensure a single backslash will precede the ampersand 
  when the resultant string is passed to the function. (For example, to specify 
  one literal ampersand in the replacement string, use <B>gsub</B>( <B>ERE</B>, 
  <TT>"\\&amp;"</TT> ).)</P>
  <P>Historically the only special character in the <I>repl</I> argument of 
  <B>sub</B> and <B>gsub</B> string functions was the ampersand ( 
  <TT>'&amp;'</TT> ) character and preceding it with the backslash character was 
  used to turn off its special meaning.</P>
  <P>The description in the ISO&nbsp;POSIX-2:1993 standard introduced behavior 
  such that the backslash character was another special character and it was 
  unspecified whether there were any other special characters. This description 
  introduced several portability problems, some of which are described below, 
  and so it has been replaced with the more historical description. Some of the 
  problems include:</P>
  <UL>
    <LI>
    <P>Historically, to create the replacement string, a script could use 
    <B>gsub</B>( <B>ERE</B>, <TT>"\\&amp;"</TT> ), but with the 
    ISO&nbsp;POSIX-2:1993 standard wording, it was necessary to use <B>gsub</B>( 
    <B>ERE</B>, <TT>"\\\\&amp;"</TT> ). Backslash characters are doubled here 
    because all string literals are subject to lexical analysis, which would 
    reduce each pair of backslash characters to a single backslash before being 
    passed to <B>gsub</B>.</P>
    <LI>
    <P>Since it was unspecified what the special characters were, for portable 
    scripts to guarantee that characters are printed literally, each character 
    had to be preceded with a backslash. (For example, a portable script had to 
    use <B>gsub</B>( <B>ERE</B>, <TT>"\\h\\i"</TT> ) to produce a replacement 
    string of <TT>"hi"</TT>.)</P></LI></UL>
  <P>The description for comparisons in the ISO&nbsp;POSIX-2:1993 standard did 
  not properly describe historical practice because of the way numeric strings 
  are compared as numbers. The current rules cause the following code:</P><PRE><TT>if (0 == "000")
    print "strange, but true"
else
    print "not true"
</TT>
</PRE>
  <P>to do a numeric comparison, causing the <B>if</B> to succeed. It should be 
  intuitively obvious that this is incorrect behavior, and indeed, no historical 
  implementation of <I>awk</I> actually behaves this way.</P>
  <P>To fix this problem, the definition of <I>numeric string</I> was enhanced 
  to include only those values obtained from specific circumstances (mostly 
  external sources) where it is not possible to determine unambiguously whether 
  the value is intended to be a string or a numeric.</P>
  <P>Variables that are assigned to a numeric string shall also be treated as a 
  numeric string. (For example, the notion of a numeric string can be propagated 
  across assignments.) In comparisons, all variables having the uninitialized 
  value are to be treated as a numeric operand evaluating to the numeric value 
  zero.</P>
  <P>Uninitialized variables include all types of variables including scalars, 
  array elements, and fields. The definition of an uninitialized value in <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/awk.html#tag_04_06_13_03">Variables 
  and Special Variables</A> is necessary to describe the value placed on 
  uninitialized variables and on fields that are valid (for example, <B>&lt;</B> 
  <B>$NF</B>) but have no characters in them and to describe how these variables 
  are to be used in comparisons. A valid field, such as <B>$1</B>, that has no 
  characters in it can be obtained from an input line of <TT>"\t\t"</TT> when 
  <B>FS=</B> <TT>'\t'</TT>. Historically, the comparison ( <B>$1&lt;</B>10) was 
  done numerically after evaluating <B>$1</B> to the value zero.</P>
  <P>The phrase "... also shall have the numeric value of the numeric string" 
  was removed from several sections of the ISO&nbsp;POSIX-2:1993 standard 
  because is specifies an unnecessary implementation detail. It is not necessary 
  for IEEE&nbsp;Std&nbsp;1003.1-2001 to specify that these objects be assigned 
  two different values. It is only necessary to specify that these objects may 
  evaluate to two different values depending on context.</P>
  <P>The description of numeric string processing is based on the behavior of 
  the <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/atof.html"><I>atof</I>()</A> 
  function in the ISO&nbsp;C standard. While it is not a requirement for an 
  implementation to use this function, many historical implementations of 
  <I>awk</I> do. In the ISO&nbsp;C standard, floating-point constants use a 
  period as a decimal point character for the language itself, independent of 
  the current locale, but the <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/atof.html"><I>atof</I>()</A> 
  function and the associated <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/strtod.html"><I>strtod</I>()</A> 
  function use the decimal point character of the current locale when converting 
  strings to numeric values. Similarly in <I>awk</I>, floating-point constants 
  in an <I>awk</I> script use a period independent of the locale, but input 
  strings use the decimal point character of the locale.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_19></A>FUTURE DIRECTIONS</H4>
<BLOCKQUOTE>
  <P>None.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_20></A>SEE ALSO</H4>
<BLOCKQUOTE>
  <P><A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/xcu_chap01.html#tag_01_10"><I>Grammar 
  Conventions</I></A>, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/grep.html"><I>grep</I></A>, 
  <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/lex.html"><I>lex</I></A>, 
  <A 
  href="http://www.opengroup.org/onlinepubs/009695399/utilities/sed.html"><I>sed</I></A>, 
  the System Interfaces volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/atof.html"><I>atof</I>()</A>, 
  <I>exec</I>, <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/popen.html"><I>popen</I>()</A>, 
  <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/setlocale.html"><I>setlocale</I>()</A>, 
  <A 
  href="http://www.opengroup.org/onlinepubs/009695399/functions/strtod.html"><I>strtod</I>()</A></P></BLOCKQUOTE>
<H4><A name=tag_04_06_21></A>CHANGE HISTORY</H4>
<BLOCKQUOTE>
  <P>First released in Issue 2.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_22></A>Issue 5</H4>
<BLOCKQUOTE>
  <P>The FUTURE DIRECTIONS section is added.</P></BLOCKQUOTE>
<H4><A name=tag_04_06_23></A>Issue 6</H4>
<BLOCKQUOTE>
  <P>The <I>awk</I> utility is aligned with the IEEE&nbsp;P1003.2b draft 
  standard.</P>
  <P>The normative text is reworded to avoid use of the term "must" for 
  application requirements.<BR></P>
  <P>IEEE PASC Interpretation 1003.2 #211 is applied, adding the sentence "An 
  occurrence of two consecutive backslashes shall be interpreted as just a 
  single literal backslash character." into the description of the <B>sub</B> 
  string function.</P></BLOCKQUOTE>
<DIV class=box><EM>End of informative text.</EM></DIV>
<HR noShade SIZE=2>

<CENTER><FONT size=2><!--footer start-->UNIX ® is a registered Trademark of The 
Open Group.<BR>POSIX ® is a registered Trademark of The IEEE.<BR>[ <A 
href="http://www.opengroup.org/onlinepubs/009695399/mindex.html">Main Index</A> 
| <A 
href="http://www.opengroup.org/onlinepubs/009695399/basedefs/contents.html">XBD</A> 
| <A 
href="http://www.opengroup.org/onlinepubs/009695399/utilities/contents.html">XCU</A> 
| <A 
href="http://www.opengroup.org/onlinepubs/009695399/functions/contents.html">XSH</A> 
| <A 
href="http://www.opengroup.org/onlinepubs/009695399/xrat/contents.html">XRAT</A> 
]</FONT></CENTER><!--footer end-->
<HR noShade SIZE=2>
</BASEFONT></BODY></HTML>
