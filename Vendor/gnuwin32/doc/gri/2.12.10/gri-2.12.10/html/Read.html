<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Gri: Read commands</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000EE" vlink="#551A8B" alink="FF0000">
<!-- newfile Read.html "Gri: Read commands" "Gri Commands" --> 

<!-- @node   Read, Read Colornames, Quit, List Of Gri Commands -->
<a name="Read" ></a>

<img src="./resources/top_banner.gif" alt="navigation map" usemap="#navigate_top" border="0">
<table summary="top banner" border="0" cellspacing="0" cellpadding="0">
<tr>
<td width="150" valign="top">
<font size=-1>
<br>
Chapters:
<br>
&nbsp;&nbsp;<a href="Introduction.html">1: Introduction</a><br>
&nbsp;&nbsp;<a href="SimpleExample.html">2: Simple example</a><br>
&nbsp;&nbsp;<a href="InvokingGri.html">3: Invocation</a><br>
&nbsp;&nbsp;<a href="GettingMoreControl.html">4: Finer Control</a><br>
&nbsp;&nbsp;<a href="X-Y.html">5: X-Y Plots</a><br>
&nbsp;&nbsp;<a href="ContourPlots.html">6: Contour Plots</a><br>
&nbsp;&nbsp;<a href="Images.html">7: Image Plots</a><br>
&nbsp;&nbsp;<a href="Examples.html">8: Examples</a><br>
&nbsp;&nbsp;<a href="Commands.html">9: Gri Commands</a><br>
&nbsp;&nbsp;<a href="Programming.html">10: Programming</a><br>
&nbsp;&nbsp;<a href="Environment.html">11: Environment</a><br>
&nbsp;&nbsp;<a href="Emacs.html">12: Emacs Mode</a><br>
&nbsp;&nbsp;<a href="History.html">13: History</a><br>
&nbsp;&nbsp;<a href="Installation.html">14: Installation</a><br>
&nbsp;&nbsp;<a href="Bugs.html">15: Gri Bugs</a><br>
&nbsp;&nbsp;<a href="TestSuite.html">16: Test Suite</a><br>
&nbsp;&nbsp;<a href="GriInThePress.html">17: Gri in Press</a><br>
&nbsp;&nbsp;<a href="Acknowledgments.html">18: Acknowledgments</a><br>
&nbsp;&nbsp;<a href="License.html">19: License</a><br>
<br>
Indices:<br>
&nbsp;&nbsp;<a href="ConceptIndex.html"><i>Concepts</i></a><br>
&nbsp;&nbsp;<a href="CommandIndex.html"><i>Commands</i></a><br>
&nbsp;&nbsp;<a href="BuiltinIndex.html"><i>Variables</i></a><br>
</font>
<td width="500" valign="top">
<map name="navigate_top">
<area alt="index.html#Top" shape="rect" coords="5,2,218,24" href="index.html#Top">
<area alt="ListOfGriCommands.html#ListOfGriCommands" shape="rect" coords="516,2,532,24" href="ListOfGriCommands.html#ListOfGriCommands">
<area alt="Gri: `quit' command" shape="rect" coords="557,2,573,24" href="Quit.html">
<area alt="Gri: `regress' command" shape="rect" coords="581,2,599,24" href="Regress.html">
</map>
<map name="navigate_bottom">
<area alt="index.html#Top" shape="rect" coords="5,2,218,24" href="index.html#Top">
<area alt="Gri: `regress' command" shape="rect" coords="581,2,599,24" href="Regress.html">
</map>
<h3>9.3.33: The `<font color="#82140F"><code>read</code></font>' commands</h3>


There are several varieties of `<font color="#82140F"><code>read</code></font>' command.  Those commands used
for reading numerical information (e.g. `<font color="#82140F"><code>read columns</code></font>') are able to
decode variables and synonyms as well as simple numbers.
<p>
<UL>
<LI><a href="Read.html#ReadColornames">Read Colornames</a>: Read colornames
<LI><a href="Read.html#ReadColumns">Read Columns</a>: Read (x,y,...) columnar data
<LI><a href="Read.html#ReadGrid">Read Grid</a>: Read grid for contouring
<LI><a href="Read.html#ReadImageColorscale">Read Image Colorscale</a>: Read colormap for color image
<LI><a href="Read.html#ReadImageGrayscale">Read Image Grayscale</a>: Read colormap for gray image
<LI><a href="Read.html#ReadImageMask">Read Image Mask</a>: Read mask for image
<LI><a href="Read.html#ReadImage">Read Image</a>: Read image
<LI><a href="Read.html#ReadFrom">Read From</a>: Change which open file looked at
<LI><a href="Read.html#ReadSynonymorVariable">Read Synonym or Variable</a>: Read individual synonym or variable
<LI><a href="Read.html#ReadLine">Read Line</a>: Read whole line
</UL>


<!-- @node   Read Colornames, Read Columns, Read, Read -->
<a name="ReadColornames" ></a>
<h4>9.3.33.1: `<font color="#82140F"><code>read colornames</code></font>'</h4>

<!-- latex: \index{read colornames} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read colornames from RGB "\filename"'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read colornames from named file, which is in the X11 format.  This
format has 4 or more columns, the first three giving the red, green and
blue values in the range 0 to 255, and the last columns giving the
colorname (which may have more than one word).  You can create colors
yourself or read an X11 color file.  In many cases you will want to
`<font color="#82140F"><code>read colornames from RGB "/usr/lib/X11/rgb.txt"</code></font>'.  Full filenames
must be used; the '~' syntax is not permitted.  Once you have read in a
colorname table, the named colors may be used as builtin colors
(see <a href="Set.html#SetColor">Set Color</a>).  To view the colors available on your particular
system, use the Unix command `<font color="#82140F"><code>xcolors</code></font>' or `<font color="#82140F"><code>excolors</code></font>'; to see
the RGB values of all colors on your X11 system, use the `<font color="#82140F"><code>showrgb</code></font>'
unix command..  To view the names and RGB values of the colors Gri
knows, including builtin ones and ones from `<font color="#82140F"><code>read colornames</code></font>', use
`<font color="#82140F"><code>show colornames</code></font>'.
<p>
This command is akin to `<font color="82140F"><code>set colorname</code></font>' (see <a href="Set.html#SetColorname">Set Colorname</a>),
except that the latter uses the Gri notation of color constituents being
in the range from 0 to 1, whereas for `<font color="#82140F"><code>read colornames</code></font>' uses an
X11 database, so that the color constitutents range from 0 to 255.
<p>

<!-- @node   Read Columns, Read Grid, Read Colornames, Read -->
<a name="ReadColumns" ></a>
<h4>9.3.33.2: `<font color="#82140F"><code>read columns</code></font>'</h4>

<!-- latex: \index{read columns} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read columns ...'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>
Read numbers into columns.  These columns have predefined
meanings and names.  For example, `<font color="#82140F"><code>read columns x y</code></font>' instructs Gri
to read data into columns called `<font color="#82140F"><code>x</code></font>' and `<font color="#82140F"><code>y</code></font>'; it is these data
that Gri will use if you tell it to `<font color="#82140F"><code>draw curve</code></font>'.  Other columns
are: `<font color="#82140F"><code>z</code></font>', used for contouring a function `<font color="#82140F"><code>z=z(x,y)</code></font>';
`<font color="#82140F"><code>weight</code></font>', used for weighting data points; `<font color="#82140F"><code>u</code></font>' and `<font color="#82140F"><code>v</code></font>',
used for arrow (vector) plots.
<p>
If the keyword `<font color="#82140F"><code>appending</code></font>' is given as the last word on the
`<font color="#82140F"><code>read columns</code></font>' line, then the new data will be appended to any
existing columnar data; otherwise they will overwrite any existing data.
<p>
As a special case, if the `<font color="#82140F"><code>x</code></font>' column is not indicated
(e.g. `<font color="#82140F"><code>read columns y</code></font>') then Gri creates x-values automatically, in
the sequence 0, 1, 2, etc.
<p>
<ul>
<p>
<li> `<font color="#82140F"><code>read columns x y</code></font>'
Read `<font color="#82140F"><code>x</code></font>' in column 1, `<font color="#82140F"><code>y</code></font>' in column 2 until blank-line found.
Only the first two numbers on each line will be read; any extra numbers
(or words) on the line will be ignored.
<p>
<li> `<font color="#82140F"><code>read columns * y * * x</code></font>'
Read `<font color="#82140F"><code>x</code></font>' in column 5, `<font color="#82140F"><code>y</code></font>' in column 2.  The `<font color="#82140F"><code>*</code></font>' character
is a spacer.  It instructs Gri to skip the first, third, and fourth
words on the data line.  These words need not be numbers.  This example
illustrates a general mechanism of using the `<font color="#82140F"><code>*</code></font>' character to skip
over unwanted items in the data file.  Note that there is no need to
supply `<font color="#82140F"><code>*</code></font>' characters for trailing extraneous words; Gri will skip
them anywary.  Finally, note that any order of `<font color="#82140F"><code>x</code></font>' and `<font color="#82140F"><code>y</code></font>'
(and the other columns; see below) is allowed.
<p>
<li> `<font color="#82140F"><code>read columns y=2 x=5</code></font>' or `<font color="#82140F"><code>read columns x=5 y=2</code></font>'
As above; read `<font color="#82140F"><code>x</code></font>' in column 5 and `<font color="#82140F"><code>y</code></font>' in column 2.  The
column number may be specified in this manner for all the named column
variables.  No spaces are allowed before or after the `<font color="#82140F"><code>=</code></font>' sign.
The first column is called column 1.  Whether this format is used or the
`<font color="#82140F"><code>*</code></font>' format is a matter of choice, except that numbered format also
permits using a given number to fill several variables (for example
`<font color="#82140F"><code>read columns x=1 y=2 u=1 v=2</code></font>').
<p>

<li> `<font color="#82140F"><code>read columns x="netCDF_name" ...</code></font>'
If the file is a `<font color="#82140F"><code>netCDF</code></font>' file, opened
by e.g. `<font color="#82140F"><code>open myfile.nc netCDF</code></font>', then the `<font color="#82140F"><code>netCDF</code></font>' variables
for the columns, e.g. 
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
open latlon.nc netCDF
read columns x="longitude" y="latitude"
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Note: the data <b>must</b> be stored as the `<font color="#82140F"><code>netCDF</code></font>' ``float''
type.
<p>
For more information on netCDF format, see
<p>
`<font color="#82140F"><code>http://www.unidata.ucar.edu/packages/netcdf/index.html</code></font>'
<a href="http://www.unidata.ucar.edu/packages/netcdf/index.html"> 
here </a>. 
<p>
<li> `<font color="#82140F"><code>read columns * y z * x</code></font>'
Read `<font color="#82140F"><code>x</code></font>' in column 5, `<font color="#82140F"><code>y</code></font>' in column 2, and `<font color="#82140F"><code>z</code></font>' in column
3.  The `<font color="#82140F"><code>z</code></font>' column is used for contouring.
<p>
<li> `<font color="#82140F"><code>read columns x y u v</code></font>'
Read `<font color="#82140F"><code>x</code></font>' and `<font color="#82140F"><code>y</code></font>' in first two columns, and the ``arrow'' data
`<font color="#82140F"><code>u</code></font>' and `<font color="#82140F"><code>v</code></font>' as third and fourth columns.
<p>
<li> `<font color="#82140F"><code>read columns .rows. x y</code></font>'
Read `<font color="#82140F"><code>.rows.</code></font>' rows of column data.
</ul>
<p>

Sometimes you'll have `<font color="#82140F"><code>x</code></font>' in one file and `<font color="#82140F"><code>y</code></font>' in another.  In
that case, use the operating system or an editor to put the columns in
one file.  In unix, the easy way is
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
open "paste file_with_x file_with_y |"
read columns x y
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

NOTE FOR BINARY FILES: For ascii files, Gri will proceed to a new line
after it has read the items requested; it skips any words appearing on
the data line after the last object of interest.  Thus 
`<font color="#82140F"><code>read columns x y</code></font>' will read the first two columns and ignore any other
columns that might be present.  But for binary files, Gri has no way of
knowing how to "skip" to the next line (see `<font color="#82140F"><code>skip</code></font>' command), so you
will have to flesh out the `<font color="#82140F"><code>read columns</code></font>' command with as many
spacers as are present in your data.  For example, if you have four
numbers in each data record and want to interpret the first two as
`<font color="#82140F"><code>x</code></font>' and `<font color="#82140F"><code>y</code></font>', you would use `<font color="#82140F"><code>read columns x y * *</code></font>' to read
the data.
<p>

RETURN VALUE:
Sets `<font color="#82140F"><code>\.return_value</code></font>' to 
`<font color="#82140F"><code>N rows N non-missing N inside-clip-region</code></font>'  
<p>

<!-- @node   Read Grid, Read Image Colorscale, Read Columns, Read -->
<a name="ReadGrid" ></a>
<h4>9.3.33.3: `<font color="#82140F"><code>read grid</code></font>'</h4>

<!-- latex: \index{read grid} -->

`<font color="#82140F"><code>read grid</code></font>' commands read grid characteristics.  (The ``grid'' is
the object that is contoured.)
<p>
For normal ascii or binary files, the commands to read the grid's
x-locations, y-locations and data are:
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read grid x [.rows.]'
`read grid y [.rows.]'
`read grid data [spacers] \
  [.rows. .cols.] [spacers] [bycolumns]'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>
For `<font color="#82140F"><code>netCDF</code></font>' files, the commands are as follows (note that it is
not possible to specify the number of data to read, nor to read the grid
by columns).
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read grid x = "variable_name"'
`read grid y = "variable_name"'
`read grid data = "variable_name"'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

The ordering of the y-grid data is the same as if they were read from a
normal file: the first number is considered to be at the top of the
plot.
<p>
For more information on netCDF format, see
<p>
`<font color="#82140F"><code>http://www.unidata.ucar.edu/packages/netcdf/index.html</code></font>'
<a href="http://www.unidata.ucar.edu/packages/netcdf/index.html"> 
here </a>. 
<p>

Details of the non-netCDF commands:
<ul>
<p>
<li> `<font color="#82140F"><code>read grid x [.cols.]</code></font>'
Read the `<font color="#82140F"><code>x</code></font>' locations of the grid points, one number per line.
If `<font color="#82140F"><code>.cols.</code></font>' is supplied, then that many values will be read;
otherwise, reading will stop at end-of-file or blank-line.
<p>
<li> `<font color="#82140F"><code>read grid y [.rows.]</code></font>'
As above, but for y grid;  `<font color="#82140F"><code>.rows.</code></font>' is the number of rows.  The
first number to be read corresponds to the location of the <b>top</b>
edge of the grid.  Thus, if you were to view the column of numbers with
a text editor, they would be oriented the same way as the corresponding
elements will appear on the page.
<p>
<li> `<font color="#82140F"><code>read grid data [.rows. .cols.]</code></font>'
Read data for a grid having `<font color="#82140F"><code>.rows.</code></font>' and `<font color="#82140F"><code>.cols.</code></font>' columns.
(If `<font color="#82140F"><code>.rows.</code></font>' and `<font color="#82140F"><code>.cols.</code></font>' are not supplied, but the grid
already exists, then those pre-existing values are used.  If they are
specified here, then they are checked for consistency with the
pre-existing values if they exist.) Gri will read `<font color="#82140F"><code>.rows.</code></font>' lines,
each containing `<font color="#82140F"><code>.cols.</code></font>' numbers.  (Extra information in the file
can be skipped; see discussion of the `<font color="#82140F"><code>*</code></font>' keyword below.)  Gri
will interpret the first line it reads as the grid data corresponding
to a value of y equal to `<font color="#82140F"><code>y[.rows.]</code></font>'.  Thus, file should be
arranged like this:
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
f(x[1], y[.rows.])  ...  f(x[.cols.], y[.rows.])
        .
        .
        .
f(x[1], y[3])       ...  f(x[.cols], y[3])
f(x[1], y[2])       ...  f(x[.cols], y[2])
f(x[1], y[1])       ...  f(x[.cols], y[1])
</font></PRE>
</TD>
</TR>
</TABLE>
 
<li> `<font color="#82140F"><code>read grid data [.rows. .cols.] bycolumns</code></font>'
As above, but the `<font color="#82140F"><code>bycolumns</code></font>' keyword tells Gri to read the data
one column at a time, instead of one row at a time.  Each line is
expected to contain `<font color="#82140F"><code>.rows.</code></font>' numbers (as opposed to `<font color="#82140F"><code>.cols.</code></font>'
numbers, as in the format where the `<font color="#82140F"><code>bycolumns</code></font>' keyword is not
present).  (Extra information in the file can be skipped; see
discussion of the `<font color="#82140F"><code>*</code></font>' keyword below).  The first line of the data
file contains the first column of the gridded data, corresponding to x
equal to `<font color="#82140F"><code>x[1]</code></font>').  The file should look like this:
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
f(x[1], y[1])     ...     f(x[1], y[.cols.])
f(x[2], y[1])     ...     f(x[2], y[.cols.])
f(x[3], y[1])     ...     f(x[3], y[.cols.])
        .
        .
        .
f(x[.rows.],y[1]) ...  f(x[.rows.], y[.cols.])
</font></PRE>
</TD>
</TR>
</TABLE>
<p>
<li> `<font color="#82140F"><code>read grid data * * [.rows. .cols.]</code></font>'
As `<font color="#82140F"><code>read grid data .rows. .cols.</code></font>' except that the first two words
on each line are skipped.  As usual, trailing extraneous numbers are
also skipped.
</ul>
<p>
<b>See also</b> `<font color="#82140F"><code>set x grid</code></font>', `<font color="#82140F"><code>set y grid</code></font>'
<p>


RETURN VALUE:
<p>
`<font color="#82140F"><code>read grid x</code></font>' sets `<font color="#82140F"><code>\.return_value</code></font>' to `<font color="#82140F"><code>N cols</code></font>'
<p>
`<font color="#82140F"><code>read grid y</code></font>' sets `<font color="#82140F"><code>\.return_value</code></font>' to `<font color="#82140F"><code>N rows</code></font>'
<p>
`<font color="#82140F"><code>read grid data</code></font>' sets `<font color="#82140F"><code>\.return_value</code></font>' to `<font color="#82140F"><code>N rows N cols</code></font>'
<p>

<!-- @node   Read Image Colorscale, Read Image Grayscale, Read Grid, Read -->
<a name="ReadImageColorscale" ></a>
<h4>9.3.33.4: `<font color="#82140F"><code>read image colorscale</code></font>'</h4>

<!-- latex: \index{read image colorscale} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read image colorscale [rgb|hsb]'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read colorscale for image, from 256 lines each containing values for
Red, Green, and Blue (or Hue, Saturation and Brightness), separated by
whitespace.  The values are expected to be in the range 0 to 1, and are
clipped to these limits if not.  
<p>
For hints on how to create such an input file, 
see <a href="Read.html#ReadImageGrayscale">Read Image Grayscale</a>.  If the example given there has the
following code instead, 
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
open "awk 'BEGIN {               \
     for(i=0;i&lt;256;i++) {        \
       print((i - 50)/50, 1, 1)  \
     }                           \
   }' |"
read image colorscale hsb
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

then a linear full-color spectrum running from red at 10C to magenta at
15C is achieved.
<p>

<!-- @node   Read Image Grayscale, Read Image Mask, Read Image Colorscale, Read -->
<a name="ReadImageGrayscale" ></a>
<h4>9.3.33.5: `<font color="#82140F"><code>read image grayscale</code></font>'</h4>

<!-- latex: \index{read image grayscale} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read image grayscale'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read grayscale for an image, from 256 lines each containing a
single value.  The values are expected to be in the range 0 to 1, and
are clipped to these limits if not.  For 8-bit images, Gri multiplies
these values by 255, and uses this list for the grayscale mapping.  Such
a list is created by `<font color="#82140F"><code>write image grayscale</code></font>'.
<p>
As an example, consider the code fragment (see <a href="Images.html#Images">Images</a>).
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
set image range 5 30.5
set image grayscale black 10 white 15
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

is equivalent to
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
set image range 5 30.5
open "awk 'BEGIN {\
  for(i=0;i&lt;256;i++) {\
    print(1-(i-50)/50)\
  } \
}' |"
read image grayscale
close
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

because the image formula is
<BLOCKQUOTE>
Temperature = 5C + 0.1C * pixelvalue
</BLOCKQUOTE>
<p>
where the pixelvalue ranges from 0 to 255.  Therefore, a temperature of
10C is a pixelvalue of 50, and 15C is 100.  To get a grayscale ranging
between these values, therefore, we create a linear function which maps
the 50th pixelvalue into grayvalue 1, and the 100th pixelvalue into
grayvalue 0.  That is what the awk line does; to see the actual numbers,
you could insert the line `<font color="#82140F"><code>write image grayscale to TMP</code></font>' and look at
the file `<font color="#82140F"><samp>TMP</samp></font>' (bear in mind that Gri will clip the values to the
range 0 to 1).
<p>
Sometimes you will have a file, say named `<font color="#82140F"><samp>map.dat</samp></font>', with RGB
numbers in the range 0-255, rather than 0-1 as Gri requires.  To read
them, use the operating system to convert the numbers for you
(see <a href="Open.html#Open">Open</a>).
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
open "cat map.dat \
  | awk '{print(($1+$2+$3)/3/255)}' |"
read image grayscale
close
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

<!-- @node   Read Image Mask, Read Image, Read Image Grayscale, Read -->
<a name="ReadImageMask" ></a>
<h4>9.3.33.6: `<font color="#82140F"><code>read image mask</code></font>'</h4>

<!-- latex: \index{read image mask} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read image mask rasterfile|{.rows. .cols.}'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read image mask.  The mask is associated with the image read in by the
`<font color="#82140F"><code>read image</code></font>' command in the following way.  When computing image
histograms, Gri ignores any pixels in the image for which the
corresponding pixel in the mask is set to `<font color="#82140F"><code>1</code></font>'.
<p>
<ul>
<p>
<li> `<font color="#82140F"><code>read image mask rasterfile</code></font>'
The image size is specified in the rasterfile file itself, so 
it is not specified.
<p>
<li> `<font color="#82140F"><code>read image mask .rows. .cols.</code></font>'
The file must contain `<font color="#82140F"><code>.rows.*.cols.</code></font>' binary data.  Pixel 
order is the same as for images.
</ul>
<p>

<!-- @node   Read Image, Read From, Read Image Mask, Read -->
<a name="ReadImage" ></a>
<h4>9.3.33.7: `<font color="#82140F"><code>read image</code></font>'</h4>

<!-- latex: \index{read image} -->

There are several types of `<font color="#82140F"><code>read image</code></font>' commands, depending on the
file format.  If the file is "raw", with no embedded information about
things like the width and height, then we need to specify everything, as
in the first format given below.  The other formats make use of the
header information in, e.g. PGM files.
<p>
<b>Headerless images</b>
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read image .rows. .cols. \
  [box .xleft. .ybottom. .xright. .ytop.] \
  [bycolumns]'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

With no options specified (`<font color="#82140F"><code>read image .rows. .cols.</code></font>'), read binary
data defining an `<font color="#82140F"><code>image</code></font>'.  The image range must have previously
have been set by `<font color="#82140F"><code>set image range</code></font>'.  The data are as written by
"unsigned char" format in C.
<p>
When the `<font color="#82140F"><code>box</code></font>' option is specified, the geometry of the image, in
user coordinates, is specified in terms of the cartesian coordinates of
the lower-left corner (`<font color="#82140F"><code>.xleft.</code></font>', `<font color="#82140F"><code>.ybottom.</code></font>') and upper-right
corner (`<font color="#82140F"><code>.xright.</code></font>', `<font color="#82140F"><code>.ytop.</code></font>').  If the `<font color="#82140F"><code>box</code></font>' option is not
specified, this geometry can be specified with either `<font color="#82140F"><code>read x grid</code></font>'
or `<font color="#82140F"><code>set x grid</code></font>', plus either `<font color="#82140F"><code>read y grid</code></font>' or 
`<font color="#82140F"><code>set y grid</code></font>'.
<p>
With the `<font color="#82140F"><code>bycolumns</code></font>' keyword present, the image is read sweeping
from top-to-bottom, then left-to-right, instead of the usual order.
<p>

<b>Sun rasterfile images</b>
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read image rasterfile [box .xleft. .ybottom. .xright. .ytop.]'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read image in Sun rasterfile format.  Image geometry is inferred from
the header, so `<font color="#82140F"><code>.rows.</code></font>' and `<font color="#82140F"><code>.cols</code></font>' parameters are not given.
<p>
<b>PGM images</b>
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read image pgm [box .xleft. .ybottom. .xright. .ytop.]'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read image in PGM (Portable Gray Map) format.  Image geometry is
inferred from the header, so `<font color="#82140F"><code>.rows.</code></font>' and `<font color="#82140F"><code>.cols</code></font>' parameters
are not given.  Both ascii and binary PGM formats are supported (that
is, files with magic characters of P2 and P5).
<p>
<b>NOTE</b> that there are many image formats and Gri doesn't try to
deal with them all.  The idea is to use another program to convert
images to a file format that Gri understands.  In the future Gri may
support PNG and other popular formats, especially in the Linux versions,
for which libraries exist to ease the input.
<p>


<!-- @node   Read From, Read Synonym or Variable, Read Image, Read -->
<a name="ReadFrom" ></a>
<h4>9.3.33.8: `<font color="#82140F"><code>read from \filename</code></font>'</h4>

<!-- latex: \index{read from} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read from \filename'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Cause future `<font color="#82140F"><code>read</code></font>' commands to read from the indicated file.  If
that file is not open, an error message will result.  Use 
`<font color="#82140F"><code>read from \filename</code></font>' to shuffle reading among several open files.
<p>
Gri can look up filenames for `<font color="#82140F"><code>read from</code></font>' in terms of their
<b>full</b> pathnames or their <b>local</b> pathnames.  Thus, a local file
called `<font color="#82140F"><code>a.dat</code></font>' in the directory `<font color="#82140F"><code>/home/gri</code></font>' can be referred to
by `<font color="#82140F"><code>read from a.dat</code></font>' or by `<font color="#82140F"><code>read from /home/gri/a.dat</code></font>', which
comes in handy if you need to work with two files of the same name, in
other directories.  However, since Gri has the ability to search for
files in a "path" (see <a href="Set.html#SetPathTo">Set Path To</a>), you may not have specified an
exact path name; this is why the `<font color="#82140F"><code>open</code></font>' command provides a return
value which names the full pathname (see <a href="Open.html#OpeningSimpleFiles">Opening Simple Files</a>).
<p>

<!-- @node   Read Synonym or Variable, Read Line, Read From, Read -->
<a name="ReadSynonymorVariable" ></a>
<h4>9.3.33.9: `<font color="#82140F"><code>read</code></font>' synonym/variable</h4>

<!-- latex: \index{read} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read [* [*...]] \synonym|.variable. [\synonym|.variable. [...]]}'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read one or more items from the next line of the input file.  These
items may be synonyms or variables.  The token `<font color="#82140F"><code>*</code></font>' indicates
that the word in the datafile should be skipped.  As usual, the datafile
may be embedded in the commandfile, providing the last data line is blank.
<p>
Normally one would use synonyms for words, and variables for numbers.
The items are separated by one or more "whitespace" characters
(e.g. space or TAB).  Thus, if a file contained the line
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
Temperature 10.3
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

then the line
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">        
read \var_name .var_value.
</font></PRE>
</TD>
</TR>
</TABLE>    
<p>

would have the same result as
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">        
\var_name = "Temperature"
.var_value. = 10.3
</font></PRE>
</TD>
</TR>
</TABLE>
<p>
This command ignores any trailing items on the line.  That is, the next
`<font color="#82140F"><code>read</code></font>' command will start on the next line of the file.  In a
sense then, you get just one shot at analysing the input line in your
datafile.  If you need flexibility, you may wish to read the
<b>whole</b> contents of the line into a synonym, which may be done
using the `<font color="#82140F"><code>read line</code></font>' command instead, to read it in as a string.
(see <a href="Read.html#ReadLine">Read Line</a>).
<p>

If the input file is in the netCDF format, the
indicated item will be read.  For example, 
`<font color="#82140F"><code>read \time:_MissingValue</code></font>' reads the missing value for the variable
called `<font color="#82140F"><code>time</code></font>'.  This conveniently allows your data file to dictate
axes names, units, missing values, etc.  Example:
<p>
<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
# Plot profile of TU81N (age-corrected tritium)
open profile.nc netCDF
read columns x="TU81N" y="z"
read \{z:_FillValue}		# assume same for all
read \{z:long_name}
read \{z:units}
read \{TU81N:long_name}
read \{TU81N:units}
close
set missing value \{z:_FillValue}
set x name "\{TU81N:long_name} (\{TU81N:units)}"
set y name "\{z:long_name} (\{z:units)}"
set y axis decreasing
draw curve
</font></PRE>
</TD>
</TR>
</TABLE>
<p>
For more information on netCDF format, see
`<font color="#82140F"><code>http://www.unidata.ucar.edu/packages/netcdf/index.html</code></font>'
<a href="http://www.unidata.ucar.edu/packages/netcdf/index.html"> 
here </a>. 
<p>


<!-- @node   Read Line, Regress, Read Synonym or Variable, Read -->
<a name="ReadLine" ></a>
<h4>9.3.33.10: `<font color="#82140F"><code>read line</code></font>'</h4>

<!-- latex: \index{read line} -->

<TABLE SUMMARY="Example" BORDER="0" BGCOLOR="#efefef" WIDTH="100%">
<TR>
<TD>
<PRE>
<font color="#82140F">
`read line \synonym'
</font></PRE>
</TD>
</TR>
</TABLE>
<p>

Read the next line of the datafile (or commandfile), trim off a trailing
comment if there is one, and then store the next line of datafile into
the named synonym.
<p>
</table>
<img src="./resources/bottom_banner.gif" alt="navigation map" usemap="#navigate_bottom" border="0">

</body>
</html>
